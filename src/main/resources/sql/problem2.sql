-- Chapter: 알고리즘 (id: 2), Unit: 시간복잡도 & Big-O 표기법 (id: 11)

-- Lesson 생성
INSERT INTO lesson (id, unit_id, title)
VALUES (30, 11, '시간 복잡도 기초 문제집'),
       (31, 11, 'Big-O 표기법 문제집'),
       (32, 11, '시간 복잡도 비교 문제집');

-- Chapter: 알고리즘 (id: 2), Unit: 시간복잡도 & Big-O 표기법 (id: 11), Lesson: 시간 복잡도 기초 문제집 (id: 30)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (175, 30, '다음 중 시간 복잡도의 정의로 올바른 것은?', '시간 복잡도는 알고리즘의 성능을 분석하는 척도이다.', 'OBJECTIVE'),
       (176, 30, '빈칸에 들어갈 용어를 작성하시오', '시간 복잡도는 알고리즘이 문제를 해결하는 데 걸리는 시간을 입력 크기 ___의 함수로 나타낸 것이다.', 'SUBJECTIVE'),
       (177, 30, '다음 중 O(1)의 의미로 올바른 것은?', 'O(1)은 시간 복잡도 표기법 중 하나이다.', 'OBJECTIVE'),
       (178, 30, '다음 중 O(n)의 예시로 올바른 것은?', 'O(n)은 선형 시간 복잡도를 의미한다.', 'OBJECTIVE'),
       (179, 30, '빈칸에 들어갈 시간 복잡도를 작성하시오', '배열의 특정 인덱스에 접근하는 연산의 시간 복잡도는 ___이다.', 'SUBJECTIVE'),
       (180, 30, '다음 중 시간 복잡도가 중요한 이유로 올바른 것은?', '시간 복잡도는 알고리즘 선택에 중요한 기준이 된다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (465, 175, '알고리즘이 문제를 해결하는 데 걸리는 시간을 입력 크기 n의 함수로 나타낸 것이다',
        '시간 복잡도는 알고리즘이 문제를 해결하는 데 걸리는 시간을 입력 크기 n의 함수로 나타낸 것이다. 입력이 커질수록 실행 시간이 얼마나 증가하는지 예측할 수 있다.',
        true),
       (466, 175, '알고리즘이 사용하는 메모리 양을 나타낸 것이다',
        '이는 공간 복잡도의 정의이다. 시간 복잡도는 실행 시간을 나타낸다.', false),
       (467, 175, '알고리즘의 정확성을 나타내는 척도이다',
        '시간 복잡도는 성능을 나타내는 척도이다. 정확성과는 다른 개념이다.', false),
       (468, 175, '알고리즘의 코드 길이를 나타낸 것이다',
        '시간 복잡도는 실행 시간을 나타낸다. 코드 길이와는 무관하다.', false),

       (469, 177, '입력 크기와 상관없이 일정한 시간이 소요된다',
        'O(1)은 상수 시간 복잡도로, 입력 크기와 상관없이 항상 일정한 시간이 소요됨을 의미한다. 배열의 인덱스 접근, 해시 테이블의 조회 등이 대표적인 예시이다.',
        true),
       (470, 177, '입력 크기에 비례하여 시간이 증가한다',
        '이는 O(n)의 특징이다. O(1)은 입력 크기와 무관하게 일정한 시간이 소요된다.', false),
       (471, 177, '입력 크기의 제곱에 비례하여 시간이 증가한다',
        '이는 O(n²)의 특징이다. O(1)은 입력 크기와 무관하다.', false),
       (472, 177, '로그 시간이 소요된다',
        '이는 O(log n)의 특징이다. O(1)은 상수 시간이다.', false),

       (473, 178, '단순 반복문으로 배열을 순회하는 경우',
        'O(n)은 선형 시간 복잡도로, 입력 개수만큼 순회하는 경우를 의미한다. 단순 반복문으로 배열을 순회하거나 선형 탐색을 수행하는 경우가 대표적이다.',
        true),
       (474, 178, '배열의 특정 인덱스에 접근하는 경우',
        '배열의 인덱스 접근은 O(1)이다. O(n)이 아니다.', false),
       (475, 178, '이중 반복문으로 배열을 순회하는 경우',
        '이중 반복문은 O(n²)이다. O(n)이 아니다.', false),
       (476, 178, '이진 탐색을 수행하는 경우',
        '이진 탐색은 O(log n)이다. O(n)이 아니다.', false),

       (477, 180, '입력 크기가 커질수록 실행 시간 차이가 급격히 벌어지므로 효율적인 알고리즘 선택이 필수적이다',
        '시간 복잡도는 알고리즘의 효율성을 정량적으로 비교하기 위한 기준이다. 같은 기능을 수행하더라도 입력 크기가 커지면 성능 차이가 급격히 벌어진다. 대규모 데이터나 실시간 시스템에서는 복잡도가 낮은 알고리즘 선택이 필수적이다.',
        true),
       (478, 180, '알고리즘의 정확성을 보장하기 위해서이다',
        '시간 복잡도는 성능 분석을 위한 것이다. 정확성 보장과는 다른 개념이다.', false),
       (479, 180, '코드를 짧게 작성하기 위해서이다',
        '시간 복잡도는 실행 시간 분석을 위한 것이다. 코드 길이와는 무관하다.', false),
       (480, 180, '메모리 사용량을 줄이기 위해서이다',
        '이는 공간 복잡도와 관련된 이유이다. 시간 복잡도는 실행 시간과 관련이 있다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (59, 176, 'n',
        '시간 복잡도는 알고리즘이 문제를 해결하는 데 걸리는 시간을 입력 크기 n의 함수로 나타낸 것이다. 입력이 커질수록 실행 시간이 얼마나 증가하는지를 예측할 수 있다.'),
       (60, 179, 'O(1)',
        '배열의 특정 인덱스에 접근하는 연산의 시간 복잡도는 O(1)이다. 인덱스를 통해 직접 접근할 수 있으므로 입력 크기와 무관하게 일정한 시간이 소요된다.');

-- Chapter: 알고리즘 (id: 2), Unit: 시간복잡도 & Big-O 표기법 (id: 11), Lesson: Big-O 표기법 문제집 (id: 31)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (181, 31, '다음 중 Big-O 표기법의 정의로 올바른 것은?', 'Big-O 표기법은 점근적 표기법의 한 종류이다.', 'OBJECTIVE'),
       (182, 31, '빈칸에 들어갈 용어를 작성하시오', 'Big-O 표기법은 입력 크기 n이 커질 때 알고리즘이 수행하는 연산 수의 ___을 표현한다.', 'SUBJECTIVE'),
       (183, 31, '다음 중 O(log n)의 예시로 올바른 것은?', 'O(log n)은 로그 시간 복잡도를 의미한다.', 'OBJECTIVE'),
       (184, 31, '다음 중 O(n²)의 예시로 올바른 것은?', 'O(n²)은 제곱 시간 복잡도를 의미한다.', 'OBJECTIVE'),
       (185, 31, '빈칸에 들어갈 시간 복잡도를 작성하시오', '병합 정렬과 퀵 정렬의 평균 시간 복잡도는 ___이다.', 'SUBJECTIVE'),
       (186, 31, '다음 중 Big-O 표기법의 특징으로 올바른 것은?', 'Big-O 표기법은 특정한 규칙을 따른다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (481, 181, '입력 크기 n이 커질 때 알고리즘의 실행 시간 상한을 표현하는 표기법이다',
        'Big-O 표기법은 입력 크기 n이 커질 때 알고리즘이 수행하는 연산 수의 상한(최악의 경우)을 표현한다. 알고리즘의 효율성을 비교하고 예측할 수 있게 해준다.',
        true),
       (482, 181, '알고리즘의 정확한 실행 시간을 초 단위로 표현한다',
        'Big-O 표기법은 증가율을 표현한다. 정확한 실행 시간을 초 단위로 표현하지 않는다.', false),
       (483, 181, '알고리즘의 메모리 사용량만 표현한다',
        'Big-O 표기법은 시간 복잡도와 공간 복잡도 모두 표현할 수 있다. 메모리만 표현하는 것이 아니다.', false),
       (484, 181, '알고리즘의 코드 줄 수를 나타낸다',
        'Big-O 표기법은 연산 수의 증가율을 나타낸다. 코드 줄 수와는 무관하다.', false),

       (485, 183, '이진 탐색과 힙 연산',
        'O(log n)은 로그 시간 복잡도로, 매 단계마다 입력을 절반으로 줄이는 경우를 의미한다. 이진 탐색, 힙의 삽입/삭제 연산 등이 대표적인 예시이다.',
        true),
       (486, 183, '단순 반복문으로 배열 순회',
        '단순 반복문은 O(n)이다. O(log n)이 아니다.', false),
       (487, 183, '이중 반복문',
        '이중 반복문은 O(n²)이다. O(log n)이 아니다.', false),
       (488, 183, '배열의 인덱스 접근',
        '배열의 인덱스 접근은 O(1)이다. O(log n)이 아니다.', false),

       (489, 184, '이중 반복문 구조로 배열을 순회하는 경우',
        'O(n²)은 제곱 시간 복잡도로, 이중 반복문 구조를 의미한다. 버블 정렬, 선택 정렬, 삽입 정렬 등이 대표적인 예시이다.',
        true),
       (490, 184, '단순 반복문으로 배열을 순회하는 경우',
        '단순 반복문은 O(n)이다. O(n²)이 아니다.', false),
       (491, 184, '이진 탐색을 수행하는 경우',
        '이진 탐색은 O(log n)이다. O(n²)이 아니다.', false),
       (492, 184, '배열의 인덱스에 접근하는 경우',
        '배열의 인덱스 접근은 O(1)이다. O(n²)이 아니다.', false),

       (493, 186, '상수나 작은 항들은 무시하고 증가율에만 집중한다',
        'Big-O 표기법은 상수나 작은 항들은 무시하고 증가율에만 집중한다. 예를 들어 3n² + 2n + 1은 O(n²)로 표기한다. 가장 빠르게 증가하는 항만 고려한다.',
        true),
       (494, 186, '모든 상수와 계수를 정확히 표현한다',
        'Big-O 표기법은 상수와 낮은 차수의 항을 무시한다. 모든 것을 정확히 표현하지 않는다.', false),
       (495, 186, '최선의 경우만 표현한다',
        'Big-O 표기법은 상한(최악의 경우)을 표현한다. 최선의 경우는 Ω(오메가) 표기법이다.', false),
       (496, 186, '알고리즘의 정확성을 보장한다',
        'Big-O 표기법은 성능 분석을 위한 것이다. 정확성 보장과는 무관하다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (61, 182, '상한, 최악',
        'Big-O 표기법은 입력 크기 n이 커질 때 알고리즘이 수행하는 연산 수의 상한(최악의 경우)을 표현한다. 알고리즘의 실행 시간이 이 값보다 느리지 않음을 보장한다.'),
       (62, 185, 'O(n log n)',
        '병합 정렬과 퀵 정렬의 평균 시간 복잡도는 O(n log n)이다. 이는 선형과 로그의 복합 형태로, 효율적인 정렬 알고리즘의 대표적인 시간 복잡도이다.');

-- Chapter: 알고리즘 (id: 2), Unit: 시간복잡도 & Big-O 표기법 (id: 11), Lesson: 시간 복잡도 비교 문제집 (id: 32)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (187, 32, '다음 중 시간 복잡도를 효율적인 순서대로 나열한 것은?', '시간 복잡도는 효율성 순서가 존재한다.', 'OBJECTIVE'),
       (188, 32, '빈칸에 들어갈 실행 횟수를 작성하시오', '입력 크기가 10일 때 O(2ⁿ)의 실행 횟수는 ___이다.', 'SUBJECTIVE'),
       (189, 32, '다음 중 실용적으로 사용 가능한 시간 복잡도는?', '일부 시간 복잡도는 실용적이지 않다.', 'OBJECTIVE'),
       (190, 32, '다음 중 O(2ⁿ)의 특징으로 올바른 것은?', 'O(2ⁿ)은 지수 시간 복잡도이다.', 'OBJECTIVE'),
       (191, 32, '빈칸에 들어갈 시간 복잡도를 작성하시오', '모든 순열을 탐색하는 외판원 문제의 시간 복잡도는 ___이다.', 'SUBJECTIVE'),
       (192, 32, '다음 중 시간 복잡도 비교로 올바른 것은?', '시간 복잡도는 입력 크기에 따라 차이가 발생한다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (497, 187, 'O(1) < O(log n) < O(n) < O(n log n) < O(n²) < O(2ⁿ) < O(n!)',
        '시간 복잡도를 효율적인 순서대로 나열하면 O(1) < O(log n) < O(n) < O(n log n) < O(n²) < O(2ⁿ) < O(n!)이다. 위로 갈수록 효율적이고 아래로 갈수록 비효율적이다.',
        true),
       (498, 187, 'O(n²) < O(n) < O(log n) < O(1)',
        '순서가 반대이다. O(1)이 가장 효율적이고 O(n²)이 덜 효율적이다.', false),
       (499, 187, 'O(n!) < O(2ⁿ) < O(n²) < O(n log n)',
        '순서가 반대이다. O(n!)이 가장 비효율적이다.', false),
       (500, 187, '모든 시간 복잡도는 동일하다',
        '시간 복잡도는 서로 다른 효율성을 가진다.', false),

       (501, 189, 'O(n log n) 이하의 복잡도',
        '현실적으로 O(n log n) 이하의 시간 복잡도만 실용적이다. O(1), O(log n), O(n), O(n log n)은 대규모 데이터 처리에 적합하다. O(2ⁿ), O(n!)은 입력이 조금만 커져도 현실적으로 불가능해진다.',
        true),
       (502, 189, 'O(2ⁿ)과 O(n!)',
        'O(2ⁿ)과 O(n!)은 입력이 조금만 커져도 실행 시간이 급격히 증가하여 비실용적이다.', false),
       (503, 189, 'O(n²)만 실용적이다',
        'O(n²)은 작은 데이터에서는 사용 가능하지만, O(n log n) 이하가 더 실용적이다.', false),
       (504, 189, '모든 시간 복잡도가 실용적이다',
        'O(2ⁿ), O(n!) 등은 비실용적이다.', false),

       (505, 190, '가능한 모든 경우를 탐색하며 입력이 조금만 커져도 실행 시간이 급격히 증가한다',
        'O(2ⁿ)은 지수 시간 복잡도로, 가능한 모든 경우를 탐색한다. 입력 크기가 10일 때 1,024번, 20일 때 1,048,576번 실행되어 입력이 조금만 커져도 현실적으로 불가능해진다.',
        true),
       (506, 190, '매우 효율적인 알고리즘이다',
        'O(2ⁿ)은 비효율적이다. 입력이 조금만 커져도 실행 시간이 급격히 증가한다.', false),
       (507, 190, 'O(n)보다 효율적이다',
        'O(2ⁿ)은 O(n)보다 훨씬 비효율적이다.', false),
       (508, 190, '로그 시간 복잡도이다',
        'O(2ⁿ)은 지수 시간 복잡도이다. 로그 시간이 아니다.', false),

       (509, 192, '입력 크기가 커질수록 O(1)~O(n log n)은 실용적이지만 O(2ⁿ), O(n!)은 불가능해진다',
        '입력이 커질수록 시간 복잡도에 따른 성능 차이가 급격히 벌어진다. 입력 크기 20일 때 O(n)은 20번, O(n²)은 400번이지만 O(2ⁿ)은 1,048,576번 실행된다. 따라서 효율적인 알고리즘 선택이 중요하다.',
        true),
       (510, 192, '모든 시간 복잡도는 입력 크기와 무관하게 동일하다',
        '시간 복잡도는 입력 크기에 따라 크게 달라진다.', false),
       (511, 192, 'O(2ⁿ)이 가장 효율적이다',
        'O(2ⁿ)은 가장 비효율적인 시간 복잡도 중 하나이다.', false),
       (512, 192, 'O(1)이 가장 비효율적이다',
        'O(1)은 가장 효율적인 시간 복잡도이다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (63, 188, '1024',
        '입력 크기가 10일 때 O(2ⁿ)의 실행 횟수는 2¹⁰ = 1024이다. 입력이 20이면 2²⁰ = 1,048,576번으로 급격히 증가한다. 이는 지수 함수의 특징이다.'),
       (64, 191, 'O(n!)',
        '모든 순열을 탐색하는 외판원 문제(TSP)의 시간 복잡도는 O(n!)이다. 이는 팩토리얼 시간 복잡도로 가장 비효율적인 시간 복잡도 중 하나이며, 입력이 조금만 커져도 실행이 불가능하다.');

-- Chapter: 알고리즘 (id: 2), Unit: 공간 복잡도 & 점근적 표기 (id: 12)

-- Lesson 생성
INSERT INTO lesson (id, unit_id, title)
VALUES (33, 12, '공간 복잡도 기초 문제집'),
       (34, 12, '점근적 표기법 문제집'),
       (35, 12, '시간-공간 트레이드오프 문제집');

-- Chapter: 알고리즘 (id: 2), Unit: 공간 복잡도 & 점근적 표기 (id: 12), Lesson: 공간 복잡도 기초 문제집 (id: 33)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (193, 33, '다음 중 공간 복잡도의 정의로 올바른 것은?', '공간 복잡도는 알고리즘의 효율성을 나타내는 척도 중 하나이다.', 'OBJECTIVE'),
       (194, 33, '빈칸에 들어갈 용어를 작성하시오', '공간 복잡도는 알고리즘이 문제를 해결하기 위해 사용하는 ___의 양을 나타낸다.', 'SUBJECTIVE'),
       (195, 33, '다음 중 공간 복잡도의 구분으로 올바른 것은?', '공간 복잡도는 크게 두 가지로 구분된다.', 'OBJECTIVE'),
       (196, 33, '다음 중 O(1) 공간 복잡도의 예시로 올바른 것은?', 'O(1)은 상수 공간 복잡도를 의미한다.', 'OBJECTIVE'),
       (197, 33, '빈칸에 들어갈 공간 복잡도를 작성하시오', '크기가 n인 배열을 새로 생성하는 알고리즘의 공간 복잡도는 ___이다.', 'SUBJECTIVE'),
       (198, 33, '다음 중 공간 복잡도가 중요한 이유로 올바른 것은?', '공간 복잡도는 알고리즘 선택에 영향을 준다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (513, 193, '알고리즘이 문제를 해결하기 위해 얼마나 많은 메모리를 사용하는가를 분석하는 척도이다',
        '공간 복잡도는 알고리즘이 문제를 해결하기 위해 얼마나 많은 메모리를 사용하는가를 분석하는 척도이다. 입력 크기 n이 커질수록 추가로 필요한 메모리 양이 얼마나 증가하는지를 평가한다.',
        true),
       (514, 193, '알고리즘의 실행 시간을 나타내는 척도이다',
        '이는 시간 복잡도의 정의이다. 공간 복잡도는 메모리 사용량을 나타낸다.', false),
       (515, 193, '알고리즘의 정확성을 보장하는 척도이다',
        '공간 복잡도는 메모리 사용량을 나타낸다. 정확성 보장과는 다른 개념이다.', false),
       (516, 193, '알고리즘의 코드 길이를 나타낸다',
        '공간 복잡도는 메모리 사용량을 나타낸다. 코드 길이와는 무관하다.', false),

       (517, 195, '고정 공간과 가변 공간으로 구분된다',
        '공간 복잡도는 고정 공간과 가변 공간으로 구분된다. 고정 공간은 입력 크기와 관계없이 항상 동일한 크기의 메모리를 사용하고(상수, 변수, 포인터), 가변 공간은 입력 크기에 따라 메모리 사용량이 달라진다(배열, 리스트, 재귀 스택).',
        true),
       (518, 195, '시간 공간과 메모리 공간으로 구분된다',
        '공간 복잡도는 고정 공간과 가변 공간으로 구분된다. 시간 공간이라는 개념은 없다.', false),
       (519, 195, '입력 공간과 출력 공간으로 구분된다',
        '공간 복잡도는 고정 공간과 가변 공간으로 구분된다. 입력/출력 공간으로 구분하지 않는다.', false),
       (520, 195, '상수 공간만 존재한다',
        '공간 복잡도는 고정 공간과 가변 공간 모두 존재한다.', false),

       (521, 196, '단일 변수만 사용하는 경우',
        'O(1)은 상수 공간 복잡도로, 입력 크기와 관계없이 일정한 메모리를 사용한다. 단일 변수, 상수, 포인터만 사용하는 경우가 대표적이다.',
        true),
       (522, 196, '입력 크기만큼 배열을 생성하는 경우',
        '배열을 생성하는 경우는 O(n)이다. O(1)이 아니다.', false),
       (523, 196, '재귀 호출 깊이가 n인 경우',
        '재귀 호출 깊이가 n이면 O(n)이다. O(1)이 아니다.', false),
       (524, 196, '2차원 배열을 생성하는 경우',
        '2차원 배열은 O(n²)이다. O(1)이 아니다.', false),

       (525, 198, '메모리가 제한된 환경에서는 불필요한 공간 사용이 성능 저하로 이어진다',
        '메모리가 제한된 환경에서는 불필요한 공간 사용이 성능 저하로 이어진다. 함수 호출 시 스택이 누적되므로 공간 복잡도 분석이 필수적이다. 임베디드 시스템이나 모바일 환경에서는 공간 복잡도가 특히 중요하다.',
        true),
       (526, 198, '실행 시간을 줄이기 위해서이다',
        '이는 시간 복잡도와 관련된 이유이다. 공간 복잡도는 메모리 사용과 관련이 있다.', false),
       (527, 198, '코드를 짧게 작성하기 위해서이다',
        '공간 복잡도는 메모리 사용량과 관련이 있다. 코드 길이와는 무관하다.', false),
       (528, 198, '알고리즘의 정확성을 보장하기 위해서이다',
        '공간 복잡도는 메모리 효율성과 관련이 있다. 정확성 보장과는 다른 개념이다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (65, 194, '메모리, memory',
        '공간 복잡도는 알고리즘이 문제를 해결하기 위해 사용하는 메모리의 양을 나타낸다. 입력 크기 n이 커질수록 추가로 필요한 메모리 양이 얼마나 증가하는지를 평가한다.'),
       (66, 197, 'O(n)',
        '크기가 n인 배열을 새로 생성하는 알고리즘의 공간 복잡도는 O(n)이다. 입력 크기에 비례하는 메모리를 사용하므로 선형 공간 복잡도를 가진다.');

-- Chapter: 알고리즘 (id: 2), Unit: 공간 복잡도 & 점근적 표기 (id: 12), Lesson: 점근적 표기법 문제집 (id: 34)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (199, 34, '다음 중 점근적 표기법의 정의로 올바른 것은?', '점근적 표기법은 알고리즘 분석에 사용되는 수학적 표기법이다.', 'OBJECTIVE'),
       (200, 34, '빈칸에 들어갈 표기법을 작성하시오', '입력 크기 n이 커질 때 알고리즘의 실행 시간 상한을 표현하는 표기법을 ___라 한다.', 'SUBJECTIVE'),
       (201, 34, '다음 중 Ω(오메가) 표기법의 의미로 올바른 것은?', 'Ω 표기법은 점근적 표기법 중 하나이다.', 'OBJECTIVE'),
       (202, 34, '다음 중 Θ(세타) 표기법의 의미로 올바른 것은?', 'Θ 표기법은 점근적 표기법 중 하나이다.', 'OBJECTIVE'),
       (203, 34, '빈칸에 들어갈 표기법을 작성하시오', '알고리즘의 최선의 경우 실행 시간을 표현하는 표기법은 ___이다.', 'SUBJECTIVE'),
       (204, 34, '다음 중 점근적 표기법의 특징으로 올바른 것은?', '점근적 표기법은 특정한 규칙을 따른다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (529, 199, '입력 크기가 커질 때 증가율에만 집중하여 상수나 작은 항들은 무시하는 표기법이다',
        '점근적 표기법은 알고리즘의 실행 시간이나 메모리 사용량이 입력 크기 n이 커질 때 어떤 속도로 증가하는지를 표현하는 수학적 표기법이다. 상수나 작은 항들은 무시하고 증가율에만 집중한다.',
        true),
       (530, 199, '알고리즘의 정확한 실행 시간을 초 단위로 표현한다',
        '점근적 표기법은 증가율을 표현한다. 정확한 실행 시간을 초 단위로 표현하지 않는다.', false),
       (531, 199, '모든 상수와 계수를 정확히 표현한다',
        '점근적 표기법은 상수와 낮은 차수의 항을 무시한다. 모든 것을 정확히 표현하지 않는다.', false),
       (532, 199, '알고리즘의 메모리 사용량만 표현한다',
        '점근적 표기법은 시간 복잡도와 공간 복잡도 모두 표현할 수 있다. 메모리만 표현하는 것이 아니다.', false),

       (533, 201, '알고리즘의 실행 시간 하한을 표현하며 최선의 경우를 의미한다',
        'Ω(오메가) 표기법은 알고리즘의 실행 시간 하한(최선의 경우)을 표현한다. 실행 시간이 이 값보다 빠르지 않음을 보장한다.',
        true),
       (534, 201, '알고리즘의 실행 시간 상한을 표현한다',
        '상한은 Big-O 표기법이다. Ω는 하한을 표현한다.', false),
       (535, 201, '알고리즘의 평균 실행 시간을 표현한다',
        '평균은 Θ(세타) 표기법이다. Ω는 하한(최선의 경우)을 표현한다.', false),
       (536, 201, '알고리즘의 메모리 사용량만 표현한다',
        'Ω는 시간 복잡도와 공간 복잡도 모두 표현할 수 있다. 메모리만 표현하는 것이 아니다.', false),

       (537, 202, '상한과 하한이 일치할 때 사용하며 평균적인 경우를 의미한다',
        'Θ(세타) 표기법은 상한과 하한이 일치할 때 사용한다. 알고리즘의 평균적인 실행 시간을 표현하며, 최선과 최악의 경우가 같을 때 사용한다.',
        true),
       (538, 202, '최악의 경우만 표현한다',
        '최악의 경우는 Big-O 표기법이다. Θ는 상한과 하한이 일치할 때 사용한다.', false),
       (539, 202, '최선의 경우만 표현한다',
        '최선의 경우는 Ω 표기법이다. Θ는 상한과 하한이 일치할 때 사용한다.', false),
       (540, 202, '공간 복잡도만 표현한다',
        'Θ는 시간 복잡도와 공간 복잡도 모두 표현할 수 있다.', false),

       (541, 204, '상수나 작은 항들은 무시하고 증가율에만 집중한다',
        '점근적 표기법은 상수나 작은 항들은 무시하고 증가율에만 집중한다. 예를 들어 3n² + 2n + 1은 O(n²), Ω(n²), Θ(n²)로 표기할 수 있다. 가장 빠르게 증가하는 항만 고려한다.',
        true),
       (542, 204, '모든 상수와 계수를 정확히 표현한다',
        '점근적 표기법은 상수와 낮은 차수의 항을 무시한다.', false),
       (543, 204, '시간 복잡도만 표현할 수 있다',
        '점근적 표기법은 시간 복잡도와 공간 복잡도 모두 표현할 수 있다.', false),
       (544, 204, '알고리즘의 정확성을 보장한다',
        '점근적 표기법은 성능 분석을 위한 것이다. 정확성 보장과는 무관하다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (67, 200, 'Big-O, 빅오, O',
        '입력 크기 n이 커질 때 알고리즘의 실행 시간 상한(최악의 경우)을 표현하는 표기법을 Big-O 표기법이라 한다. 알고리즘의 실행 시간이 이 값보다 느리지 않음을 보장한다.'),
       (68, 203, 'Ω, 오메가, Omega',
        '알고리즘의 최선의 경우 실행 시간을 표현하는 표기법은 Ω(오메가) 표기법이다. 실행 시간이 이 값보다 빠르지 않음을 보장한다.');

-- Chapter: 알고리즘 (id: 2), Unit: 공간 복잡도 & 점근적 표기 (id: 12), Lesson: 시간-공간 트레이드오프 문제집 (id: 35)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (205, 35, '다음 중 시간 복잡도와 공간 복잡도의 관계로 올바른 것은?', '시간 복잡도와 공간 복잡도는 서로 관계가 있다.', 'OBJECTIVE'),
       (206, 35, '빈칸에 들어갈 용어를 작성하시오', '공간을 더 사용하면 시간을 줄일 수 있고, 시간을 더 사용하면 공간을 절약할 수 있는 관계를 ___라 한다.', 'SUBJECTIVE'),
       (207, 35, '다음 중 공간 복잡도의 종류로 올바른 것은?', '공간 복잡도는 여러 종류로 분류할 수 있다.', 'OBJECTIVE'),
       (208, 35, '다음 중 재귀 함수의 공간 복잡도로 올바른 것은?', '재귀 함수는 특정한 공간 복잡도를 가진다.', 'OBJECTIVE'),
       (209, 35, '빈칸에 들어갈 공간 복잡도를 작성하시오', '재귀 호출 깊이가 n인 경우 공간 복잡도는 ___이다.', 'SUBJECTIVE'),
       (210, 35, '다음 중 메모이제이션의 특징으로 올바른 것은?', '메모이제이션은 시간-공간 트레이드오프의 한 예이다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (545, 205, '시간을 줄이려면 공간을 더 사용하고, 공간을 줄이려면 시간을 더 사용하는 트레이드오프 관계이다',
        '시간 복잡도와 공간 복잡도는 트레이드오프 관계이다. 공간을 더 쓰면 시간을 줄일 수 있고(메모이제이션), 시간을 더 쓰면 공간을 절약할 수 있다(재계산). 최적의 균형을 찾는 것이 중요하다.',
        true),
       (546, 205, '시간과 공간은 완전히 독립적이다',
        '시간과 공간은 트레이드오프 관계이다. 독립적이지 않다.', false),
       (547, 205, '시간을 줄이면 항상 공간도 줄어든다',
        '시간을 줄이려면 보통 공간을 더 사용한다. 동시에 줄어들지 않는다.', false),
       (548, 205, '공간 복잡도는 시간 복잡도보다 항상 중요하다',
        '상황에 따라 시간이 더 중요할 수도, 공간이 더 중요할 수도 있다. 항상 공간이 더 중요한 것은 아니다.', false),

       (549, 207, 'O(1), O(log n), O(n), O(n²) 등으로 분류된다',
        '공간 복잡도는 시간 복잡도와 마찬가지로 O(1)(상수 공간), O(log n)(로그 공간), O(n)(선형 공간), O(n²)(제곱 공간) 등으로 분류된다. 알고리즘이 사용하는 추가 메모리 양에 따라 결정된다.',
        true),
       (550, 207, 'O(1)만 존재한다',
        '공간 복잡도는 O(1), O(log n), O(n), O(n²) 등 다양하게 존재한다.', false),
       (551, 207, '시간 복잡도와 완전히 동일하다',
        '공간 복잡도는 메모리 사용량을 나타낸다. 시간 복잡도와는 다른 개념이다.', false),
       (552, 207, '고정 공간만 존재한다',
        '공간 복잡도는 고정 공간과 가변 공간 모두 존재한다.', false),

       (553, 208, '재귀 호출 스택에 비례하여 O(깊이)의 공간 복잡도를 가진다',
        '재귀 함수는 재귀 호출 스택에 메모리를 사용한다. 재귀 호출 깊이가 n이면 O(n), log n이면 O(log n)의 공간 복잡도를 가진다. 각 호출마다 스택 프레임이 생성되기 때문이다.',
        true),
       (554, 208, '항상 O(1)의 공간 복잡도를 가진다',
        '재귀 함수는 호출 스택을 사용하므로 O(1)이 아니다. 재귀 깊이에 비례한다.', false),
       (555, 208, '공간을 전혀 사용하지 않는다',
        '재귀 함수는 호출 스택 메모리를 사용한다.', false),
       (556, 208, '시간 복잡도와 동일하다',
        '재귀 함수의 공간 복잡도는 재귀 깊이에 비례한다. 시간 복잡도와는 다를 수 있다.', false),

       (557, 210, '이전에 계산한 값을 저장하여 시간을 줄이는 대신 공간을 더 사용한다',
        '메모이제이션은 이전에 계산한 값을 메모리에 저장하여 재계산을 피함으로써 시간을 줄인다. 대신 저장 공간이 필요하므로 공간 복잡도가 증가한다. 이는 시간-공간 트레이드오프의 대표적인 예이다.',
        true),
       (558, 210, '시간과 공간을 모두 줄인다',
        '메모이제이션은 시간을 줄이지만 공간을 더 사용한다. 모두 줄이지 않는다.', false),
       (559, 210, '공간을 전혀 사용하지 않는다',
        '메모이제이션은 계산 결과를 저장하므로 추가 공간을 사용한다.', false),
       (560, 210, '시간을 늘리고 공간을 줄인다',
        '메모이제이션은 시간을 줄이는 대신 공간을 더 사용한다. 반대이다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (69, 206, '시간-공간 트레이드오프, time-space tradeoff',
        '공간을 더 사용하면 시간을 줄일 수 있고, 시간을 더 사용하면 공간을 절약할 수 있는 관계를 시간-공간 트레이드오프(time-space tradeoff)라 한다. 알고리즘 설계 시 상황에 맞는 최적의 균형을 찾는 것이 중요하다.'),
       (70, 209, 'O(n)',
        '재귀 호출 깊이가 n인 경우 공간 복잡도는 O(n)이다. 각 재귀 호출마다 스택 프레임이 생성되므로 재귀 깊이에 비례하는 메모리를 사용한다.');

-- Chapter: 알고리즘 (id: 2), Unit: 브루트 포스 개념과 한계 (id: 13)

-- Lesson 생성
INSERT INTO lesson (id, unit_id, title)
VALUES (36, 13, '브루트 포스 기초 문제집'),
       (37, 13, '브루트 포스 구현 문제집'),
       (38, 13, '브루트 포스 한계 문제집');

-- Chapter: 알고리즘 (id: 2), Unit: 브루트 포스 개념과 한계 (id: 13), Lesson: 브루트 포스 기초 문제집 (id: 36)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (211, 36, '다음 중 브루트 포스의 정의로 올바른 것은?', '브루트 포스는 문제 해결 방법 중 하나이다.', 'OBJECTIVE'),
       (212, 36, '빈칸에 들어갈 용어를 작성하시오', '브루트 포스는 가능한 ___를 탐색하면서 조건을 만족하는 해만 고르는 알고리즘이다.', 'SUBJECTIVE'),
       (213, 36, '다음 중 브루트 포스와 완전 탐색의 차이로 올바른 것은?', '브루트 포스와 완전 탐색은 미세한 차이가 있다.', 'OBJECTIVE'),
       (214, 36, '다음 중 브루트 포스의 장점으로 올바른 것은?', '브루트 포스는 특정한 장점을 가진다.', 'OBJECTIVE'),
       (215, 36, '빈칸에 들어갈 용어를 작성하시오', '브루트 포스는 모든 경우의 수를 탐색하기 때문에 ___를 보장한다.', 'SUBJECTIVE'),
       (216, 36, '다음 중 브루트 포스의 단점으로 올바른 것은?', '브루트 포스는 단점도 가지고 있다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (561, 211, '가능한 모든 경우의 수를 탐색하면서 조건을 만족하는 해만 고르는 알고리즘이다',
        '브루트 포스는 가능한 모든 경우의 수를 탐색하면서 조건을 만족하는 해만 고르는 알고리즘이다. 완전 탐색이라고도 하며, 모든 가능성을 시도하여 문제를 해결한다.',
        true),
       (562, 211, '최선의 선택만 고르는 알고리즘이다',
        '이는 그리디 알고리즘의 특징이다. 브루트 포스는 모든 경우의 수를 탐색한다.', false),
       (563, 211, '분할 정복 방식으로 문제를 해결한다',
        '이는 분할 정복 알고리즘의 특징이다. 브루트 포스는 모든 경우를 탐색한다.', false),
       (564, 211, '중복 계산을 제거하는 알고리즘이다',
        '이는 다이내믹 프로그래밍의 특징이다. 브루트 포스는 모든 경우를 탐색한다.', false),

       (565, 213, '브루트 포스는 결과를 찾는 것에 중점을 두고 완전 탐색은 탐색에 중점을 둔다',
        '브루트 포스와 완전 탐색은 같은 의미로 쓰이기도 하지만 미세한 차이가 있다. 브루트 포스는 결과를 찾는 것에 중점을 두고, 완전 탐색은 탐색에 중점을 둔다.',
        true),
       (566, 213, '브루트 포스와 완전 탐색은 완전히 다른 개념이다',
        '브루트 포스와 완전 탐색은 같은 의미로 쓰이기도 한다. 완전히 다른 개념은 아니다.', false),
       (567, 213, '완전 탐색이 브루트 포스보다 항상 빠르다',
        '두 방법은 비슷한 개념이며 속도 차이가 있는 것이 아니다.', false),
       (568, 213, '브루트 포스는 백트래킹을 사용한다',
        '브루트 포스는 모든 경우를 탐색한다. 백트래킹은 가지치기를 통해 탐색을 줄인다.', false),

       (569, 214, '알고리즘의 설계와 구현이 간단하다',
        '브루트 포스의 장점은 알고리즘의 설계와 구현이 간단하고, 모든 경우의 수를 탐색하기 때문에 해를 보장한다는 것이다. 직관적이고 이해하기 쉽다.',
        true),
       (570, 214, '시간이 매우 빠르다',
        '브루트 포스는 모든 경우를 탐색하므로 시간이 오래 걸린다. 빠르지 않다.', false),
       (571, 214, '메모리 사용량이 매우 적다',
        '브루트 포스는 메모리 사용이 비효율적일 수 있다. 메모리 사용량이 적지 않다.', false),
       (572, 214, '항상 최적해를 빠르게 찾는다',
        '브루트 포스는 해를 보장하지만 빠르지 않다. 모든 경우를 탐색하므로 시간이 오래 걸린다.', false),

       (573, 216, '모든 경우의 수를 탐색하기 때문에 시간이 매우 오래 걸린다',
        '브루트 포스의 단점은 모든 경우의 수를 탐색하기 때문에 시간이 매우 오래 걸리고, 메모리 사용이 비효율적이라는 것이다. 입력 크기가 커지면 현실적으로 사용이 불가능해진다.',
        true),
       (574, 216, '해를 보장하지 못한다',
        '브루트 포스는 모든 경우를 탐색하므로 해를 보장한다. 이는 장점이다.', false),
       (575, 216, '구현이 매우 복잡하다',
        '브루트 포스는 구현이 간단하다. 복잡하지 않다.', false),
       (576, 216, '메모리 사용량이 적다',
        '브루트 포스는 메모리 사용이 비효율적이다. 적지 않다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (71, 212, '모든 경우의 수, 모든 경우',
        '브루트 포스는 가능한 모든 경우의 수를 탐색하면서 조건을 만족하는 해만 고르는 알고리즘이다. 완전 탐색이라고도 불린다.'),
       (72, 215, '해, 정답',
        '브루트 포스는 모든 경우의 수를 탐색하기 때문에 해를 보장한다. 가능한 모든 경우를 시도하므로 반드시 답을 찾을 수 있다.');

-- Chapter: 알고리즘 (id: 2), Unit: 브루트 포스 개념과 한계 (id: 13), Lesson: 브루트 포스 구현 문제집 (id: 37)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (217, 37, '다음 중 브루트 포스의 반복문 기반 구현에 대한 설명으로 올바른 것은?', '브루트 포스는 반복문으로 구현할 수 있다.', 'OBJECTIVE'),
       (218, 37, '빈칸에 들어갈 구현 방식을 작성하시오', '경우의 수가 단계적으로 늘어나거나 깊이 있는 탐색에서는 ___ 기반으로 브루트 포스를 구현한다.', 'SUBJECTIVE'),
       (219, 37, '다음 중 재귀 기반 브루트 포스의 특징으로 올바른 것은?', '재귀 기반 브루트 포스는 특정한 특징을 가진다.', 'OBJECTIVE'),
       (220, 37, '다음 중 브루트 포스 구현 방법 선택 기준으로 올바른 것은?', '브루트 포스 구현 방법은 상황에 따라 선택한다.', 'OBJECTIVE'),
       (221, 37, '빈칸에 들어갈 자료구조를 작성하시오', '반복문 기반 브루트 포스는 주로 ___를 사용하여 구현한다.', 'SUBJECTIVE'),
       (222, 37, '다음 중 브루트 포스의 시간 복잡도로 올바른 것은?', '브루트 포스는 특정한 시간 복잡도를 가진다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (577, 217, '경우의 수가 일정하거나 단순할 때 사용한다',
        '반복문 기반 브루트 포스는 경우의 수가 일정하거나 단순할 때 사용한다. for문 등을 사용하여 모든 경우를 순차적으로 탐색한다. 구현이 직관적이고 이해하기 쉽다.',
        true),
       (578, 217, '경우의 수가 무한정 늘어날 때 사용한다',
        '경우의 수가 단계적으로 늘어나면 재귀를 사용한다. 반복문은 경우의 수가 일정할 때 사용한다.', false),
       (579, 217, '백트래킹을 구현할 때 주로 사용한다',
        '백트래킹은 재귀로 구현하는 것이 일반적이다. 반복문 기반은 단순한 경우에 사용한다.', false),
       (580, 217, '메모리를 전혀 사용하지 않는다',
        '반복문도 변수 등을 통해 메모리를 사용한다.', false),

       (581, 219, '경우의 수가 단계적으로 늘어나거나 깊이 있는 탐색에 적합하다',
        '재귀 기반 브루트 포스는 경우의 수가 단계적으로 늘어나거나 깊이 있는 탐색에서 사용한다. 함수 호출을 통해 상태를 저장하고 탐색하므로 복잡한 경우의 수를 다루기 좋다.',
        true),
       (582, 219, '경우의 수가 일정할 때만 사용한다',
        '경우의 수가 일정하면 반복문을 사용한다. 재귀는 경우의 수가 단계적으로 늘어날 때 사용한다.', false),
       (583, 219, '메모리를 전혀 사용하지 않는다',
        '재귀는 호출 스택에 메모리를 사용한다.', false),
       (584, 219, '항상 반복문보다 빠르다',
        '재귀는 함수 호출 오버헤드가 있어 반복문보다 느릴 수 있다.', false),

       (585, 220, '경우의 수가 일정하면 반복문을, 단계적으로 늘어나면 재귀를 사용한다',
        '브루트 포스 구현 방법은 경우의 수의 특성에 따라 선택한다. 경우의 수가 일정하거나 단순하면 반복문을, 단계적으로 늘어나거나 깊이 있는 탐색이면 재귀를 사용한다.',
        true),
       (586, 220, '항상 반복문을 사용한다',
        '상황에 따라 재귀를 사용하는 것이 더 적합할 수 있다.', false),
       (587, 220, '항상 재귀를 사용한다',
        '상황에 따라 반복문을 사용하는 것이 더 적합할 수 있다.', false),
       (588, 220, '메모리가 적으면 재귀를, 많으면 반복문을 사용한다',
        '구현 방법은 경우의 수 특성에 따라 선택한다. 메모리만으로 결정하지 않는다.', false),

       (589, 222, '모든 경우를 탐색하므로 O(경우의 수)이다',
        '브루트 포스는 모든 경우의 수를 탐색하므로 시간 복잡도는 O(경우의 수)이다. 경우의 수가 n개면 O(n), 2^n개면 O(2^n)이 된다. 입력 크기에 따라 지수적으로 증가할 수 있다.',
        true),
       (590, 222, '항상 O(1)이다',
        '브루트 포스는 모든 경우를 탐색하므로 O(1)이 아니다.', false),
       (591, 222, '항상 O(n)이다',
        '브루트 포스의 시간 복잡도는 경우의 수에 따라 달라진다. 항상 O(n)은 아니다.', false),
       (592, 222, '항상 O(log n)이다',
        '브루트 포스는 모든 경우를 탐색하므로 O(log n)이 아니다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (73, 218, '재귀, recursion',
        '경우의 수가 단계적으로 늘어나거나 깊이 있는 탐색에서는 재귀 기반으로 브루트 포스를 구현한다. 재귀 함수를 사용하여 각 단계에서 가능한 모든 선택을 탐색한다.'),
       (74, 221, '반복문, for, while',
        '반복문 기반 브루트 포스는 주로 for문이나 while문 등의 반복문을 사용하여 구현한다. 경우의 수가 일정하거나 단순할 때 사용한다.');

-- Chapter: 알고리즘 (id: 2), Unit: 브루트 포스 개념과 한계 (id: 13), Lesson: 브루트 포스 한계 문제집 (id: 38)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (223, 38, '다음 중 브루트 포스의 한계로 올바른 것은?', '브루트 포스는 명확한 한계를 가진다.', 'OBJECTIVE'),
       (224, 38, '빈칸에 들어갈 알고리즘 기법을 작성하시오', '브루트 포스의 한계를 극복하기 위해 필요한 부분만 선택적으로 확인하는 ___를 사용할 수 있다.', 'SUBJECTIVE'),
       (225, 38, '다음 중 백트래킹과 브루트 포스의 차이로 올바른 것은?', '백트래킹은 브루트 포스를 개선한 기법이다.', 'OBJECTIVE'),
       (226, 38, '다음 중 브루트 포스가 비효율적인 경우로 올바른 것은?', '브루트 포스는 특정 상황에서 비효율적이다.', 'OBJECTIVE'),
       (227, 38, '빈칸에 들어갈 용어를 작성하시오', '백트래킹은 조건을 만족하지 않는 경로를 ___하여 탐색 효율을 높인다.', 'SUBJECTIVE'),
       (228, 38, '다음 중 브루트 포스 개선 방법으로 올바른 것은?', '브루트 포스는 다양한 방법으로 개선할 수 있다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (593, 223, '모든 경우의 수를 탐색하기 때문에 시간적, 공간적 비용이 크다',
        '브루트 포스는 모든 경우의 수를 탐색하기 때문에 시간적, 공간적 비용이 크다. 경우의 수가 많아질수록 실행 시간이 기하급수적으로 증가하여 현실적으로 사용이 불가능해진다.',
        true),
       (594, 223, '항상 최적해를 빠르게 찾는다',
        '브루트 포스는 해를 보장하지만 빠르지 않다. 모든 경우를 탐색하므로 시간이 오래 걸린다.', false),
       (595, 223, '메모리를 전혀 사용하지 않는다',
        '브루트 포스는 메모리를 사용한다. 공간적 비용이 크다.', false),
       (596, 223, '구현이 매우 복잡하다',
        '브루트 포스의 한계는 시간과 공간 비용이다. 구현이 복잡한 것은 아니다.', false),

       (597, 225, '백트래킹은 가지치기를 통해 해답이 아닌 경로를 제거하지만 브루트 포스는 모든 경로를 탐색한다',
        '백트래킹은 현재 상태가 조건을 만족하지 않으면 가지치기를 통해 해당 경로를 제거한다. 반면 브루트 포스는 가지치기 없이 모든 경우를 탐색한다. 백트래킹이 더 효율적이다.',
        true),
       (598, 225, '백트래킹과 브루트 포스는 완전히 동일하다',
        '백트래킹은 가지치기를 사용하지만 브루트 포스는 모든 경우를 탐색한다. 동일하지 않다.', false),
       (599, 225, '브루트 포스가 백트래킹보다 항상 빠르다',
        '백트래킹이 가지치기를 통해 탐색량을 줄이므로 더 빠르다.', false),
       (600, 225, '백트래킹은 해를 보장하지 못한다',
        '백트래킹도 모든 유효한 경로를 탐색하므로 해를 보장한다.', false),

       (601, 226, '경우의 수가 기하급수적으로 증가하는 경우',
        '브루트 포스는 경우의 수가 기하급수적으로 증가하는 경우(O(2^n), O(n!)) 비효율적이다. 입력 크기가 조금만 커져도 실행 시간이 급격히 증가하여 현실적으로 사용이 불가능해진다.',
        true),
       (602, 226, '경우의 수가 매우 적은 경우',
        '경우의 수가 적으면 브루트 포스도 효율적으로 사용할 수 있다.', false),
       (603, 226, '입력 크기가 작은 경우',
        '입력 크기가 작으면 브루트 포스도 충분히 사용 가능하다.', false),
       (604, 226, '해가 하나만 존재하는 경우',
        '해의 개수는 브루트 포스의 효율성과 직접적인 관련이 없다. 경우의 수가 중요하다.', false),

       (605, 228, '백트래킹, 그리디, 다이내믹 프로그래밍 등을 사용한다',
        '브루트 포스는 백트래킹(가지치기), 그리디(매 순간 최선 선택), 다이내믹 프로그래밍(중복 계산 제거) 등의 기법으로 개선할 수 있다. 상황에 맞는 최적화 기법을 선택하는 것이 중요하다.',
        true),
       (606, 228, '더 많은 경우의 수를 탐색한다',
        '개선 방법은 탐색량을 줄이는 것이다. 더 많이 탐색하는 것이 아니다.', false),
       (607, 228, '해를 찾지 않고 종료한다',
        '개선 방법도 해를 찾는 것을 목표로 한다. 해를 찾지 않는 것이 아니다.', false),
       (608, 228, '무작위로 경우를 선택한다',
        '개선 방법은 체계적인 최적화 기법이다. 무작위 선택이 아니다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (75, 224, '백트래킹, backtracking',
        '브루트 포스의 한계를 극복하기 위해 필요한 부분만 선택적으로 확인하는 백트래킹(backtracking)을 사용할 수 있다. 백트래킹은 조건을 만족하지 않는 경로를 가지치기하여 탐색 효율을 높인다.'),
       (76, 227, '가지치기, 제거',
        '백트래킹은 조건을 만족하지 않는 경로를 가지치기(pruning)하여 탐색 효율을 높인다. 유망하지 않은 노드를 제거함으로써 탐색량을 줄인다.');

-- Chapter: 알고리즘 (id: 2), Unit: 백트래킹 (id: 14)

-- Lesson 생성
INSERT INTO lesson (id, unit_id, title)
VALUES (39, 14, '백트래킹 기초 문제집'),
       (40, 14, '백트래킹 동작 과정 문제집'),
       (41, 14, '백트래킹 응용 문제집');

-- Chapter: 알고리즘 (id: 2), Unit: 백트래킹 (id: 14), Lesson: 백트래킹 기초 문제집 (id: 39)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (229, 39, '다음 중 백트래킹의 정의로 올바른 것은?', '백트래킹은 특정한 문제 해결 전략이다.', 'OBJECTIVE'),
       (230, 39, '빈칸에 들어갈 용어를 작성하시오', '백트래킹은 현재 상태가 제한 조건을 위배하는지 판단하고, 위배되는 경우 ___를 통해 해당 경로를 제거한다.', 'SUBJECTIVE'),
       (231, 39, '다음 중 백트래킹의 특징으로 올바른 것은?', '백트래킹은 특정한 특징을 가진다.', 'OBJECTIVE'),
       (232, 39, '다음 중 백트래킹 구현에 적합한 방법으로 올바른 것은?', '백트래킹은 특정 방식으로 구현하는 것이 적합하다.', 'OBJECTIVE'),
       (233, 39, '빈칸에 들어갈 자료구조를 작성하시오', '백트래킹은 주로 ___와 함께 사용되며 재귀적 구조로 구현된다.', 'SUBJECTIVE'),
       (234, 39, '다음 중 백트래킹과 브루트 포스의 차이로 올바른 것은?', '백트래킹은 브루트 포스와 차이가 있다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (609, 229, '현재 상태에서 가능한 모든 후보군을 탐색하되 조건을 만족하지 않으면 되돌아가는 전략이다',
        '백트래킹은 현재 상태에서 가능한 모든 후보군을 탐색하되, 조건을 만족하지 않으면 되돌아가는 문제 해결 전략이다. 모든 경우의 수를 탐색하되 해답이 아닌 경로를 가지치기하여 탐색 효율을 높인다.',
        true),
       (610, 229, '매 순간 최선의 선택을 하는 전략이다',
        '이는 그리디 알고리즘의 특징이다. 백트래킹은 모든 경우를 탐색하되 가지치기를 사용한다.', false),
       (611, 229, '문제를 작은 부분으로 나누어 해결하는 전략이다',
        '이는 분할 정복 알고리즘의 특징이다. 백트래킹은 조건을 만족하지 않으면 되돌아가는 전략이다.', false),
       (612, 229, '중복 계산을 제거하는 전략이다',
        '이는 다이내믹 프로그래밍의 특징이다. 백트래킹은 가지치기를 통해 탐색 효율을 높인다.', false),

       (613, 231, '재귀적 구조로 문제를 해결하며 조건을 만족하지 않으면 가지치기를 통해 해당 경로를 제거한다',
        '백트래킹은 재귀적 구조로 문제를 해결하며, 현재 상태가 제한 조건을 위배하면 가지치기를 통해 해당 경로를 제거한다. 주로 DFS와 함께 사용되며 상태 공간 트리로 표현 가능하다.',
        true),
       (614, 231, '반복문만으로 구현한다',
        '백트래킹은 주로 재귀적 구조로 구현한다. 반복문만으로 구현하지 않는다.', false),
       (615, 231, '가지치기를 사용하지 않는다',
        '백트래킹의 핵심은 가지치기이다. 가지치기를 통해 탐색 효율을 높인다.', false),
       (616, 231, '항상 최적해를 보장하지 못한다',
        '백트래킹은 모든 유효한 경로를 탐색하므로 해를 보장한다.', false),

       (617, 232, 'DFS를 사용한 재귀 구현이 적합하다',
        '백트래킹은 DFS를 사용한 재귀 구현이 적합하다. 현재 상태가 조건을 만족하지 않으면 이전 상태로 돌아가야 하므로 DFS의 깊이 우선 탐색과 백트래킹이 잘 맞는다.',
        true),
       (618, 232, 'BFS를 사용한 반복문 구현이 적합하다',
        '백트래킹은 DFS와 재귀가 더 적합하다. BFS보다는 DFS가 백트래킹에 적합하다.', false),
       (619, 232, '정렬 알고리즘을 사용한다',
        '백트래킹은 탐색 기법이다. 정렬 알고리즘과는 관련이 없다.', false),
       (620, 232, '해시 테이블을 사용한다',
        '백트래킹은 주로 재귀와 DFS로 구현한다. 해시 테이블이 필수는 아니다.', false),

       (621, 234, '백트래킹은 가지치기를 사용하지만 브루트 포스는 모든 경로를 탐색한다',
        '백트래킹은 유망하지 않은 경로를 제거하여 탐색량을 감소시키지만, 브루트 포스는 가지치기 없이 모든 경우를 탐색한다. 백트래킹이 브루트 포스보다 효율적이다.',
        true),
       (622, 234, '백트래킹과 브루트 포스는 완전히 동일하다',
        '백트래킹은 가지치기를 사용하지만 브루트 포스는 모든 경우를 탐색한다. 동일하지 않다.', false),
       (623, 234, '브루트 포스가 백트래킹보다 항상 빠르다',
        '백트래킹이 가지치기를 통해 탐색량을 줄이므로 더 효율적이다.', false),
       (624, 234, '백트래킹은 해를 보장하지 못한다',
        '백트래킹도 모든 유효한 경로를 탐색하므로 해를 보장한다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (77, 230, '가지치기, pruning',
        '백트래킹은 현재 상태가 제한 조건을 위배하는지 판단하고, 위배되는 경우 가지치기(pruning)를 통해 해당 경로를 제거한다. 유망하지 않은 노드를 제거함으로써 탐색 효율을 높인다.'),
       (78, 233, 'DFS, 깊이 우선 탐색, Depth First Search',
        '백트래킹은 주로 DFS(깊이 우선 탐색)와 함께 사용되며 재귀적 구조로 구현된다. 한 경로를 끝까지 탐색한 후 되돌아가는 DFS의 특성이 백트래킹에 적합하다.');

-- Chapter: 알고리즘 (id: 2), Unit: 백트래킹 (id: 14), Lesson: 백트래킹 동작 과정 문제집 (id: 40)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (235, 40, '다음 중 백트래킹 과정의 첫 번째 단계로 올바른 것은?', '백트래킹은 단계적으로 동작한다.', 'OBJECTIVE'),
       (236, 40, '빈칸에 들어갈 용어를 작성하시오', '백트래킹 과정에서 현재 상태가 조건을 만족하는지 확인하는 단계를 ___ 검사라고 한다.', 'SUBJECTIVE'),
       (237, 40, '다음 중 백트래킹의 가지치기 단계에 대한 설명으로 올바른 것은?', '백트래킹은 가지치기 단계를 포함한다.', 'OBJECTIVE'),
       (238, 40, '다음 중 백트래킹의 상태 공간 트리에 대한 설명으로 올바른 것은?', '백트래킹은 상태 공간 트리로 표현할 수 있다.', 'OBJECTIVE'),
       (239, 40, '빈칸에 들어갈 용어를 작성하시오', '백트래킹은 조건을 만족하는 경우 결과를 저장하고 다른 ___를 계속 탐색한다.', 'SUBJECTIVE'),
       (240, 40, '다음 중 백트래킹 예시 문제로 올바른 것은?', '백트래킹은 특정 유형의 문제에 사용된다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (625, 235, '시작 노드부터 탐색을 시작한다',
        '백트래킹 과정의 첫 번째 단계는 시작 노드부터 탐색을 시작하는 것이다. 초기 상태에서 가능한 모든 선택지를 탐색하기 시작한다.',
        true),
       (626, 235, '정답을 도출한다',
        '정답 도출은 마지막 단계이다. 첫 번째 단계는 탐색 시작이다.', false),
       (627, 235, '가지치기를 수행한다',
        '가지치기는 세 번째 단계이다. 첫 번째 단계는 탐색 시작이다.', false),
       (628, 235, '모든 경로를 저장한다',
        '첫 번째 단계는 탐색 시작이다. 경로 저장은 후속 단계에서 이루어진다.', false),

       (629, 237, '조건을 만족하지 않으면 해당 경로를 포기하고 이전 상태로 돌아간다',
        '백트래킹의 가지치기 단계는 조건을 만족하지 않으면 해당 경로를 포기하고 이전 상태로 돌아간다. 조건을 만족하면 해당 경로로 깊게 탐색한다. 이를 통해 불필요한 탐색을 줄인다.',
        true),
       (630, 237, '조건과 관계없이 모든 경로를 탐색한다',
        '백트래킹은 조건을 만족하지 않으면 가지치기를 한다. 모든 경로를 탐색하지 않는다.', false),
       (631, 237, '가장 짧은 경로만 선택한다',
        '백트래킹은 조건 만족 여부로 가지치기를 한다. 경로 길이만으로 판단하지 않는다.', false),
       (632, 237, '무작위로 경로를 선택한다',
        '백트래킹은 체계적으로 조건을 검사한다. 무작위 선택이 아니다.', false),

       (633, 238, '백트래킹의 탐색 과정을 트리 형태로 표현한 것이다',
        '상태 공간 트리는 백트래킹의 탐색 과정을 트리 형태로 표현한 것이다. 각 노드는 상태를, 간선은 상태 전이를 나타낸다. 가지치기된 경로는 트리에서 제거된다.',
        true),
       (634, 238, '이진 탐색 트리를 의미한다',
        '상태 공간 트리는 탐색 과정의 표현이다. 이진 탐색 트리와는 다르다.', false),
       (635, 238, '힙 자료구조를 의미한다',
        '상태 공간 트리는 백트래킹의 탐색 과정을 표현한 것이다. 힙과는 관련이 없다.', false),
       (636, 238, 'AVL 트리를 의미한다',
        '상태 공간 트리는 백트래킹의 탐색 과정을 나타낸다. AVL 트리와는 다르다.', false),

       (637, 240, 'N-Queen 문제, 순열과 조합, 스도쿠, 미로 탐색',
        '백트래킹은 N-Queen 문제(N×N 체스판에 N개의 퀸 배치), 순열과 조합(n개 중 r개 선택), 스도쿠(9×9 칸에 숫자 채우기), 미로 탐색(출구 찾기) 등에 사용된다. 제약 조건이 명확한 문제에 효과적이다.',
        true),
       (638, 240, '정렬 문제',
        '정렬 문제는 백트래킹보다 정렬 알고리즘이 적합하다.', false),
       (639, 240, '최단 경로 문제',
        '최단 경로 문제는 다익스트라 등의 알고리즘이 더 적합하다.', false),
       (640, 240, '문자열 검색 문제',
        '문자열 검색은 다른 알고리즘이 더 적합하다. 백트래킹은 제약 조건이 있는 탐색 문제에 사용된다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (79, 236, '유망성, 유망',
        '백트래킹 과정에서 현재 상태가 조건을 만족하는지 확인하는 단계를 유망성 검사라고 한다. 유망하지 않으면 가지치기를 통해 해당 경로를 제거한다.'),
       (80, 239, '경우의 수, 경우',
        '백트래킹은 조건을 만족하는 경우 결과를 저장하고 다른 경우의 수를 계속 탐색한다. 모든 가능한 해를 찾기 위해 탐색을 계속한다.');

-- Chapter: 알고리즘 (id: 2), Unit: 백트래킹 (id: 14), Lesson: 백트래킹 응용 문제집 (id: 41)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (241, 41, '다음 중 백트래킹의 시간 복잡도에 대한 설명으로 올바른 것은?', '백트래킹의 시간 복잡도는 상황에 따라 다르다.', 'OBJECTIVE'),
       (242, 41, '빈칸에 들어갈 용어를 작성하시오', '백트래킹은 ___가 실패하면 브루트 포스처럼 동작하여 비효율적이다.', 'SUBJECTIVE'),
       (243, 41, '다음 중 백트래킹의 장점으로 올바른 것은?', '백트래킹은 특정한 장점을 가진다.', 'OBJECTIVE'),
       (244, 41, '다음 중 백트래킹의 단점으로 올바른 것은?', '백트래킹은 단점도 가지고 있다.', 'OBJECTIVE'),
       (245, 41, '빈칸에 들어갈 개념을 작성하시오', '백트래킹은 ___가 명확한 문제에 효과적이며 N-Queen이나 스도쿠 같은 문제에 적합하다.', 'SUBJECTIVE'),
       (246, 41, '다음 중 백트래킹과 DFS의 관계로 올바른 것은?', '백트래킹은 DFS와 관련이 있다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (641, 241, '문제의 크기와 가지치기의 효과에 따라 달라진다',
        '백트래킹의 시간 복잡도는 문제의 크기와 가지치기의 효과에 따라 달라진다. 가지치기가 효과적이면 탐색량이 줄어들지만, 가지치기가 실패하면 브루트 포스처럼 동작한다.',
        true),
       (642, 241, '항상 O(1)이다',
        '백트래킹의 시간 복잡도는 상황에 따라 달라진다. 항상 O(1)이 아니다.', false),
       (643, 241, '항상 O(n)이다',
        '백트래킹의 시간 복잡도는 가지치기 효과에 따라 달라진다. 항상 O(n)은 아니다.', false),
       (644, 241, '항상 O(log n)이다',
        '백트래킹의 시간 복잡도는 문제와 가지치기에 따라 달라진다. 항상 O(log n)은 아니다.', false),

       (645, 243, '유망하지 않은 경로를 제거하여 탐색량을 감소시킨다',
        '백트래킹의 장점은 유망하지 않은 경로를 제거하여 탐색량을 감소시키고, 모든 경우를 고려하므로 최적해를 보장(완전 탐색)한다는 것이다. 브루트 포스보다 효율적이다.',
        true),
       (646, 243, '항상 O(1) 시간에 해를 찾는다',
        '백트래킹이 브루트 포스보다 효율적이지만 항상 O(1)은 아니다.', false),
       (647, 243, '메모리를 전혀 사용하지 않는다',
        '백트래킹도 메모리를 사용한다. 재귀 호출 스택 등에 메모리가 필요하다.', false),
       (648, 243, '구현이 매우 간단하다',
        '백트래킹은 브루트 포스보다 구현이 복잡할 수 있다.', false),

       (649, 244, '가지치기가 실패하면 브루트포스처럼 동작하여 비효율적이다',
        '백트래킹의 단점은 가지치기가 실패하면 브루트포스처럼 동작하여 비효율적이고, 최악의 경우 지수 시간 복잡도(O(N!), O(2^N))를 가진다는 것이다. 가지치기 효과가 중요하다.',
        true),
       (650, 244, '해를 보장하지 못한다',
        '백트래킹은 모든 유효한 경로를 탐색하므로 해를 보장한다. 이는 장점이다.', false),
       (651, 244, '메모리를 너무 많이 사용한다',
        '백트래킹의 주요 단점은 시간 복잡도이다. 메모리는 주요 단점이 아니다.', false),
       (652, 244, '구현이 불가능하다',
        '백트래킹은 구현 가능하다. 단지 가지치기가 실패하면 비효율적일 수 있다.', false),

       (653, 246, '백트래킹은 DFS의 탐색 방식을 기반으로 하며 가지치기를 추가한 것이다',
        '백트래킹은 DFS의 깊이 우선 탐색 방식을 기반으로 하며, 조건 검사와 가지치기를 추가한 것이다. DFS로 모든 경로를 탐색하되, 유망하지 않은 경로는 가지치기로 제거한다.',
        true),
       (654, 246, '백트래킹과 DFS는 완전히 다른 개념이다',
        '백트래킹은 DFS 기반에 가지치기를 추가한 것이다. 완전히 다르지 않다.', false),
       (655, 246, '백트래킹은 BFS를 사용한다',
        '백트래킹은 DFS 기반이다. BFS보다는 DFS가 백트래킹에 적합하다.', false),
       (656, 246, 'DFS는 백트래킹의 특수한 경우이다',
        '백트래킹이 DFS에 가지치기를 추가한 것이다. DFS가 백트래킹의 특수한 경우가 아니다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (81, 242, '가지치기, pruning',
        '백트래킹은 가지치기가 실패하면 브루트 포스처럼 동작하여 비효율적이다. 가지치기 효과가 백트래킹의 효율성을 결정한다.'),
       (82, 245, '제약 조건, 조건',
        '백트래킹은 제약 조건이 명확한 문제에 효과적이다. N-Queen이나 스도쿠처럼 명확한 규칙이 있는 문제에 적합하다. 조건을 잘 설정할수록 효율이 높아진다.');

-- Chapter: 알고리즘 (id: 2), Unit: 버블 정렬 (id: 15)

-- Lesson 생성
INSERT INTO lesson (id, unit_id, title)
VALUES (42, 15, '버블 정렬 기초 문제집'),
       (43, 15, '버블 정렬 동작 과정 문제집'),
       (44, 15, '버블 정렬 분석 문제집');

-- Chapter: 알고리즘 (id: 2), Unit: 버블 정렬 (id: 15), Lesson: 버블 정렬 기초 문제집 (id: 42)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (247, 42, '다음 중 버블 정렬의 정의로 올바른 것은?', '버블 정렬은 특정한 방식으로 동작하는 정렬 알고리즘이다.', 'OBJECTIVE'),
       (248, 42, '빈칸에 들어갈 용어를 작성하시오', '버블 정렬은 ___한 두 원소를 비교하여 조건에 맞지 않으면 자리를 교환하며 정렬한다.', 'SUBJECTIVE'),
       (249, 42, '다음 중 버블 정렬의 이름 유래로 올바른 것은?', '버블 정렬이라는 이름은 특정한 이유로 붙여졌다.', 'OBJECTIVE'),
       (250, 42, '다음 중 버블 정렬의 특징으로 올바른 것은?', '버블 정렬은 특정한 특징을 가진다.', 'OBJECTIVE'),
       (251, 42, '빈칸에 들어갈 구조를 작성하시오', '버블 정렬은 각 회전마다 가장 큰 값이 배열의 ___로 이동한다.', 'SUBJECTIVE'),
       (252, 42, '다음 중 버블 정렬의 안정성에 대한 설명으로 올바른 것은?', '버블 정렬은 안정성과 관련된 특성을 가진다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (657, 247, '인접한 두 원소를 비교하여 조건에 맞지 않으면 자리를 교환하며 정렬하는 알고리즘이다',
        '버블 정렬은 인접한 두 원소를 순차적으로 비교하여 조건에 맞지 않으면 자리를 교환하며 정렬하는 알고리즘이다. 가장 큰 값이 물거품처럼 뒤로 이동하는 모습에서 이름이 유래했다.',
        true),
       (658, 247, '피벗을 기준으로 분할하며 정렬하는 알고리즘이다',
        '이는 퀵 정렬의 특징이다. 버블 정렬은 인접한 두 원소를 비교하며 정렬한다.', false),
       (659, 247, '배열을 절반씩 나누어 정렬하는 알고리즘이다',
        '이는 병합 정렬의 특징이다. 버블 정렬은 인접한 원소를 비교한다.', false),
       (660, 247, '가장 작은 값을 찾아 앞으로 이동시키는 알고리즘이다',
        '이는 선택 정렬의 특징이다. 버블 정렬은 인접한 원소를 비교하며 큰 값을 뒤로 보낸다.', false),

       (661, 249, '가장 큰 값이 물거품처럼 뒤로 이동하는 모습에서 유래했다',
        '버블 정렬이라는 이름은 가장 큰 값이 물거품처럼 뒤로 이동하는 모습에서 유래했다. 각 회전마다 가장 큰 원소가 배열의 맨 뒤로 이동한다.',
        true),
       (662, 249, '정렬 속도가 빠르기 때문이다',
        '버블 정렬은 느린 정렬 알고리즘이다. 이름은 큰 값이 물거품처럼 뒤로 이동하는 모습에서 유래했다.', false),
       (663, 249, '메모리 사용량이 적기 때문이다',
        '이름은 메모리와 무관하다. 큰 값이 물거품처럼 뒤로 이동하는 모습에서 유래했다.', false),
       (664, 249, '구현이 간단하기 때문이다',
        '이름은 구현 난이도와 무관하다. 큰 값이 물거품처럼 이동하는 모습에서 유래했다.', false),

       (665, 250, '인접한 두 원소를 순차적으로 비교하며 각 회전마다 가장 큰 값이 맨 뒤로 이동한다',
        '버블 정렬은 인접한 두 원소를 순차적으로 비교하며, 각 회전마다 가장 큰 값이 배열의 맨 뒤로 이동한다. 정렬 범위가 회전마다 1씩 감소한다.',
        true),
       (666, 250, '피벗을 선택하여 분할한다',
        '이는 퀵 정렬의 특징이다. 버블 정렬은 인접한 원소를 비교한다.', false),
       (667, 250, '힙 자료구조를 사용한다',
        '이는 힙 정렬의 특징이다. 버블 정렬은 단순 비교와 교환으로 정렬한다.', false),
       (668, 250, '중간 원소를 기준으로 분할한다',
        '이는 병합 정렬의 특징이다. 버블 정렬은 인접한 원소를 비교한다.', false),

       (669, 252, '안정 정렬이며 동일한 값의 순서를 유지한다',
        '버블 정렬은 안정 정렬(Stable Sort)이다. 동일한 값의 순서가 유지되므로 동일한 키를 가진 데이터의 상대적 순서가 변하지 않는다.',
        true),
       (670, 252, '불안정 정렬이며 동일한 값의 순서가 바뀔 수 있다',
        '버블 정렬은 안정 정렬이다. 동일한 값의 순서가 유지된다.', false),
       (671, 252, '동일한 값을 처리할 수 없다',
        '버블 정렬은 동일한 값을 처리할 수 있으며 순서를 유지한다.', false),
       (672, 252, '동일한 값은 항상 제거된다',
        '버블 정렬은 동일한 값을 유지한다. 제거하지 않는다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (83, 248, '인접, 인접한',
        '버블 정렬은 인접한 두 원소를 비교하여 조건에 맞지 않으면 자리를 교환하며 정렬한다. 첫 번째와 두 번째, 두 번째와 세 번째 원소를 순차적으로 비교한다.'),
       (84, 251, '맨 뒤, 끝',
        '버블 정렬은 각 회전마다 가장 큰 값이 배열의 맨 뒤로 이동한다. 물거품처럼 큰 값이 뒤로 올라가는 모습에서 이름이 유래했다.');

-- Chapter: 알고리즘 (id: 2), Unit: 버블 정렬 (id: 15), Lesson: 버블 정렬 동작 과정 문제집 (id: 43)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (253, 43, '다음 중 버블 정렬의 정렬 과정으로 올바른 것은?', '버블 정렬은 단계적으로 동작한다.', 'OBJECTIVE'),
       (254, 43, '빈칸에 들어갈 숫자를 작성하시오', 'N개의 원소가 있을 때 버블 정렬은 최대 ___번의 회전을 수행한다.', 'SUBJECTIVE'),
       (255, 43, '다음 중 버블 정렬의 비교 횟수에 대한 설명으로 올바른 것은?', '버블 정렬의 비교 횟수는 특정한 규칙을 따른다.', 'OBJECTIVE'),
       (256, 43, '다음 중 버블 정렬의 교환 횟수에 대한 설명으로 올바른 것은?', '버블 정렬의 교환 횟수는 상황에 따라 다르다.', 'OBJECTIVE'),
       (257, 43, '빈칸에 들어갈 수식을 작성하시오', '버블 정렬은 모든 경우에서 ___번의 비교를 수행한다.', 'SUBJECTIVE'),
       (258, 43, '다음 중 버블 정렬에서 각 회전 후 변화로 올바른 것은?', '버블 정렬은 각 회전 후 특정한 변화가 일어난다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (673, 253, '첫 번째와 두 번째 원소부터 순차적으로 비교하여 큰 값을 뒤로 보낸다',
        '버블 정렬은 첫 번째와 두 번째, 두 번째와 세 번째 원소를 순차적으로 비교하여 큰 값을 뒤로 보낸다. 1회전 후 가장 큰 원소가 맨 뒤로 이동하고, 이 과정을 모든 원소가 정렬될 때까지 반복한다.',
        true),
       (674, 253, '가장 작은 값을 찾아 첫 번째 위치로 이동시킨다',
        '이는 선택 정렬의 동작이다. 버블 정렬은 인접한 원소를 비교하며 큰 값을 뒤로 보낸다.', false),
       (675, 253, '배열을 절반으로 나누어 각각 정렬한다',
        '이는 병합 정렬의 동작이다. 버블 정렬은 인접한 원소를 비교한다.', false),
       (676, 253, '피벗을 기준으로 작은 값과 큰 값을 분리한다',
        '이는 퀵 정렬의 동작이다. 버블 정렬은 인접한 원소를 비교하며 정렬한다.', false),

       (677, 255, '모든 경우에서 n(n-1)/2번의 비교를 수행한다',
        '버블 정렬은 모든 경우에서 n(n-1)/2번의 비교를 수행한다. 정렬 여부와 무관하게 모든 인접한 원소를 비교하므로 비교 횟수는 일정하다.',
        true),
       (678, 255, '최선의 경우 n번의 비교를 수행한다',
        '버블 정렬은 최선의 경우에도 모든 비교를 수행한다. n(n-1)/2번 비교한다.', false),
       (679, 255, '최악의 경우에만 비교를 수행한다',
        '버블 정렬은 모든 경우에 비교를 수행한다. 정렬 여부와 무관하게 비교한다.', false),
       (680, 255, '이미 정렬된 경우 비교하지 않는다',
        '버블 정렬은 정렬 여부와 무관하게 모든 비교를 수행한다.', false),

       (681, 256, '최선의 경우 0번, 최악의 경우 3n(n-1)/2번 교환한다',
        '버블 정렬의 교환 횟수는 최선의 경우(이미 정렬된 경우) 0번, 최악의 경우(역순 정렬) 3n(n-1)/2번이다. temp를 이용한 swap 연산 때문에 비교 횟수의 3배가 된다.',
        true),
       (682, 256, '항상 n번 교환한다',
        '교환 횟수는 데이터 상태에 따라 다르다. 항상 n번은 아니다.', false),
       (683, 256, '최선의 경우에도 n(n-1)/2번 교환한다',
        '최선의 경우(이미 정렬된 경우) 교환은 0번이다.', false),
       (684, 256, '교환은 발생하지 않는다',
        '정렬되지 않은 경우 교환이 발생한다. 최악의 경우 3n(n-1)/2번 교환한다.', false),

       (685, 258, '가장 큰 원소가 맨 뒤로 이동하고 정렬 범위가 1씩 감소한다',
        '버블 정렬은 각 회전 후 가장 큰 원소가 맨 뒤로 이동하고, 정렬 범위가 1씩 감소한다. N번째 원소는 정렬에서 제외되고 나머지 원소들에 대해 동일한 과정을 반복한다.',
        true),
       (686, 258, '가장 작은 원소가 맨 앞으로 이동한다',
        '버블 정렬은 큰 값이 뒤로 이동한다. 작은 값이 앞으로 이동하는 것은 선택 정렬이다.', false),
       (687, 258, '정렬 범위가 변하지 않는다',
        '버블 정렬은 각 회전마다 정렬 범위가 1씩 감소한다.', false),
       (688, 258, '피벗이 확정된다',
        '피벗은 퀵 정렬의 개념이다. 버블 정렬은 가장 큰 원소가 맨 뒤로 확정된다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (85, 254, 'N-1, n-1',
        'N개의 원소가 있을 때 버블 정렬은 최대 N-1번의 회전을 수행한다. 각 회전마다 하나의 원소가 확정되므로 N-1번이면 모든 원소가 정렬된다.'),
       (86, 257, 'n(n-1)/2, (n*(n-1))/2',
        '버블 정렬은 모든 경우에서 n(n-1)/2번의 비교를 수행한다. 첫 회전에서 n-1번, 두 번째 회전에서 n-2번 비교하므로 총 n(n-1)/2번이다.');

-- Chapter: 알고리즘 (id: 2), Unit: 버블 정렬 (id: 15), Lesson: 버블 정렬 분석 문제집 (id: 44)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (259, 44, '다음 중 버블 정렬의 시간 복잡도로 올바른 것은?', '버블 정렬은 특정한 시간 복잡도를 가진다.', 'OBJECTIVE'),
       (260, 44, '빈칸에 들어갈 표기를 작성하시오', '버블 정렬의 최선, 평균, 최악의 시간 복잡도는 모두 ___이다.', 'SUBJECTIVE'),
       (261, 44, '다음 중 버블 정렬의 장점으로 올바른 것은?', '버블 정렬은 특정한 장점을 가진다.', 'OBJECTIVE'),
       (262, 44, '다음 중 버블 정렬의 단점으로 올바른 것은?', '버블 정렬은 단점도 가지고 있다.', 'OBJECTIVE'),
       (263, 44, '빈칸에 들어갈 정렬 방식을 작성하시오', '버블 정렬은 추가 메모리가 불필요한 ___ 정렬이다.', 'SUBJECTIVE'),
       (264, 44, '다음 중 버블 정렬과 다른 정렬 알고리즘의 비교로 올바른 것은?', '버블 정렬은 다른 정렬 알고리즘과 비교할 수 있다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (689, 259, '최선, 평균, 최악 모두 O(n²)이다',
        '버블 정렬의 시간 복잡도는 최선, 평균, 최악의 경우 모두 O(n²)이다. 이미 정렬된 경우에도 모든 비교를 수행하므로 최선의 경우도 O(n²)이다.',
        true),
       (690, 259, '최선 O(n), 평균 O(n log n), 최악 O(n²)이다',
        '버블 정렬은 모든 경우에 O(n²)이다. 정렬 여부와 무관하게 모든 비교를 수행한다.', false),
       (691, 259, '모든 경우에 O(n log n)이다',
        '버블 정렬은 O(n²)이다. O(n log n)은 병합 정렬이나 퀵 정렬의 시간 복잡도이다.', false),
       (692, 259, '최선 O(1), 평균 O(n), 최악 O(n²)이다',
        '버블 정렬은 모든 경우에 O(n²)이다. 최선의 경우도 O(n²)이다.', false),

       (693, 261, '구현이 매우 간단하고 직관적이며 제자리 정렬이고 안정 정렬이다',
        '버블 정렬의 장점은 구현이 매우 간단하고 직관적이며, 제자리 정렬(in-place sorting)로 추가 메모리가 불필요하고, 안정 정렬(Stable Sort)로 동일한 값의 순서를 유지한다는 것이다.',
        true),
       (694, 261, '시간이 매우 빠르다',
        '버블 정렬은 O(n²)으로 느린 정렬 알고리즘이다. 시간이 빠르지 않다.', false),
       (695, 261, '최악의 경우에도 O(n log n)이다',
        '버블 정렬은 최악의 경우 O(n²)이다. O(n log n)이 아니다.', false),
       (696, 261, '메모리를 많이 사용한다',
        '버블 정렬은 제자리 정렬로 추가 메모리가 거의 불필요하다. 이는 장점이지만 메모리를 많이 사용하는 것은 아니다.', false),

       (697, 262, '비효율적인 시간 복잡도와 정렬 여부와 무관하게 모든 비교를 수행한다',
        '버블 정렬의 단점은 비효율적인 시간 복잡도(O(n²))를 가지고, 정렬 여부와 무관하게 모든 비교를 수행하며, 교환 연산(swap)이 빈번하게 발생한다는 것이다. 실무에서는 거의 사용되지 않는다.',
        true),
       (698, 262, '구현이 매우 복잡하다',
        '버블 정렬은 구현이 간단하다. 복잡하지 않다.', false),
       (699, 262, '안정 정렬이 아니다',
        '버블 정렬은 안정 정렬이다. 동일한 값의 순서를 유지한다.', false),
       (700, 262, '추가 메모리가 많이 필요하다',
        '버블 정렬은 제자리 정렬로 추가 메모리가 거의 불필요하다.', false),

       (701, 264, '작은 데이터나 거의 정렬된 데이터에는 삽입 정렬이 더 효율적이다',
        '버블 정렬은 교육 목적으로 많이 사용되지만 실무에서는 거의 사용되지 않는다. 작은 데이터셋이나 거의 정렬된 데이터에는 삽입 정렬이, 일반적인 경우에는 퀵 정렬이나 병합 정렬이 더 효율적이다.',
        true),
       (702, 264, '버블 정렬이 퀵 정렬보다 항상 빠르다',
        '버블 정렬은 O(n²), 퀵 정렬은 평균 O(n log n)으로 퀵 정렬이 더 빠르다.', false),
       (703, 264, '버블 정렬이 병합 정렬보다 메모리를 많이 사용한다',
        '버블 정렬은 제자리 정렬로 추가 메모리가 거의 없다. 병합 정렬은 O(n) 메모리가 필요하다.', false),
       (704, 264, '버블 정렬이 힙 정렬보다 안정적이다',
        '버블 정렬은 안정 정렬이고 힙 정렬은 불안정 정렬이지만, 시간 복잡도 측면에서 힙 정렬이 더 효율적이다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (87, 260, 'O(n²), O(n^2)',
        '버블 정렬의 최선, 평균, 최악의 시간 복잡도는 모두 O(n²)이다. 정렬 여부와 관계없이 모든 비교를 수행하므로 항상 O(n²)이다.'),
       (88, 263, '제자리, in-place',
        '버블 정렬은 추가 메모리가 불필요한 제자리(in-place) 정렬이다. 원본 배열 내에서 교환만으로 정렬하므로 추가 메모리가 거의 필요하지 않다.');


-- Chapter: 알고리즘 (id: 2), Unit: 선택 정렬 (id: 16)

-- Lesson 생성
INSERT INTO lesson (id, unit_id, title)
VALUES (45, 16, '선택 정렬 기초 문제집'),
       (46, 16, '선택 정렬 동작 과정 문제집'),
       (47, 16, '선택 정렬 분석 문제집');

-- Chapter: 알고리즘 (id: 2), Unit: 선택 정렬 (id: 16), Lesson: 선택 정렬 기초 문제집 (id: 45)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (265, 45, '다음 중 선택 정렬의 정의로 올바른 것은?', '선택 정렬은 특정한 방식으로 동작하는 정렬 알고리즘이다.', 'OBJECTIVE'),
       (266, 45, '빈칸에 들어갈 용어를 작성하시오', '선택 정렬은 정렬할 위치는 이미 정해져 있고 어떤 ___를 선택하여 그 위치에 넣을지 결정한다.', 'SUBJECTIVE'),
       (267, 45, '다음 중 선택 정렬의 특징으로 올바른 것은?', '선택 정렬은 특정한 특징을 가진다.', 'OBJECTIVE'),
       (268, 45, '다음 중 선택 정렬의 교환 횟수에 대한 설명으로 올바른 것은?', '선택 정렬의 교환 횟수는 특정한 규칙을 따른다.', 'OBJECTIVE'),
       (269, 45, '빈칸에 들어갈 용어를 작성하시오', '선택 정렬은 매 회전마다 ___을 탐색하여 정해진 위치에 배치한다.', 'SUBJECTIVE'),
       (270, 45, '다음 중 선택 정렬의 안정성에 대한 설명으로 올바른 것은?', '선택 정렬은 안정성과 관련된 특성을 가진다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (705, 265, '정렬할 위치는 이미 정해져 있고 어떤 원소를 선택하여 그 위치에 넣을지 결정하는 알고리즘이다',
        '선택 정렬은 정렬할 위치는 이미 정해져 있고, 어떤 원소를 선택하여 그 위치에 넣을지 결정하는 알고리즘이다. 매 회전마다 가장 작은 값을 찾아 앞쪽의 정해진 위치와 교환한다.',
        true),
       (706, 265, '인접한 두 원소를 비교하여 교환하는 알고리즘이다',
        '이는 버블 정렬의 특징이다. 선택 정렬은 최솟값을 찾아 정해진 위치에 배치한다.', false),
       (707, 265, '정렬된 부분에 원소를 삽입하는 알고리즘이다',
        '이는 삽입 정렬의 특징이다. 선택 정렬은 최솟값을 선택하여 위치에 배치한다.', false),
       (708, 265, '피벗을 기준으로 분할하는 알고리즘이다',
        '이는 퀵 정렬의 특징이다. 선택 정렬은 최솟값을 선택하여 배치한다.', false),

       (709, 267, '매 회전마다 최솟값을 탐색하여 정해진 위치에 배치하고 교환 횟수가 최대 n-1번으로 제한된다',
        '선택 정렬은 매 회전마다 최솟값을 탐색하여 정해진 위치에 배치하며, 교환 횟수가 최대 n-1번으로 제한된다. 버블 정렬보다 교환 횟수가 적지만 불안정 정렬이다.',
        true),
       (710, 267, '인접한 원소를 비교한다',
        '이는 버블 정렬의 특징이다. 선택 정렬은 최솟값을 찾아 배치한다.', false),
       (711, 267, '교환 횟수가 O(n²)이다',
        '선택 정렬의 교환 횟수는 최대 n-1번이다. O(n²)이 아니라 O(n)이다.', false),
       (712, 267, '안정 정렬이다',
        '선택 정렬은 불안정 정렬이다. 동일한 값의 순서가 바뀔 수 있다.', false),

       (713, 268, '교환 횟수가 최대 n-1번으로 제한된다',
        '선택 정렬의 교환 횟수는 최대 n-1번으로 제한된다. 매 회전마다 최대 1번 교환하므로 버블 정렬보다 교환 횟수가 훨씬 적다.',
        true),
       (714, 268, '교환 횟수가 n(n-1)/2번이다',
        '이는 비교 횟수이다. 교환 횟수는 최대 n-1번이다.', false),
       (715, 268, '교환이 전혀 발생하지 않는다',
        '정렬되지 않은 경우 교환이 발생한다. 최대 n-1번 교환한다.', false),
       (716, 268, '교환 횟수가 버블 정렬보다 많다',
        '선택 정렬의 교환 횟수는 버블 정렬보다 적다. 최대 n-1번으로 제한된다.', false),

       (717, 270, '불안정 정렬이며 동일한 값의 순서가 바뀔 수 있다',
        '선택 정렬은 불안정 정렬(Unstable Sort)이다. 동일한 값의 순서가 바뀔 수 있으므로 동일한 키를 가진 데이터의 상대적 순서가 변할 수 있다.',
        true),
       (718, 270, '안정 정렬이며 동일한 값의 순서를 유지한다',
        '선택 정렬은 불안정 정렬이다. 동일한 값의 순서가 바뀔 수 있다.', false),
       (719, 270, '동일한 값을 처리할 수 없다',
        '선택 정렬은 동일한 값을 처리할 수 있지만 순서가 바뀔 수 있다.', false),
       (720, 270, '동일한 값은 항상 제거된다',
        '선택 정렬은 동일한 값을 유지한다. 제거하지 않는다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (89, 266, '원소, 요소',
        '선택 정렬은 정렬할 위치는 이미 정해져 있고 어떤 원소를 선택하여 그 위치에 넣을지 결정한다. 매 회전마다 최솟값을 선택하여 배치한다.'),
       (90, 269, '최솟값, 가장 작은 값',
        '선택 정렬은 매 회전마다 최솟값을 탐색하여 정해진 위치에 배치한다. 첫 번째 위치에는 전체 중 최솟값을, 두 번째 위치에는 나머지 중 최솟값을 배치한다.');

-- Chapter: 알고리즘 (id: 2), Unit: 선택 정렬 (id: 16), Lesson: 선택 정렬 동작 과정 문제집 (id: 46)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (271, 46, '다음 중 선택 정렬의 정렬 과정으로 올바른 것은?', '선택 정렬은 단계적으로 동작한다.', 'OBJECTIVE'),
       (272, 46, '빈칸에 들어갈 용어를 작성하시오', '선택 정렬의 1회전에서는 첫 번째 원소를 ___부터 마지막 원소까지와 비교하여 가장 작은 값을 첫 번째 위치에 옮긴다.', 'SUBJECTIVE'),
       (273, 46, '다음 중 선택 정렬의 비교 횟수에 대한 설명으로 올바른 것은?', '선택 정렬의 비교 횟수는 특정한 규칙을 따른다.', 'OBJECTIVE'),
       (274, 46, '다음 중 선택 정렬에서 각 회전 후 변화로 올바른 것은?', '선택 정렬은 각 회전 후 특정한 변화가 일어난다.', 'OBJECTIVE'),
       (275, 46, '빈칸에 들어갈 수식을 작성하시오', '선택 정렬은 모든 경우에서 ___번의 비교를 수행한다.', 'SUBJECTIVE'),
       (276, 46, '다음 중 선택 정렬의 교환 시점에 대한 설명으로 올바른 것은?', '선택 정렬은 특정한 시점에 교환을 수행한다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (721, 271, '주어진 배열에서 가장 작은 값을 찾아 첫 번째 요소의 값과 교체한다',
        '선택 정렬은 주어진 배열에서 가장 작은 값을 찾아 첫 번째 요소의 값과 교체한다. 정렬된 맨 처음 위치를 빼고 나머지 배열을 같은 방법으로 교체하며, 하나의 원소만 남을 때까지 반복한다.',
        true),
       (722, 271, '인접한 두 원소를 순차적으로 비교하여 교환한다',
        '이는 버블 정렬의 동작이다. 선택 정렬은 최솟값을 찾아 정해진 위치에 배치한다.', false),
       (723, 271, '정렬된 부분에 원소를 삽입한다',
        '이는 삽입 정렬의 동작이다. 선택 정렬은 최솟값을 선택하여 위치에 배치한다.', false),
       (724, 271, '배열을 절반으로 나누어 정렬한다',
        '이는 병합 정렬의 동작이다. 선택 정렬은 최솟값을 찾아 배치한다.', false),

       (725, 273, '모든 경우에서 n(n-1)/2번의 비교를 수행한다',
        '선택 정렬은 모든 경우에서 n(n-1)/2번의 비교를 수행한다. 정렬 여부와 무관하게 최솟값을 찾기 위해 모든 원소를 비교하므로 비교 횟수는 일정하다.',
        true),
       (726, 273, '최선의 경우 n번의 비교를 수행한다',
        '선택 정렬은 최선의 경우에도 모든 비교를 수행한다. n(n-1)/2번 비교한다.', false),
       (727, 273, '이미 정렬된 경우 비교하지 않는다',
        '선택 정렬은 정렬 여부와 무관하게 모든 비교를 수행한다.', false),
       (728, 273, '최악의 경우에만 비교를 수행한다',
        '선택 정렬은 모든 경우에 비교를 수행한다. 정렬 여부와 무관하다.', false),

       (729, 274, '가장 작은 값이 정해진 위치로 이동하고 정렬 범위가 1씩 감소한다',
        '선택 정렬은 각 회전 후 가장 작은 값이 정해진 위치로 이동하고, 정렬 범위가 1씩 감소한다. 정렬된 부분을 제외하고 나머지 원소들에 대해 동일한 과정을 반복한다.',
        true),
       (730, 274, '가장 큰 값이 맨 뒤로 이동한다',
        '이는 버블 정렬의 특징이다. 선택 정렬은 가장 작은 값이 앞으로 이동한다.', false),
       (731, 274, '정렬 범위가 변하지 않는다',
        '선택 정렬은 각 회전마다 정렬 범위가 1씩 감소한다.', false),
       (732, 274, '피벗이 확정된다',
        '피벗은 퀵 정렬의 개념이다. 선택 정렬은 최솟값이 확정된다.', false),

       (733, 276, '각 회전에서 최솟값을 찾은 후 정해진 위치와 한 번만 교환한다',
        '선택 정렬은 각 회전에서 최솟값을 찾은 후 정해진 위치와 한 번만 교환한다. 비교는 여러 번 하지만 교환은 회전당 최대 1번만 발생하므로 교환 횟수가 적다.',
        true),
       (734, 276, '비교할 때마다 교환한다',
        '선택 정렬은 최솟값을 찾은 후 한 번만 교환한다. 비교할 때마다 교환하지 않는다.', false),
       (735, 276, '교환이 전혀 발생하지 않는다',
        '정렬되지 않은 경우 교환이 발생한다. 회전당 최대 1번 교환한다.', false),
       (736, 276, '항상 모든 원소를 교환한다',
        '선택 정렬은 회전당 최대 1번만 교환한다. 모든 원소를 교환하지 않는다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (91, 272, '두 번째, 2번째',
        '선택 정렬의 1회전에서는 첫 번째 원소를 두 번째 원소부터 마지막 원소까지와 비교하여 가장 작은 값을 첫 번째 위치에 옮긴다. 이 과정에서 원소를 n-1번 비교한다.'),
       (92, 275, 'n(n-1)/2, (n*(n-1))/2',
        '선택 정렬은 모든 경우에서 n(n-1)/2번의 비교를 수행한다. 첫 회전에서 n-1번, 두 번째 회전에서 n-2번 비교하므로 총 n(n-1)/2번이다.');

-- Chapter: 알고리즘 (id: 2), Unit: 선택 정렬 (id: 16), Lesson: 선택 정렬 분석 문제집 (id: 47)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (277, 47, '다음 중 선택 정렬의 시간 복잡도로 올바른 것은?', '선택 정렬은 특정한 시간 복잡도를 가진다.', 'OBJECTIVE'),
       (278, 47, '빈칸에 들어갈 표기를 작성하시오', '선택 정렬의 최선, 평균, 최악의 시간 복잡도는 모두 ___이다.', 'SUBJECTIVE'),
       (279, 47, '다음 중 선택 정렬의 장점으로 올바른 것은?', '선택 정렬은 특정한 장점을 가진다.', 'OBJECTIVE'),
       (280, 47, '다음 중 선택 정렬의 단점으로 올바른 것은?', '선택 정렬은 단점도 가지고 있다.', 'OBJECTIVE'),
       (281, 47, '빈칸에 들어갈 정렬 방식을 작성하시오', '선택 정렬은 추가 메모리가 불필요한 ___ 정렬이다.', 'SUBJECTIVE'),
       (282, 47, '다음 중 선택 정렬의 활용에 대한 설명으로 올바른 것은?', '선택 정렬은 특정 상황에서 유용하다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (737, 277, '최선, 평균, 최악 모두 O(n²)이다',
        '선택 정렬의 시간 복잡도는 최선, 평균, 최악의 경우 모두 O(n²)이다. 이미 정렬된 경우에도 최솟값을 찾기 위해 모든 비교를 수행하므로 최선의 경우도 O(n²)이다.',
        true),
       (738, 277, '최선 O(n), 평균 O(n log n), 최악 O(n²)이다',
        '선택 정렬은 모든 경우에 O(n²)이다. 정렬 여부와 무관하게 모든 비교를 수행한다.', false),
       (739, 277, '모든 경우에 O(n log n)이다',
        '선택 정렬은 O(n²)이다. O(n log n)은 병합 정렬이나 퀵 정렬의 시간 복잡도이다.', false),
       (740, 277, '최선 O(1), 평균 O(n), 최악 O(n²)이다',
        '선택 정렬은 모든 경우에 O(n²)이다. 최선의 경우도 O(n²)이다.', false),

       (741, 279, '교환 횟수가 적고 제자리 정렬이며 자료 이동 횟수가 미리 결정된다',
        '선택 정렬의 장점은 구현이 간단하고 이해하기 쉬우며, 교환 횟수가 적고(버블 정렬보다 효율적), 제자리 정렬로 추가 메모리가 불필요하고, 자료 이동 횟수가 미리 결정된다(최대 n-1번)는 것이다.',
        true),
       (742, 279, '시간이 매우 빠르다',
        '선택 정렬은 O(n²)으로 느린 정렬 알고리즘이다. 시간이 빠르지 않다.', false),
       (743, 279, '안정 정렬이다',
        '선택 정렬은 불안정 정렬이다. 동일한 값의 순서가 바뀔 수 있다.', false),
       (744, 279, '정렬된 배열에서 O(n)이다',
        '선택 정렬은 정렬 여부와 무관하게 O(n²)이다. 정렬된 배열에서도 O(n²)이다.', false),

       (745, 280, '비효율적인 시간 복잡도와 정렬 여부와 무관하게 모든 비교를 수행한다',
        '선택 정렬의 단점은 비효율적인 시간 복잡도(O(n²))를 가지고, 정렬 여부와 무관하게 모든 비교를 수행하며, 불안정 정렬로 동일한 값의 순서가 바뀔 수 있다는 것이다.',
        true),
       (746, 280, '구현이 매우 복잡하다',
        '선택 정렬은 구현이 간단하다. 복잡하지 않다.', false),
       (747, 280, '교환 횟수가 매우 많다',
        '선택 정렬의 교환 횟수는 적다. 최대 n-1번으로 제한된다.', false),
       (748, 280, '추가 메모리가 많이 필요하다',
        '선택 정렬은 제자리 정렬로 추가 메모리가 거의 불필요하다.', false),

       (749, 282, '교환 횟수가 적어 메모리 쓰기 비용이 큰 환경에서 유용하다',
        '선택 정렬은 교환 횟수가 적어 메모리 쓰기 비용이 큰 환경(예: EEPROM)에서 유용하다. 하지만 대부분의 경우 삽입 정렬, 퀵 정렬, 병합 정렬이 더 효율적이다.',
        true),
       (750, 282, '대용량 데이터 정렬에 적합하다',
        '선택 정렬은 O(n²)으로 대용량 데이터에 비효율적이다. 퀵 정렬이나 병합 정렬이 더 적합하다.', false),
       (751, 282, '실시간 시스템에서 주로 사용된다',
        '선택 정렬은 시간 복잡도가 높아 실시간 시스템에 부적합하다.', false),
       (752, 282, '네트워크 프로토콜 구현에 사용된다',
        '선택 정렬은 일반적인 정렬 알고리즘이다. 네트워크 프로토콜과는 직접적인 관련이 없다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (93, 278, 'O(n²), O(n^2)',
        '선택 정렬의 최선, 평균, 최악의 시간 복잡도는 모두 O(n²)이다. 정렬 여부와 관계없이 최솟값을 찾기 위해 모든 비교를 수행하므로 항상 O(n²)이다.'),
       (94, 281, '제자리, in-place',
        '선택 정렬은 추가 메모리가 불필요한 제자리(in-place) 정렬이다. 원본 배열 내에서 교환만으로 정렬하므로 추가 메모리가 거의 필요하지 않다.');

-- Chapter: 알고리즘 (id: 2), Unit: 삽입 정렬 (id: 17)

-- Lesson 생성
INSERT INTO lesson (id, unit_id, title)
VALUES (48, 17, '삽입 정렬 기초 문제집'),
       (49, 17, '삽입 정렬 동작 과정 문제집'),
       (50, 17, '삽입 정렬 분석 문제집');

-- Chapter: 알고리즘 (id: 2), Unit: 삽입 정렬 (id: 17), Lesson: 삽입 정렬 기초 문제집 (id: 48)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (283, 48, '다음 중 삽입 정렬의 정의로 올바른 것은?', '삽입 정렬은 특정한 방식으로 동작하는 정렬 알고리즘이다.', 'OBJECTIVE'),
       (284, 48, '빈칸에 들어갈 용어를 작성하시오', '삽입 정렬은 ___된 부분과 정렬되지 않은 부분으로 나누어 정렬한다.', 'SUBJECTIVE'),
       (285, 48, '다음 중 삽입 정렬의 특징으로 올바른 것은?', '삽입 정렬은 특정한 특징을 가진다.', 'OBJECTIVE'),
       (286, 48, '다음 중 삽입 정렬이 효율적인 경우로 올바른 것은?', '삽입 정렬은 특정 상황에서 효율적이다.', 'OBJECTIVE'),
       (287, 48, '빈칸에 들어갈 시간 복잡도를 작성하시오', '삽입 정렬은 거의 정렬된 배열에서 ___의 효율적인 성능을 보인다.', 'SUBJECTIVE'),
       (288, 48, '다음 중 삽입 정렬의 안정성에 대한 설명으로 올바른 것은?', '삽입 정렬은 안정성과 관련된 특성을 가진다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (753, 283, '정렬된 부분과 정렬되지 않은 부분으로 나누어 정렬되지 않은 부분에서 원소를 하나씩 꺼내 정렬된 부분의 올바른 위치에 삽입하는 알고리즘이다',
        '삽입 정렬은 배열을 정렬된 부분과 정렬되지 않은 부분으로 나누어, 정렬되지 않은 부분에서 원소를 하나씩 꺼내 정렬된 부분의 올바른 위치에 삽입하는 알고리즘이다. 손안의 카드를 정렬하는 방법과 유사하다.',
        true),
       (754, 283, '가장 작은 값을 찾아 앞으로 이동시키는 알고리즘이다',
        '이는 선택 정렬의 특징이다. 삽입 정렬은 원소를 정렬된 부분에 삽입한다.', false),
       (755, 283, '인접한 두 원소를 비교하여 교환하는 알고리즘이다',
        '이는 버블 정렬의 특징이다. 삽입 정렬은 정렬된 부분에 원소를 삽입한다.', false),
       (756, 283, '피벗을 기준으로 분할하는 알고리즘이다',
        '이는 퀵 정렬의 특징이다. 삽입 정렬은 정렬된 부분에 원소를 삽입한다.', false),

       (757, 285, '배열을 정렬된 부분과 정렬되지 않은 부분으로 구분하고 정렬된 부분의 맨 뒤 원소부터 비교하며 적절한 위치를 찾는다',
        '삽입 정렬은 배열을 정렬된 부분과 정렬되지 않은 부분으로 구분하고, 정렬되지 않은 부분에서 원소를 하나씩 선택하여 삽입한다. 정렬된 부분의 맨 뒤 원소부터 비교하며 적절한 위치를 찾는다.',
        true),
       (758, 285, '항상 인접한 원소만 비교한다',
        '삽입 정렬은 정렬된 부분의 원소들과 비교한다. 인접한 원소만 비교하는 것은 아니다.', false),
       (759, 285, '교환 횟수가 최대 n-1번이다',
        '이는 선택 정렬의 특징이다. 삽입 정렬은 상황에 따라 교환 횟수가 다르다.', false),
       (760, 285, '불안정 정렬이다',
        '삽입 정렬은 안정 정렬이다. 동일한 값의 순서를 유지한다.', false),

       (761, 286, '거의 정렬된 데이터에서 O(n)의 효율적인 성능을 보인다',
        '삽입 정렬은 거의 정렬된 배열에서 매우 효율적이며 O(n)의 성능을 보인다. 각 원소가 거의 제자리에 있으면 비교와 이동이 최소화된다. TimSort와 IntroSort는 작은 부분 배열에서 삽입 정렬을 사용한다.',
        true),
       (762, 286, '역순으로 정렬된 배열에서 빠르다',
        '역순 정렬된 배열은 삽입 정렬의 최악의 경우이다. O(n²)의 성능을 보인다.', false),
       (763, 286, '무작위 배열에서 가장 빠르다',
        '무작위 배열에서는 퀵 정렬이나 병합 정렬이 더 빠르다. 삽입 정렬은 거의 정렬된 데이터에 효율적이다.', false),
       (764, 286, '대용량 데이터에서 효율적이다',
        '삽입 정렬은 작은 배열이나 거의 정렬된 데이터에 효율적이다. 대용량 데이터에는 부적합하다.', false),

       (765, 288, '안정 정렬이며 동일한 값의 순서를 유지한다',
        '삽입 정렬은 안정 정렬(Stable Sort)이다. 동일한 값의 순서가 유지되므로 동일한 키를 가진 데이터의 상대적 순서가 변하지 않는다.',
        true),
       (766, 288, '불안정 정렬이며 동일한 값의 순서가 바뀔 수 있다',
        '삽입 정렬은 안정 정렬이다. 동일한 값의 순서가 유지된다.', false),
       (767, 288, '동일한 값을 처리할 수 없다',
        '삽입 정렬은 동일한 값을 처리할 수 있으며 순서를 유지한다.', false),
       (768, 288, '동일한 값은 항상 제거된다',
        '삽입 정렬은 동일한 값을 유지한다. 제거하지 않는다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (95, 284, '정렬, 정렬된',
        '삽입 정렬은 정렬된 부분과 정렬되지 않은 부분으로 나누어 정렬한다. 배열의 첫 번째 요소는 정렬이 되어 있다고 가정하고, 두 번째 요소부터 시작한다.'),
       (96, 287, 'O(n)',
        '삽입 정렬은 거의 정렬된 배열에서 O(n)의 효율적인 성능을 보인다. 각 원소가 거의 제자리에 있으면 비교만 하고 이동이 최소화되므로 선형 시간에 정렬된다.');

-- Chapter: 알고리즘 (id: 2), Unit: 삽입 정렬 (id: 17), Lesson: 삽입 정렬 동작 과정 문제집 (id: 49)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (289, 49, '다음 중 삽입 정렬의 정렬 과정으로 올바른 것은?', '삽입 정렬은 단계적으로 동작한다.', 'OBJECTIVE'),
       (290, 49, '빈칸에 들어갈 위치를 작성하시오', '삽입 정렬은 배열의 ___요소는 정렬이 되어 있다고 가정하고 두 번째 요소부터 시작한다.', 'SUBJECTIVE'),
       (291, 49, '다음 중 삽입 정렬에서 현재 요소와 비교하는 방향으로 올바른 것은?', '삽입 정렬은 특정한 방향으로 비교한다.', 'OBJECTIVE'),
       (292, 49, '다음 중 삽입 정렬에서 원소를 이동시키는 조건으로 올바른 것은?', '삽입 정렬은 특정 조건에서 원소를 이동시킨다.', 'OBJECTIVE'),
       (293, 49, '빈칸에 들어갈 위치를 작성하시오', '삽입 정렬은 현재 요소보다 작거나 같은 요소를 만나면 그 ___위치에 현재 요소를 삽입한다.', 'SUBJECTIVE'),
       (294, 49, '다음 중 삽입 정렬의 종료 조건으로 올바른 것은?', '삽입 정렬은 특정 조건에서 종료한다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (769, 289, '정렬되지 않은 부분의 첫 번째 요소를 현재 요소로 선택하고 정렬된 부분의 요소들과 뒤에서부터 비교한다',
        '삽입 정렬은 정렬되지 않은 부분의 첫 번째 요소를 현재 요소로 선택한다. 현재 요소를 정렬된 부분의 요소들과 뒤에서부터 차례대로 비교하고, 현재 요소보다 큰 요소들을 오른쪽으로 한 칸씩 이동시킨다.',
        true),
       (770, 289, '가장 작은 값을 찾아 첫 번째 위치로 이동시킨다',
        '이는 선택 정렬의 동작이다. 삽입 정렬은 현재 요소를 정렬된 부분에 삽입한다.', false),
       (771, 289, '인접한 두 원소를 순차적으로 비교하여 교환한다',
        '이는 버블 정렬의 동작이다. 삽입 정렬은 정렬된 부분에 원소를 삽입한다.', false),
       (772, 289, '배열을 절반으로 나누어 정렬한다',
        '이는 병합 정렬의 동작이다. 삽입 정렬은 정렬된 부분에 원소를 삽입한다.', false),

       (773, 291, '정렬된 부분의 맨 뒤 원소부터 앞쪽으로 비교한다',
        '삽입 정렬은 현재 요소를 정렬된 부분의 맨 뒤 원소부터 앞쪽으로 차례대로 비교한다. 뒤에서부터 비교하면서 적절한 삽입 위치를 찾는다.',
        true),
       (774, 291, '정렬된 부분의 맨 앞 원소부터 뒤쪽으로 비교한다',
        '삽입 정렬은 뒤에서부터 앞으로 비교한다. 앞에서부터 비교하지 않는다.', false),
       (775, 291, '무작위로 비교한다',
        '삽입 정렬은 체계적으로 뒤에서부터 앞으로 비교한다. 무작위가 아니다.', false),
       (776, 291, '중간부터 양쪽으로 비교한다',
        '삽입 정렬은 맨 뒤부터 앞으로 순차적으로 비교한다. 중간부터 시작하지 않는다.', false),

       (777, 292, '현재 요소보다 큰 요소들을 오른쪽으로 한 칸씩 이동시킨다',
        '삽입 정렬은 현재 요소보다 큰 요소들을 오른쪽으로 한 칸씩 이동시킨다. 이렇게 공간을 만들어 현재 요소를 올바른 위치에 삽입한다.',
        true),
       (778, 292, '현재 요소보다 작은 요소들을 이동시킨다',
        '현재 요소보다 큰 요소들을 이동시킨다. 작은 요소는 이동하지 않는다.', false),
       (779, 292, '모든 요소를 항상 이동시킨다',
        '현재 요소보다 큰 요소만 이동시킨다. 모든 요소를 이동하지 않는다.', false),
       (780, 292, '요소를 전혀 이동시키지 않는다',
        '현재 요소보다 큰 요소들은 오른쪽으로 이동한다.', false),

       (781, 294, '모든 원소가 정렬될 때까지 반복한다',
        '삽입 정렬은 정렬되지 않은 부분의 모든 원소를 정렬된 부분에 삽입할 때까지, 즉 모든 원소가 정렬될 때까지 반복한다. N개의 원소가 있으면 N-1번 반복한다.',
        true),
       (782, 294, '첫 번째 원소만 정렬하면 종료한다',
        '삽입 정렬은 모든 원소가 정렬될 때까지 반복한다.', false),
       (783, 294, '한 번만 수행하고 종료한다',
        '삽입 정렬은 모든 원소가 정렬될 때까지 반복한다.', false),
       (784, 294, '절반만 정렬하면 종료한다',
        '삽입 정렬은 모든 원소가 정렬될 때까지 반복한다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (97, 290, '첫 번째, 1번째',
        '삽입 정렬은 배열의 첫 번째 요소는 정렬이 되어 있다고 가정하고, 두 번째 요소부터 시작한다. 첫 번째 요소는 이미 정렬된 것으로 간주한다.'),
       (98, 293, '오른쪽',
        '삽입 정렬은 현재 요소보다 작거나 같은 요소를 만나면, 그 오른쪽 위치에 현재 요소를 삽입한다. 큰 요소들을 오른쪽으로 이동시켜 공간을 만든 후 삽입한다.');

-- Chapter: 알고리즘 (id: 2), Unit: 삽입 정렬 (id: 17), Lesson: 삽입 정렬 분석 문제집 (id: 50)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (295, 50, '다음 중 삽입 정렬의 시간 복잡도로 올바른 것은?', '삽입 정렬은 상황에 따라 다른 시간 복잡도를 가진다.', 'OBJECTIVE'),
       (296, 50, '빈칸에 들어갈 시간 복잡도를 작성하시오', '삽입 정렬의 최선의 경우 시간 복잡도는 ___이다.', 'SUBJECTIVE'),
       (297, 50, '다음 중 삽입 정렬의 비교 횟수에 대한 설명으로 올바른 것은?', '삽입 정렬의 비교 횟수는 상황에 따라 다르다.', 'OBJECTIVE'),
       (298, 50, '다음 중 삽입 정렬의 장점으로 올바른 것은?', '삽입 정렬은 특정한 장점을 가진다.', 'OBJECTIVE'),
       (299, 50, '빈칸에 들어갈 정렬 방식을 작성하시오', '삽입 정렬은 추가 메모리가 불필요한 ___ 정렬이다.', 'SUBJECTIVE'),
       (300, 50, '다음 중 삽입 정렬의 활용에 대한 설명으로 올바른 것은?', '삽입 정렬은 실무에서 특정하게 활용된다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (785, 295, '최선 O(n), 평균 O(n²), 최악 O(n²)이다',
        '삽입 정렬의 시간 복잡도는 최선의 경우(이미 정렬된 경우) O(n), 평균과 최악의 경우(역순 정렬) O(n²)이다. 거의 정렬된 배열에서 매우 효율적이다.',
        true),
       (786, 295, '모든 경우에 O(n²)이다',
        '삽입 정렬은 최선의 경우 O(n)이다. 모든 경우가 O(n²)은 아니다.', false),
       (787, 295, '모든 경우에 O(n log n)이다',
        '삽입 정렬은 평균과 최악의 경우 O(n²)이다. O(n log n)이 아니다.', false),
       (788, 295, '최선 O(1), 평균 O(n), 최악 O(n²)이다',
        '삽입 정렬의 최선은 O(n)이다. O(1)이 아니다.', false),

       (789, 297, '최선의 경우 n-1번, 최악의 경우 n(n-1)/2번 비교한다',
        '삽입 정렬의 비교 횟수는 최선의 경우(이미 정렬된 경우) n-1번(각 원소당 1번씩만 비교), 최악의 경우(역순 정렬) n(n-1)/2번이다. 상황에 따라 비교 횟수가 크게 달라진다.',
        true),
       (790, 297, '항상 n(n-1)/2번 비교한다',
        '삽입 정렬의 비교 횟수는 상황에 따라 다르다. 최선의 경우 n-1번만 비교한다.', false),
       (791, 297, '비교를 전혀 하지 않는다',
        '삽입 정렬은 정렬된 부분과 비교하여 위치를 찾는다. 비교를 수행한다.', false),
       (792, 297, '항상 n번만 비교한다',
        '삽입 정렬의 비교 횟수는 상황에 따라 다르다. 최선 n-1번, 최악 n(n-1)/2번이다.', false),

       (793, 298, '구현이 간단하고 거의 정렬된 배열에서 매우 효율적이며 제자리 정렬이고 안정 정렬이다',
        '삽입 정렬의 장점은 구현이 간단하고 직관적이며, 거의 정렬된 배열에서 매우 효율적(O(n))이고, 제자리 정렬로 추가 메모리가 불필요하며, 안정 정렬로 동일한 값의 순서를 유지한다는 것이다.',
        true),
       (794, 298, '대용량 데이터에서 가장 빠르다',
        '삽입 정렬은 작은 배열이나 거의 정렬된 데이터에 효율적이다. 대용량 데이터에는 퀵 정렬이나 병합 정렬이 더 빠르다.', false),
       (795, 298, '항상 O(n log n)이다',
        '삽입 정렬은 평균과 최악의 경우 O(n²)이다. 항상 O(n log n)은 아니다.', false),
       (796, 298, '불안정 정렬이다',
        '삽입 정렬은 안정 정렬이다. 동일한 값의 순서를 유지한다.', false),

       (797, 300, 'TimSort와 IntroSort는 작은 부분 배열에서 삽입 정렬을 사용한다',
        '실제로 TimSort(Python, Java 기본 정렬)와 IntroSort(C++ STL)는 작은 부분 배열에서 삽입 정렬을 사용한다. 거의 정렬된 데이터나 작은 배열에서 매우 효율적이기 때문이다. 하지만 큰 무작위 배열에는 퀵 정렬이나 병합 정렬이 더 적합하다.',
        true),
       (798, 300, '삽입 정렬은 실무에서 전혀 사용되지 않는다',
        '삽입 정렬은 TimSort, IntroSort 등에서 작은 부분 배열 정렬에 사용된다.', false),
       (799, 300, '네트워크 라우팅에 주로 사용된다',
        '삽입 정렬은 정렬 알고리즘이다. 네트워크 라우팅과는 직접적인 관련이 없다.', false),
       (800, 300, '데이터베이스 인덱싱에만 사용된다',
        '삽입 정렬은 다양한 정렬 알고리즘에서 부분적으로 사용된다. 데이터베이스 인덱싱에만 사용되지 않는다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (99, 296, 'O(n)',
        '삽입 정렬의 최선의 경우(이미 정렬된 경우) 시간 복잡도는 O(n)이다. 각 원소를 한 번씩만 비교하면 되므로 선형 시간에 정렬된다.'),
       (100, 299, '제자리, in-place',
        '삽입 정렬은 추가 메모리가 불필요한 제자리(in-place) 정렬이다. 원본 배열 내에서 삽입과 이동만으로 정렬하므로 추가 메모리가 거의 필요하지 않다.');
-- Chapter: 알고리즘 (id: 2), Unit: 합병 정렬 (id: 18)

-- Lesson 생성
INSERT INTO lesson (id, unit_id, title)
VALUES (51, 18, '합병 정렬 기초 문제집'),
       (52, 18, '합병 정렬 동작 과정 문제집'),
       (53, 18, '합병 정렬 분석 문제집');

-- Chapter: 알고리즘 (id: 2), Unit: 합병 정렬 (id: 18), Lesson: 합병 정렬 기초 문제집 (id: 51)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (301, 51, '다음 중 합병 정렬의 정의로 올바른 것은?', '합병 정렬은 특정한 방식으로 동작하는 정렬 알고리즘이다.', 'OBJECTIVE'),
       (302, 51, '빈칸에 들어갈 용어를 작성하시오', '합병 정렬은 ___방식을 사용하여 배열을 절반씩 나누어 정렬한 후 합병하며 정렬한다.', 'SUBJECTIVE'),
       (303, 51, '다음 중 합병 정렬의 특징으로 올바른 것은?', '합병 정렬은 특정한 특징을 가진다.', 'OBJECTIVE'),
       (304, 51, '다음 중 합병 정렬의 시간 복잡도로 올바른 것은?', '합병 정렬은 특정한 시간 복잡도를 가진다.', 'OBJECTIVE'),
       (305, 51, '빈칸에 들어갈 시간 복잡도를 작성하시오', '합병 정렬은 모든 경우에 ___의 안정적인 성능을 보인다.', 'SUBJECTIVE'),
       (306, 51, '다음 중 합병 정렬의 안정성에 대한 설명으로 올바른 것은?', '합병 정렬은 안정성과 관련된 특성을 가진다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (801, 301, '분할 정복 방식을 사용하여 배열을 절반씩 나누어 정렬한 후 합병하며 정렬하는 알고리즘이다',
        '합병 정렬은 분할 정복(Divide and Conquer) 방식을 사용하여, 배열을 절반씩 나누어 정렬한 후 합병하며 정렬하는 알고리즘이다. 재귀적 구조로 구현되며 추가 메모리가 필요하다.',
        true),
       (802, 301, '인접한 두 원소를 비교하여 교환하는 알고리즘이다',
        '이는 버블 정렬의 특징이다. 합병 정렬은 배열을 분할하여 정렬 후 합병한다.', false),
       (803, 301, '가장 작은 값을 찾아 앞으로 이동시키는 알고리즘이다',
        '이는 선택 정렬의 특징이다. 합병 정렬은 분할 정복 방식을 사용한다.', false),
       (804, 301, '피벗을 기준으로 비균등 분할하는 알고리즘이다',
        '이는 퀵 정렬의 특징이다. 합병 정렬은 균등하게 절반씩 분할한다.', false),

       (805, 303, '분할 정복 알고리즘의 대표적인 예시이며 재귀적 구조로 문제를 해결하고 안정 정렬이다',
        '합병 정렬은 분할 정복 알고리즘의 대표적인 예시이며, 재귀적 구조로 문제를 해결하고, 배열을 절반씩 분할하여 크기 1이 될 때까지 나눈다. 안정 정렬로 동일한 값의 순서를 유지한다.',
        true),
       (806, 303, '제자리 정렬이다',
        '합병 정렬은 추가 메모리가 필요하다. 제자리 정렬이 아니다.', false),
       (807, 303, '불안정 정렬이다',
        '합병 정렬은 안정 정렬이다. 동일한 값의 순서를 유지한다.', false),
       (808, 303, '비균등하게 분할한다',
        '합병 정렬은 균등하게 절반씩 분할한다. 비균등 분할은 퀵 정렬의 특징이다.', false),

       (809, 304, '모든 경우에 O(n log n)이다',
        '합병 정렬의 시간 복잡도는 최선, 평균, 최악의 경우 모두 O(n log n)이다. 모든 경우에 O(n log n)의 안정적인 성능을 보이며, 데이터 분포에 영향을 덜 받는다.',
        true),
       (810, 304, '최선 O(n), 평균 O(n²), 최악 O(n²)이다',
        '합병 정렬은 모든 경우에 O(n log n)이다. O(n²)이 아니다.', false),
       (811, 304, '최선 O(n log n), 평균 O(n log n), 최악 O(n²)이다',
        '합병 정렬은 최악의 경우에도 O(n log n)이다. O(n²)이 되지 않는다.', false),
       (812, 304, '모든 경우에 O(n²)이다',
        '합병 정렬은 O(n log n)이다. O(n²)이 아니다.', false),

       (813, 306, '안정 정렬이며 동일한 값의 순서를 유지한다',
        '합병 정렬은 안정 정렬(Stable Sort)이다. 동일한 값의 순서가 유지되므로 동일한 키를 가진 데이터의 상대적 순서가 변하지 않는다.',
        true),
       (814, 306, '불안정 정렬이며 동일한 값의 순서가 바뀔 수 있다',
        '합병 정렬은 안정 정렬이다. 동일한 값의 순서가 유지된다.', false),
       (815, 306, '동일한 값을 처리할 수 없다',
        '합병 정렬은 동일한 값을 처리할 수 있으며 순서를 유지한다.', false),
       (816, 306, '동일한 값은 항상 제거된다',
        '합병 정렬은 동일한 값을 유지한다. 제거하지 않는다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (101, 302, '분할 정복, Divide and Conquer',
        '합병 정렬은 분할 정복(Divide and Conquer) 방식을 사용하여 배열을 절반씩 나누어 정렬한 후 합병하며 정렬한다. 문제를 작은 문제로 나누어 해결하는 방식이다.'),
       (102, 305, 'O(n log n), O(nlogn)',
        '합병 정렬은 모든 경우에 O(n log n)의 안정적인 성능을 보인다. 최선, 평균, 최악의 경우 모두 동일한 시간 복잡도를 가진다.');

-- Chapter: 알고리즘 (id: 2), Unit: 합병 정렬 (id: 18), Lesson: 합병 정렬 동작 과정 문제집 (id: 52)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (307, 52, '다음 중 합병 정렬의 분할 단계에 대한 설명으로 올바른 것은?', '합병 정렬은 분할 단계를 포함한다.', 'OBJECTIVE'),
       (308, 52, '빈칸에 들어갈 크기를 작성하시오', '합병 정렬은 배열을 ___이 될 때까지 반복적으로 분할한다.', 'SUBJECTIVE'),
       (309, 52, '다음 중 합병 정렬의 정복 단계에 대한 설명으로 올바른 것은?', '합병 정렬은 정복 단계를 포함한다.', 'OBJECTIVE'),
       (310, 52, '다음 중 합병 정렬의 결합 단계에 대한 설명으로 올바른 것은?', '합병 정렬은 결합 단계를 포함한다.', 'OBJECTIVE'),
       (311, 52, '빈칸에 들어갈 단계를 작성하시오', '합병 정렬의 ___단계에서 실제 정렬이 이루어진다.', 'SUBJECTIVE'),
       (312, 52, '다음 중 합병 정렬의 합병 과정에 대한 설명으로 올바른 것은?', '합병 정렬은 특정한 방식으로 합병한다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (817, 307, '배열을 같은 크기의 2개 부분 배열로 분할하고 크기가 1이 될 때까지 반복한다',
        '합병 정렬의 분할 단계는 배열을 같은 크기의 2개 부분 배열로 분할한다. 배열의 크기가 1이 될 때까지 반복하며, 크기가 1인 배열은 이미 정렬된 것으로 간주한다.',
        true),
       (818, 307, '피벗을 기준으로 비균등하게 분할한다',
        '이는 퀵 정렬의 특징이다. 합병 정렬은 균등하게 절반씩 분할한다.', false),
       (819, 307, '최솟값을 찾아 분리한다',
        '이는 선택 정렬의 특징이다. 합병 정렬은 중간 지점을 기준으로 분할한다.', false),
       (820, 307, '인접한 원소를 비교하여 분할한다',
        '합병 정렬은 중간 지점을 기준으로 기계적으로 분할한다. 원소 비교로 분할하지 않는다.', false),

       (821, 309, '각 부분 배열을 재귀적으로 정렬하고 크기가 1인 배열은 이미 정렬된 것으로 간주한다',
        '합병 정렬의 정복 단계는 각 부분 배열을 재귀적으로 정렬한다. 크기가 1인 배열은 이미 정렬된 것으로 간주하며, 이것이 재귀의 기저 조건이 된다.',
        true),
       (822, 309, '피벗을 확정한다',
        '이는 퀵 정렬의 특징이다. 합병 정렬은 재귀적으로 부분 배열을 정렬한다.', false),
       (823, 309, '최솟값을 앞으로 이동시킨다',
        '이는 선택 정렬의 특징이다. 합병 정렬은 재귀적으로 정렬한다.', false),
       (824, 309, '인접한 원소를 교환한다',
        '이는 버블 정렬의 특징이다. 합병 정렬은 재귀적으로 정렬 후 합병한다.', false),

       (825, 310, '정렬된 2개의 부분 배열을 하나의 정렬된 배열로 합병하며 이 단계에서 실제 정렬이 이루어진다',
        '합병 정렬의 결합 단계는 정렬된 2개의 부분 배열을 하나의 정렬된 배열로 합병한다. 이 단계에서 실제 정렬이 이루어지며, 별도 병합 과정이 필요하지 않다.',
        true),
       (826, 310, '피벗을 기준으로 재배치한다',
        '이는 퀵 정렬의 특징이다. 합병 정렬은 정렬된 배열들을 합병한다.', false),
       (827, 310, '교환 없이 단순히 연결한다',
        '합병 정렬은 정렬하면서 합병한다. 단순히 연결하는 것이 아니다.', false),
       (828, 310, '결합 단계가 없다',
        '합병 정렬은 결합 단계에서 실제 정렬이 이루어진다. 결합 단계가 필수이다.', false),

       (829, 312, '두 부분 배열의 원소를 순차적으로 비교하여 작은 값부터 정렬된 배열에 추가한다',
        '합병 정렬은 두 부분 배열의 원소를 순차적으로 비교하여 작은 값부터 정렬된 배열에 추가한다. 한쪽 배열이 모두 소진되면 나머지 배열의 원소들을 순서대로 추가한다.',
        true),
       (830, 312, '무작위로 선택하여 합병한다',
        '합병 정렬은 체계적으로 작은 값부터 선택하여 합병한다. 무작위가 아니다.', false),
       (831, 312, '큰 값부터 추가한다',
        '합병 정렬은 작은 값부터 순서대로 추가한다. 큰 값부터가 아니다.', false),
       (832, 312, '합병 없이 단순 연결한다',
        '합병 정렬은 비교하며 정렬된 순서로 합병한다. 단순 연결이 아니다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (103, 308, '1, 크기 1',
        '합병 정렬은 배열을 크기가 1이 될 때까지 반복적으로 분할한다. 크기가 1인 배열은 이미 정렬된 것으로 간주하며, 이것이 재귀의 기저 조건이다.'),
       (104, 311, '결합, 합병',
        '합병 정렬의 결합(Combine) 단계에서 실제 정렬이 이루어진다. 정렬된 두 부분 배열을 하나의 정렬된 배열로 합병하면서 정렬한다.');

-- Chapter: 알고리즘 (id: 2), Unit: 합병 정렬 (id: 18), Lesson: 합병 정렬 분석 문제집 (id: 53)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (313, 53, '다음 중 합병 정렬의 시간 복잡도 계산으로 올바른 것은?', '합병 정렬의 시간 복잡도는 특정하게 계산된다.', 'OBJECTIVE'),
       (314, 53, '빈칸에 들어갈 공간 복잡도를 작성하시오', '합병 정렬의 공간 복잡도는 합병 과정에서 임시 배열이 필요하므로 ___이다.', 'SUBJECTIVE'),
       (315, 53, '다음 중 합병 정렬의 장점으로 올바른 것은?', '합병 정렬은 특정한 장점을 가진다.', 'OBJECTIVE'),
       (316, 53, '다음 중 합병 정렬의 단점으로 올바른 것은?', '합병 정렬은 단점도 가지고 있다.', 'OBJECTIVE'),
       (317, 53, '빈칸에 들어갈 분할 방식을 작성하시오', '합병 정렬은 ___분할을 수행하며 중간 지점을 기준으로 나눈다.', 'SUBJECTIVE'),
       (318, 53, '다음 중 합병 정렬의 활용에 대한 설명으로 올바른 것은?', '합병 정렬은 실무에서 특정하게 활용된다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (833, 313, '분할 단계는 log n 깊이이고 합병 단계는 각 단계에서 n번 연산하므로 O(n log n)이다',
        '합병 정렬의 시간 복잡도는 분할 단계에서 배열을 절반씩 나누므로 깊이는 log₂n이고, 합병 단계에서 각 단계마다 모든 원소를 비교하고 이동하므로 n번 연산한다. 전체는 O(n) × O(log n) = O(n log n)이다.',
        true),
       (834, 313, '모든 경우에 O(n²)이다',
        '합병 정렬은 O(n log n)이다. O(n²)이 아니다.', false),
       (835, 313, '최선의 경우 O(n)이다',
        '합병 정렬은 모든 경우에 O(n log n)이다. 최선의 경우도 O(n log n)이다.', false),
       (836, 313, '상황에 따라 O(n)부터 O(n²)까지 다르다',
        '합병 정렬은 모든 경우에 O(n log n)으로 일정하다.', false),

       (837, 315, '안정적인 시간 복잡도로 모든 경우 O(n log n)을 보장하고 안정 정렬이며 데이터 분포에 영향을 덜 받는다',
        '합병 정렬의 장점은 안정적인 시간 복잡도로 모든 경우 O(n log n)을 보장하고, 안정 정렬로 동일한 값의 순서를 유지하며, 데이터 분포에 영향을 덜 받고, 연결 리스트로 구현 시 효율적이고, 대용량 데이터 정렬에 적합하다.',
        true),
       (838, 315, '제자리 정렬이다',
        '합병 정렬은 추가 메모리가 필요하다. 제자리 정렬이 아니다.', false),
       (839, 315, '작은 데이터에서 가장 빠르다',
        '작은 데이터에서는 삽입 정렬이 더 빠를 수 있다. 합병 정렬은 대용량 데이터에 적합하다.', false),
       (840, 315, '추가 메모리가 불필요하다',
        '합병 정렬은 O(n)의 추가 메모리가 필요하다.', false),

       (841, 316, '추가 메모리가 필요하며 제자리 정렬이 아니고 작은 데이터에서는 삽입 정렬보다 느릴 수 있다',
        '합병 정렬의 단점은 추가 메모리가 필요하고(O(n)의 공간 복잡도), 제자리 정렬이 아니며, 작은 데이터에서는 삽입 정렬보다 느릴 수 있다는 것이다.',
        true),
       (842, 316, '시간 복잡도가 O(n²)이다',
        '합병 정렬은 O(n log n)이다. O(n²)이 아니다.', false),
       (843, 316, '불안정 정렬이다',
        '합병 정렬은 안정 정렬이다. 동일한 값의 순서를 유지한다.', false),
       (844, 316, '데이터 분포에 크게 영향을 받는다',
        '합병 정렬은 데이터 분포에 영향을 덜 받는다. 이는 장점이다.', false),

       (845, 318, 'Python의 Timsort와 Java의 정렬은 합병 정렬을 기반으로 한다',
        '합병 정렬은 안정성과 예측 가능한 성능이 중요한 경우에 적합하다. Python의 Timsort와 Java의 정렬은 합병 정렬을 기반으로 한다. 하지만 일반적인 경우 퀵 정렬이 더 빠른 경향이 있다.',
        true),
       (846, 318, '실무에서 전혀 사용되지 않는다',
        '합병 정렬은 Python, Java 등의 표준 정렬에서 사용된다. 실무에서 활용된다.', false),
       (847, 318, '네트워크 라우팅에만 사용된다',
        '합병 정렬은 다양한 정렬 상황에서 사용된다. 네트워크 라우팅에만 국한되지 않는다.', false),
       (848, 318, '작은 데이터에만 사용된다',
        '합병 정렬은 대용량 데이터 정렬에 적합하다. 작은 데이터에만 사용되지 않는다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (105, 314, 'O(n)',
        '합병 정렬의 공간 복잡도는 합병 과정에서 임시 배열이 필요하므로 O(n)이다. 배열 크기만큼의 추가 메모리를 사용한다.'),
       (106, 317, '균등, 균등 분할',
        '합병 정렬은 균등 분할을 수행하며 중간 지점을 기준으로 나눈다. 항상 절반씩 동일한 크기로 분할한다. 이는 퀵 정렬의 비균등 분할과 차이가 있다.');

-- Chapter: 알고리즘 (id: 2), Unit: 퀵 정렬 (id: 19)

-- Lesson 생성
INSERT INTO lesson (id, unit_id, title)
VALUES (54, 19, '퀵 정렬 기초 문제집'),
       (55, 19, '퀵 정렬 동작 과정 문제집'),
       (56, 19, '퀵 정렬 분석 문제집');

-- Chapter: 알고리즘 (id: 2), Unit: 퀵 정렬 (id: 19), Lesson: 퀵 정렬 기초 문제집 (id: 54)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (319, 54, '다음 중 퀵 정렬의 정의로 올바른 것은?', '퀵 정렬은 특정한 방식으로 동작하는 정렬 알고리즘이다.', 'OBJECTIVE'),
       (320, 54, '빈칸에 들어갈 용어를 작성하시오', '퀵 정렬은 ___을 기준으로 배열을 비균등 분할하는 분할 정복 알고리즘이다.', 'SUBJECTIVE'),
       (321, 54, '다음 중 퀵 정렬의 특징으로 올바른 것은?', '퀵 정렬은 특정한 특징을 가진다.', 'OBJECTIVE'),
       (322, 54, '다음 중 퀵 정렬의 시간 복잡도로 올바른 것은?', '퀵 정렬은 특정한 시간 복잡도를 가진다.', 'OBJECTIVE'),
       (323, 54, '빈칸에 들어갈 시간 복잡도를 작성하시오', '퀵 정렬은 평균적으로 ___의 시간 복잡도를 가지지만 최악의 경우 O(n²)으로 저하된다.', 'SUBJECTIVE'),
       (324, 54, '다음 중 퀵 정렬의 안정성에 대한 설명으로 올바른 것은?', '퀵 정렬은 안정성과 관련된 특성을 가진다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (849, 319, '피벗을 기준으로 배열을 비균등 분할하며 제자리 정렬이 가능한 분할 정복 알고리즘이다',
        '퀵 정렬은 분할 정복 알고리즘 기반 정렬 방식이다. 피벗(Pivot)을 기준으로 배열을 비균등 분할하며, 제자리 정렬이 가능하다. 평균적으로 O(n log n) 시간 복잡도를 가지지만, 최악의 경우 O(n²)으로 저하된다.',
        true),
       (850, 319, '배열을 균등하게 절반씩 분할하는 알고리즘이다',
        '이는 합병 정렬의 특징이다. 퀵 정렬은 피벗을 기준으로 비균등하게 분할한다.', false),
       (851, 319, '인접한 두 원소를 비교하여 교환하는 알고리즘이다',
        '이는 버블 정렬의 특징이다. 퀵 정렬은 피벗을 기준으로 분할한다.', false),
       (852, 319, '정렬된 부분에 원소를 삽입하는 알고리즘이다',
        '이는 삽입 정렬의 특징이다. 퀵 정렬은 분할 정복 방식을 사용한다.', false),

       (853, 321, '분할 정복 방식으로 피벗을 기준으로 비균등 분할하고 제자리 정렬이 가능하며 불안정 정렬이다',
        '퀵 정렬은 분할 정복 방식으로 피벗을 기준으로 배열을 비균등하게 분할하며, 제자리 정렬(In-place Sort)이 가능하여 추가 메모리 공간을 최소화한다. 불안정 정렬로 동일 값의 순서가 바뀔 수 있고, 평균적으로 다른 O(n log n) 알고리즘보다 빠르며, 캐시 효율성이 높아 실무에서 많이 사용된다.',
        true),
       (854, 321, '균등 분할을 수행한다',
        '퀵 정렬은 피벗을 기준으로 비균등 분할한다. 균등 분할은 합병 정렬의 특징이다.', false),
       (855, 321, '안정 정렬이다',
        '퀵 정렬은 불안정 정렬이다. 동일한 값의 순서가 바뀔 수 있다.', false),
       (856, 321, '추가 메모리가 O(n) 필요하다',
        '퀵 정렬은 제자리 정렬로 추가 메모리가 O(log n)이다. O(n)은 합병 정렬의 공간 복잡도이다.', false),

       (857, 322, '평균 O(n log n), 최악 O(n²)이다',
        '퀵 정렬의 시간 복잡도는 평균적으로 O(n log n)이지만, 최악의 경우(정렬된 배열에서 첫/끝 피벗 선택 시) O(n²)으로 저하된다. 이는 합병 정렬과의 주요 차이점이다.',
        true),
       (858, 322, '모든 경우에 O(n log n)이다',
        '퀵 정렬은 최악의 경우 O(n²)이다. 모든 경우가 O(n log n)은 아니다.', false),
       (859, 322, '모든 경우에 O(n²)이다',
        '퀵 정렬은 평균적으로 O(n log n)이다. 최악의 경우에만 O(n²)이다.', false),
       (860, 322, '최선 O(n), 평균 O(n²), 최악 O(n²)이다',
        '퀵 정렬은 평균 O(n log n)이다. 평균이 O(n²)이 아니다.', false),

       (861, 324, '불안정 정렬이며 동일한 값의 순서가 바뀔 수 있다',
        '퀵 정렬은 불안정 정렬(Unstable Sort)이다. 동일한 값의 순서가 바뀔 수 있으므로 동일한 키를 가진 데이터의 상대적 순서가 변할 수 있다.',
        true),
       (862, 324, '안정 정렬이며 동일한 값의 순서를 유지한다',
        '퀵 정렬은 불안정 정렬이다. 동일한 값의 순서가 바뀔 수 있다.', false),
       (863, 324, '동일한 값을 처리할 수 없다',
        '퀵 정렬은 동일한 값을 처리할 수 있지만 순서가 바뀔 수 있다.', false),
       (864, 324, '동일한 값은 항상 제거된다',
        '퀵 정렬은 동일한 값을 유지한다. 제거하지 않는다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (107, 320, '피벗, Pivot',
        '퀵 정렬은 피벗(Pivot)을 기준으로 배열을 비균등 분할하는 분할 정복 알고리즘이다. 피벗보다 작은 원소는 왼쪽, 큰 원소는 오른쪽으로 배치한다.'),
       (108, 323, 'O(n log n), O(nlogn)',
        '퀵 정렬은 평균적으로 O(n log n)의 시간 복잡도를 가지지만 최악의 경우 O(n²)으로 저하된다. 피벗 선택에 따라 성능이 달라진다.');

-- Chapter: 알고리즘 (id: 2), Unit: 퀵 정렬 (id: 19), Lesson: 퀵 정렬 동작 과정 문제집 (id: 55)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (325, 55, '다음 중 퀵 정렬의 분할 단계에 대한 설명으로 올바른 것은?', '퀵 정렬은 분할 단계를 포함한다.', 'OBJECTIVE'),
       (326, 55, '빈칸에 들어갈 용어를 작성하시오', '퀵 정렬의 분할 과정은 ___을 기준으로 배열을 2개의 부분 배열로 나눈다.', 'SUBJECTIVE'),
       (327, 55, '다음 중 퀵 정렬의 정복 단계에 대한 설명으로 올바른 것은?', '퀵 정렬은 정복 단계를 포함한다.', 'OBJECTIVE'),
       (328, 55, '다음 중 퀵 정렬의 결합 단계에 대한 설명으로 올바른 것은?', '퀵 정렬은 결합 단계와 관련된 특징을 가진다.', 'OBJECTIVE'),
       (329, 55, '빈칸에 들어갈 개수를 작성하시오', '퀵 정렬의 분할 과정은 ___개의 포인터를 사용하여 배열을 분할한다.', 'SUBJECTIVE'),
       (330, 55, '다음 중 퀵 정렬의 분할 과정으로 올바른 것은?', '퀵 정렬은 특정한 방식으로 분할한다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (865, 325, '피벗을 선택하고 피벗보다 작은 원소는 왼쪽 큰 원소는 오른쪽으로 배치하여 배열을 2개의 부분 배열로 분할한다',
        '퀵 정렬의 분할 단계는 피벗을 선택하고, 피벗보다 작은 원소는 왼쪽, 큰 원소는 오른쪽으로 배치하여 배열을 2개의 부분 배열로 분할한다. 이는 비균등 분할이다.',
        true),
       (866, 325, '배열을 균등하게 절반으로 나눈다',
        '이는 합병 정렬의 특징이다. 퀵 정렬은 피벗을 기준으로 비균등하게 분할한다.', false),
       (867, 325, '최솟값을 찾아 분리한다',
        '이는 선택 정렬의 특징이다. 퀵 정렬은 피벗을 기준으로 분할한다.', false),
       (868, 325, '인접한 원소를 비교하여 분할한다',
        '퀵 정렬은 피벗과 비교하여 분할한다. 인접한 원소끼리 비교하지 않는다.', false),

       (869, 327, '분할된 부분 배열에 대해 재귀적으로 퀵 정렬을 반복한다',
        '퀵 정렬의 정복 단계는 분할된 부분 배열에 대해 재귀적으로 퀵 정렬을 반복한다. 배열 크기가 1이 될 때까지 반복하며, 크기가 1이면 정렬된 것으로 간주한다.',
        true),
       (870, 327, '정렬된 배열을 합병한다',
        '이는 합병 정렬의 특징이다. 퀵 정렬은 제자리에서 정렬하므로 합병 과정이 없다.', false),
       (871, 327, '최솟값을 앞으로 이동시킨다',
        '이는 선택 정렬의 특징이다. 퀵 정렬은 재귀적으로 부분 배열을 정렬한다.', false),
       (872, 327, '한 번만 수행하고 종료한다',
        '퀵 정렬은 재귀적으로 반복한다. 한 번만 수행하지 않는다.', false),

       (873, 328, '정렬된 부분 배열을 하나로 합치는 별도 병합 과정이 불필요하다',
        '퀵 정렬의 결합 단계는 정렬된 부분 배열을 하나로 합친다. 별도 병합 과정은 불필요하며, 제자리에서 정렬되므로 자연스럽게 정렬된 배열이 완성된다.',
        true),
       (874, 328, '정렬된 배열들을 합병하는 과정이 필수이다',
        '퀵 정렬은 제자리 정렬이므로 별도 합병 과정이 불필요하다.', false),
       (875, 328, '추가 배열을 사용하여 합병한다',
        '퀵 정렬은 제자리 정렬로 추가 배열이 불필요하다.', false),
       (876, 328, '결합 단계가 가장 많은 시간이 걸린다',
        '퀵 정렬은 분할 과정에서 정렬이 이루어진다. 결합은 별도 과정이 불필요하다.', false),

       (877, 330, 'low 포인터는 왼쪽에서 오른쪽으로 피벗보다 큰 값을 찾고 high 포인터는 오른쪽에서 왼쪽으로 피벗보다 작은 값을 찾아 교환한다',
        '퀵 정렬의 분할 과정은 두 개의 포인터(low, high)를 사용한다. low는 왼쪽에서 오른쪽으로 피벗보다 큰 값을 탐색하고, high는 오른쪽에서 왼쪽으로 피벗보다 작은 값을 탐색한다. 두 값을 교환하고 low > high가 될 때까지 반복한다.',
        true),
       (878, 330, '한 개의 포인터만 사용한다',
        '퀵 정렬은 두 개의 포인터(low, high)를 사용한다.', false),
       (879, 330, '중간부터 양쪽으로 탐색한다',
        '퀵 정렬은 양 끝에서 중앙으로 탐색한다. 중간부터 시작하지 않는다.', false),
       (880, 330, '무작위로 원소를 선택한다',
        '퀵 정렬은 체계적으로 포인터를 이동하며 탐색한다. 무작위가 아니다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (109, 326, '피벗, Pivot',
        '퀵 정렬의 분할 과정은 피벗(Pivot)을 기준으로 배열을 2개의 부분 배열로 나눈다. 피벗보다 작은 원소는 왼쪽, 큰 원소는 오른쪽으로 배치한다.'),
       (110, 329, '2, 두, 둘',
        '퀵 정렬의 분할 과정은 2개의 포인터(low, high)를 사용하여 배열을 분할한다. low는 왼쪽에서, high는 오른쪽에서 탐색한다.');

-- Chapter: 알고리즘 (id: 2), Unit: 퀵 정렬 (id: 19), Lesson: 퀵 정렬 분석 문제집 (id: 56)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (331, 56, '다음 중 퀵 정렬의 피벗 선택 전략으로 올바른 것은?', '퀵 정렬은 다양한 피벗 선택 전략을 가진다.', 'OBJECTIVE'),
       (332, 56, '빈칸에 들어갈 공간 복잡도를 작성하시오', '퀵 정렬은 제자리 정렬로 재귀 호출 스택에 ___의 공간이 필요하다.', 'SUBJECTIVE'),
       (333, 56, '다음 중 퀵 정렬의 장점으로 올바른 것은?', '퀵 정렬은 특정한 장점을 가진다.', 'OBJECTIVE'),
       (334, 56, '다음 중 퀵 정렬의 단점으로 올바른 것은?', '퀵 정렬은 단점도 가지고 있다.', 'OBJECTIVE'),
       (335, 56, '빈칸에 들어갈 정렬 알고리즘을 작성하시오', '퀵 정렬은 평균적으로 같은 O(n log n)인 ___보다 2~3배 빠르다.', 'SUBJECTIVE'),
       (336, 56, '다음 중 퀵 정렬과 합병 정렬의 차이로 올바른 것은?', '퀵 정렬과 합병 정렬은 차이가 있다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (881, 331, '첫/마지막 원소, 중간 원소, 무작위 선택, 중앙값 등 다양한 전략이 있다',
        '퀵 정렬의 피벗 선택 전략은 첫/마지막 원소(구현 간단하지만 정렬된 배열에 취약), 중간 원소(균등 분할 가능성 증가), 무작위 선택(최악의 경우 확률 감소), 중앙값(최적 분할이지만 연산 비용 증가) 등이 있다.',
        true),
       (882, 331, '항상 첫 번째 원소만 사용한다',
        '피벗 선택 전략은 다양하다. 첫 번째 원소만 사용하는 것은 아니다.', false),
       (883, 331, '피벗을 선택하지 않는다',
        '퀵 정렬은 피벗 선택이 필수이다. 피벗이 없으면 분할할 수 없다.', false),
       (884, 331, '가장 큰 값만 피벗으로 선택한다',
        '피벗은 다양한 전략으로 선택된다. 가장 큰 값만 선택하는 것은 아니다.', false),

       (885, 333, '빠른 속도로 평균적으로 O(n log n) 알고리즘 중 가장 빠르고 캐시 효율성이 높으며 제자리 정렬이다',
        '퀵 정렬의 장점은 빠른 속도로 평균적으로 O(n log n) 알고리즘 중 가장 빠르고, 캐시 효율성이 높아 인접 데이터 비교로 캐시 히트율이 높으며, 제자리 정렬로 추가 메모리 공간을 최소화한다는 것이다.',
        true),
       (886, 333, '최악의 경우에도 O(n log n)이다',
        '퀵 정렬은 최악의 경우 O(n²)이다. 항상 O(n log n)이 아니다.', false),
       (887, 333, '안정 정렬이다',
        '퀵 정렬은 불안정 정렬이다. 동일한 값의 순서가 바뀔 수 있다.', false),
       (888, 333, '추가 메모리가 O(n) 필요하다',
        '퀵 정렬은 제자리 정렬로 추가 메모리가 O(log n)이다. O(n)이 아니다.', false),

       (889, 334, '최악의 경우 O(n²)으로 정렬된 배열에서 첫/끝 피벗 선택 시 성능이 저하되고 불안정 정렬이며 재귀 오버헤드가 있다',
        '퀵 정렬의 단점은 최악의 경우 O(n²)으로 정렬된 배열에서 첫/끝 피벗 선택 시 성능이 저하되고, 불안정 정렬로 동일 값의 순서가 보장되지 않으며, 재귀 오버헤드로 인한 스택 사용이 있다는 것이다.',
        true),
       (890, 334, '평균적으로 매우 느리다',
        '퀵 정렬은 평균적으로 가장 빠른 정렬 알고리즘 중 하나이다.', false),
       (891, 334, '구현이 매우 복잡하다',
        '퀵 정렬의 기본 구현은 비교적 간단하다. 매우 복잡하지 않다.', false),
       (892, 334, '제자리 정렬이 불가능하다',
        '퀵 정렬은 제자리 정렬이 가능하다. 이는 장점이다.', false),

       (893, 336, '퀵 정렬은 비균등 분할이고 합병 정렬은 균등 분할이며 퀵 정렬은 평균적으로 더 빠르다',
        '퀵 정렬은 비균등 분할(피벗)을 하고 합병 정렬은 균등 분할(중간)을 한다. 퀵 정렬의 추가 메모리는 O(log n)이고 합병 정렬은 O(n)이다. 퀵 정렬은 불안정 정렬이고 합병 정렬은 안정 정렬이다. 퀵 정렬은 평균적으로 더 빠르지만 최악의 경우는 O(n²)이고 합병 정렬은 항상 O(n log n)이다.',
        true),
       (894, 336, '퀵 정렬과 합병 정렬은 완전히 동일하다',
        '퀵 정렬과 합병 정렬은 분할 방식, 안정성, 공간 복잡도 등에서 차이가 있다.', false),
       (895, 336, '합병 정렬이 항상 더 빠르다',
        '평균적으로 퀵 정렬이 더 빠르다. 하지만 최악의 경우 합병 정렬이 안정적이다.', false),
       (896, 336, '퀵 정렬은 안정 정렬이고 합병 정렬은 불안정 정렬이다',
        '반대이다. 퀵 정렬은 불안정 정렬이고 합병 정렬은 안정 정렬이다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (111, 332, 'O(log n), O(logn)',
        '퀵 정렬은 제자리 정렬로 재귀 호출 스택에 O(log n)의 공간이 필요하다. 최악의 경우 O(n)까지 증가할 수 있지만 평균적으로 O(log n)이다.'),
       (112, 335, '합병 정렬, 병합 정렬, Merge Sort',
        '퀵 정렬은 평균적으로 같은 O(n log n)인 합병 정렬보다 2~3배 빠르다. 캐시 효율성이 높고 실제 수행 시간이 짧다. 하지만 일반적인 경우에 한정된다.');

-- Chapter: 알고리즘 (id: 2), Unit: 힙 정렬 (id: 20)

-- Lesson 생성
INSERT INTO lesson (id, unit_id, title)
VALUES (57, 20, '힙 정렬 기초 문제집'),
       (58, 20, '힙 정렬 동작 과정 문제집'),
       (59, 20, '힙 정렬 분석 문제집');

-- Chapter: 알고리즘 (id: 2), Unit: 힙 정렬 (id: 20), Lesson: 힙 정렬 기초 문제집 (id: 57)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (337, 57, '다음 중 힙 정렬의 정의로 올바른 것은?', '힙 정렬은 특정한 자료구조를 활용하는 정렬 알고리즘이다.', 'OBJECTIVE'),
       (338, 57, '빈칸에 들어갈 자료구조를 작성하시오', '힙 정렬은 완전 이진 트리 기반의 ___을 활용하는 정렬 알고리즘이다.', 'SUBJECTIVE'),
       (339, 57, '다음 중 힙 정렬의 특징으로 올바른 것은?', '힙 정렬은 여러 가지 특징을 가진다.', 'OBJECTIVE'),
       (340, 57, '다음 중 힙 정렬의 시간 복잡도로 올바른 것은?', '힙 정렬은 특정한 시간 복잡도를 가진다.', 'OBJECTIVE'),
       (341, 57, '빈칸에 들어갈 정렬 유형을 작성하시오', '힙 정렬은 ___이므로 추가 메모리를 최소화할 수 있다.', 'SUBJECTIVE'),
       (342, 57, '다음 중 힙 정렬의 안정성에 대한 설명으로 올바른 것은?', '힙 정렬은 안정성과 관련된 특징을 가진다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (897, 337, '완전 이진 트리 기반의 힙 자료구조를 활용하며 제자리 정렬이 가능하고 최악의 경우에도 O(n log n)을 보장하는 선택 정렬의 개선 형태이다',
        '힙 정렬은 완전 이진 트리 기반의 힙(Heap) 자료구조를 활용하는 정렬 알고리즘이다. 선택 정렬의 개선 형태로, 제자리 정렬이 가능하며 최악의 경우에도 O(n log n)을 보장한다.',
        true),
       (898, 337, '피벗을 기준으로 분할하는 알고리즘이다',
        '이는 퀵 정렬의 특징이다. 힙 정렬은 힙 자료구조를 활용한다.', false),
       (899, 337, '배열을 균등하게 분할하는 알고리즘이다',
        '이는 합병 정렬의 특징이다. 힙 정렬은 힙 자료구조를 활용한다.', false),
       (900, 337, '인접한 원소를 비교하여 정렬하는 알고리즘이다',
        '이는 버블 정렬의 특징이다. 힙 정렬은 힙 자료구조를 활용한다.', false),

       (901, 339, '완전 이진 트리 기반의 힙 자료구조를 활용하며 제자리 정렬이 가능하고 불안정 정렬이며 최악의 경우에도 O(n log n)을 보장한다',
        '힙 정렬은 완전 이진 트리 기반의 힙 자료구조를 활용하고, 제자리 정렬(In-place Sort)로 추가 메모리를 최소화하며, 불안정 정렬(Unstable Sort)로 동일 값의 순서가 바뀔 수 있고, 최악의 경우에도 O(n log n)을 보장하며, 우선순위 큐의 구현 원리와 동일하다.',
        true),
       (902, 339, '안정 정렬이다',
        '힙 정렬은 불안정 정렬이다. 동일한 값의 순서가 바뀔 수 있다.', false),
       (903, 339, '최악의 경우 O(n²)이다',
        '힙 정렬은 최악의 경우에도 O(n log n)을 보장한다. O(n²)이 아니다.', false),
       (904, 339, '추가 메모리가 O(n) 필요하다',
        '힙 정렬은 제자리 정렬로 추가 메모리가 O(1)이다. O(n)이 아니다.', false),

       (905, 340, '최선/평균/최악 모두 O(n log n)이다',
        '힙 정렬의 시간 복잡도는 최선, 평균, 최악 모두 O(n log n)이다. 힙 구축은 O(n)이고, 정렬 단계는 O(n log n)이므로 총 시간 복잡도는 O(n log n)이다.',
        true),
       (906, 340, '평균 O(n log n), 최악 O(n²)이다',
        '힙 정렬은 최악의 경우에도 O(n log n)이다. O(n²)이 아니다.', false),
       (907, 340, '모든 경우에 O(n²)이다',
        '힙 정렬은 모든 경우에 O(n log n)이다. O(n²)이 아니다.', false),
       (908, 340, '최선 O(n), 평균 O(n log n), 최악 O(n²)이다',
        '힙 정렬은 모든 경우에 O(n log n)이다. 최선이 O(n)이 아니다.', false),

       (909, 342, '불안정 정렬이며 동일한 값의 순서가 바뀔 수 있다',
        '힙 정렬은 불안정 정렬(Unstable Sort)이다. 동일한 값의 순서가 바뀔 수 있으므로 동일한 키를 가진 데이터의 상대적 순서가 변할 수 있다.',
        true),
       (910, 342, '안정 정렬이며 동일한 값의 순서를 유지한다',
        '힙 정렬은 불안정 정렬이다. 동일한 값의 순서가 바뀔 수 있다.', false),
       (911, 342, '동일한 값을 처리할 수 없다',
        '힙 정렬은 동일한 값을 처리할 수 있지만 순서가 바뀔 수 있다.', false),
       (912, 342, '동일한 값은 항상 제거된다',
        '힙 정렬은 동일한 값을 유지한다. 제거하지 않는다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (113, 338, '힙, Heap',
        '힙 정렬은 완전 이진 트리 기반의 힙(Heap) 자료구조를 활용하는 정렬 알고리즘이다. 최대 힙 또는 최소 힙을 구축하여 정렬한다.'),
       (114, 341, '제자리 정렬, In-place Sort',
        '힙 정렬은 제자리 정렬(In-place Sort)이므로 추가 메모리를 최소화할 수 있다. 추가 배열이 불필요하여 공간 복잡도가 O(1)이다.');

-- Chapter: 알고리즘 (id: 2), Unit: 힙 정렬 (id: 20), Lesson: 힙 정렬 동작 과정 문제집 (id: 58)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (343, 58, '다음 중 힙 정렬의 힙 구축 단계에 대한 설명으로 올바른 것은?', '힙 정렬은 힙 구축 단계를 포함한다.', 'OBJECTIVE'),
       (344, 58, '빈칸에 들어갈 힙 종류를 작성하시오', '오름차순 정렬을 위해서는 ___을 구축하고 내림차순 정렬을 위해서는 최소 힙을 구축한다.', 'SUBJECTIVE'),
       (345, 58, '다음 중 힙 정렬의 정렬 단계에 대한 설명으로 올바른 것은?', '힙 정렬은 정렬 단계를 포함한다.', 'OBJECTIVE'),
       (346, 58, '다음 중 Heapify 과정에 대한 설명으로 올바른 것은?', 'Heapify는 힙 정렬의 핵심 과정이다.', 'OBJECTIVE'),
       (347, 58, '빈칸에 들어갈 연산을 작성하시오', '힙 정렬은 루트 노드를 삭제한 후 마지막 노드를 루트 위치로 이동시키고 ___을 수행한다.', 'SUBJECTIVE'),
       (348, 58, '다음 중 힙 정렬에서 최댓값을 추출하는 방법으로 올바른 것은?', '힙 정렬은 특정한 방법으로 최댓값을 추출한다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (913, 343, '정렬되지 않은 배열을 최대 힙 또는 최소 힙으로 변환한다',
        '힙 정렬의 힙 구축 단계는 정렬되지 않은 배열을 최대 힙(Max Heap) 또는 최소 힙(Min Heap)으로 변환한다. 오름차순 정렬은 최대 힙, 내림차순 정렬은 최소 힙을 사용한다.',
        true),
       (914, 343, '배열을 균등하게 분할한다',
        '이는 합병 정렬의 특징이다. 힙 정렬은 힙 자료구조로 변환한다.', false),
       (915, 343, '피벗을 선택한다',
        '이는 퀵 정렬의 특징이다. 힙 정렬은 힙을 구축한다.', false),
       (916, 343, '최솟값을 찾는다',
        '힙 구축은 전체 배열을 힙 구조로 만드는 것이다. 최솟값만 찾는 것이 아니다.', false),

       (917, 345, '힙의 루트를 배열의 마지막 원소와 교환한 후 힙 크기를 줄이고 힙을 재구성하며 배열 크기가 1이 될 때까지 반복한다',
        '힙 정렬의 정렬 단계는 힙의 루트(최댓값 또는 최솟값)를 배열의 마지막 원소와 교환한 후, 힙 크기를 줄이고 힙을 재구성한다. 배열 크기가 1이 될 때까지 반복한다.',
        true),
       (918, 345, '배열을 합병한다',
        '이는 합병 정렬의 특징이다. 힙 정렬은 루트를 교환하고 힙을 재구성한다.', false),
       (919, 345, '피벗을 기준으로 분할한다',
        '이는 퀵 정렬의 특징이다. 힙 정렬은 루트를 교환한다.', false),
       (920, 345, '한 번만 수행하고 종료한다',
        '힙 정렬은 배열 크기가 1이 될 때까지 반복한다. 한 번만 수행하지 않는다.', false),

       (921, 346, '특정 노드를 루트로 하는 부분 트리를 힙 속성에 맞게 재구성하는 과정이다',
        'Heapify는 특정 노드를 루트로 하는 부분 트리를 힙 속성에 맞게 재구성하는 과정이다. 부모 노드와 자식 노드를 비교하며 힙 속성을 만족할 때까지 교환한다.',
        true),
       (922, 346, '배열을 분할하는 과정이다',
        'Heapify는 힙 속성을 유지하는 과정이다. 배열을 분할하지 않는다.', false),
       (923, 346, '최솟값을 찾는 과정이다',
        'Heapify는 힙 속성을 재구성하는 과정이다. 최솟값만 찾는 것이 아니다.', false),
       (924, 346, '정렬을 완성하는 과정이다',
        'Heapify는 힙 속성을 유지하는 보조 과정이다. 정렬을 직접 완성하지 않는다.', false),

       (925, 348, '최대 힙의 루트 노드에 항상 최댓값이 위치하므로 O(1) 시간에 접근 가능하다',
        '힙 정렬에서 최댓값을 추출하는 방법은 최대 힙의 루트 노드에 항상 최댓값이 위치하므로 O(1) 시간에 접근 가능하다. 루트를 제거한 후 힙을 재구성한다.',
        true),
       (926, 348, '배열 전체를 순회해야 한다',
        '최댓값은 루트 노드에 위치하므로 순회가 불필요하다.', false),
       (927, 348, '중간 노드에서 찾는다',
        '최댓값은 항상 루트 노드에 위치한다. 중간 노드가 아니다.', false),
       (928, 348, '리프 노드에서 찾는다',
        '최댓값은 루트 노드에 위치한다. 리프 노드가 아니다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (115, 344, '최대 힙, Max Heap',
        '오름차순 정렬을 위해서는 최대 힙(Max Heap)을 구축하고 내림차순 정렬을 위해서는 최소 힙을 구축한다. 최대 힙의 루트에는 항상 최댓값이 위치한다.'),
       (116, 347, 'Heapify, 힙 재구성',
        '힙 정렬은 루트 노드를 삭제한 후 마지막 노드를 루트 위치로 이동시키고 Heapify를 수행한다. Heapify는 힙 속성을 재구성하는 과정이다.');

-- Chapter: 알고리즘 (id: 2), Unit: 힙 정렬 (id: 20), Lesson: 힙 정렬 분석 문제집 (id: 59)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (349, 59, '다음 중 힙 정렬의 시간 복잡도 분석으로 올바른 것은?', '힙 정렬은 특정한 시간 복잡도를 가진다.', 'OBJECTIVE'),
       (350, 59, '빈칸에 들어갈 공간 복잡도를 작성하시오', '힙 정렬은 제자리 정렬이므로 추가 메모리가 ___이다.', 'SUBJECTIVE'),
       (351, 59, '다음 중 힙 정렬의 장점으로 올바른 것은?', '힙 정렬은 여러 가지 장점을 가진다.', 'OBJECTIVE'),
       (352, 59, '다음 중 힙 정렬의 단점으로 올바른 것은?', '힙 정렬은 단점도 가지고 있다.', 'OBJECTIVE'),
       (353, 59, '빈칸에 들어갈 정렬 알고리즘을 작성하시오', '힙 정렬은 같은 O(n log n)인 ___보다 2~3배 느리다.', 'SUBJECTIVE'),
       (354, 59, '다음 중 힙 정렬과 퀵 정렬의 비교로 올바른 것은?', '힙 정렬과 퀵 정렬은 차이가 있다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (929, 349, '힙 구축은 O(n)이고 정렬 단계는 O(n log n)이므로 총 시간 복잡도는 O(n log n)이다',
        '힙 정렬의 시간 복잡도는 힙 구축 O(n)과 정렬 단계 O(n log n)으로 구성되며, 총 시간 복잡도는 O(n) + O(n log n) = O(n log n)이다. 모든 경우에 O(n log n)을 보장한다.',
        true),
       (930, 349, '모든 경우에 O(n²)이다',
        '힙 정렬은 모든 경우에 O(n log n)이다. O(n²)이 아니다.', false),
       (931, 349, '평균 O(n log n), 최악 O(n²)이다',
        '힙 정렬은 최악의 경우에도 O(n log n)이다. O(n²)이 아니다.', false),
       (932, 349, '힙 구축은 O(n log n)이다',
        '힙 구축은 O(n)이다. O(n log n)이 아니다.', false),

       (933, 351, '안정적인 시간 복잡도로 최악의 경우에도 O(n log n)을 보장하고 제자리 정렬로 추가 메모리가 O(1)이며 예측 가능하고 최댓값이나 최솟값 추출에 효율적이다',
        '힙 정렬의 장점은 안정적인 성능으로 최악의 경우에도 O(n log n)을 보장하고, 제자리 정렬로 추가 메모리가 O(1)이며, 예측 가능하여 입력 데이터에 관계없이 일정한 성능을 보이고, 최댓값/최솟값 추출 시 효율적이다.',
        true),
       (934, 351, '안정 정렬이다',
        '힙 정렬은 불안정 정렬이다. 동일한 값의 순서가 바뀔 수 있다.', false),
       (935, 351, '캐시 효율성이 매우 높다',
        '힙 정렬은 캐시 지역성이 낮다. 부모-자식 노드 간 메모리 주소가 멀어 캐시 효율이 저하된다.', false),
       (936, 351, '퀵 정렬보다 빠르다',
        '힙 정렬은 같은 O(n log n)인 퀵 정렬보다 2~3배 느리다.', false),

       (937, 352, '불안정 정렬이며 캐시 지역성이 낮고 실제 수행 시간이 같은 O(n log n)인 퀵 정렬보다 2~3배 느리다',
        '힙 정렬의 단점은 불안정 정렬로 동일 값의 순서가 보장되지 않고, 캐시 지역성이 낮아 부모-자식 노드 간 메모리 주소가 멀어 캐시 효율이 저하되며, 실제 수행 시간이 같은 O(n log n)인 퀵 정렬보다 2~3배 느리다.',
        true),
       (938, 352, '최악의 경우 O(n²)이다',
        '힙 정렬은 최악의 경우에도 O(n log n)이다. O(n²)이 아니다.', false),
       (939, 352, '추가 메모리가 O(n) 필요하다',
        '힙 정렬은 제자리 정렬로 추가 메모리가 O(1)이다. O(n)이 아니다.', false),
       (940, 352, '구현이 매우 복잡하다',
        '힙 정렬의 구현은 중간 수준의 복잡도이다. 매우 복잡하지 않다.', false),

       (941, 354, '힙 정렬은 평균 O(n log n)이고 퀵 정렬도 평균 O(n log n)이지만 힙 정렬은 최악의 경우에도 O(n log n)을 보장하고 퀵 정렬은 최악 O(n²)이다',
        '힙 정렬은 평균/최악 모두 O(n log n)이고, 공간 복잡도는 O(1)이며, 불안정 정렬이고, 수행 속도는 느리지만, 최악 보장이 필요한 경우 적합하다. 퀵 정렬은 평균 O(n log n), 최악 O(n²)이고, 공간 복잡도는 O(log n)이며, 불안정 정렬이고, 수행 속도는 빠르며, 평균 케이스에 적합하다.',
        true),
       (942, 354, '힙 정렬이 항상 퀵 정렬보다 빠르다',
        '일반적으로 퀵 정렬이 힙 정렬보다 2~3배 빠르다.', false),
       (943, 354, '힙 정렬은 최악 O(n²)이고 퀵 정렬은 최악 O(n log n)이다',
        '반대이다. 힙 정렬은 최악 O(n log n)이고 퀵 정렬은 최악 O(n²)이다.', false),
       (944, 354, '힙 정렬과 퀵 정렬은 완전히 동일하다',
        '힙 정렬과 퀵 정렬은 최악의 경우 시간 복잡도, 수행 속도 등에서 차이가 있다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (117, 350, 'O(1)',
        '힙 정렬은 제자리 정렬이므로 추가 메모리가 O(1)이다. 재귀 구현 시 O(log n)의 스택 공간이 필요하지만, 반복 구현 시 O(1)이다.'),
       (118, 353, '퀵 정렬, Quick Sort',
        '힙 정렬은 같은 O(n log n)인 퀵 정렬보다 2~3배 느리다. 캐시 지역성이 낮고 실제 수행 시간이 길다. 하지만 최악의 경우를 보장한다.');

-- Chapter: 알고리즘 (id: 2), Unit: 기수 정렬 (id: 21)

-- Lesson 생성
INSERT INTO lesson (id, unit_id, title)
VALUES (60, 21, '기수 정렬 기초 문제집'),
       (61, 21, '기수 정렬 동작 과정 문제집'),
       (62, 21, '기수 정렬 분석 문제집');

-- Chapter: 알고리즘 (id: 2), Unit: 기수 정렬 (id: 21), Lesson: 기수 정렬 기초 문제집 (id: 60)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (355, 60, '다음 중 기수 정렬의 정의로 올바른 것은?', '기수 정렬은 특정한 방식으로 동작하는 정렬 알고리즘이다.', 'OBJECTIVE'),
       (356, 60, '빈칸에 들어갈 용어를 작성하시오', '기수 정렬은 ___부터 비교하여 정렬하는 알고리즘이다.', 'SUBJECTIVE'),
       (357, 60, '다음 중 기수 정렬의 특징으로 올바른 것은?', '기수 정렬은 여러 가지 특징을 가진다.', 'OBJECTIVE'),
       (358, 60, '다음 중 기수 정렬과 다른 정렬의 차이로 올바른 것은?', '기수 정렬은 다른 정렬과 차이가 있다.', 'OBJECTIVE'),
       (359, 60, '빈칸에 들어갈 정렬 유형을 작성하시오', '기수 정렬은 비교 연산을 수행하지 않는 ___이다.', 'SUBJECTIVE'),
       (360, 60, '다음 중 기수 정렬의 안정성에 대한 설명으로 올바른 것은?', '기수 정렬은 안정성과 관련된 특징을 가진다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (945, 355, '낮은 자리수부터 비교하여 정렬하며 비교 연산을 수행하지 않고 자릿수를 이용해 정렬하는 알고리즘이다',
        '기수 정렬은 낮은 자리수부터 비교하여 정렬하는 알고리즘이다. 다른 정렬 알고리즘과 달리 비교 연산을 수행하지 않고 자릿수를 이용해 정렬한다. 안정 정렬이며, 자릿수가 고정된 정수나 문자열 정렬에 효율적이다.',
        true),
       (946, 355, '높은 자리수부터 비교하여 정렬한다',
        '기수 정렬은 낮은 자리수부터 비교한다. 높은 자리수부터가 아니다.', false),
       (947, 355, '피벗을 기준으로 분할하는 알고리즘이다',
        '이는 퀵 정렬의 특징이다. 기수 정렬은 자릿수를 이용한다.', false),
       (948, 355, '인접한 원소를 비교하여 정렬하는 알고리즘이다',
        '기수 정렬은 비교 연산을 수행하지 않는다. 자릿수를 이용한다.', false),

       (949, 357, '비교 연산을 수행하지 않는 정렬이며 낮은 자리수부터 높은 자리수로 순차적으로 정렬하고 안정 정렬이며 0부터 9까지의 버킷을 사용한다',
        '기수 정렬은 비교 연산을 수행하지 않는 정렬(Non-Comparison Sort)이고, 낮은 자리수부터 높은 자리수로 순차적으로 정렬하며(LSD - Least Significant Digit), 안정 정렬(Stable Sort)로 동일한 값의 순서가 유지되고, 0~9까지의 버킷(Bucket) 또는 큐(Queue)를 사용하며, 정렬할 수들의 최대 자릿수(d)에 영향을 받고, 내부적으로 계수 정렬(Counting Sort)을 활용한다.',
        true),
       (950, 357, '비교 연산을 수행한다',
        '기수 정렬은 비교 연산을 수행하지 않는다. 자릿수를 이용한다.', false),
       (951, 357, '불안정 정렬이다',
        '기수 정렬은 안정 정렬이다. 동일한 값의 순서가 유지된다.', false),
       (952, 357, '높은 자리수부터 정렬한다',
        '기수 정렬은 낮은 자리수부터 정렬한다. 높은 자리수부터가 아니다.', false),

       (953, 358, '기수 정렬은 비교 연산을 수행하지 않고 자릿수를 이용하며 다른 정렬은 대부분 비교 연산을 수행한다',
        '기수 정렬은 비교 연산을 수행하지 않는 정렬(Non-Comparison Sort)로 자릿수를 이용해 정렬한다. 다른 정렬 알고리즘은 대부분 원소 간 비교 연산을 수행하여 정렬한다.',
        true),
       (954, 358, '기수 정렬은 비교 연산을 수행하고 다른 정렬은 비교 연산을 수행하지 않는다',
        '반대이다. 기수 정렬은 비교 연산을 수행하지 않는다.', false),
       (955, 358, '기수 정렬과 다른 정렬은 완전히 동일하다',
        '기수 정렬은 비교 연산 수행 여부에서 다른 정렬과 차이가 있다.', false),
       (956, 358, '기수 정렬은 피벗을 사용한다',
        '기수 정렬은 자릿수를 이용한다. 피벗을 사용하지 않는다.', false),

       (957, 360, '안정 정렬이며 동일한 값의 순서가 유지된다',
        '기수 정렬은 안정 정렬(Stable Sort)이다. 동일한 값의 순서가 유지되므로 동일한 키를 가진 데이터의 상대적 순서가 보존된다.',
        true),
       (958, 360, '불안정 정렬이며 동일한 값의 순서가 바뀔 수 있다',
        '기수 정렬은 안정 정렬이다. 동일한 값의 순서가 유지된다.', false),
       (959, 360, '동일한 값을 처리할 수 없다',
        '기수 정렬은 동일한 값을 처리할 수 있으며 순서를 유지한다.', false),
       (960, 360, '동일한 값은 항상 제거된다',
        '기수 정렬은 동일한 값을 유지한다. 제거하지 않는다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (119, 356, '낮은 자리수, 1의 자리',
        '기수 정렬은 낮은 자리수부터 비교하여 정렬하는 알고리즘이다. LSD(Least Significant Digit) 방식으로 1의 자리부터 시작하여 높은 자리수로 순차적으로 정렬한다.'),
       (120, 359, '비교 연산을 수행하지 않는 정렬, Non-Comparison Sort',
        '기수 정렬은 비교 연산을 수행하지 않는 정렬(Non-Comparison Sort)이다. 원소 간 비교 없이 자릿수를 이용하여 정렬한다.');

-- Chapter: 알고리즘 (id: 2), Unit: 기수 정렬 (id: 21), Lesson: 기수 정렬 동작 과정 문제집 (id: 61)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (361, 61, '다음 중 기수 정렬의 버킷 준비 단계에 대한 설명으로 올바른 것은?', '기수 정렬은 버킷 준비 단계를 포함한다.', 'OBJECTIVE'),
       (362, 61, '빈칸에 들어갈 개수를 작성하시오', '기수 정렬은 0부터 9까지 ___개의 버킷을 준비한다.', 'SUBJECTIVE'),
       (363, 61, '다음 중 기수 정렬의 분배 단계에 대한 설명으로 올바른 것은?', '기수 정렬은 분배 단계를 포함한다.', 'OBJECTIVE'),
       (364, 61, '다음 중 기수 정렬의 수집 단계에 대한 설명으로 올바른 것은?', '기수 정렬은 수집 단계를 포함한다.', 'OBJECTIVE'),
       (365, 61, '빈칸에 들어갈 용어를 작성하시오', '기수 정렬은 가장 높은 자릿수까지 분배와 수집 과정을 ___한다.', 'SUBJECTIVE'),
       (366, 61, '다음 중 기수 정렬의 버킷 시스템에 대한 설명으로 올바른 것은?', '기수 정렬의 버킷은 특정한 역할을 한다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (961, 361, '0부터 9까지 10개의 버킷 또는 큐를 준비한다',
        '기수 정렬의 버킷 준비 단계는 0부터 9까지 10개의 버킷(큐)을 준비한다. 각 버킷은 해당 자릿수 값(0~9)에 해당하는 데이터를 임시로 저장한다.',
        true),
       (962, 361, '5개의 버킷을 준비한다',
        '기수 정렬은 10개의 버킷을 준비한다. 5개가 아니다.', false),
       (963, 361, '버킷을 준비하지 않는다',
        '기수 정렬은 버킷 시스템을 사용한다. 버킷 준비가 필수이다.', false),
       (964, 361, '1개의 버킷만 사용한다',
        '기수 정렬은 0~9까지 10개의 버킷을 사용한다. 1개가 아니다.', false),

       (965, 363, '현재 자릿수를 기준으로 각 데이터를 해당 버킷에 넣는다',
        '기수 정렬의 분배 단계는 현재 자릿수를 기준으로 각 데이터를 해당 버킷에 넣는다. 예를 들어, 1의 자리를 처리할 때 1의 자리 값이 2인 데이터는 버킷 2에 삽입한다.',
        true),
       (966, 363, '데이터를 무작위로 배치한다',
        '기수 정렬은 자릿수를 기준으로 체계적으로 분배한다. 무작위가 아니다.', false),
       (967, 363, '가장 큰 값만 선택한다',
        '기수 정렬은 모든 데이터를 자릿수에 따라 버킷에 분배한다. 가장 큰 값만 선택하지 않는다.', false),
       (968, 363, '데이터를 절반으로 나눈다',
        '기수 정렬은 자릿수를 기준으로 10개의 버킷에 분배한다. 절반으로 나누지 않는다.', false),

       (969, 364, '0번 버킷부터 순서대로 데이터를 다시 가져온다',
        '기수 정렬의 수집 단계는 0번 버킷부터 순서대로 데이터를 다시 가져온다. 버킷에 저장된 순서를 유지하며 원래 배열에 다시 넣는다.',
        true),
       (970, 364, '9번 버킷부터 역순으로 가져온다',
        '기수 정렬은 0번 버킷부터 순서대로 가져온다. 역순이 아니다.', false),
       (971, 364, '무작위로 가져온다',
        '기수 정렬은 0번부터 순서대로 체계적으로 가져온다. 무작위가 아니다.', false),
       (972, 364, '수집 단계가 없다',
        '기수 정렬은 분배 후 반드시 수집 단계를 수행한다.', false),

       (973, 366, '버킷은 각 자릿수의 값에 해당하는 임시 저장 공간이며 FIFO 구조의 큐 또는 계수 정렬을 사용하여 구현한다',
        '기수 정렬에서 버킷은 각 자릿수의 값(0~9)에 해당하는 임시 저장 공간이다. 버킷 인덱스는 (숫자 / 10^현재자리) % 10으로 계산되며, FIFO 구조의 큐로 순서를 유지하거나 계수 정렬(카운팅 배열 + 누적합)로 구현한다.',
        true),
       (974, 366, '버킷은 데이터를 영구 저장한다',
        '버킷은 임시 저장 공간이다. 영구 저장하지 않는다.', false),
       (975, 366, '버킷은 하나의 자료구조만 사용한다',
        '버킷은 큐 또는 계수 정렬 등 다양한 방식으로 구현 가능하다.', false),
       (976, 366, '버킷은 사용하지 않는다',
        '기수 정렬은 버킷 시스템을 핵심으로 사용한다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (121, 362, '10, 열, 십',
        '기수 정렬은 0부터 9까지 10개의 버킷을 준비한다. 각 버킷은 해당 자릿수 값(0~9)에 해당하는 데이터를 임시로 저장한다.'),
       (122, 365, '반복',
        '기수 정렬은 가장 높은 자릿수까지 분배와 수집 과정을 반복한다. 모든 자릿수를 처리할 때까지 분배-수집을 반복하여 정렬을 완성한다.');

-- Chapter: 알고리즘 (id: 2), Unit: 기수 정렬 (id: 21), Lesson: 기수 정렬 분석 문제집 (id: 62)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (367, 62, '다음 중 기수 정렬의 시간 복잡도로 올바른 것은?', '기수 정렬은 특정한 시간 복잡도를 가진다.', 'OBJECTIVE'),
       (368, 62, '빈칸에 들어갈 공간 복잡도를 작성하시오', '기수 정렬은 버킷 공간과 출력 배열로 ___의 공간 복잡도를 가진다.', 'SUBJECTIVE'),
       (369, 62, '다음 중 기수 정렬의 장점으로 올바른 것은?', '기수 정렬은 여러 가지 장점을 가진다.', 'OBJECTIVE'),
       (370, 62, '다음 중 기수 정렬의 단점으로 올바른 것은?', '기수 정렬은 단점도 가지고 있다.', 'OBJECTIVE'),
       (371, 62, '빈칸에 들어갈 용어를 작성하시오', '기수 정렬은 정수나 ___에만 사용 가능하여 적용 범위가 제한적이다.', 'SUBJECTIVE'),
       (372, 62, '다음 중 기수 정렬의 적용 조건으로 올바른 것은?', '기수 정렬은 특정한 조건에서 사용 가능하다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (977, 367, '최선/평균/최악 모두 O(d × n)이다',
        '기수 정렬의 시간 복잡도는 최선, 평균, 최악 모두 O(d × (n + b))이다. d는 최대 자릿수, n은 데이터 개수, b는 기수(10)이다. 일반적으로 b는 상수로 취급하므로 O(d × n) 또는 O(dn)으로 표현한다. 자릿수가 적을 때 O(n)에 가까운 성능을 보인다.',
        true),
       (978, 367, '모든 경우에 O(n²)이다',
        '기수 정렬은 O(d × n)이다. O(n²)이 아니다.', false),
       (979, 367, '평균 O(n log n), 최악 O(n²)이다',
        '기수 정렬은 O(d × n)이다. O(n log n)이 아니다.', false),
       (980, 367, '모든 경우에 O(n)이다',
        '기수 정렬은 O(d × n)이다. 자릿수 d에 영향을 받는다.', false),

       (981, 369, '빠른 속도로 자릿수가 적을 때 O(n)에 가까운 성능이며 안정 정렬로 동일한 값의 순서가 유지되고 예측 가능한 성능으로 입력 데이터 분포에 영향을 받지 않으며 비교 연산이 없어 구현이 직관적이다',
        '기수 정렬의 장점은 빠른 속도로 자릿수가 적을 때 O(n)에 가까운 성능을 보이고, 안정 정렬로 동일한 값의 순서가 유지되며, 예측 가능한 성능으로 입력 데이터의 분포에 영향을 받지 않고, 단순한 구조로 비교 연산이 없어 구현이 직관적이다.',
        true),
       (982, 369, '불안정 정렬이다',
        '기수 정렬은 안정 정렬이다. 동일한 값의 순서가 유지된다.', false),
       (983, 369, '비교 연산을 수행한다',
        '기수 정렬은 비교 연산을 수행하지 않는다. 자릿수를 이용한다.', false),
       (984, 369, '추가 메모리가 불필요하다',
        '기수 정렬은 O(n + b)의 추가 메모리가 필요하다.', false),

       (985, 370, '제한적 사용으로 정수나 고정 길이 문자열에만 사용 가능하고 높은 공간 복잡도로 O(n + b)의 추가 메모리가 필요하며 자릿수 의존성으로 자릿수가 클수록 성능이 저하되고 부동소수점이나 음수 처리에 추가 전처리가 필요하다',
        '기수 정렬의 단점은 제한적 사용으로 정수나 고정 길이 문자열에만 사용 가능하고, 높은 공간 복잡도로 O(n + b)의 추가 메모리가 필요하며, 자릿수 의존성으로 자릿수가 클수록 성능이 저하되고, 부동소수점/음수 처리에 추가적인 전처리가 필요하다.',
        true),
       (986, 370, '자릿수에 영향을 받지 않는다',
        '기수 정렬은 자릿수가 클수록 성능이 저하된다. 자릿수에 크게 영향을 받는다.', false),
       (987, 370, '추가 메모리가 O(1)이다',
        '기수 정렬은 O(n + b)의 추가 메모리가 필요하다. O(1)이 아니다.', false),
       (988, 370, '모든 데이터 타입에 사용 가능하다',
        '기수 정렬은 정수나 고정 길이 문자열에만 사용 가능하다. 적용 범위가 제한적이다.', false),

       (989, 372, '정수 데이터, 고정 길이 문자열, 자릿수가 적은 데이터에 사용 가능하다',
        '기수 정렬은 정수 데이터, 고정 길이 문자열, 자릿수가 적은 데이터에 사용 가능하다. 부동소수점 숫자는 전처리가 필요하고, 음수는 오프셋 처리가 필요하며, 가변 길이 데이터나 비교 기반 정렬이 필요한 경우는 사용 불가능하다.',
        true),
       (990, 372, '부동소수점에 바로 사용 가능하다',
        '부동소수점은 전처리가 필요하다. 바로 사용할 수 없다.', false),
       (991, 372, '가변 길이 데이터에 적합하다',
        '기수 정렬은 고정 길이 데이터에만 적합하다. 가변 길이는 사용 불가능하다.', false),
       (992, 372, '모든 데이터 타입에 적용 가능하다',
        '기수 정렬은 정수나 고정 길이 문자열에만 사용 가능하다. 적용 범위가 제한적이다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (123, 368, 'O(n + b), O(n)',
        '기수 정렬은 버킷 공간 O(n + b)의 공간 복잡도를 가진다. n개의 데이터를 담을 출력 배열과 b개의 카운팅 배열이 필요하다. 일반적으로 b(기수=10)는 상수로 취급하므로 O(n)으로 표현한다.'),
       (124, 371, '고정 길이 문자열, 문자열',
        '기수 정렬은 정수나 고정 길이 문자열에만 사용 가능하여 적용 범위가 제한적이다. 부동소수점, 음수, 가변 길이 데이터는 추가 처리가 필요하거나 사용 불가능하다.');

-- Chapter: 알고리즘 (id: 2), Unit: 위상 정렬 (id: 22)

-- Lesson 생성
INSERT INTO lesson (id, unit_id, title)
VALUES (63, 22, '위상 정렬 기초 문제집'),
       (64, 22, '위상 정렬 응용 문제집');

-- Chapter: 알고리즘 (id: 2), Unit: 위상 정렬 (id: 22), Lesson: 위상 정렬 기초 문제집 (id: 63)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (373, 63, '다음 중 위상 정렬에 대한 설명으로 올바른 것은?', '위상 정렬은 방향 그래프에서 사용되는 정렬 알고리즘이다.', 'OBJECTIVE'),
       (374, 63, '다음 중 위상 정렬이 가능한 그래프의 조건은?', '위상 정렬을 수행하기 위해서는 그래프가 특정 조건을 만족해야 한다.', 'OBJECTIVE'),
       (375, 63, '빈칸에 들어갈 용어를 작성하시오', '위상 정렬은 ___에서만 수행 가능하다. (사이클이 없는 방향 그래프)', 'SUBJECTIVE'),
       (376, 63, '다음 중 진입 차수(Indegree)에 대한 설명으로 올바른 것은?', '위상 정렬에서 진입 차수는 중요한 개념이다.', 'OBJECTIVE'),
       (377, 63, '빈칸에 들어갈 알고리즘 이름을 작성하시오', '큐를 이용한 위상 정렬 알고리즘을 ___라고 한다.', 'SUBJECTIVE'),
       (378, 63, '다음 중 위상 정렬의 시간 복잡도는?', 'V는 정점의 개수, E는 간선의 개수를 의미한다.', 'OBJECTIVE'),
       (379, 63, '다음 중 위상 정렬의 특징으로 올바르지 않은 것은?', '위상 정렬은 여러 가지 특징을 가지고 있다.', 'OBJECTIVE'),
       (380, 63, '빈칸에 들어갈 숫자를 작성하시오', '위상 정렬을 수행할 때 처음에 큐에 삽입하는 노드는 진입 차수가 ___인 노드이다.', 'SUBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (993, 373, '순서가 정해진 작업을 정렬하는 알고리즘이다', '위상 정렬은 순서가 정해져 있는 일련의 작업을 차례대로 수행해야 할 때 사용하므로 정답이다.', true),
       (994, 373, '가중치의 합을 최소화하는 알고리즘이다', '가중치 합 최소화는 최소 신장 트리의 목적이므로 오답이다.', false),
       (995, 373, '최단 경로를 찾는 알고리즘이다', '최단 경로 탐색은 다익스트라 등의 알고리즘이므로 오답이다.', false),
       (996, 373, '배열을 오름차순으로 정렬하는 알고리즘이다', '위상 정렬은 작업 순서를 결정하는 알고리즘이므로 오답이다.', false),

       (997, 374, '사이클이 없는 방향 그래프(DAG)', '위상 정렬은 DAG에서만 수행 가능하므로 정답이다.', true),
       (998, 374, '사이클이 있는 방향 그래프', '사이클이 있으면 위상 정렬이 불가능하므로 오답이다.', false),
       (999, 374, '무방향 그래프', '무방향 그래프는 위상 정렬을 수행할 수 없으므로 오답이다.', false),
       (1000, 374, '완전 그래프', '완전 그래프는 위상 정렬의 조건이 아니므로 오답이다.', false),

       (1001, 376, '특정 노드로 들어오는 간선의 개수', '진입 차수는 특정 노드로 들어오는 간선의 개수를 의미하므로 정답이다.', true),
       (1002, 376, '특정 노드에서 나가는 간선의 개수', '이는 진출 차수에 대한 설명이므로 오답이다.', false),
       (1003, 376, '노드의 총 간선 개수', '진입 차수는 들어오는 간선만 계산하므로 오답이다.', false),
       (1004, 376, '노드가 가진 자식의 개수', '진입 차수는 간선의 개수를 의미하므로 오답이다.', false),

       (1005, 378, 'O(V + E)', '위상 정렬의 시간 복잡도는 O(V + E)이므로 정답이다.', true),
       (1006, 378, 'O(V²)', '위상 정렬은 O(V²)보다 효율적이므로 오답이다.', false),
       (1007, 378, 'O(E log V)', '이는 다익스트라 알고리즘의 시간 복잡도이므로 오답이다.', false),
       (1008, 378, 'O(V log V)', '위상 정렬의 시간 복잡도는 O(V + E)이므로 오답이다.', false),

       (1009, 379, '여러 개의 해답이 존재할 수 있다', '진입 차수가 0인 노드가 여러 개면 여러 가지 답이 존재하므로 오답이다.', false),
       (1010, 379, '사이클 탐지가 가능하다', '위상 정렬을 통해 사이클 존재 여부를 확인할 수 있으므로 오답이다.', false),
       (1011, 379, '무방향 그래프에서도 사용 가능하다', '위상 정렬은 방향 그래프에서만 사용 가능하므로 정답이다.', true),
       (1012, 379, 'DFS 방식과 BFS 방식 두 가지로 구현 가능하다', '두 가지 구현 방법이 모두 가능하므로 오답이다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (125, 375, 'DAG, 사이클이 없는 방향 그래프, Directed Acyclic Graph', '위상 정렬은 DAG(Directed Acyclic Graph)에서만 수행 가능하다.'),
       (126, 377, 'Kahn''s Algorithm, 칸 알고리즘, Kahn Algorithm', '큐를 이용한 위상 정렬 알고리즘을 Kahn''s Algorithm이라고 한다.'),
       (127, 380, '0', '위상 정렬 시작 시 진입 차수가 0인 노드를 큐에 삽입한다.');

-- Chapter: 알고리즘 (id: 2), Unit: 위상 정렬 (id: 22), Lesson: 위상 정렬 응용 문제집 (id: 64)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (381, 64, '다음 중 위상 정렬의 활용 사례로 올바르지 않은 것은?', '위상 정렬은 다양한 분야에서 활용된다.', 'OBJECTIVE'),
       (382, 64, '다음 중 위상 정렬에서 사이클을 탐지하는 방법은?', '위상 정렬을 이용하면 사이클 존재 여부를 확인할 수 있다.', 'OBJECTIVE'),
       (383, 64, '다음 중 위상 정렬을 BFS로 구현할 때 사용하는 자료구조는?', 'Kahn''s Algorithm은 특정 자료구조를 사용한다.', 'OBJECTIVE'),
       (384, 64, '다음 설명이 올바른지 판단하시오', '위상 정렬 결과가 여러 개 나올 수 있는 이유는 진입 차수가 0인 노드가 동시에 여러 개 존재할 수 있기 때문이다.', 'OBJECTIVE'),
       (385, 64, '빈칸에 들어갈 내용을 작성하시오', '위상 정렬을 수행한 후 모든 노드를 방문하지 못했다면 그래프에 ___이 존재한다는 의미이다.', 'SUBJECTIVE'),
       (386, 64, '다음 중 DFS를 이용한 위상 정렬의 특징은?', 'DFS 방식의 위상 정렬은 스택을 활용한다.', 'OBJECTIVE'),
       (387, 64, '다음 중 위상 정렬의 장점으로 올바른 것은?', '위상 정렬은 여러 가지 장점을 가지고 있다.', 'OBJECTIVE'),
       (388, 64, '다음 중 위상 정렬의 단점으로 올바른 것은?', '위상 정렬은 단점도 가지고 있다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (1013, 381, '선수과목 순서 결정', '선수과목 순서는 위상 정렬의 대표적인 활용 사례이므로 오답이다.', false),
       (1014, 381, '작업 스케줄링', '작업 스케줄링은 위상 정렬의 활용 사례이므로 오답이다.', false),
       (1015, 381, '최단 경로 탐색', '최단 경로 탐색은 위상 정렬의 활용 사례가 아니므로 정답이다.', true),
       (1016, 381, '빌드 시스템 의존성 해결', '빌드 시스템 의존성은 위상 정렬의 활용 사례이므로 오답이다.', false),

       (1017, 382, '모든 노드를 방문하지 못한 경우', '위상 정렬 후 모든 노드를 방문하지 못했다면 사이클이 존재하므로 정답이다.', true),
       (1018, 382, '진입 차수가 0인 노드가 없는 경우', '진입 차수가 0인 노드가 없으면 사이클이 존재할 가능성이 있으나 충분조건은 아니므로 오답이다.', false),
       (1019, 382, '간선의 개수가 정점보다 많은 경우', '간선 개수만으로는 사이클을 판단할 수 없으므로 오답이다.', false),
       (1020, 382, '진출 차수가 0인 노드가 여러 개인 경우', '진출 차수는 사이클 탐지와 직접적인 관련이 없으므로 오답이다.', false),

       (1021, 383, '큐(Queue)', 'Kahn''s Algorithm은 큐를 사용하여 진입 차수가 0인 노드를 관리하므로 정답이다.', true),
       (1022, 383, '스택(Stack)', '스택은 DFS 방식 위상 정렬에서 사용되므로 오답이다.', false),
       (1023, 383, '우선순위 큐(Priority Queue)', '위상 정렬에서 우선순위 큐는 필수가 아니므로 오답이다.', false),
       (1024, 383, '덱(Deque)', '덱은 위상 정렬의 기본 자료구조가 아니므로 오답이다.', false),

       (1025, 384, '올바르다', '진입 차수가 0인 노드가 여러 개면 선택 순서에 따라 여러 답이 나오므로 정답이다.', true),
       (1026, 384, '올바르지 않다', '해당 설명은 올바르므로 오답이다.', false),

       (1027, 386, '스택을 역순으로 pop하여 결과를 생성한다', 'DFS 방식은 스택에 노드를 추가한 후 역순으로 pop하여 위상 정렬 결과를 얻으므로 정답이다.', true),
       (1028, 386, '진입 차수를 계산하여 사용한다', '진입 차수 계산은 BFS 방식의 특징이므로 오답이다.', false),
       (1029, 386, '큐를 사용하여 구현한다', '큐 사용은 BFS 방식의 특징이므로 오답이다.', false),
       (1030, 386, '진입 차수가 0인 노드부터 처리한다', '이는 BFS 방식의 특징이므로 오답이다.', false),

       (1031, 387, '선형 시간 복잡도로 효율적이다', '위상 정렬은 O(V + E)의 선형 시간 복잡도로 효율적이므로 정답이다.', true),
       (1032, 387, '항상 유일한 답을 보장한다', '위상 정렬은 여러 개의 답이 나올 수 있으므로 오답이다.', false),
       (1033, 387, '그래프 변경 시 부분 수정이 가능하다', '그래프 변경 시 처음부터 다시 계산해야 하므로 오답이다.', false),
       (1034, 387, '모든 그래프에 적용 가능하다', '위상 정렬은 DAG에만 적용 가능하므로 오답이다.', false),

       (1035, 388, 'DAG에만 적용 가능하다', '위상 정렬은 DAG에만 적용 가능하므로 정답이다.', true),
       (1036, 388, '항상 유일한 답을 제공한다', '위상 정렬은 여러 개의 답이 나올 수 있으므로 오답이다.', false),
       (1037, 388, '추가 메모리가 필요 없다', '위상 정렬은 큐나 스택 등 추가 메모리가 필요하므로 오답이다.', false),
       (1038, 388, '그래프 변경 시 부분 수정이 가능하다', '그래프 변경 시 처음부터 다시 계산해야 하므로 오답이다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (128, 385, '사이클, cycle', '위상 정렬 후 모든 노드를 방문하지 못했다면 사이클이 존재한다는 의미이다.');

-- Chapter: 알고리즘 (id: 2), Unit: DFS와 BFS (id: 13)

-- Lesson 생성
INSERT INTO lesson (id, unit_id, title)
VALUES (65, 13, 'DFS 기초 문제집'),
       (66, 13, 'BFS 기초 문제집'),
       (67, 13, 'DFS와 BFS 비교 문제집');

-- Chapter: 알고리즘 (id: 2), Unit: DFS와 BFS (id: 13), Lesson: DFS 기초 문제집 (id: 65)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (389, 65, '다음 중 DFS(깊이 우선 탐색)에 대한 설명으로 올바른 것은?', 'DFS는 그래프 탐색 알고리즘이다.', 'OBJECTIVE'),
       (390, 65, '빈칸에 들어갈 용어를 작성하시오', 'DFS는 ___을 사용하여 구현하거나 재귀 함수로 구현한다.', 'SUBJECTIVE'),
       (391, 65, '다음 중 DFS의 특징으로 올바른 것은?', 'DFS는 여러 가지 특징을 가진다.', 'OBJECTIVE'),
       (392, 65, '다음 중 DFS의 시간 복잡도는?', 'V는 정점의 개수, E는 간선의 개수를 의미한다.', 'OBJECTIVE'),
       (393, 65, '빈칸에 들어갈 내용을 작성하시오', 'DFS는 한 방향으로 끝까지 탐색 후 다른 방향을 탐색하는 ___ 방식이다.', 'SUBJECTIVE'),
       (394, 65, '다음 중 DFS의 공간 복잡도는?', 'DFS의 공간 복잡도는 재귀 깊이에 영향을 받는다.', 'OBJECTIVE'),
       (395, 65, '다음 중 DFS의 활용 사례로 올바른 것은?', 'DFS는 다양한 분야에서 활용된다.', 'OBJECTIVE'),
       (396, 65, '다음 중 DFS의 장점으로 올바른 것은?', 'DFS는 여러 가지 장점을 가진다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (1039, 389, '갈 수 있는 곳까지 최대한 깊이 들어가고 더 이상 갈 곳이 없으면 이전 정점으로 돌아가 다른 경로를 탐색하는 방식이다', 'DFS는 한 방향으로 끝까지 탐색 후 백트래킹하여 다른 경로를 탐색하므로 정답이다.', true),
       (1040, 389, '시작 정점에서 가까운 정점부터 차례대로 탐색하는 방식이다', '이는 BFS의 설명이므로 오답이다.', false),
       (1041, 389, '가중치가 가장 작은 간선부터 탐색하는 방식이다', '이는 최단 경로 알고리즘의 설명이므로 오답이다.', false),
       (1042, 389, '모든 정점을 동시에 탐색하는 방식이다', 'DFS는 순차적으로 탐색하므로 오답이다.', false),

       (1043, 391, '스택 또는 재귀 함수로 구현하고 백트래킹 방식으로 동작하며 모든 경로를 탐색해야 하는 문제에 유리하고 구현이 BFS보다 간단하다', 'DFS는 스택이나 재귀로 구현하고, 백트래킹 방식으로 동작하며, 모든 경로 탐색에 유리하고, 구현이 간단하므로 정답이다.', true),
       (1044, 391, '큐를 사용하여 구현한다', 'DFS는 스택 또는 재귀를 사용하므로 오답이다.', false),
       (1045, 391, '최단 경로를 보장한다', 'DFS는 최단 경로를 보장하지 않으므로 오답이다.', false),
       (1046, 391, '레벨 순서대로 탐색한다', '이는 BFS의 특징이므로 오답이다.', false),

       (1047, 392, '인접 리스트 기준 O(V + E)', 'DFS의 시간 복잡도는 인접 리스트 기준 O(V + E)이므로 정답이다.', true),
       (1048, 392, 'O(V²)', '인접 행렬 기준은 O(V²)이지만 인접 리스트가 더 일반적이므로 오답이다.', false),
       (1049, 392, 'O(V log E)', 'DFS의 시간 복잡도는 O(V + E)이므로 오답이다.', false),
       (1050, 392, 'O(E log V)', 'DFS의 시간 복잡도는 O(V + E)이므로 오답이다.', false),

       (1051, 394, 'O(V)', '재귀 호출 스택의 최대 깊이가 V이므로 O(V)가 정답이다.', true),
       (1052, 394, 'O(E)', 'DFS의 공간 복잡도는 정점 수에 비례하므로 오답이다.', false),
       (1053, 394, 'O(1)', 'DFS는 재귀 스택 공간이 필요하므로 오답이다.', false),
       (1054, 394, 'O(V²)', 'DFS의 공간 복잡도는 O(V)이므로 오답이다.', false),

       (1055, 395, '경로 탐색, 사이클 검출, 위상 정렬, 연결 요소 찾기, 백트래킹 문제', 'DFS는 경로 탐색, 사이클 검출, 위상 정렬, 연결 요소 찾기, 백트래킹 문제 등에 활용되므로 정답이다.', true),
       (1056, 395, '최단 거리 문제', '최단 거리는 BFS가 더 적합하므로 오답이다.', false),
       (1057, 395, '레벨별 탐색', '레벨별 탐색은 BFS가 더 적합하므로 오답이다.', false),
       (1058, 395, '정렬 문제', '정렬은 DFS의 주요 활용 사례가 아니므로 오답이다.', false),

       (1059, 396, '구현이 간단하고 현재 경로상의 노드만 기억하므로 메모리 효율적이며 모든 경로를 탐색해야 하는 문제에 적합하고 백트래킹 기법과 함께 사용하기 용이하다', 'DFS는 구현이 간단하고, 메모리 효율적이며, 모든 경로 탐색과 백트래킹에 적합하므로 정답이다.', true),
       (1060, 396, '최단 경로를 보장한다', 'DFS는 최단 경로를 보장하지 않으므로 오답이다.', false),
       (1061, 396, '메모리 사용량이 BFS보다 많다', 'DFS는 현재 경로만 기억하므로 메모리 효율적이어서 오답이다.', false),
       (1062, 396, '레벨별 탐색이 가능하다', '레벨별 탐색은 BFS의 장점이므로 오답이다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (129, 390, '스택, Stack', 'DFS는 스택을 사용하여 구현하거나 재귀 함수로 구현한다. 재귀 함수도 내부적으로 호출 스택을 사용한다.'),
       (130, 393, '백트래킹, Backtracking', 'DFS는 한 방향으로 끝까지 탐색 후 다른 방향을 탐색하는 백트래킹 방식이다.');

-- Chapter: 알고리즘 (id: 2), Unit: DFS와 BFS (id: 13), Lesson: BFS 기초 문제집 (id: 66)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (397, 66, '다음 중 BFS(너비 우선 탐색)에 대한 설명으로 올바른 것은?', 'BFS는 그래프 탐색 알고리즘이다.', 'OBJECTIVE'),
       (398, 66, '빈칸에 들어갈 자료구조를 작성하시오', 'BFS는 ___를 사용하여 구현한다.', 'SUBJECTIVE'),
       (399, 66, '다음 중 BFS의 특징으로 올바른 것은?', 'BFS는 여러 가지 특징을 가진다.', 'OBJECTIVE'),
       (400, 66, '다음 중 BFS의 시간 복잡도는?', 'V는 정점의 개수, E는 간선의 개수를 의미한다.', 'OBJECTIVE'),
       (401, 66, '빈칸에 들어갈 내용을 작성하시오', 'BFS는 가중치가 없는 그래프에서 ___를 보장한다.', 'SUBJECTIVE'),
       (402, 66, '다음 중 BFS의 공간 복잡도는?', 'BFS의 공간 복잡도는 큐의 크기에 영향을 받는다.', 'OBJECTIVE'),
       (403, 66, '다음 중 BFS의 활용 사례로 올바른 것은?', 'BFS는 다양한 분야에서 활용된다.', 'OBJECTIVE'),
       (404, 66, '다음 중 BFS의 장점으로 올바른 것은?', 'BFS는 여러 가지 장점을 가진다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (1063, 397, '시작 정점에서 가까운 정점부터 차례대로 탐색하고 같은 깊이의 노드를 모두 탐색한 후 다음 깊이로 넘어가는 방식이다', 'BFS는 레벨 순서대로 가까운 정점부터 탐색하므로 정답이다.', true),
       (1064, 397, '갈 수 있는 곳까지 최대한 깊이 들어가는 방식이다', '이는 DFS의 설명이므로 오답이다.', false),
       (1065, 397, '가중치가 가장 작은 간선부터 탐색하는 방식이다', '이는 최단 경로 알고리즘의 설명이므로 오답이다.', false),
       (1066, 397, '백트래킹 방식으로 탐색하는 알고리즘이다', '백트래킹은 DFS의 특징이므로 오답이다.', false),

       (1067, 399, '큐를 사용하고 레벨 순서대로 탐색하며 최단 거리를 보장하고 시작점으로부터의 거리 계산이 가능하며 메모리 사용량이 DFS보다 많을 수 있다', 'BFS는 큐를 사용하고, 레벨 순서 탐색, 최단 거리 보장, 거리 계산 가능, 메모리 사용량이 많은 특징을 가지므로 정답이다.', true),
       (1068, 399, '스택을 사용하여 구현한다', 'BFS는 큐를 사용하므로 오답이다.', false),
       (1069, 399, '백트래킹 방식으로 동작한다', '백트래킹은 DFS의 특징이므로 오답이다.', false),
       (1070, 399, '재귀로만 구현 가능하다', 'BFS는 큐를 사용하며 재귀로는 구현하기 어려우므로 오답이다.', false),

       (1071, 400, '인접 리스트 기준 O(V + E)', 'BFS의 시간 복잡도는 인접 리스트 기준 O(V + E)이므로 정답이다.', true),
       (1072, 400, 'O(V²)', '인접 행렬 기준은 O(V²)이지만 인접 리스트가 더 일반적이므로 오답이다.', false),
       (1073, 400, 'O(V log E)', 'BFS의 시간 복잡도는 O(V + E)이므로 오답이다.', false),
       (1074, 400, 'O(E log V)', 'BFS의 시간 복잡도는 O(V + E)이므로 오답이다.', false),

       (1075, 402, 'O(V)', '큐에 최악의 경우 모든 정점이 저장될 수 있으므로 O(V)가 정답이다.', true),
       (1076, 402, 'O(E)', 'BFS의 공간 복잡도는 정점 수에 비례하므로 오답이다.', false),
       (1077, 402, 'O(1)', 'BFS는 큐 공간이 필요하므로 오답이다.', false),
       (1078, 402, 'O(V²)', 'BFS의 공간 복잡도는 O(V)이므로 오답이다.', false),

       (1079, 403, '최단 거리 문제, 레벨별 탐색, 연결 요소 찾기, 가중치 없는 최단 경로', 'BFS는 최단 거리 문제, 레벨별 탐색, 연결 요소 찾기, 가중치 없는 최단 경로 등에 활용되므로 정답이다.', true),
       (1080, 403, '백트래킹 문제', '백트래킹은 DFS가 더 적합하므로 오답이다.', false),
       (1081, 403, '모든 경로 탐색', '모든 경로 탐색은 DFS가 더 적합하므로 오답이다.', false),
       (1082, 403, '정렬 문제', '정렬은 BFS의 주요 활용 사례가 아니므로 오답이다.', false),

       (1083, 404, '최단 경로를 보장하고 레벨별 탐색이 명확하여 특정 깊이까지만 탐색 가능하다', 'BFS는 최단 경로를 보장하고 레벨별 탐색이 명확하므로 정답이다.', true),
       (1084, 404, '메모리 사용량이 적다', 'BFS는 큐에 많은 노드를 저장할 수 있어 메모리 사용량이 많으므로 오답이다.', false),
       (1085, 404, '모든 경로 탐색이 용이하다', '모든 경로 탐색은 DFS가 더 적합하므로 오답이다.', false),
       (1086, 404, '재귀로 구현이 간단하다', 'BFS는 재귀 구현이 불가능하므로 오답이다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (131, 398, '큐, Queue', 'BFS는 큐(Queue)를 사용하여 구현한다. 먼저 들어간 노드를 먼저 처리하는 FIFO 방식이다.'),
       (132, 401, '최단 경로, 최단 거리', 'BFS는 가중치가 없는 그래프에서 최단 경로를 보장한다.');

-- Chapter: 알고리즘 (id: 2), Unit: DFS와 BFS (id: 13), Lesson: DFS와 BFS 비교 문제집 (id: 67)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (405, 67, '다음 중 DFS와 BFS의 차이로 올바른 것은?', 'DFS와 BFS는 탐색 방향이 다르다.', 'OBJECTIVE'),
       (406, 67, '빈칸에 들어갈 알고리즘을 작성하시오', '최단 경로를 보장하는 탐색 알고리즘은 ___이다.', 'SUBJECTIVE'),
       (407, 67, '다음 중 DFS가 BFS보다 유리한 경우는?', 'DFS와 BFS는 각각 유리한 상황이 다르다.', 'OBJECTIVE'),
       (408, 67, '다음 중 BFS가 DFS보다 유리한 경우는?', 'BFS와 DFS는 각각 적합한 문제가 다르다.', 'OBJECTIVE'),
       (409, 67, '빈칸에 들어갈 알고리즘을 작성하시오', '메모리 사용량이 더 적은 탐색 알고리즘은 ___이다.', 'SUBJECTIVE'),
       (410, 67, '다음 중 DFS와 BFS의 공통점은?', 'DFS와 BFS는 공통점도 가지고 있다.', 'OBJECTIVE'),
       (411, 67, '다음 상황에서 적합한 알고리즘을 선택하시오', '미로 탈출에서 최소 이동 횟수를 구해야 하는 경우', 'OBJECTIVE'),
       (412, 67, '다음 상황에서 적합한 알고리즘을 선택하시오', '모든 경로를 탐색하여 조건을 만족하는 경로를 찾아야 하는 경우', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (1087, 405, 'DFS는 깊이 우선이고 BFS는 너비 우선이며 DFS는 스택을 사용하고 BFS는 큐를 사용한다', 'DFS는 깊이 우선으로 스택을 사용하고, BFS는 너비 우선으로 큐를 사용하므로 정답이다.', true),
       (1088, 405, 'DFS는 큐를 사용하고 BFS는 스택을 사용한다', 'DFS는 스택, BFS는 큐를 사용하므로 오답이다.', false),
       (1089, 405, 'DFS와 BFS는 동일한 탐색 방향을 가진다', 'DFS와 BFS는 탐색 방향이 다르므로 오답이다.', false),
       (1090, 405, 'DFS는 최단 경로를 보장하고 BFS는 보장하지 않는다', 'BFS가 최단 경로를 보장하므로 오답이다.', false),

       (1091, 407, '모든 경로를 탐색해야 하는 문제', 'DFS는 모든 경로 탐색에 유리하므로 정답이다.', true),
       (1092, 407, '최단 거리를 구하는 문제', '최단 거리는 BFS가 더 적합하므로 오답이다.', false),
       (1093, 407, '레벨별로 탐색해야 하는 문제', '레벨별 탐색은 BFS가 더 적합하므로 오답이다.', false),
       (1094, 407, '가까운 노드부터 탐색해야 하는 문제', '가까운 노드부터는 BFS가 더 적합하므로 오답이다.', false),

       (1095, 408, '최단 거리를 구하는 문제', 'BFS는 최단 거리 문제에 유리하므로 정답이다.', true),
       (1096, 408, '모든 경로를 탐색하는 문제', '모든 경로 탐색은 DFS가 더 적합하므로 오답이다.', false),
       (1097, 408, '백트래킹이 필요한 문제', '백트래킹은 DFS가 더 적합하므로 오답이다.', false),
       (1098, 408, '깊은 곳까지 탐색해야 하는 문제', '깊은 곳 탐색은 DFS가 더 적합하므로 오답이다.', false),

       (1099, 410, '시간 복잡도가 O(V + E)로 동일하고 모든 정점을 방문한다', 'DFS와 BFS는 시간 복잡도가 동일하고 모든 정점을 방문하므로 정답이다.', true),
       (1100, 410, '사용하는 자료구조가 동일하다', 'DFS는 스택, BFS는 큐를 사용하므로 오답이다.', false),
       (1101, 410, '탐색 순서가 동일하다', 'DFS와 BFS는 탐색 순서가 다르므로 오답이다.', false),
       (1102, 410, '최단 경로를 보장한다', 'DFS는 최단 경로를 보장하지 않으므로 오답이다.', false),

       (1103, 411, 'BFS', 'BFS는 최단 거리를 보장하므로 최소 이동 횟수를 구하는 문제에 적합하여 정답이다.', true),
       (1104, 411, 'DFS', 'DFS는 최단 거리를 보장하지 않으므로 오답이다.', false),

       (1105, 412, 'DFS', 'DFS는 모든 경로를 탐색하는 데 적합하므로 정답이다.', true),
       (1106, 412, 'BFS', 'BFS는 모든 경로 탐색에는 적합하지 않으므로 오답이다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (133, 406, 'BFS, 너비 우선 탐색, Breadth First Search', 'BFS는 가중치가 없는 그래프에서 최단 경로를 보장한다.'),
       (134, 409, 'DFS, 깊이 우선 탐색, Depth First Search', 'DFS는 현재 경로상의 노드만 기억하므로 메모리 사용량이 적다.');

-- Chapter: 알고리즘 (id: 2), Unit: 그리디 알고리즘 (id: 14)

-- Lesson 생성
INSERT INTO lesson (id, unit_id, title)
VALUES (68, 14, '그리디 알고리즘 기초 문제집'),
       (69, 14, '그리디 알고리즘 예시 문제집'),
       (70, 14, '그리디 알고리즘 한계 문제집');

-- Chapter: 알고리즘 (id: 2), Unit: 그리디 알고리즘 (id: 14), Lesson: 그리디 알고리즘 기초 문제집 (id: 68)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (413, 68, '다음 중 그리디 알고리즘에 대한 설명으로 올바른 것은?', '그리디 알고리즘은 특정한 방식으로 문제를 해결한다.', 'OBJECTIVE'),
       (414, 68, '빈칸에 들어갈 용어를 작성하시오', '그리디 알고리즘은 각 단계에서 ___을 선택하여 전역 최적을 기대한다.', 'SUBJECTIVE'),
       (415, 68, '다음 중 그리디 알고리즘의 주요 속성으로 올바른 것은?', '그리디 알고리즘은 두 가지 주요 속성을 가진다.', 'OBJECTIVE'),
       (416, 68, '다음 중 탐욕 선택 속성에 대한 설명으로 올바른 것은?', '탐욕 선택 속성은 그리디 알고리즘의 핵심 개념이다.', 'OBJECTIVE'),
       (417, 68, '빈칸에 들어갈 용어를 작성하시오', '그리디 알고리즘에서 전체 문제의 최적해가 부분 문제의 최적해로 구성될 수 있는 경우를 ___라고 한다.', 'SUBJECTIVE'),
       (418, 68, '다음 중 그리디 알고리즘의 특징으로 올바른 것은?', '그리디 알고리즘은 여러 가지 특징을 가진다.', 'OBJECTIVE'),
       (419, 68, '다음 중 그리디 알고리즘의 장점으로 올바른 것은?', '그리디 알고리즘은 장점을 가지고 있다.', 'OBJECTIVE'),
       (420, 68, '다음 중 그리디 알고리즘의 단점으로 올바른 것은?', '그리디 알고리즘은 단점도 가지고 있다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (1107, 413, '매 순간 지금 당장 가장 좋아 보이는 선택을 하면서 답을 만드는 알고리즘이다', '그리디 알고리즘은 각 단계에서 지역 최적을 선택하여 전역 최적을 기대하므로 정답이다.', true),
       (1108, 413, '모든 경우의 수를 탐색하는 알고리즘이다', '이는 브루트 포스의 설명이므로 오답이다.', false),
       (1109, 413, '이전 결과를 저장하여 재사용하는 알고리즘이다', '이는 다이내믹 프로그래밍의 설명이므로 오답이다.', false),
       (1110, 413, '분할 정복 방식을 사용하는 알고리즘이다', '이는 병합 정렬 등의 설명이므로 오답이다.', false),

       (1111, 415, '탐욕 선택 속성과 최적 부분 구조', '그리디 알고리즘이 최적해를 보장하려면 탐욕 선택 속성과 최적 부분 구조를 모두 만족해야 하므로 정답이다.', true),
       (1112, 415, '분할 정복과 메모이제이션', '이는 다른 알고리즘의 속성이므로 오답이다.', false),
       (1113, 415, '백트래킹과 가지치기', '이는 백트래킹의 속성이므로 오답이다.', false),
       (1114, 415, '순환 구조와 재귀 호출', '이는 그리디의 주요 속성이 아니므로 오답이다.', false),

       (1115, 416, '각 단계에서 최선의 선택을 했을 때 전체 문제의 최적해를 구할 수 있는 경우', '탐욕 선택 속성은 각 단계의 최선 선택이 전체적으로 최적의 결과를 가져오는 경우이므로 정답이다.', true),
       (1116, 416, '모든 경우의 수를 탐색하는 것', '이는 탐욕 선택 속성의 설명이 아니므로 오답이다.', false),
       (1117, 416, '이전 결과를 재사용하는 것', '이는 탐욕 선택 속성의 설명이 아니므로 오답이다.', false),
       (1118, 416, '문제를 분할하여 해결하는 것', '이는 탐욕 선택 속성의 설명이 아니므로 오답이다.', false),

       (1119, 418, '빠르고 구현이 단순하지만 항상 최적해를 보장하지는 않는다', '그리디 알고리즘은 빠르고 단순하지만 항상 최적해를 보장하지 않으므로 정답이다.', true),
       (1120, 418, '항상 최적해를 보장한다', '그리디는 항상 최적해를 보장하지 않으므로 오답이다.', false),
       (1121, 418, '메모리 사용량이 많다', '그리디는 메모리 사용량이 적으므로 오답이다.', false),
       (1122, 418, '구현이 복잡하다', '그리디는 구현이 단순하므로 오답이다.', false),

       (1123, 419, '구현이 직관적이고 빠른 실행 시간을 가진다', '그리디 알고리즘은 구현이 직관적이고 실행 시간이 빠르므로 정답이다.', true),
       (1124, 419, '항상 최적해를 보장한다', '그리디는 항상 최적해를 보장하지 않으므로 오답이다.', false),
       (1125, 419, '메모리 사용량이 많다', '그리디는 메모리 효율적이므로 오답이다.', false),
       (1126, 419, '구현이 복잡하다', '그리디는 구현이 단순하므로 오답이다.', false),

       (1127, 420, '항상 최적해를 보장하지 않는다', '그리디 알고리즘은 두 속성을 만족하지 않으면 최적해를 보장하지 않으므로 정답이다.', true),
       (1128, 420, '실행 시간이 매우 느리다', '그리디는 실행 시간이 빠르므로 오답이다.', false),
       (1129, 420, '구현이 매우 복잡하다', '그리디는 구현이 단순하므로 오답이다.', false),
       (1130, 420, '메모리 사용량이 많다', '그리디는 메모리 효율적이므로 오답이다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (135, 414, '지역 최적, Local Optimum, 최선의 선택', '그리디 알고리즘은 각 단계에서 지역 최적(Local Optimum)을 선택하여 전역 최적을 기대한다.'),
       (136, 417, '최적 부분 구조, Optimal Substructure', '전체 문제의 최적해가 부분 문제의 최적해로 구성될 수 있는 경우를 최적 부분 구조라고 한다.');

-- Chapter: 알고리즘 (id: 2), Unit: 그리디 알고리즘 (id: 14), Lesson: 그리디 알고리즘 예시 문제집 (id: 69)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (421, 69, '다음 중 코인 거스름돈 문제에서 그리디 전략으로 올바른 것은?', '동전 종류가 500, 100, 50, 10원이고 1260원을 거슬러 준다.', 'OBJECTIVE'),
       (422, 69, '빈칸에 들어갈 개수를 작성하시오', '코인 거스름돈 문제에서 500, 100, 50, 10원으로 1260원을 거슬러 줄 때 필요한 최소 동전 개수는 ___개이다.', 'SUBJECTIVE'),
       (423, 69, '다음 중 코인 거스름돈 문제에서 그리디가 최적인 이유로 올바른 것은?', '코인이 500, 100, 50, 10원인 경우를 고려한다.', 'OBJECTIVE'),
       (424, 69, '다음 중 회의실 배정 문제의 그리디 전략으로 올바른 것은?', '여러 회의를 하나의 회의실에 배정해야 한다.', 'OBJECTIVE'),
       (425, 69, '빈칸에 들어갈 기준을 작성하시오', '회의실 배정 문제에서 모든 회의를 ___으로 정렬한 후 그리디 알고리즘을 적용한다.', 'SUBJECTIVE'),
       (426, 69, '다음 중 그리디 알고리즘 진행 단계를 순서대로 나열한 것은?', '그리디 알고리즘은 체계적인 단계로 진행된다.', 'OBJECTIVE'),
       (427, 69, '다음 중 그리디 알고리즘에서 선택 기준 정의에 대한 설명으로 올바른 것은?', '선택 기준은 그리디의 핵심 요소이다.', 'OBJECTIVE'),
       (428, 69, '다음 중 그리디 알고리즘의 정렬 또는 우선순위 구조 준비 단계의 목적은?', '그리디는 데이터를 사전에 정렬하거나 우선순위 구조를 준비한다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (1131, 421, '남은 금액을 넘지 않는 가장 큰 동전부터 최대한 많이 사용한다', '그리디 전략은 큰 동전부터 최대한 많이 사용하므로 정답이다.', true),
       (1132, 421, '가장 작은 동전부터 사용한다', '그리디는 큰 동전부터 사용하므로 오답이다.', false),
       (1133, 421, '모든 경우의 수를 탐색한다', '그리디는 모든 경우를 탐색하지 않으므로 오답이다.', false),
       (1134, 421, '무작위로 동전을 선택한다', '그리디는 체계적으로 큰 동전부터 선택하므로 오답이다.', false),

       (1135, 423, '큰 동전이 작은 동전의 배수 구조이므로 탐욕 선택 속성과 최적 부분 구조를 모두 만족한다', '500, 100, 50, 10은 배수 구조여서 큰 동전을 최대한 써도 문제없으므로 정답이다.', true),
       (1136, 423, '작은 동전부터 사용하기 때문이다', '그리디는 큰 동전부터 사용하므로 오답이다.', false),
       (1137, 423, '모든 경우를 탐색하기 때문이다', '그리디는 모든 경우를 탐색하지 않으므로 오답이다.', false),
       (1138, 423, '무작위로 선택하기 때문이다', '그리디는 체계적으로 선택하므로 오답이다.', false),

       (1139, 424, '시작 시간 오름차순으로 정렬하고 현재 회의보다 이전에 끝난 회의실을 찾아 배정한다', '회의실 배정 문제는 시작 시간으로 정렬 후 끝난 회의실을 찾아 배정하므로 정답이다.', true),
       (1140, 424, '종료 시간이 늦은 순서대로 배정한다', '종료 시간이 빠른 순서를 고려해야 하므로 오답이다.', false),
       (1141, 424, '회의 시간이 긴 순서대로 배정한다', '시작 시간 기준이 더 중요하므로 오답이다.', false),
       (1142, 424, '무작위로 배정한다', '그리디는 체계적으로 배정하므로 오답이다.', false),

       (1143, 426, '문제 구조 파악 → 선택 기준 정의 → 정렬 또는 우선순위 구조 준비 → 반복 선택 및 적절성 검사 → 해답 검사', '그리디 알고리즘은 문제 구조 파악, 선택 기준 정의, 정렬, 반복 선택, 해답 검사 순서로 진행되므로 정답이다.', true),
       (1144, 426, '해답 검사 → 선택 기준 정의 → 문제 구조 파악', '순서가 잘못되었으므로 오답이다.', false),
       (1145, 426, '정렬 → 문제 구조 파악 → 선택 기준 정의', '순서가 잘못되었으므로 오답이다.', false),
       (1146, 426, '반복 선택 → 문제 구조 파악 → 해답 검사', '순서가 잘못되었으므로 오답이다.', false),

       (1147, 427, '현재 상태에서 가장 좋은 선택의 기준을 정한다', '선택 기준 정의는 현재 상태에서 최선의 선택 기준을 정하는 것이므로 정답이다.', true),
       (1148, 427, '모든 경우의 수를 나열한다', '선택 기준 정의는 모든 경우를 나열하는 것이 아니므로 오답이다.', false),
       (1149, 427, '이전 결과를 저장한다', '선택 기준 정의는 이전 결과 저장과 관련 없으므로 오답이다.', false),
       (1150, 427, '문제를 분할한다', '선택 기준 정의는 문제 분할과 관련 없으므로 오답이다.', false),

       (1151, 428, '기준에 맞게 정렬하거나 우선순위 큐를 사용하여 선택을 용이하게 한다', '정렬 또는 우선순위 구조 준비는 선택을 용이하게 하기 위함이므로 정답이다.', true),
       (1152, 428, '모든 경우의 수를 저장한다', '정렬은 모든 경우를 저장하는 것이 아니므로 오답이다.', false),
       (1153, 428, '이전 결과를 재사용한다', '정렬은 이전 결과 재사용과 관련 없으므로 오답이다.', false),
       (1154, 428, '문제를 분할한다', '정렬은 문제 분할과 관련 없으므로 오답이다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (137, 422, '6', '500원 2개, 100원 2개, 50원 1개, 10원 1개로 총 6개의 동전이 필요하다.'),
       (138, 425, '시작 시간 오름차순, 시작 시간', '회의실 배정 문제에서 모든 회의를 시작 시간 오름차순으로 정렬한 후 그리디 알고리즘을 적용한다.');

-- Chapter: 알고리즘 (id: 2), Unit: 그리디 알고리즘 (id: 14), Lesson: 그리디 알고리즘 한계 문제집 (id: 70)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (429, 70, '다음 중 그리디 알고리즘이 최적해를 보장하지 못하는 경우는?', '특정 조건에서 그리디는 최적해를 보장하지 못한다.', 'OBJECTIVE'),
       (430, 70, '빈칸에 들어갈 개수를 작성하시오', '동전이 16, 5, 1원이고 20원을 만들 때 그리디로 구한 답은 5개이지만 실제 최적해는 ___개이다.', 'SUBJECTIVE'),
       (431, 70, '다음 중 동전이 16, 5, 1원일 때 20원을 만드는 그리디의 문제점은?', '이 경우 그리디는 최적해를 찾지 못한다.', 'OBJECTIVE'),
       (432, 70, '다음 중 그리디 알고리즘의 한계를 극복하는 방법은?', '그리디의 한계는 다른 방법으로 극복할 수 있다.', 'OBJECTIVE'),
       (433, 70, '빈칸에 들어갈 속성을 작성하시오', '그리디가 최적해를 보장하지 못하는 이유는 ___가 깨지기 때문이다.', 'SUBJECTIVE'),
       (434, 70, '다음 중 그리디가 적합한 문제의 특징은?', '그리디는 특정 조건을 만족하는 문제에 적합하다.', 'OBJECTIVE'),
       (435, 70, '다음 중 그리디가 적합하지 않은 문제는?', '일부 문제는 그리디로 해결할 수 없다.', 'OBJECTIVE'),
       (436, 70, '다음 중 그리디 알고리즘 사용 전 확인해야 할 사항은?', '그리디 사용 전 특정 조건을 확인해야 한다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (1155, 429, '탐욕 선택 속성이나 최적 부분 구조를 만족하지 않는 경우', '두 속성 중 하나라도 만족하지 않으면 그리디는 최적해를 보장하지 못하므로 정답이다.', true),
       (1156, 429, '문제가 너무 단순한 경우', '문제의 단순성은 그리디의 실패 원인이 아니므로 오답이다.', false),
       (1157, 429, '입력 크기가 작은 경우', '입력 크기는 그리디의 실패 원인이 아니므로 오답이다.', false),
       (1158, 429, '정렬이 필요한 경우', '정렬 필요 여부는 그리디의 실패 원인이 아니므로 오답이다.', false),

       (1159, 431, '16원을 먼저 선택하면 남은 4원을 1원으로만 채울 수 있어 전체 최적해의 일부라고 보장할 수 없다', '큰 동전을 먼저 선택하는 것이 전체 최적해로 이어지지 않으므로 정답이다.', true),
       (1160, 431, '동전의 개수가 부족하다', '동전은 무한히 있으므로 오답이다.', false),
       (1161, 431, '정렬이 잘못되었다', '정렬은 문제없으므로 오답이다.', false),
       (1162, 431, '계산이 복잡하다', '계산 복잡도는 문제가 아니므로 오답이다.', false),

       (1163, 432, '다이내믹 프로그래밍을 사용하여 모든 경우를 고려한다', '그리디의 한계는 다이내믹 프로그래밍으로 극복할 수 있으므로 정답이다.', true),
       (1164, 432, '더 큰 메모리를 사용한다', '메모리 증가는 한계 극복 방법이 아니므로 오답이다.', false),
       (1165, 432, '더 빠른 컴퓨터를 사용한다', '하드웨어 개선은 한계 극복 방법이 아니므로 오답이다.', false),
       (1166, 432, '정렬을 생략한다', '정렬 생략은 한계 극복 방법이 아니므로 오답이다.', false),

       (1167, 434, '탐욕 선택 속성과 최적 부분 구조를 만족하는 문제', '두 속성을 만족하면 그리디가 적합하므로 정답이다.', true),
       (1168, 434, '모든 경우를 고려해야 하는 문제', '모든 경우 고려는 그리디에 적합하지 않으므로 오답이다.', false),
       (1169, 434, '이전 결과에 의존하는 문제', '이전 결과 의존은 그리디에 적합하지 않을 수 있으므로 오답이다.', false),
       (1170, 434, '복잡한 계산이 필요한 문제', '복잡한 계산은 그리디의 특징이 아니므로 오답이다.', false),

       (1171, 435, '배낭 문제에서 물건을 쪼갤 수 없는 경우', '물건을 쪼갤 수 없는 0-1 배낭 문제는 그리디로 해결할 수 없으므로 정답이다.', true),
       (1172, 435, '동전이 배수 구조인 거스름돈 문제', '배수 구조 동전은 그리디로 해결 가능하므로 오답이다.', false),
       (1173, 435, '회의실 배정 문제', '회의실 배정은 그리디로 해결 가능하므로 오답이다.', false),
       (1174, 435, '물건을 쪼갤 수 있는 배낭 문제', '쪼갤 수 있으면 그리디로 해결 가능하므로 오답이다.', false),

       (1175, 436, '탐욕 선택 속성과 최적 부분 구조를 만족하는지 확인한다', '두 속성 만족 여부를 확인해야 하므로 정답이다.', true),
       (1176, 436, '입력 크기만 확인한다', '입력 크기만으로는 부족하므로 오답이다.', false),
       (1177, 436, '정렬 가능 여부만 확인한다', '정렬 가능 여부만으로는 부족하므로 오답이다.', false),
       (1178, 436, '메모리 용량만 확인한다', '메모리 용량만으로는 부족하므로 오답이다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (139, 430, '4', '5원 동전 4개를 사용하면 총 4개로 20원을 만들 수 있어 그리디의 5개보다 최적이다.'),
       (140, 433, '탐욕 선택 속성, Greedy Choice Property', '16원을 먼저 선택하는 것이 전체 최적해의 일부라고 보장할 수 없어 탐욕 선택 속성이 깨진다.');


-- Chapter: 알고리즘 (id: 2), Unit: 다이내믹 프로그래밍 (id: 15)

-- Lesson 생성
INSERT INTO lesson (id, unit_id, title)
VALUES (71, 15, '다이내믹 프로그래밍 기초 문제집'),
       (72, 15, '다이내믹 프로그래밍 예시 문제집'),
       (73, 15, '다이내믹 프로그래밍 접근법 문제집');

-- Chapter: 알고리즘 (id: 2), Unit: 다이내믹 프로그래밍 (id: 15), Lesson: 다이내믹 프로그래밍 기초 문제집 (id: 71)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (437, 71, '다음 중 다이내믹 프로그래밍에 대한 설명으로 올바른 것은?', '다이내믹 프로그래밍은 특정한 방식으로 문제를 해결한다.', 'OBJECTIVE'),
       (438, 71, '빈칸에 들어갈 용어를 작성하시오', '다이내믹 프로그래밍은 큰 문제를 작은 부분 문제로 쪼개고 각 부분 문제의 해를 ___에 저장해두었다가 재사용한다.', 'SUBJECTIVE'),
       (439, 71, '다음 중 다이내믹 프로그래밍의 핵심 개념으로 올바른 것은?', '다이내믹 프로그래밍은 두 가지 핵심 개념을 가진다.', 'OBJECTIVE'),
       (440, 71, '다음 중 최적 부분 구조에 대한 설명으로 올바른 것은?', '최적 부분 구조는 DP의 필수 조건이다.', 'OBJECTIVE'),
       (441, 71, '빈칸에 들어갈 용어를 작성하시오', '문제를 풀다 보면 같은 부분 문제를 여러 번 다시 풀어야 하는 구조를 ___라고 한다.', 'SUBJECTIVE'),
       (442, 71, '다음 중 다이내믹 프로그래밍의 특징으로 올바른 것은?', '다이내믹 프로그래밍은 여러 가지 특징을 가진다.', 'OBJECTIVE'),
       (443, 71, '다음 중 다이내믹 프로그래밍과 그리디의 차이로 올바른 것은?', '다이내믹 프로그래밍과 그리디는 접근 방식이 다르다.', 'OBJECTIVE'),
       (444, 71, '다음 중 다이내믹 프로그래밍의 장점으로 올바른 것은?', '다이내믹 프로그래밍은 장점을 가지고 있다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (1179, 437, '큰 문제를 작은 부분 문제로 쪼개고 각 부분 문제의 해를 저장해두었다가 재사용하면서 전체 문제의 최적해를 구하는 알고리즘 설계 기법이다', '다이내믹 프로그래밍은 부분 문제의 해를 저장하고 재사용하여 최적해를 구하므로 정답이다.', true),
       (1180, 437, '매 순간 최선의 선택을 하는 알고리즘이다', '이는 그리디 알고리즘의 설명이므로 오답이다.', false),
       (1181, 437, '모든 경우의 수를 탐색하는 알고리즘이다', '이는 브루트 포스의 설명이므로 오답이다.', false),
       (1182, 437, '분할 정복만 사용하는 알고리즘이다', 'DP는 분할 정복과 메모이제이션을 함께 사용하므로 오답이다.', false),

       (1183, 439, '중복 계산 제거와 최적해를 단계적으로 구성', '다이내믹 프로그래밍은 중복 계산을 제거하고 최적해를 단계적으로 구성하므로 정답이다.', true),
       (1184, 439, '백트래킹과 가지치기', '이는 백트래킹의 개념이므로 오답이다.', false),
       (1185, 439, '탐욕 선택과 지역 최적', '이는 그리디의 개념이므로 오답이다.', false),
       (1186, 439, '순환 구조와 재귀 호출', '이는 DP의 핵심 개념이 아니므로 오답이다.', false),

       (1187, 440, '큰 문제의 최적해가 작은 부분 문제들의 최적해로부터 구성될 수 있는 구조', '최적 부분 구조는 큰 문제의 최적해가 작은 문제의 최적해로 구성되는 것이므로 정답이다.', true),
       (1188, 440, '모든 경우를 탐색하는 것', '이는 최적 부분 구조의 설명이 아니므로 오답이다.', false),
       (1189, 440, '매 순간 최선을 선택하는 것', '이는 최적 부분 구조의 설명이 아니므로 오답이다.', false),
       (1190, 440, '백트래킹을 사용하는 것', '이는 최적 부분 구조의 설명이 아니므로 오답이다.', false),

       (1191, 442, 'dp 테이블에 결과를 저장하여 재사용하고 가능한 경우를 모두 고려하며 항상 최적해를 보장하지만 메모리와 시간이 더 소요된다', '다이내믹 프로그래밍은 결과를 저장하고 모든 경우를 고려하며 최적해를 보장하므로 정답이다.', true),
       (1192, 442, '매 순간 최선만 선택한다', '이는 그리디의 특징이므로 오답이다.', false),
       (1193, 442, '메모리 사용이 적다', 'DP는 메모리를 더 사용하므로 오답이다.', false),
       (1194, 442, '최적해를 보장하지 않는다', 'DP는 최적해를 보장하므로 오답이다.', false),

       (1195, 443, 'DP는 가능한 경우를 모두 고려하고 그리디는 지금 최선만 고르며 DP는 항상 최적해를 보장하지만 그리디는 보장하지 않는다', 'DP는 모든 경우를 고려하여 최적해를 보장하고 그리디는 지역 최적만 선택하므로 정답이다.', true),
       (1196, 443, 'DP와 그리디는 동일한 방식이다', 'DP와 그리디는 접근 방식이 다르므로 오답이다.', false),
       (1197, 443, 'DP는 최적해를 보장하지 않는다', 'DP는 최적해를 보장하므로 오답이다.', false),
       (1198, 443, '그리디가 DP보다 메모리를 더 많이 사용한다', 'DP가 더 많은 메모리를 사용하므로 오답이다.', false),

       (1199, 444, '항상 최적해를 보장한다', '다이내믹 프로그래밍은 조건을 만족하면 항상 최적해를 보장하므로 정답이다.', true),
       (1200, 444, '메모리 사용이 매우 적다', 'DP는 메모리를 더 사용하므로 오답이다.', false),
       (1201, 444, '구현이 항상 간단하다', 'DP는 구현이 복잡할 수 있으므로 오답이다.', false),
       (1202, 444, '실행 시간이 항상 빠르다', 'DP는 모든 경우를 고려하므로 항상 빠르지는 않아서 오답이다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (141, 438, 'dp 테이블, 배열, dp 배열', '다이내믹 프로그래밍은 각 부분 문제의 해를 dp 테이블(배열)에 저장해두었다가 재사용한다.'),
       (142, 441, '부분 문제의 중복, Overlapping Subproblems', '같은 부분 문제를 여러 번 다시 풀어야 하는 구조를 부분 문제의 중복이라고 한다.');

-- Chapter: 알고리즘 (id: 2), Unit: 다이내믹 프로그래밍 (id: 15), Lesson: 다이내믹 프로그래밍 예시 문제집 (id: 72)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (445, 72, '다음 중 피보나치 수열의 점화식으로 올바른 것은?', '피보나치 수열은 DP의 대표적인 예시이다.', 'OBJECTIVE'),
       (446, 72, '빈칸에 들어갈 값을 작성하시오', '피보나치 수열에서 fib(5) = fib(4) + fib(3) = 3 + 2 = ___이다.', 'SUBJECTIVE'),
       (447, 72, '다음 중 피보나치 수열에서 DP를 사용하는 이유는?', '피보나치는 DP 적용의 좋은 예시이다.', 'OBJECTIVE'),
       (448, 72, '다음 중 거스름돈 문제에서 DP의 점화식으로 올바른 것은?', 'C[j]는 j원을 거슬러 줄 때 사용되는 동전 개수의 최소값이다.', 'OBJECTIVE'),
       (449, 72, '빈칸에 들어갈 개수를 작성하시오', '동전이 16, 5, 1원이고 20원을 거슬러 줄 때 DP로 구한 최소 동전 개수는 ___개이다.', 'SUBJECTIVE'),
       (450, 72, '다음 중 거스름돈 문제에서 DP가 그리디보다 우수한 이유는?', '특정 경우에 DP가 그리디보다 정확하다.', 'OBJECTIVE'),
       (451, 72, '다음 중 DP 문제 해결 과정에서 가장 먼저 해야 할 단계는?', 'DP는 체계적인 접근이 필요하다.', 'OBJECTIVE'),
       (452, 72, '다음 중 점화식 세우기에 대한 설명으로 올바른 것은?', '점화식은 DP의 핵심이다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (1203, 445, 'fib(n) = fib(n-1) + fib(n-2), fib(0) = 0, fib(1) = 1', '피보나치의 점화식은 fib(n) = fib(n-1) + fib(n-2)이므로 정답이다.', true),
       (1204, 445, 'fib(n) = fib(n-1) × fib(n-2)', '피보나치는 곱셈이 아닌 덧셈이므로 오답이다.', false),
       (1205, 445, 'fib(n) = fib(n-1) - fib(n-2)', '피보나치는 뺄셈이 아닌 덧셈이므로 오답이다.', false),
       (1206, 445, 'fib(n) = 2 × fib(n-1)', '피보나치는 이전 두 항의 합이므로 오답이다.', false),

       (1207, 447, 'fib(3), fib(2) 등이 여러 번 반복 계산되므로 한 번 계산한 값을 저장하여 재사용하는 것이 효율적이다', '피보나치는 같은 부분 문제가 반복되므로 메모이제이션이 효율적이어서 정답이다.', true),
       (1208, 447, '매 순간 최선을 선택하기 위해서', '피보나치는 최선 선택 문제가 아니므로 오답이다.', false),
       (1209, 447, '백트래킹을 사용하기 위해서', '피보나치는 백트래킹 문제가 아니므로 오답이다.', false),
       (1210, 447, '정렬을 하기 위해서', '피보나치는 정렬 문제가 아니므로 오답이다.', false),

       (1211, 448, 'C[j] = min(C[j-1] + 1, C[j-5] + 1, C[j-16] + 1)', '마지막에 어떤 동전을 쓰느냐에 따라 경우가 나뉘므로 정답이다.', true),
       (1212, 448, 'C[j] = C[j-1] + C[j-5] + C[j-16]', '동전 개수는 합이 아닌 최솟값을 선택하므로 오답이다.', false),
       (1213, 448, 'C[j] = max(C[j-1], C[j-5], C[j-16])', '최솟값을 구하는 것이므로 오답이다.', false),
       (1214, 448, 'C[j] = C[j-1] × C[j-5]', '곱셈이 아닌 최솟값 선택이므로 오답이다.', false),

       (1215, 450, 'DP는 모든 경우를 고려하여 진짜 최적해를 찾지만 그리디는 지역 최적만 선택하여 실패할 수 있다', 'DP는 모든 경우를 고려하므로 그리디보다 정확하여 정답이다.', true),
       (1216, 450, '그리디가 DP보다 더 정확하다', 'DP가 더 정확하므로 오답이다.', false),
       (1217, 450, 'DP가 더 빠르다', 'DP가 항상 더 빠르지는 않으므로 오답이다.', false),
       (1218, 450, 'DP가 메모리를 덜 사용한다', 'DP가 메모리를 더 사용하므로 오답이다.', false),

       (1219, 451, '상태 정의', 'DP 문제 해결의 첫 단계는 dp[i]가 무엇인지 정의하는 상태 정의이므로 정답이다.', true),
       (1220, 451, '코드 작성', '코드 작성은 마지막 단계이므로 오답이다.', false),
       (1221, 451, '초기값 설정', '초기값 설정은 상태 정의 이후이므로 오답이다.', false),
       (1222, 451, '계산 순서 정하기', '계산 순서는 점화식 이후이므로 오답이다.', false),

       (1223, 452, '상태 전이 관계를 정의하는 것', '점화식은 상태 전이 관계를 정의하는 것이므로 정답이다.', true),
       (1224, 452, '초기값을 설정하는 것', '초기값 설정은 점화식과 별개이므로 오답이다.', false),
       (1225, 452, '코드를 작성하는 것', '코드 작성은 점화식 이후이므로 오답이다.', false),
       (1226, 452, '문제를 이해하는 것', '문제 이해는 점화식 이전 단계이므로 오답이다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (143, 446, '5', 'fib(5) = fib(4) + fib(3) = 3 + 2 = 5이다.'),
       (144, 449, '4', 'DP를 사용하면 5원 동전 4개로 20원을 만들 수 있어 최소 4개가 필요하다.');

-- Chapter: 알고리즘 (id: 2), Unit: 다이내믹 프로그래밍 (id: 15), Lesson: 다이내믹 프로그래밍 접근법 문제집 (id: 73)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (453, 73, '다음 중 Bottom-Up 방식에 대한 설명으로 올바른 것은?', 'Bottom-Up은 DP의 구현 방식 중 하나이다.', 'OBJECTIVE'),
       (454, 73, '빈칸에 들어갈 용어를 작성하시오', 'Top-Down 방식은 ___를 사용하여 dp[n]의 값을 찾기 위해 위에서부터 호출을 시작한다.', 'SUBJECTIVE'),
       (455, 73, '다음 중 Top-Down 방식의 특징으로 올바른 것은?', 'Top-Down은 재귀를 활용한다.', 'OBJECTIVE'),
       (456, 73, '다음 중 Bottom-Up과 Top-Down의 차이로 올바른 것은?', '두 방식은 계산 순서가 다르다.', 'OBJECTIVE'),
       (457, 73, '빈칸에 들어갈 용어를 작성하시오', 'Bottom-Up 방식은 ___라고도 하며 테이블에 저장된 값에 직접 접근하여 재활용한다.', 'SUBJECTIVE'),
       (458, 73, '다음 중 DP 문제 접근 단계를 순서대로 나열한 것은?', 'DP는 체계적인 접근이 필요하다.', 'OBJECTIVE'),
       (459, 73, '다음 중 초기값 설정에 대한 설명으로 올바른 것은?', '초기값은 DP의 시작점이다.', 'OBJECTIVE'),
       (460, 73, '다음 중 DP 사용이 적합한 문제의 특징은?', 'DP는 특정 조건을 만족하는 문제에 적합하다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (1227, 453, '아래에서부터 계산을 수행하고 누적시켜 전체 문제를 해결하며 dp[0]에서 시작해 점화식을 통해 dp[n]까지 값을 전이시킨다', 'Bottom-Up은 작은 문제부터 계산하여 큰 문제로 진행하므로 정답이다.', true),
       (1228, 453, '위에서부터 재귀 호출을 시작한다', '이는 Top-Down의 설명이므로 오답이다.', false),
       (1229, 453, '메모이제이션을 사용한다', '메모이제이션은 Top-Down의 특징이므로 오답이다.', false),
       (1230, 453, '재귀 함수를 사용한다', '재귀는 Top-Down의 특징이므로 오답이다.', false),

       (1231, 455, 'dp[n]의 값을 찾기 위해 위에서부터 호출을 시작하고 dp[0]까지 내려간 다음 결과값을 재귀를 통해 전이시켜 재활용하며 메모리에 저장된 내역을 꺼내서 사용한다', 'Top-Down은 재귀와 메모이제이션을 사용하므로 정답이다.', true),
       (1232, 455, '반복문만 사용한다', 'Top-Down은 재귀를 사용하므로 오답이다.', false),
       (1233, 455, '아래에서부터 계산한다', 'Top-Down은 위에서부터 시작하므로 오답이다.', false),
       (1234, 455, '테이블을 사용하지 않는다', 'Top-Down도 메모리에 저장하므로 오답이다.', false),

       (1235, 456, 'Bottom-Up은 아래에서부터 계산하고 Top-Down은 위에서부터 재귀 호출하며 Bottom-Up은 테이블에 직접 접근하고 Top-Down은 메모이제이션을 사용한다', '두 방식은 계산 순서와 구현 방법이 다르므로 정답이다.', true),
       (1236, 456, '두 방식은 완전히 동일하다', '두 방식은 계산 순서가 다르므로 오답이다.', false),
       (1237, 456, 'Bottom-Up이 항상 더 빠르다', '상황에 따라 다르므로 오답이다.', false),
       (1238, 456, 'Top-Down은 반복문만 사용한다', 'Top-Down은 재귀를 사용하므로 오답이다.', false),

       (1239, 458, '상태 정의 → 점화식 세우기 → 초기값 설정 → 계산 순서 정하기', 'DP는 상태 정의, 점화식, 초기값, 계산 순서 단계로 진행되므로 정답이다.', true),
       (1240, 458, '초기값 설정 → 상태 정의 → 계산 순서 정하기', '순서가 잘못되었으므로 오답이다.', false),
       (1241, 458, '계산 순서 정하기 → 상태 정의 → 점화식', '순서가 잘못되었으므로 오답이다.', false),
       (1242, 458, '점화식 → 초기값 → 상태 정의', '순서가 잘못되었으므로 오답이다.', false),

       (1243, 459, 'Base Case를 설정하는 것', '초기값 설정은 Base Case를 설정하는 것이므로 정답이다.', true),
       (1244, 459, '점화식을 세우는 것', '점화식은 초기값과 별개이므로 오답이다.', false),
       (1245, 459, '상태를 정의하는 것', '상태 정의는 초기값 이전 단계이므로 오답이다.', false),
       (1246, 459, '계산 순서를 정하는 것', '계산 순서는 초기값 이후이므로 오답이다.', false),

       (1247, 460, '최적 부분 구조와 부분 문제의 중복을 만족하는 문제', 'DP는 최적 부분 구조와 부분 문제의 중복을 만족하는 문제에 적합하므로 정답이다.', true),
       (1248, 460, '탐욕 선택 속성을 만족하는 문제', '탐욕 선택 속성은 그리디의 조건이므로 오답이다.', false),
       (1249, 460, '백트래킹이 필요한 문제', '백트래킹은 DP와 별개이므로 오답이다.', false),
       (1250, 460, '정렬만 필요한 문제', '정렬만으로 해결되는 문제는 DP가 불필요하므로 오답이다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (145, 454, '재귀, Recursion, 메모이제이션, Memoization', 'Top-Down 방식은 재귀(Memoization)를 사용하여 dp[n]의 값을 찾기 위해 위에서부터 호출을 시작한다.'),
       (146, 457, 'Tabulation, 타뷸레이션', 'Bottom-Up 방식은 Tabulation이라고도 하며 테이블에 저장된 값에 직접 접근하여 재활용한다.');

-- Chapter: 알고리즘 (id: 2), Unit: 최소 신장 트리 (id: 16)

-- Lesson 생성
INSERT INTO lesson (id, unit_id, title)
VALUES (74, 16, '최소 신장 트리 기초 문제집'),
       (75, 16, 'Prim 알고리즘 문제집'),
       (76, 16, 'Kruskal 알고리즘 문제집');

-- Chapter: 알고리즘 (id: 2), Unit: 최소 신장 트리 (id: 16), Lesson: 최소 신장 트리 기초 문제집 (id: 74)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (461, 74, '다음 중 신장 트리에 대한 설명으로 올바른 것은?', '신장 트리는 그래프의 특별한 형태이다.', 'OBJECTIVE'),
       (462, 74, '빈칸에 들어갈 수를 작성하시오', 'n개의 정점을 가지는 그래프의 신장 트리는 ___개의 간선으로 연결된다.', 'SUBJECTIVE'),
       (463, 74, '다음 중 최소 신장 트리에 대한 설명으로 올바른 것은?', '최소 신장 트리는 신장 트리 중 특별한 조건을 만족한다.', 'OBJECTIVE'),
       (464, 74, '다음 중 최소 신장 트리의 특징으로 올바른 것은?', '최소 신장 트리는 여러 특징을 가진다.', 'OBJECTIVE'),
       (465, 74, '빈칸에 들어갈 용어를 작성하시오', '최소 신장 트리는 간선 ___의 합이 최소인 트리이다.', 'SUBJECTIVE'),
       (466, 74, '다음 중 최소 신장 트리의 활용 사례로 올바른 것은?', '최소 신장 트리는 여러 분야에서 활용된다.', 'OBJECTIVE'),
       (467, 74, '다음 중 신장 트리가 트리 형태가 되는 이유는?', '신장 트리는 특정 조건을 만족한다.', 'OBJECTIVE'),
       (468, 74, '다음 중 최소 신장 트리를 구하는 알고리즘으로 올바른 것은?', '최소 신장 트리를 구하는 대표적인 알고리즘이 있다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (1251, 461, '그래프 내의 모든 정점을 포함하는 트리로 그래프의 최소 연결 부분 그래프이다', '신장 트리는 모든 정점을 포함하는 최소 연결 부분 그래프이므로 정답이다.', true),
       (1252, 461, '일부 정점만 포함하는 트리이다', '신장 트리는 모든 정점을 포함하므로 오답이다.', false),
       (1253, 461, '사이클을 포함하는 그래프이다', '신장 트리는 사이클을 포함하지 않으므로 오답이다.', false),
       (1254, 461, '방향 그래프에만 존재한다', '신장 트리는 무방향 그래프에서도 존재하므로 오답이다.', false),

       (1255, 463, '신장 트리 중에서 간선들의 가중치 합이 최소인 트리', '최소 신장 트리는 가중치 합이 최소인 신장 트리이므로 정답이다.', true),
       (1256, 463, '가장 많은 간선을 가진 트리', '최소 신장 트리는 간선 개수가 아닌 가중치 합이 최소인 트리이므로 오답이다.', false),
       (1257, 463, '가장 높이가 낮은 트리', '최소 신장 트리는 높이와 무관하므로 오답이다.', false),
       (1258, 463, '사이클을 가진 그래프', '최소 신장 트리는 사이클이 없으므로 오답이다.', false),

       (1259, 464, '간선 가중치의 합이 최소이고 n개의 정점에 대해 n-1개의 간선만 사용하며 사이클이 포함되지 않는다', '최소 신장 트리는 가중치 합 최소, n-1개 간선, 사이클 없음의 특징을 가지므로 정답이다.', true),
       (1260, 464, '사이클을 반드시 포함한다', '최소 신장 트리는 사이클이 없으므로 오답이다.', false),
       (1261, 464, 'n개 정점에 n개 간선을 사용한다', 'n개 정점에는 n-1개 간선이 필요하므로 오답이다.', false),
       (1262, 464, '가중치의 합이 최대이다', '최소 신장 트리는 가중치 합이 최소이므로 오답이다.', false),

       (1263, 466, '도로 건설 시 도시들을 연결하면서 도로 길이 최소화와 전기 회로에서 단자들을 연결하면서 전선 길이 최소화', '최소 신장 트리는 도로 건설, 전기 회로, 통신망, 배관 등에 활용되므로 정답이다.', true),
       (1264, 466, '정렬 알고리즘', '정렬은 최소 신장 트리의 활용 사례가 아니므로 오답이다.', false),
       (1265, 466, '이진 탐색', '이진 탐색은 최소 신장 트리의 활용 사례가 아니므로 오답이다.', false),
       (1266, 466, '해시 테이블', '해시 테이블은 최소 신장 트리의 활용 사례가 아니므로 오답이다.', false),

       (1267, 467, 'n개의 정점을 n-1개의 간선으로 연결하면 필연적으로 트리 형태가 되며 사이클을 포함하지 않기 때문이다', 'n개 정점을 n-1개 간선으로 연결하면 트리 형태가 되므로 정답이다.', true),
       (1268, 467, '사이클이 많아서', '신장 트리는 사이클이 없으므로 오답이다.', false),
       (1269, 467, 'n개 간선을 사용하기 때문에', 'n-1개 간선을 사용하므로 오답이다.', false),
       (1270, 467, '방향 그래프이기 때문에', '방향성은 트리 형태와 무관하므로 오답이다.', false),

       (1271, 468, 'Prim 알고리즘과 Kruskal 알고리즘', 'Prim과 Kruskal이 대표적인 최소 신장 트리 알고리즘이므로 정답이다.', true),
       (1272, 468, 'Dijkstra 알고리즘', 'Dijkstra는 최단 경로 알고리즘이므로 오답이다.', false),
       (1273, 468, 'DFS와 BFS', 'DFS와 BFS는 탐색 알고리즘이므로 오답이다.', false),
       (1274, 468, '퀵 정렬', '퀵 정렬은 정렬 알고리즘이므로 오답이다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (147, 462, 'n-1', 'n개의 정점을 가지는 그래프의 신장 트리는 n-1개의 간선으로 연결된다.'),
       (148, 465, '가중치', '최소 신장 트리는 간선 가중치의 합이 최소인 트리이다.');

-- Chapter: 알고리즘 (id: 2), Unit: 최소 신장 트리 (id: 16), Lesson: Prim 알고리즘 문제집 (id: 75)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (469, 75, '다음 중 Prim 알고리즘에 대한 설명으로 올바른 것은?', 'Prim 알고리즘은 최소 신장 트리를 구하는 방법이다.', 'OBJECTIVE'),
       (470, 75, '빈칸에 들어갈 용어를 작성하시오', 'Prim 알고리즘은 ___을 기준으로 신장 트리를 확장하는 알고리즘이다.', 'SUBJECTIVE'),
       (471, 75, '다음 중 Prim 알고리즘의 동작 과정으로 올바른 것은?', 'Prim 알고리즘은 단계적으로 확장한다.', 'OBJECTIVE'),
       (472, 75, '다음 중 Prim 알고리즘의 특징으로 올바른 것은?', 'Prim 알고리즘은 특정 방식으로 동작한다.', 'OBJECTIVE'),
       (473, 75, '빈칸에 들어갈 시간 복잡도를 작성하시오', 'Prim 알고리즘의 시간 복잡도는 ___이다. (우선순위 큐 사용 시)', 'SUBJECTIVE'),
       (474, 75, '다음 중 Prim 알고리즘에서 매 단계마다 선택하는 것은?', 'Prim은 특정 기준으로 선택한다.', 'OBJECTIVE'),
       (475, 75, '다음 중 Prim 알고리즘이 정점 선택 기반인 이유는?', 'Prim은 정점을 중심으로 확장한다.', 'OBJECTIVE'),
       (476, 75, '다음 중 Prim 알고리즘의 종료 조건은?', 'Prim은 특정 조건에서 종료한다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (1275, 469, '시작 정점에서 출발하여 신장 트리 집합을 단계적으로 확장하는 정점 선택 기반 알고리즘', 'Prim은 시작 정점에서 출발하여 단계적으로 확장하므로 정답이다.', true),
       (1276, 469, '모든 간선을 정렬하여 선택하는 알고리즘', '이는 Kruskal의 설명이므로 오답이다.', false),
       (1277, 469, '최단 경로를 찾는 알고리즘', 'Prim은 최소 신장 트리를 구하므로 오답이다.', false),
       (1278, 469, '사이클을 포함하는 알고리즘', 'Prim은 사이클을 포함하지 않으므로 오답이다.', false),

       (1279, 471, '시작 정점만 MST 집합에 포함하고 MST 집합에 인접한 정점들 중 최소 간선으로 연결된 정점 선택하며 n-1개의 간선을 가질 때까지 반복한다', 'Prim의 동작 과정은 시작 정점에서 인접 정점 중 최소 간선으로 연결된 정점을 선택하므로 정답이다.', true),
       (1280, 471, '모든 간선을 정렬한다', '간선 정렬은 Kruskal이므로 오답이다.', false),
       (1281, 471, 'Union-Find를 사용한다', 'Union-Find는 Kruskal에서 사용하므로 오답이다.', false),
       (1282, 471, '사이클을 만든다', 'Prim은 사이클을 만들지 않으므로 오답이다.', false),

       (1283, 472, '이전 단계에서 만들어진 신장 트리를 확장하는 방식이며 매 단계마다 가장 낮은 가중치의 간선을 선택한다', 'Prim은 이전 트리를 확장하며 최소 가중치 간선을 선택하므로 정답이다.', true),
       (1284, 472, '간선을 독립적으로 선택한다', '간선 독립 선택은 Kruskal이므로 오답이다.', false),
       (1285, 472, '정렬을 먼저 수행한다', '정렬은 Kruskal의 특징이므로 오답이다.', false),
       (1286, 472, 'Union-Find가 필수이다', 'Union-Find는 Kruskal에서 사용하므로 오답이다.', false),

       (1287, 474, 'MST 집합에 인접한 정점들 중 최소 간선으로 연결된 정점', 'Prim은 인접 정점 중 최소 간선으로 연결된 정점을 선택하므로 정답이다.', true),
       (1288, 474, '가중치가 가장 큰 간선', '최소 가중치를 선택하므로 오답이다.', false),
       (1289, 474, '무작위 정점', '최소 간선으로 연결된 정점을 선택하므로 오답이다.', false),
       (1290, 474, '사이클을 만드는 정점', '사이클을 만들지 않으므로 오답이다.', false),

       (1291, 475, 'MST 집합에 속한 정점들과 인접한 정점 중에서 선택하기 때문이다', 'Prim은 MST 집합의 정점과 인접한 정점을 선택하므로 정답이다.', true),
       (1292, 475, '간선만 고려하기 때문이다', 'Prim은 정점을 중심으로 확장하므로 오답이다.', false),
       (1293, 475, '사이클을 만들기 위해서', 'Prim은 사이클을 만들지 않으므로 오답이다.', false),
       (1294, 475, '정렬이 필요하기 때문이다', '정렬은 필수가 아니므로 오답이다.', false),

       (1295, 476, 'n-1개의 간선을 선택했을 때', 'Prim은 n-1개의 간선을 선택하면 종료하므로 정답이다.', true),
       (1296, 476, '모든 간선을 확인했을 때', '모든 간선 확인이 아닌 n-1개 간선 선택이 조건이므로 오답이다.', false),
       (1297, 476, '사이클이 생겼을 때', '사이클이 생기면 선택하지 않으므로 오답이다.', false),
       (1298, 476, '정렬이 끝났을 때', '정렬과 무관하므로 오답이다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (149, 470, '정점, vertex', 'Prim 알고리즘은 정점을 기준으로 신장 트리를 확장하는 알고리즘이다.'),
       (150, 473, 'O(E log V)', 'Prim 알고리즘의 시간 복잡도는 우선순위 큐 사용 시 O(E log V)이다.');

-- Chapter: 알고리즘 (id: 2), Unit: 최소 신장 트리 (id: 16), Lesson: Kruskal 알고리즘 문제집 (id: 76)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (477, 76, '다음 중 Kruskal 알고리즘에 대한 설명으로 올바른 것은?', 'Kruskal 알고리즘은 최소 신장 트리를 구하는 방법이다.', 'OBJECTIVE'),
       (478, 76, '빈칸에 들어갈 용어를 작성하시오', 'Kruskal 알고리즘은 ___을 기준으로 간선을 선택하는 알고리즘이다.', 'SUBJECTIVE'),
       (479, 76, '다음 중 Kruskal 알고리즘의 동작 과정으로 올바른 것은?', 'Kruskal 알고리즘은 특정 순서로 동작한다.', 'OBJECTIVE'),
       (480, 76, '다음 중 Union-Find 연산에 대한 설명으로 올바른 것은?', 'Union-Find는 Kruskal에서 중요한 역할을 한다.', 'OBJECTIVE'),
       (481, 76, '빈칸에 들어갈 시간 복잡도를 작성하시오', 'Kruskal 알고리즘의 시간 복잡도는 ___이다. (Union-Find 사용 시)', 'SUBJECTIVE'),
       (482, 76, '다음 중 Kruskal 알고리즘의 특징으로 올바른 것은?', 'Kruskal은 특정 방식으로 동작한다.', 'OBJECTIVE'),
       (483, 76, '다음 중 Prim과 Kruskal의 차이로 올바른 것은?', '두 알고리즘은 접근 방식이 다르다.', 'OBJECTIVE'),
       (484, 76, '다음 중 Union-Find의 Find 연산에 대한 설명으로 올바른 것은?', 'Find 연산은 집합을 찾는다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (1299, 477, '탐욕적 방법을 이용하여 모든 정점을 최소 비용으로 연결하는 간선 선택 기반 알고리즘', 'Kruskal은 탐욕적 방법으로 간선을 선택하므로 정답이다.', true),
       (1300, 477, '정점을 선택하는 알고리즘', '정점 선택은 Prim이므로 오답이다.', false),
       (1301, 477, '최단 경로를 찾는 알고리즘', 'Kruskal은 최소 신장 트리를 구하므로 오답이다.', false),
       (1302, 477, '우선순위 큐가 필수인 알고리즘', '우선순위 큐는 Prim에서 주로 사용하므로 오답이다.', false),

       (1303, 479, '간선들을 가중치 오름차순으로 정렬하고 정렬된 순서대로 사이클을 형성하지 않는 간선 선택하며 n-1개의 간선을 선택할 때까지 반복한다', 'Kruskal의 동작 과정은 간선 정렬 후 사이클 없는 간선을 선택하므로 정답이다.', true),
       (1304, 479, '정점부터 선택한다', '정점 선택은 Prim이므로 오답이다.', false),
       (1305, 479, '사이클을 만든다', 'Kruskal은 사이클을 만들지 않으므로 오답이다.', false),
       (1306, 479, '정렬하지 않는다', 'Kruskal은 간선을 정렬하므로 오답이다.', false),

       (1307, 480, '간선 추가 시 사이클 형성 여부를 판단하기 위한 연산으로 두 정점이 같은 집합에 속하는지 검사한다', 'Union-Find는 사이클 형성 여부를 판단하므로 정답이다.', true),
       (1308, 480, '정점을 선택하는 연산', 'Union-Find는 집합 연산이므로 오답이다.', false),
       (1309, 480, '간선을 정렬하는 연산', 'Union-Find는 정렬과 무관하므로 오답이다.', false),
       (1310, 480, '최단 경로를 찾는 연산', 'Union-Find는 경로 탐색이 아니므로 오답이다.', false),

       (1311, 482, '이전 신장 트리와 무관하게 최소 간선만 선택하고 Union-Find 연산으로 사이클 여부를 판단하며 최적 해답이 보장된다', 'Kruskal은 간선을 독립적으로 선택하며 Union-Find로 사이클을 판단하므로 정답이다.', true),
       (1312, 482, '정점을 중심으로 확장한다', '정점 확장은 Prim이므로 오답이다.', false),
       (1313, 482, '우선순위 큐가 필수이다', '우선순위 큐는 필수가 아니므로 오답이다.', false),
       (1314, 482, '최적 해답이 보장되지 않는다', 'Kruskal은 최적 해답을 보장하므로 오답이다.', false),

       (1315, 483, 'Prim은 정점 선택 기반이고 Kruskal은 간선 선택 기반이며 Prim은 이전 트리를 확장하고 Kruskal은 간선을 독립 선택한다', 'Prim은 정점, Kruskal은 간선 기반이므로 정답이다.', true),
       (1316, 483, '두 알고리즘은 동일하다', '두 알고리즘은 접근 방식이 다르므로 오답이다.', false),
       (1317, 483, 'Prim이 항상 더 빠르다', '상황에 따라 다르므로 오답이다.', false),
       (1318, 483, 'Kruskal은 정점을 선택한다', 'Kruskal은 간선을 선택하므로 오답이다.', false),

       (1319, 484, '원소가 속한 집합의 대표 원소를 찾는 연산', 'Find는 대표 원소를 찾는 연산이므로 정답이다.', true),
       (1320, 484, '두 집합을 합치는 연산', '이는 Union의 설명이므로 오답이다.', false),
       (1321, 484, '간선을 정렬하는 연산', 'Find는 정렬과 무관하므로 오답이다.', false),
       (1322, 484, '사이클을 만드는 연산', 'Find는 사이클 생성과 무관하므로 오답이다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (151, 478, '간선, edge', 'Kruskal 알고리즘은 간선을 기준으로 간선을 선택하는 알고리즘이다.'),
       (152, 481, 'O(E log E)', 'Kruskal 알고리즘의 시간 복잡도는 Union-Find 사용 시 간선 정렬에 의해 O(E log E)이다.');

-- Chapter: 알고리즘 (id: 2), Unit: 최단 경로 알고리즘 (id: 17)

-- Lesson 생성
INSERT INTO lesson (id, unit_id, title)
VALUES (77, 17, '최단 경로 알고리즘 기초 문제집'),
       (78, 17, '다익스트라 알고리즘 문제집'),
       (79, 17, '벨만-포드와 플로이드-워셜 문제집');

-- Chapter: 알고리즘 (id: 2), Unit: 최단 경로 알고리즘 (id: 17), Lesson: 최단 경로 알고리즘 기초 문제집 (id: 77)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (485, 77, '다음 중 최단 경로 알고리즘에 대한 설명으로 올바른 것은?', '최단 경로 알고리즘은 그래프에서 경로를 찾는다.', 'OBJECTIVE'),
       (486, 77, '빈칸에 들어갈 용어를 작성하시오', '최단 경로 알고리즘은 그래프에서 두 정점 사이의 ___를 찾는 알고리즘이다.', 'SUBJECTIVE'),
       (487, 77, '다음 중 최단 경로 알고리즘이 고려하는 조건으로 올바른 것은?', '최단 경로 알고리즘은 여러 조건을 고려한다.', 'OBJECTIVE'),
       (488, 77, '다음 중 최단 경로 알고리즘의 종류로 올바른 것은?', '여러 최단 경로 알고리즘이 존재한다.', 'OBJECTIVE'),
       (489, 77, '다음 중 단일 시작점 최단 경로에 대한 설명으로 올바른 것은?', '단일 시작점은 특정 방식으로 동작한다.', 'OBJECTIVE'),
       (490, 77, '빈칸에 들어갈 용어를 작성하시오', '모든 쌍의 최단 경로를 구하는 알고리즘은 ___이다.', 'SUBJECTIVE'),
       (491, 77, '다음 중 최단 경로 알고리즘 선택 시 고려사항으로 올바른 것은?', '알고리즘 선택 시 여러 요소를 고려한다.', 'OBJECTIVE'),
       (492, 77, '다음 중 가중치 조건에 따른 알고리즘 선택으로 올바른 것은?', '가중치 조건이 알고리즘 선택에 영향을 준다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (1323, 485, '그래프에서 두 정점 사이의 최소 비용 경로를 찾는 알고리즘', '최단 경로 알고리즘은 최소 비용 경로를 찾으므로 정답이다.', true),
       (1324, 485, '최소 신장 트리를 찾는 알고리즘', '이는 최소 신장 트리 알고리즘이므로 오답이다.', false),
       (1325, 485, '정렬하는 알고리즘', '이는 정렬 알고리즘이므로 오답이다.', false),
       (1326, 485, '탐색하는 알고리즘', '이는 탐색 알고리즘이므로 오답이다.', false),

       (1327, 487, '가중치 조건과 탐색 범위', '최단 경로 알고리즘은 가중치 조건과 탐색 범위를 고려하므로 정답이다.', true),
       (1328, 487, '정렬 여부', '정렬 여부는 주요 고려사항이 아니므로 오답이다.', false),
       (1329, 487, '사이클 유무만', '가중치와 탐색 범위도 고려하므로 오답이다.', false),
       (1330, 487, '노드 개수만', '가중치 조건도 중요하므로 오답이다.', false),

       (1331, 488, '다익스트라, 벨만-포드, 플로이드-워셜', '다익스트라, 벨만-포드, 플로이드-워셜이 대표적인 최단 경로 알고리즘이므로 정답이다.', true),
       (1332, 488, 'Prim, Kruskal', '이들은 최소 신장 트리 알고리즘이므로 오답이다.', false),
       (1333, 488, '퀵 정렬, 병합 정렬', '이들은 정렬 알고리즘이므로 오답이다.', false),
       (1334, 488, 'DFS, BFS', '이들은 탐색 알고리즘이므로 오답이다.', false),

       (1335, 489, '시작 정점에서 다른 모든 정점으로의 최단 경로를 찾는다', '단일 시작점은 한 정점에서 모든 정점으로의 경로를 찾으므로 정답이다.', true),
       (1336, 489, '모든 쌍의 최단 경로를 찾는다', '이는 모든 쌍 최단 경로의 설명이므로 오답이다.', false),
       (1337, 489, '두 정점 사이만 찾는다', '다른 모든 정점으로의 경로를 찾으므로 오답이다.', false),
       (1338, 489, '최소 신장 트리를 찾는다', '이는 최단 경로가 아니므로 오답이다.', false),

       (1339, 491, '가중치 조건, 탐색 범위, 시간 복잡도', '알고리즘 선택 시 가중치 조건, 탐색 범위, 시간 복잡도를 고려하므로 정답이다.', true),
       (1340, 491, '정렬 여부만', '가중치 조건과 탐색 범위도 고려하므로 오답이다.', false),
       (1341, 491, '노드 개수만', '가중치 조건과 시간 복잡도도 고려하므로 오답이다.', false),
       (1342, 491, '메모리만', '시간 복잡도와 가중치 조건이 더 중요하므로 오답이다.', false),

       (1343, 492, '양수 가중치만 있으면 다익스트라를 사용하고 음수 가중치가 있으면 벨만-포드를 사용한다', '가중치 조건에 따라 다익스트라 또는 벨만-포드를 선택하므로 정답이다.', true),
       (1344, 492, '항상 다익스트라만 사용한다', '음수 가중치가 있으면 벨만-포드를 사용하므로 오답이다.', false),
       (1345, 492, '가중치와 무관하다', '가중치 조건이 알고리즘 선택에 영향을 주므로 오답이다.', false),
       (1346, 492, '음수만 있으면 다익스트라를 사용한다', '음수 가중치가 있으면 다익스트라는 사용 불가하므로 오답이다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (153, 486, '최소 비용 경로', '최단 경로 알고리즘은 그래프에서 두 정점 사이의 최소 비용 경로를 찾는 알고리즘이다.'),
       (154, 490, '플로이드-워셜, Floyd-Warshall', '모든 쌍의 최단 경로를 구하는 알고리즘은 플로이드-워셜이다.');

-- Chapter: 알고리즘 (id: 2), Unit: 최단 경로 알고리즘 (id: 17), Lesson: 다익스트라 알고리즘 문제집 (id: 78)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (493, 78, '다음 중 다익스트라 알고리즘에 대한 설명으로 올바른 것은?', '다익스트라 알고리즘은 최단 경로를 찾는다.', 'OBJECTIVE'),
       (494, 78, '빈칸에 들어갈 조건을 작성하시오', '다익스트라 알고리즘은 ___만 있는 그래프에서 사용 가능하다.', 'SUBJECTIVE'),
       (495, 78, '다음 중 다익스트라 알고리즘의 동작 과정으로 올바른 것은?', '다익스트라는 특정 순서로 동작한다.', 'OBJECTIVE'),
       (496, 78, '다음 중 다익스트라 알고리즘의 시간 복잡도로 올바른 것은?', '다익스트라의 시간 복잡도는 구현 방법에 따라 다르다.', 'OBJECTIVE'),
       (497, 78, '빈칸에 들어갈 용어를 작성하시오', '다익스트라 알고리즘은 ___방식으로 가장 가까운 정점부터 차례로 최단 거리를 결정한다.', 'SUBJECTIVE'),
       (498, 78, '다음 중 다익스트라 알고리즘의 활용 사례로 올바른 것은?', '다익스트라는 여러 분야에서 활용된다.', 'OBJECTIVE'),
       (499, 78, '다음 중 다익스트라 알고리즘이 음수 가중치에서 실패하는 이유는?', '다익스트라는 음수 가중치를 처리할 수 없다.', 'OBJECTIVE'),
       (500, 78, '다음 중 다익스트라 알고리즘의 특징으로 올바른 것은?', '다익스트라는 여러 특징을 가진다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (1347, 493, '시작 정점에서 다른 모든 정점으로의 최단 경로를 찾는 알고리즘으로 탐욕적 방식으로 가장 가까운 정점부터 차례로 최단 거리를 결정한다', '다익스트라는 탐욕적 방식으로 최단 경로를 찾으므로 정답이다.', true),
       (1348, 493, '모든 쌍의 최단 경로를 찾는다', '이는 플로이드-워셜의 설명이므로 오답이다.', false),
       (1349, 493, '음수 가중치를 처리할 수 있다', '다익스트라는 음수 가중치를 처리할 수 없으므로 오답이다.', false),
       (1350, 493, '최소 신장 트리를 찾는다', '이는 MST 알고리즘이므로 오답이다.', false),

       (1351, 495, '시작 정점의 거리를 0으로 나머지는 무한대로 초기화하고 방문하지 않은 정점 중 최단 거리가 가장 짧은 정점 선택하며 선택한 정점과 인접한 정점들의 거리를 갱신하고 모든 정점을 방문할 때까지 반복한다', '다익스트라의 동작 과정은 최단 거리 정점을 선택하고 인접 정점 거리를 갱신하므로 정답이다.', true),
       (1352, 495, '모든 간선을 정렬한다', '간선 정렬은 다익스트라의 과정이 아니므로 오답이다.', false),
       (1353, 495, '사이클을 만든다', '다익스트라는 사이클을 만들지 않으므로 오답이다.', false),
       (1354, 495, '음수 가중치를 확인한다', '다익스트라는 양수 가중치만 사용하므로 오답이다.', false),

       (1355, 496, '인접 리스트 + 우선순위 큐는 O((V + E) log V)이고 인접 행렬은 O(V²)이다', '다익스트라의 시간 복잡도는 구현 방법에 따라 O((V + E) log V) 또는 O(V²)이므로 정답이다.', true),
       (1356, 496, '항상 O(V + E)이다', '시간 복잡도는 구현 방법에 따라 다르므로 오답이다.', false),
       (1357, 496, '항상 O(V³)이다', '이는 플로이드-워셜의 시간 복잡도이므로 오답이다.', false),
       (1358, 496, '항상 O(V × E)이다', '이는 벨만-포드의 시간 복잡도이므로 오답이다.', false),

       (1359, 498, '네비게이션 시스템, 지도에서의 최단 경로 계산, 네트워크 경로 최적화', '다익스트라는 네비게이션, 지도, 네트워크 경로 최적화에 활용되므로 정답이다.', true),
       (1360, 498, '최소 신장 트리 구성', '이는 Prim이나 Kruskal의 활용이므로 오답이다.', false),
       (1361, 498, '정렬', '이는 정렬 알고리즘의 활용이므로 오답이다.', false),
       (1362, 498, '음수 사이클 탐지', '이는 벨만-포드의 활용이므로 오답이다.', false),

       (1363, 499, '한 번 방문한 정점의 최단 거리는 확정되는데 음수 가중치가 있으면 나중에 더 짧은 경로가 발견될 수 있기 때문이다', '다익스트라는 확정된 거리를 다시 갱신할 수 없어 음수 가중치에서 실패하므로 정답이다.', true),
       (1364, 499, '음수 가중치를 처리할 수 있다', '다익스트라는 음수 가중치를 처리할 수 없으므로 오답이다.', false),
       (1365, 499, '시간 복잡도가 너무 높아서', '시간 복잡도가 아닌 알고리즘 특성 때문이므로 오답이다.', false),
       (1366, 499, '메모리를 너무 많이 사용해서', '메모리 문제가 아니므로 오답이다.', false),

       (1367, 500, '단일 시작점 최단 경로를 구하고 탐욕적 방식을 사용하며 양수 가중치만 처리 가능하다', '다익스트라는 단일 시작점, 탐욕적 방식, 양수 가중치 처리의 특징을 가지므로 정답이다.', true),
       (1368, 500, '음수 가중치를 처리한다', '다익스트라는 양수 가중치만 처리하므로 오답이다.', false),
       (1369, 500, '모든 쌍의 최단 경로를 구한다', '다익스트라는 단일 시작점 최단 경로를 구하므로 오답이다.', false),
       (1370, 500, '동적 계획법을 사용한다', '다익스트라는 탐욕적 방식을 사용하므로 오답이다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (155, 494, '양수 가중치', '다익스트라 알고리즘은 양수 가중치만 있는 그래프에서 사용 가능하다.'),
       (156, 497, '탐욕적, greedy', '다익스트라 알고리즘은 탐욕적 방식으로 가장 가까운 정점부터 차례로 최단 거리를 결정한다.');

-- Chapter: 알고리즘 (id: 2), Unit: 최단 경로 알고리즘 (id: 17), Lesson: 벨만-포드와 플로이드-워셜 문제집 (id: 79)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (501, 79, '다음 중 벨만-포드 알고리즘에 대한 설명으로 올바른 것은?', '벨만-포드는 특정 조건을 처리할 수 있다.', 'OBJECTIVE'),
       (502, 79, '빈칸에 들어갈 시간 복잡도를 작성하시오', '벨만-포드 알고리즘의 시간 복잡도는 ___이다.', 'SUBJECTIVE'),
       (503, 79, '다음 중 벨만-포드 알고리즘의 동작 과정으로 올바른 것은?', '벨만-포드는 특정 순서로 동작한다.', 'OBJECTIVE'),
       (504, 79, '다음 중 벨만-포드가 음수 사이클을 탐지하는 방법은?', '벨만-포드는 음수 사이클을 탐지할 수 있다.', 'OBJECTIVE'),
       (505, 79, '빈칸에 들어갈 횟수를 작성하시오', '벨만-포드는 모든 간선을 확인하여 거리를 갱신하는 과정을 ___번 반복한다. (V는 정점 개수)', 'SUBJECTIVE'),
       (506, 79, '다음 중 플로이드-워셜 알고리즘에 대한 설명으로 올바른 것은?', '플로이드-워셜은 특정 범위의 최단 경로를 구한다.', 'OBJECTIVE'),
       (507, 79, '다음 중 플로이드-워셜 알고리즘의 시간 복잡도로 올바른 것은?', '플로이드-워셜의 시간 복잡도는 고정되어 있다.', 'OBJECTIVE'),
       (508, 79, '다음 중 세 알고리즘의 비교로 올바른 것은?', '다익스트라, 벨만-포드, 플로이드-워셜은 각각 특징이 다르다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (1371, 501, '시작 정점에서 다른 모든 정점으로의 최단 경로를 찾고 음수 가중치 처리가 가능하며 음수 사이클을 감지한다', '벨만-포드는 음수 가중치와 음수 사이클을 처리할 수 있으므로 정답이다.', true),
       (1372, 501, '양수 가중치만 처리한다', '벨만-포드는 음수 가중치도 처리하므로 오답이다.', false),
       (1373, 501, '모든 쌍의 최단 경로를 구한다', '벨만-포드는 단일 시작점 최단 경로를 구하므로 오답이다.', false),
       (1374, 501, '음수 사이클을 탐지할 수 없다', '벨만-포드는 음수 사이클을 탐지할 수 있으므로 오답이다.', false),

       (1375, 503, '시작 정점의 거리를 0으로 나머지는 무한대로 초기화하고 모든 간선을 확인하여 더 짧은 경로 발견 시 거리 갱신하며 이 과정을 V-1번 반복하고 V번째 갱신이 발생하면 음수 사이클 존재로 판단한다', '벨만-포드의 동작 과정은 V-1번 반복 후 V번째 갱신 확인으로 음수 사이클을 탐지하므로 정답이다.', true),
       (1376, 503, '우선순위 큐를 사용한다', '우선순위 큐는 다익스트라에서 사용하므로 오답이다.', false),
       (1377, 503, '한 번만 반복한다', '벨만-포드는 V-1번 반복하므로 오답이다.', false),
       (1378, 503, '동적 계획법을 사용한다', '벨만-포드는 동적 계획법을 사용하지 않으므로 오답이다.', false),

       (1379, 504, 'V-1번 반복 후 V번째 갱신이 발생하면 음수 사이클이 존재한다고 판단한다', '벨만-포드는 V번째 갱신 발생 시 음수 사이클로 판단하므로 정답이다.', true),
       (1380, 504, '처음부터 음수 가중치를 확인한다', '음수 사이클은 V번째 갱신으로 확인하므로 오답이다.', false),
       (1381, 504, '음수 사이클을 탐지할 수 없다', '벨만-포드는 음수 사이클을 탐지할 수 있으므로 오답이다.', false),
       (1382, 504, 'DFS로 사이클을 찾는다', '벨만-포드는 DFS가 아닌 간선 갱신으로 확인하므로 오답이다.', false),

       (1383, 506, '모든 정점 쌍 간의 최단 경로를 찾고 동적 계획법을 사용하며 양수 및 음수 가중치 모두 처리 가능하다', '플로이드-워셜은 모든 쌍의 최단 경로를 동적 계획법으로 구하므로 정답이다.', true),
       (1384, 506, '단일 시작점 최단 경로만 구한다', '플로이드-워셜은 모든 쌍의 최단 경로를 구하므로 오답이다.', false),
       (1385, 506, '양수 가중치만 처리한다', '플로이드-워셜은 음수 가중치도 처리하므로 오답이다.', false),
       (1386, 506, '탐욕적 방식을 사용한다', '플로이드-워셜은 동적 계획법을 사용하므로 오답이다.', false),

       (1387, 507, 'O(V³)', '플로이드-워셜의 시간 복잡도는 O(V³)이므로 정답이다.', true),
       (1388, 507, 'O(V + E)', '이는 BFS나 DFS의 시간 복잡도이므로 오답이다.', false),
       (1389, 507, 'O(V × E)', '이는 벨만-포드의 시간 복잡도이므로 오답이다.', false),
       (1390, 507, 'O((V + E) log V)', '이는 다익스트라의 시간 복잡도이므로 오답이다.', false),

       (1391, 508, '다익스트라는 양수만 처리하고 단일 시작점이며 O((V + E) log V)이고 벨만-포드는 음수 처리 가능하고 단일 시작점이며 O(V × E)이고 플로이드-워셜은 모든 쌍이며 O(V³)이다', '세 알고리즘의 적용 범위, 가중치 조건, 시간 복잡도가 모두 다르므로 정답이다.', true),
       (1392, 508, '세 알고리즘이 동일하다', '세 알고리즘은 특징이 다르므로 오답이다.', false),
       (1393, 508, '다익스트라가 항상 가장 빠르다', '상황에 따라 다르므로 오답이다.', false),
       (1394, 508, '플로이드-워셜이 단일 시작점이다', '플로이드-워셜은 모든 쌍을 구하므로 오답이다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (157, 502, 'O(V × E), O(VE)', '벨만-포드 알고리즘의 시간 복잡도는 O(V × E)이다.'),
       (158, 505, 'V-1', '벨만-포드는 모든 간선을 확인하여 거리를 갱신하는 과정을 V-1번 반복한다.');


