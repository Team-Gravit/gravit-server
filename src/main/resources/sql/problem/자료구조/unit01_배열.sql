-- Unit: 배열 (Unit ID: 1)
-- Chapter: 자료구조 (Chapter ID: 1)

-- Lesson 생성
INSERT INTO lesson (id, unit_id, title)
VALUES (1, 1, '배열 기초 문제집'),
       (2, 1, '배열 심화 문제집'),
       (3, 1, '배열 응용 문제집');

-- =====================================================
-- Lesson 1: 배열 기초 문제집
-- =====================================================

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (1, 1, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '배열(Array)은 메모리 상에서 데이터를 저장하는 선형 자료구조이다.', 'OBJECTIVE'),
       (2, 1, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '배열은 인덱스를 통해 요소에 접근할 수 있는 자료구조이다.', 'OBJECTIVE'),
       (3, 1, '빈칸에 들어갈 알맞은 말을 작성하시오', '배열은 논리적 저장 순서와 물리적 저장 순서가 ___하는 자료구조이다.', 'SUBJECTIVE'),
       (4, 1, '제시된 내용과 관련하여 옳은 것은?', '배열은 다양한 장단점을 가진 자료구조이다.', 'OBJECTIVE'),
       (5, 1, '빈칸에 들어갈 알맞은 말을 작성하시오', '배열에서 특정 인덱스의 원소에 접근하는 시간 복잡도는 ___이다.', 'SUBJECTIVE'),
       (6, 1, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '배열은 메모리 상에서 특정한 방식으로 데이터를 저장하는 자료구조이다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (1, 1, '비연속적인 메모리 공간에 데이터를 저장한다',
        '비연속적인 메모리 공간에 데이터를 저장하는 것은 연결리스트의 특징이다. 배열은 연속된 메모리 공간에 데이터를 저장하여 인덱스 기반의 빠른 접근을 가능하게 한다.', false),
       (2, 1, '포인터를 통해 다음 요소를 참조한다', '포인터를 통해 다음 요소를 참조하는 것은 연결리스트의 특징이다. 배열은 인덱스를 통해 직접 접근하며, 포인터를 사용하지 않는다.', false),
       (3, 1, '연속된 메모리 공간에 데이터를 저장한다', '배열은 메모리 상에서 연속된 공간에 데이터를 순차적으로 저장한다. 이로 인해 인덱스를 통한 빠른 접근이 가능하며, 캐시 지역성도 높다.',
        true),
       (4, 1, '삽입과 삭제가 O(1) 시간에 가능하다',
        '배열은 중간에 원소를 삽입하거나 삭제할 때 이후의 모든 원소를 이동시켜야 하므로 O(n)의 시간 복잡도를 가진다. O(1) 시간의 삽입과 삭제는 배열의 장점이 아니다.', false),

       (5, 2, '접근: O(n), 탐색: O(1)',
        '배열은 인덱스를 통해 O(1) 시간에 접근이 가능하다. 반대로 특정 값을 찾는 탐색은 순차적으로 확인해야 하므로 O(n)이 소요된다. 따라서 접근과 탐색의 시간 복잡도가 반대이다.', false),
       (6, 2, '접근: O(1), 탐색: O(n)',
        '배열은 인덱스를 통한 직접 접근이 가능하므로 접근 시간 복잡도는 O(1)이다. 하지만 특정 값을 찾기 위해서는 배열을 순차적으로 탐색해야 하므로 탐색 시간 복잡도는 O(n)이다.', true),
       (7, 2, '접근: O(1), 탐색: O(1)',
        '탐색이 O(1)이 되려면 해시테이블과 같은 자료구조가 필요하다. 배열은 인덱스를 통한 접근은 O(1)이지만, 특정 값을 찾는 탐색은 O(n)의 시간이 소요된다.', false),
       (8, 2, '접근: O(n), 탐색: O(n)',
        '배열의 접근 시간 복잡도는 O(1)이다. 인덱스를 통해 메모리 주소를 계산하여 바로 접근할 수 있기 때문이다. 탐색은 O(n)이 맞지만 접근은 O(n)이 아니다.', false),

       (9, 4, '인덱스로 접근할 수 없다', '배열의 가장 큰 장점은 인덱스를 통한 O(1) 시간의 직접 접근이다. 인덱스로 접근할 수 없다는 것은 배열의 단점이 아니라 잘못된 설명이다.',
        false),
       (10, 4, '메모리를 전혀 사용하지 않는다',
        '배열은 연속된 메모리 공간을 사용하여 데이터를 저장한다. 오히려 사용하지 않는 공간도 미리 할당되므로 메모리 낭비가 발생할 수 있다는 것이 단점이다.', false),
       (11, 4, '삽입과 삭제가 매우 빠르다', '배열은 중간에 원소를 삽입하거나 삭제할 때 이후의 모든 원소를 이동시켜야 하므로 O(n)의 시간이 소요된다. 이는 배열의 장점이 아니라 단점이다.',
        false),
       (12, 4, '크기가 고정되어 있다',
        '배열은 생성 시 크기를 지정해야 하며, 이후 크기를 변경할 수 없다. 크기를 늘리려면 더 큰 배열을 새로 생성하고 기존 데이터를 복사해야 하므로 O(n)의 비용이 발생한다.', true),

       (13, 6, '포인터를 사용하여 연결된다', '포인터를 사용하여 노드를 연결하는 것은 연결리스트의 특징이다. 배열은 연속된 메모리 공간에 데이터를 저장하며 포인터를 사용하지 않는다.', false),
       (14, 6, '캐시 지역성이 높다',
        '배열은 메모리 상에서 연속적으로 저장되므로 CPU가 특정 요소에 접근할 때 인접한 메모리 영역도 함께 캐시에 로드된다. 이로 인해 캐시 히트율이 높아지고 성능이 향상된다.', true),
       (15, 6, '동적으로 크기가 변경된다',
        '배열은 생성 시 크기가 고정되며 동적으로 크기를 변경할 수 없다. Python의 list나 Java의 ArrayList는 내부적으로 크기를 조정하지만, 기본 배열 자체는 고정 크기이다.',
        false),
       (16, 6, '각 요소가 독립적인 메모리 블록을 사용한다', '배열의 모든 요소는 연속된 하나의 메모리 블록 내에 저장된다. 각 요소가 독립적인 메모리 블록을 사용하는 것은 연결리스트의 특징이다.',
        false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (1, 3, '일치,같음,동일,equal,same',
        '배열은 논리적 저장 순서와 물리적 저장 순서가 일치하는 자료구조이다. 이는 배열의 첫 번째 요소가 메모리 상에서도 첫 번째에 위치하고, 두 번째 요소가 그 다음에 연속적으로 위치함을 의미한다. 이러한 특성 덕분에 인덱스를 통한 O(1) 시간의 직접 접근이 가능하다.'),
       (2, 5, 'o(1),상수 시간,constant time',
        '배열에서 특정 인덱스의 원소에 접근하는 시간 복잡도는 O(1)이다. 배열의 시작 주소와 인덱스, 요소의 크기를 알면 "시작 주소 + (인덱스 × 요소 크기)"라는 간단한 산술 연산으로 메모리 주소를 계산할 수 있기 때문이다. 이는 배열의 가장 큰 장점 중 하나이다.');

-- =====================================================
-- Lesson 2: 배열 심화 문제집
-- =====================================================

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (7, 2, '제시된 내용과 관련하여 옳은 것은?', '배열의 중간에 새로운 원소를 삽입하는 과정을 고려한다.', 'OBJECTIVE'),
       (8, 2, '빈칸에 들어갈 알맞은 말을 작성하시오', '배열의 맨 앞에 원소를 삽입하는 최악의 경우 시간 복잡도는 ___이다.', 'SUBJECTIVE'),
       (9, 2, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '배열과 연결리스트는 각각 다른 특성을 가진 자료구조이다.', 'OBJECTIVE'),
       (10, 2, '제시된 내용과 관련하여 옳은 것은?', '배열의 중간에 있는 원소를 삭제하는 과정을 고려한다.', 'OBJECTIVE'),
       (11, 2, '빈칸에 들어갈 알맞은 말을 작성하시오', '배열은 메모리 상에서 연속적으로 저장되어 ___이 좋다.', 'SUBJECTIVE'),
       (12, 2, '제시된 내용과 관련하여 옳은 것은?', '배열은 다양한 상황에서 활용될 수 있는 자료구조이다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (17, 7, '포인터만 변경하면 바로 삽입할 수 있다', '포인터만 변경하여 삽입하는 것은 연결리스트의 특징이다. 배열은 연속된 메모리 구조를 유지해야 하므로 원소들을 이동시켜야 한다.',
        false),
       (18, 7, '삽입 위치의 원소만 교체하면 된다', '단순히 원소를 교체하는 것은 삽입이 아니라 수정이다. 삽입은 새로운 원소를 추가하는 것이므로 기존 원소들을 이동시켜 공간을 확보해야 한다.',
        false),
       (19, 7, '삽입 위치 이후의 모든 원소를 오른쪽으로 이동시킨다',
        '배열 중간에 원소를 삽입하려면 삽입 위치 이후의 모든 원소를 한 칸씩 오른쪽으로 이동시켜 공간을 만들어야 한다. 이로 인해 최악의 경우 O(n)의 시간 복잡도가 발생한다.', true),
       (20, 7, '배열의 크기가 자동으로 증가한다',
        '기본 배열은 크기가 고정되어 있으며 자동으로 증가하지 않는다. Python의 list나 Java의 ArrayList는 내부적으로 크기를 조정하지만, 이는 새로운 배열을 생성하고 복사하는 과정을 거친다.',
        false),

       (21, 9, '배열은 메모리를 낭비하지만, 연결리스트는 메모리 효율이 높다',
        '배열은 사용하지 않는 공간도 미리 할당되어 메모리 낭비가 있을 수 있다. 하지만 연결리스트도 포인터 저장을 위한 추가 메모리가 필요하므로 메모리 효율이 항상 높다고 할 수 없다.', false),
       (22, 9, '배열과 연결리스트는 동일한 시간 복잡도를 가진다',
        '배열과 연결리스트는 각 연산에서 다른 시간 복잡도를 가진다. 배열은 접근 O(1), 삽입/삭제 O(n)이며, 연결리스트는 접근 O(n), 삽입/삭제 O(1)이다.', false),
       (23, 9, '연결리스트는 캐시 지역성이 배열보다 높다',
        '연결리스트는 노드들이 메모리 상에서 비연속적으로 배치되므로 캐시 지역성이 낮다. 배열은 연속적으로 저장되어 캐시 지역성이 높아 성능상 이점이 있다.', false),
       (24, 9, '배열은 접근이 빠르고, 연결리스트는 삽입/삭제가 빠르다',
        '배열은 인덱스를 통한 O(1) 접근이 가능하지만 삽입/삭제는 O(n)이 소요된다. 연결리스트는 접근에 O(n)이 필요하지만 위치를 알고 있다면 삽입/삭제는 O(1)에 가능하다. 따라서 접근이 빈번하면 배열, 삽입/삭제가 빈번하면 연결리스트가 적합하다.',
        true),

       (25, 10, '포인터만 변경하면 바로 삭제할 수 있다',
        '포인터만 변경하여 삭제하는 것은 연결리스트의 특징이다. 배열은 연속된 메모리 구조를 유지해야 하므로 원소들을 이동시켜 빈 공간을 채워야 한다.', false),
       (26, 10, '삭제 후 뒤의 모든 원소를 왼쪽으로 이동시킨다',
        '배열에서 중간 원소를 삭제하면 연속성을 유지하기 위해 삭제 위치 이후의 모든 원소를 한 칸씩 왼쪽으로 이동시켜야 한다. 이로 인해 최악의 경우 O(n)의 시간 복잡도가 발생한다.', true),
       (27, 10, '삭제된 위치에 null을 넣으면 된다',
        '단순히 null을 넣는 것은 삭제가 아니라 값을 비우는 것이다. 배열의 삭제는 원소를 제거하고 뒤의 원소들을 이동시켜 연속성을 유지하는 과정을 포함한다.', false),
       (28, 10, '배열의 크기가 자동으로 감소한다', '기본 배열은 크기가 고정되어 있으며 원소를 삭제해도 크기가 자동으로 감소하지 않는다. 단지 유효한 원소의 개수만 줄어들 뿐이다.', false),

       (29, 12, '삽입과 삭제가 빈번한 데이터', '삽입과 삭제가 빈번한 경우에는 연결리스트가 더 적합하다. 배열은 삽입/삭제 시 원소 이동이 필요하여 O(n)의 비용이 발생하기 때문이다.',
        false),
       (30, 12, '크기를 자주 변경해야 하는 데이터',
        '크기를 자주 변경해야 하는 경우에는 동적 배열(ArrayList 등)이나 연결리스트가 더 적합하다. 기본 배열은 크기가 고정되어 있어 크기 변경이 비효율적이다.', false),
       (31, 12, '조회가 빈번하고 크기가 일정한 데이터',
        '배열은 인덱스를 통한 O(1) 접근이 가능하므로 조회가 빈번한 경우에 적합하다. 또한 크기가 일정하면 고정 크기라는 배열의 단점이 문제가 되지 않는다.', true),
       (32, 12, '메모리가 비연속적으로 할당되어야 하는 데이터', '배열은 연속된 메모리 공간을 사용하는 자료구조이다. 메모리가 비연속적으로 할당되어야 하는 경우에는 연결리스트가 적합하다.',
        false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (3, 8, 'o(n),선형 시간,선형시간,linear time',
        '배열의 맨 앞에 원소를 삽입하는 경우, 기존의 모든 원소를 한 칸씩 오른쪽으로 이동시켜야 한다. 배열에 n개의 원소가 있다면 n번의 이동 연산이 필요하므로 시간 복잡도는 O(n)이다. 이는 배열 삽입의 최악의 경우에 해당한다.'),
       (4, 11, '캐시 지역성,cache locality,캐시로컬리티,locality',
        '배열은 메모리 상에서 연속적으로 저장되므로 캐시 지역성이 좋다. CPU가 특정 요소에 접근할 때 인접한 메모리 영역도 함께 캐시에 로드되므로, 순차적인 접근 시 캐시 히트율이 높아져 성능이 향상된다. 이는 배열의 중요한 성능상 이점이다.');

-- =====================================================
-- Lesson 3: 배열 응용 문제집
-- =====================================================

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (13, 3, '제시된 내용과 관련하여 옳은 것은?', '배열에서 특정 인덱스의 메모리 주소를 계산하는 방식을 고려한다.', 'OBJECTIVE'),
       (14, 3, '빈칸에 들어갈 알맞은 말을 작성하시오', '배열은 크기를 확장하려면 더 큰 배열을 생성하고 기존 데이터를 ___해야 한다.', 'SUBJECTIVE'),
       (15, 3, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '다차원 배열은 배열 안에 배열을 포함하는 구조이다.', 'OBJECTIVE'),
       (16, 3, '제시된 내용과 관련하여 옳은 것은?', 'Python의 list는 내부적으로 배열을 사용하지만 추가 기능을 제공한다.', 'OBJECTIVE'),
       (17, 3, '빈칸에 들어갈 알맞은 말을 작성하시오', '배열에서 원소들이 메모리 상에서 연속적으로 배치되는 특성을 ___라고 한다.', 'SUBJECTIVE'),
       (18, 3, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '배열의 고정 크기와 삽입/삭제의 비효율성을 개선한 자료구조가 있다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (33, 13, '시작 주소 + 인덱스',
        '원소의 크기를 고려하지 않은 잘못된 계산 방식이다. 각 원소가 차지하는 메모리 크기를 곱해주어야 정확한 주소를 얻을 수 있다. 정확한 계산식은 "시작 주소 + (인덱스 × 원소 크기)"이다.',
        false),
       (34, 13, '시작 주소 + (인덱스 × 원소 크기)',
        '배열의 메모리 주소는 "시작 주소 + (인덱스 × 원소 크기)"로 계산된다. 예를 들어 시작 주소가 1000이고 각 원소가 4바이트라면, arr[2]의 주소는 1000 + (2 × 4) = 1008이다. 이러한 간단한 산술 연산으로 O(1) 시간에 접근할 수 있다.',
        true),
       (35, 13, '포인터를 따라가며 탐색', '포인터를 따라가며 탐색하는 것은 연결리스트의 방식이다. 배열은 인덱스와 원소 크기를 이용한 산술 연산으로 메모리 주소를 직접 계산한다.', false),
       (36, 13, '이진 탐색을 통해 주소 계산', '이진 탐색은 정렬된 배열에서 값을 찾는 알고리즘이지, 메모리 주소를 계산하는 방식이 아니다. 배열은 간단한 산술 연산으로 주소를 계산한다.',
        false),

       (37, 15, '다차원 배열은 포인터로 연결된다', '다차원 배열도 메모리 상에서는 연속적으로 저장되며, 포인터로 연결되지 않는다. 포인터를 사용하는 것은 연결리스트의 특징이다.', false),
       (38, 15, '3차원 이상의 배열은 생성할 수 없다',
        '대부분의 프로그래밍 언어는 3차원 이상의 다차원 배열도 생성할 수 있다. 다만 차원이 높아질수록 메모리 사용량이 기하급수적으로 증가하고 관리가 복잡해진다.', false),
       (39, 15, '다차원 배열은 크기를 동적으로 변경할 수 있다', '다차원 배열도 기본 배열과 마찬가지로 생성 시 크기가 고정된다. 크기를 변경하려면 새로운 배열을 생성하고 데이터를 복사해야 한다.',
        false),
       (40, 15, '2차원 배열은 행과 열로 구성된다',
        '2차원 배열은 행(row)과 열(column)로 구성된 표 형태의 자료구조이다. 실제 메모리 상에서는 1차원으로 연속 저장되지만, 논리적으로는 2차원 구조로 접근할 수 있다. arr[i][j] 형태로 접근하며, 행렬 연산 등에 활용된다.',
        true),

       (41, 16, 'list는 인덱스로 접근할 수 없다',
        'Python의 list도 배열처럼 인덱스를 통한 O(1) 시간의 접근이 가능하다. list[i] 형태로 접근하며, 이는 list의 주요 장점 중 하나이다.', false),
       (42, 16, 'list는 메모리를 전혀 사용하지 않는다',
        'Python의 list는 내부적으로 배열을 사용하므로 당연히 메모리를 사용한다. 오히려 동적 크기 조정을 위한 추가 메모리가 필요할 수 있다.', false),
       (43, 16, 'list는 크기를 동적으로 조정할 수 있다',
        'Python의 list는 내부적으로 동적 배열로 구현되어 있어, 원소 추가 시 자동으로 크기를 조정한다. 기본 배열은 고정 크기이지만, list는 필요에 따라 내부 배열을 재할당하여 크기를 늘린다.',
        true),
       (44, 16, 'list는 연속된 메모리를 사용하지 않는다',
        'Python의 list는 내부적으로 연속된 메모리 공간을 사용하는 배열로 구현되어 있다. 다만 원소 추가 시 공간이 부족하면 더 큰 연속 공간으로 이동한다.', false),

       (45, 18, '스택', '스택은 LIFO 구조의 자료구조로, 배열이나 연결리스트로 구현될 수 있다. 배열의 한계를 극복한 자료구조라기보다는 특정 동작 방식을 정의한 추상 자료형이다.', false),
       (46, 18, '연결리스트',
        '연결리스트는 각 노드가 포인터로 연결되어 있어 크기 제약이 없고, 삽입/삭제 시 포인터만 변경하면 되므로 O(1)에 가능하다. 이는 배열의 고정 크기와 O(n) 삽입/삭제 문제를 해결한 자료구조이다.',
        true),
       (47, 18, '큐', '큐는 FIFO 구조의 자료구조로, 배열이나 연결리스트로 구현될 수 있다. 배열의 한계를 극복한 자료구조라기보다는 특정 동작 방식을 정의한 추상 자료형이다.', false),
       (48, 18, '트리', '트리는 계층적 구조를 표현하는 비선형 자료구조이다. 배열의 한계를 극복하기 위한 목적보다는 계층 관계를 표현하기 위해 설계된 자료구조이다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (5, 14, '복사,copy,이동,move,카피',
        '배열의 크기를 확장하려면 더 큰 새로운 배열을 생성하고, 기존 배열의 모든 데이터를 새 배열로 복사해야 한다. 이 과정은 O(n)의 시간이 소요되며, 이는 배열의 크기 변경이 비효율적인 이유이다. Python의 list나 Java의 ArrayList는 내부적으로 이러한 복사 과정을 자동으로 수행한다.'),
       (6, 17, '연속성,contiguity,순차성,연속,sequential',
        '배열의 원소들이 메모리 상에서 연속적으로 배치되는 특성을 연속성 또는 순차성이라고 한다. 이러한 연속성 덕분에 인덱스를 통한 빠른 접근이 가능하고, 캐시 지역성이 높아져 성능상 이점을 얻을 수 있다. 이는 배열의 핵심 특성이자 장점이다.');