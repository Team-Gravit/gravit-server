-- Unit: 선택 정렬 (Unit ID: 16)
-- Chapter: 알고리즘 (Chapter ID: 2)

-- Lesson 생성
INSERT INTO lesson (id, unit_id, title)
VALUES (45, 16, '선택 정렬 기초 문제집'),
       (46, 16, '선택 정렬 동작 과정 문제집'),
       (47, 16, '선택 정렬 분석 문제집');

-- =====================================================
-- Lesson 45: 선택 정렬 기초 문제집
-- =====================================================

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (265, 45, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '선택 정렬은 특정한 방식으로 동작하는 정렬 알고리즘이다.', 'OBJECTIVE'),
       (266, 45, '빈칸에 들어갈 알맞은 말을 작성하시오', '선택 정렬은 정렬할 위치는 이미 정해져 있고 어떤 ___를 선택하여 그 위치에 넣을지 결정한다.', 'SUBJECTIVE'),
       (267, 45, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '선택 정렬은 특정한 특징을 가진다.', 'OBJECTIVE'),
       (268, 45, '제시된 내용과 관련하여 옳은 것은?', '선택 정렬의 교환 횟수는 특정한 규칙을 따른다.', 'OBJECTIVE'),
       (269, 45, '빈칸에 들어갈 알맞은 말을 작성하시오', '선택 정렬은 매 회전마다 ___을 탐색하여 정해진 위치에 배치한다.', 'SUBJECTIVE'),
       (270, 45, '제시된 내용과 관련하여 옳은 것은?', '선택 정렬은 안정성과 관련된 특성을 가진다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (705, 265, '인접한 두 원소를 비교하여 교환하는 알고리즘이다',
        '이는 버블 정렬의 특징이다. 선택 정렬은 최솟값을 찾아 정해진 위치에 배치한다.', false),
       (706, 265, '정렬된 부분에 원소를 삽입하는 알고리즘이다',
        '이는 삽입 정렬의 특징이다. 선택 정렬은 최솟값을 선택하여 위치에 배치한다.', false),
       (707, 265, '정렬할 위치는 이미 정해져 있고 어떤 원소를 선택하여 그 위치에 넣을지 결정하는 알고리즘이다',
        '선택 정렬은 정렬할 위치는 이미 정해져 있고, 어떤 원소를 선택하여 그 위치에 넣을지 결정하는 알고리즘이다. 매 회전마다 가장 작은 값을 찾아 앞쪽의 정해진 위치와 교환한다.',
        true),
       (708, 265, '피벗을 기준으로 분할하는 알고리즘이다',
        '이는 퀵 정렬의 특징이다. 선택 정렬은 최솟값을 선택하여 배치한다.', false),

       (709, 267, '인접한 원소를 비교한다',
        '이는 버블 정렬의 특징이다. 선택 정렬은 최솟값을 찾아 배치한다.', false),
       (710, 267, '교환 횟수가 O(n²)이다',
        '선택 정렬의 교환 횟수는 최대 n-1번이다. O(n²)이 아니라 O(n)이다.', false),
       (711, 267, '안정 정렬이다',
        '선택 정렬은 불안정 정렬이다. 동일한 값의 순서가 바뀔 수 있다.', false),
       (712, 267, '매 회전마다 최솟값을 탐색하여 정해진 위치에 배치하고 교환 횟수가 최대 n-1번으로 제한된다',
        '선택 정렬은 매 회전마다 최솟값을 탐색하여 정해진 위치에 배치하며, 교환 횟수가 최대 n-1번으로 제한된다. 버블 정렬보다 교환 횟수가 적지만 불안정 정렬이다.',
        true),

       (713, 268, '교환 횟수가 n(n-1)/2번이다',
        '이는 비교 횟수이다. 교환 횟수는 최대 n-1번이다.', false),
       (714, 268, '교환 횟수가 최대 n-1번으로 제한된다',
        '선택 정렬의 교환 횟수는 최대 n-1번으로 제한된다. 매 회전마다 최대 1번 교환하므로 버블 정렬보다 교환 횟수가 훨씬 적다.',
        true),
       (715, 268, '교환이 전혀 발생하지 않는다',
        '정렬되지 않은 경우 교환이 발생한다. 최대 n-1번 교환한다.', false),
       (716, 268, '교환 횟수가 버블 정렬보다 많다',
        '선택 정렬의 교환 횟수는 버블 정렬보다 적다. 최대 n-1번으로 제한된다.', false),

       (717, 270, '안정 정렬이며 동일한 값의 순서를 유지한다',
        '선택 정렬은 불안정 정렬이다. 동일한 값의 순서가 바뀔 수 있다.', false),
       (718, 270, '동일한 값을 처리할 수 없다',
        '선택 정렬은 동일한 값을 처리할 수 있지만 순서가 바뀔 수 있다.', false),
       (719, 270, '불안정 정렬이며 동일한 값의 순서가 바뀔 수 있다',
        '선택 정렬은 불안정 정렬(Unstable Sort)이다. 동일한 값의 순서가 바뀔 수 있으므로 동일한 키를 가진 데이터의 상대적 순서가 변할 수 있다.',
        true),
       (720, 270, '동일한 값은 항상 제거된다',
        '선택 정렬은 동일한 값을 유지한다. 제거하지 않는다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (89, 266, '원소,요소,element',
        '선택 정렬은 정렬할 위치는 이미 정해져 있고 어떤 원소를 선택하여 그 위치에 넣을지 결정한다. 매 회전마다 최솟값을 선택하여 배치한다.'),
       (90, 269, '최솟값,가장 작은 값,최소값,minimum',
        '선택 정렬은 매 회전마다 최솟값을 탐색하여 정해진 위치에 배치한다. 첫 번째 위치에는 전체 중 최솟값을, 두 번째 위치에는 나머지 중 최솟값을 배치한다.');

-- =====================================================
-- Lesson 46: 선택 정렬 동작 과정 문제집
-- =====================================================

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (271, 46, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '선택 정렬은 단계적으로 동작한다.', 'OBJECTIVE'),
       (272, 46, '빈칸에 들어갈 알맞은 말을 작성하시오', '선택 정렬의 1회전에서는 첫 번째 원소를 ___부터  마지막 원소까지와 비교하여 가장 작은 값을 첫 번째 위치에 옮긴다.', 'SUBJECTIVE'),
       (273, 46, '제시된 내용과 관련하여 옳은 것은?', '선택 정렬의 비교 횟수는 특정한 규칙을 따른다.', 'OBJECTIVE'),
       (274, 46, '제시된 내용과 관련하여 옳은 것은?', '선택 정렬은 각 회전 후 특정한 변화가 일어난다.', 'OBJECTIVE'),
       (275, 46, '빈칸에 들어갈 알맞은 말을 작성하시오', '선택 정렬은 모든 경우에서 ___번의 비교를 수행한다.', 'SUBJECTIVE'),
       (276, 46, '제시된 내용과 관련하여 옳은 것은?', '선택 정렬은 특정한 시점에 교환을 수행한다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (721, 271, '인접한 두 원소를 순차적으로 비교하여 교환한다',
        '이는 버블 정렬의 동작이다. 선택 정렬은 최솟값을 찾아 정해진 위치에 배치한다.', false),
       (722, 271, '주어진 배열에서 가장 작은 값을 찾아 첫 번째 요소의 값과 교체한다',
        '선택 정렬은 주어진 배열에서 가장 작은 값을 찾아 첫 번째 요소의 값과 교체한다. 정렬된 맨 처음 위치를 빼고 나머지 배열을 같은 방법으로 교체하며, 하나의 원소만 남을 때까지 반복한다.',
        true),
       (723, 271, '정렬된 부분에 원소를 삽입한다',
        '이는 삽입 정렬의 동작이다. 선택 정렬은 최솟값을 선택하여 위치에 배치한다.', false),
       (724, 271, '배열을 절반으로 나누어 정렬한다',
        '이는 병합 정렬의 동작이다. 선택 정렬은 최솟값을 찾아 배치한다.', false),

       (725, 273, '최선의 경우 n번의 비교를 수행한다',
        '선택 정렬은 최선의 경우에도 모든 비교를 수행한다. n(n-1)/2번 비교한다.', false),
       (726, 273, '이미 정렬된 경우 비교하지 않는다',
        '선택 정렬은 정렬 여부와 무관하게 모든 비교를 수행한다.', false),
       (727, 273, '모든 경우에서 n(n-1)/2번의 비교를 수행한다',
        '선택 정렬은 모든 경우에서 n(n-1)/2번의 비교를 수행한다. 정렬 여부와 무관하게 최솟값을 찾기 위해 모든 원소를 비교하므로 비교 횟수는 일정하다.',
        true),
       (728, 273, '최악의 경우에만 비교를 수행한다',
        '선택 정렬은 모든 경우에 비교를 수행한다. 정렬 여부와 무관하다.', false),

       (729, 274, '가장 큰 값이 맨 뒤로 이동한다',
        '이는 버블 정렬의 특징이다. 선택 정렬은 가장 작은 값이 앞으로 이동한다.', false),
       (730, 274, '정렬 범위가 변하지 않는다',
        '선택 정렬은 각 회전마다 정렬 범위가 1씩 감소한다.', false),
       (731, 274, '가장 작은 값이 정해진 위치로 이동하고 정렬 범위가 1씩 감소한다',
        '선택 정렬은 각 회전 후 가장 작은 값이 정해진 위치로 이동하고, 정렬 범위가 1씩 감소한다. 정렬된 부분을 제외하고 나머지 원소들에 대해 동일한 과정을 반복한다.',
        true),
       (732, 274, '피벗이 확정된다',
        '피벗은 퀵 정렬의 개념이다. 선택 정렬은 최솟값이 확정된다.', false),

       (733, 276, '비교할 때마다 교환한다',
        '선택 정렬은 최솟값을 찾은 후 한 번만 교환한다. 비교할 때마다 교환하지 않는다.', false),
       (734, 276, '교환이 전혀 발생하지 않는다',
        '정렬되지 않은 경우 교환이 발생한다. 회전당 최대 1번 교환한다.', false),
       (735, 276, '각 회전에서 최솟값을 찾은 후 정해진 위치와 한 번만 교환한다',
        '선택 정렬은 각 회전에서 최솟값을 찾은 후 정해진 위치와 한 번만 교환한다. 비교는 여러 번 하지만 교환은 회전당 최대 1번만 발생하므로 교환 횟수가 적다.',
        true),
       (736, 276, '항상 모든 원소를 교환한다',
        '선택 정렬은 회전당 최대 1번만 교환한다. 모든 원소를 교환하지 않는다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (91, 272, '두 번째,2번째,둘째,second',
        '선택 정렬의 1회전에서는 첫 번째 원소를 두 번째 원소부터 마지막 원소까지와 비교하여 가장 작은 값을 첫 번째 위치에 옮긴다. 이 과정에서 원소를 n-1번 비교한다.'),
       (92, 275, 'n(n-1)/2,(n*(n-1))/2,n*(n-1)/2',
        '선택 정렬은 모든 경우에서 n(n-1)/2번의 비교를 수행한다. 첫 회전에서 n-1번, 두 번째 회전에서 n-2번 비교하므로 총 n(n-1)/2번이다.');

-- =====================================================
-- Lesson 47: 선택 정렬 분석 문제집
-- =====================================================

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (277, 47, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '선택 정렬은 특정한 시간 복잡도를 가진다.', 'OBJECTIVE'),
       (278, 47, '빈칸에 들어갈 알맞은 말을 작성하시오', '선택 정렬의 최선, 평균, 최악의 시간 복잡도는 모두 ___이다.', 'SUBJECTIVE'),
       (279, 47, '제시된 내용과 관련하여 옳은 것은?', '선택 정렬은 특정한 장점을 가진다.', 'OBJECTIVE'),
       (280, 47, '제시된 내용과 관련하여 옳은 것은?', '선택 정렬은 단점도 가지고 있다.', 'OBJECTIVE'),
       (281, 47, '빈칸에 들어갈 알맞은 말을 작성하시오', '선택 정렬은 추가 메모리가 불필요한 ___ 정렬이다.', 'SUBJECTIVE'),
       (282, 47, '제시된 내용과 관련하여 옳은 것은?', '선택 정렬은 특정 상황에서 유용하다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (737, 277, '최선 O(n), 평균 O(n log n), 최악 O(n²)이다',
        '선택 정렬은 모든 경우에 O(n²)이다. 정렬 여부와 무관하게 모든 비교를 수행한다.', false),
       (738, 277, '최선, 평균, 최악 모두 O(n²)이다',
        '선택 정렬의 시간 복잡도는 최선, 평균, 최악의 경우 모두 O(n²)이다. 이미 정렬된 경우에도 최솟값을 찾기 위해 모든 비교를 수행하므로 최선의 경우도 O(n²)이다.',
        true),
       (739, 277, '모든 경우에 O(n log n)이다',
        '선택 정렬은 O(n²)이다. O(n log n)은 병합 정렬이나 퀵 정렬의 시간 복잡도이다.', false),
       (740, 277, '최선 O(1), 평균 O(n), 최악 O(n²)이다',
        '선택 정렬은 모든 경우에 O(n²)이다. 최선의 경우도 O(n²)이다.', false),

       (741, 279, '시간이 매우 빠르다',
        '선택 정렬은 O(n²)으로 느린 정렬 알고리즘이다. 시간이 빠르지 않다.', false),
       (742, 279, '안정 정렬이다',
        '선택 정렬은 불안정 정렬이다. 동일한 값의 순서가 바뀔 수 있다.', false),
       (743, 279, '교환 횟수가 적고 제자리 정렬이며 자료 이동 횟수가 미리 결정된다',
        '선택 정렬의 장점은 구현이 간단하고 이해하기 쉬우며, 교환 횟수가 적고(버블 정렬보다 효율적), 제자리 정렬로 추가 메모리가 불필요하고, 자료 이동 횟수가 미리 결정된다(최대 n-1번)는 것이다.',
        true),
       (744, 279, '정렬된 배열에서 O(n)이다',
        '선택 정렬은 정렬 여부와 무관하게 O(n²)이다. 정렬된 배열에서도 O(n²)이다.', false),

       (745, 280, '구현이 매우 복잡하다',
        '선택 정렬은 구현이 간단하다. 복잡하지 않다.', false),
       (746, 280, '교환 횟수가 매우 많다',
        '선택 정렬의 교환 횟수는 적다. 최대 n-1번으로 제한된다.', false),
       (747, 280, '비효율적인 시간 복잡도와 정렬 여부와 무관하게 모든 비교를 수행한다',
        '선택 정렬의 단점은 비효율적인 시간 복잡도(O(n²))를 가지고, 정렬 여부와 무관하게 모든 비교를 수행하며, 불안정 정렬로 동일한 값의 순서가 바뀔 수 있다는 것이다.',
        true),
       (748, 280, '추가 메모리가 많이 필요하다',
        '선택 정렬은 제자리 정렬로 추가 메모리가 거의 불필요하다.', false),

       (749, 282, '대용량 데이터 정렬에 적합하다',
        '선택 정렬은 O(n²)으로 대용량 데이터에 비효율적이다. 퀵 정렬이나 병합 정렬이 더 적합하다.', false),
       (750, 282, '교환 횟수가 적어 메모리 쓰기 비용이 큰 환경에서 유용하다',
        '선택 정렬은 교환 횟수가 적어 메모리 쓰기 비용이 큰 환경(예: EEPROM)에서 유용하다. 하지만 대부분의 경우 삽입 정렬, 퀵 정렬, 병합 정렬이 더 효율적이다.',
        true),
       (751, 282, '실시간 시스템에서 주로 사용된다',
        '선택 정렬은 시간 복잡도가 높아 실시간 시스템에 부적합하다.', false),
       (752, 282, '네트워크 프로토콜 구현에 사용된다',
        '선택 정렬은 일반적인 정렬 알고리즘이다. 네트워크 프로토콜과는 직접적인 관련이 없다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (93, 278, 'o(n²),o(n^2),O(n²),O(n^2)',
        '선택 정렬의 최선, 평균, 최악의 시간 복잡도는 모두 O(n²)이다. 정렬 여부와 관계없이 최솟값을 찾기 위해 모든 비교를 수행하므로 항상 O(n²)이다.'),
       (94, 281, '제자리,in-place,inplace,in place',
        '선택 정렬은 추가 메모리가 불필요한 제자리(in-place) 정렬이다. 원본 배열 내에서 교환만으로 정렬하므로 추가 메모리가 거의 필요하지 않다.');
