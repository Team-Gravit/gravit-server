-- Unit: 최소 신장 트리 (Unit ID: 26)
-- Chapter: 알고리즘 (Chapter ID: 2)

-- Lesson 생성
INSERT INTO lesson (id, unit_id, title)
VALUES (74, 26, '최소 신장 트리 기초 문제집'),
       (75, 26, 'Prim 알고리즘 문제집'),
       (76, 26, 'Kruskal 알고리즘 문제집');

-- =====================================================
-- Lesson 74: 최소 신장 트리 기초 문제집
-- =====================================================

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (461, 74, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '신장 트리는 그래프의 특별한 형태이다.', 'OBJECTIVE'),
       (462, 74, '빈칸에 들어갈 알맞은 말을 작성하시오', 'n개의 정점을 가지는 그래프의 신장 트리는 ___개의 간선으로 연결된다.', 'SUBJECTIVE'),
       (463, 74, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '최소 신장 트리는 신장 트리 중 특별한 조건을 만족한다.', 'OBJECTIVE'),
       (464, 74, '제시된 내용과 관련하여 옳은 것은?', '최소 신장 트리는 여러 특징을 가진다.', 'OBJECTIVE'),
       (465, 74, '빈칸에 들어갈 알맞은 말을 작성하시오', '최소 신장 트리는 간선 ___의 합이 최소인 트리이다.', 'SUBJECTIVE'),
       (466, 74, '제시된 내용과 관련하여 옳은 것은?', '최소 신장 트리는 여러 분야에서 활용된다.', 'OBJECTIVE'),
       (467, 74, '제시된 내용과 관련하여 옳은 것은?', '신장 트리는 특정 조건을 만족한다.', 'OBJECTIVE'),
       (468, 74, '제시된 내용과 관련하여 옳은 것은?', '최소 신장 트리를 구하는 대표적인 알고리즘이 있다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (1251, 461, '사이클을 포함하는 그래프이다', '신장 트리는 트리의 일종으로 사이클을 포함하지 않는다. 사이클이 있으면 트리가 아니라 일반 그래프가 된다.', false),
       (1252, 461, '방향 그래프에만 존재한다', '신장 트리는 방향 그래프뿐만 아니라 무방향 그래프에서도 존재한다. 일반적으로 최소 신장 트리 문제는 무방향 가중치 그래프에서 다룬다.', false),
       (1253, 461, '그래프 내의 모든 정점을 포함하는 트리로 그래프의 최소 연결 부분 그래프이다', '신장 트리는 모든 정점을 포함하는 최소 연결 부분 그래프이다. 트리의 정의에 따라 사이클이 없으며, n개의 정점에 대해 정확히 n-1개의 간선으로 연결된다.', true),
       (1254, 461, '일부 정점만 포함하는 트리이다', '신장 트리는 모든 정점을 포함하므로 오답이다.', false),

       (1255, 463, '가장 많은 간선을 가진 트리', '최소 신장 트리는 간선의 개수가 아닌 간선들의 가중치 합이 최소인 트리이다. 신장 트리는 모두 n-1개의 간선을 가진다.', false),
       (1256, 463, '가장 높이가 낮은 트리', '최소 신장 트리는 트리의 높이와는 무관하며, 오직 간선 가중치의 합만을 고려한다.', false),
       (1257, 463, '신장 트리 중에서 간선들의 가중치 합이 최소인 트리', '최소 신장 트리(Minimum Spanning Tree, MST)는 그래프의 모든 신장 트리 중에서 간선들의 가중치 합이 최소인 트리를 의미한다. 네트워크 설계에서 비용을 최소화하는 데 사용된다.', true),
       (1258, 463, '사이클을 가진 그래프', '최소 신장 트리는 트리의 정의에 따라 사이클이 없어야 한다. 사이클이 있으면 트리가 아니다.', false),

       (1259, 464, '사이클을 반드시 포함한다', '최소 신장 트리는 트리이므로 사이클을 포함하지 않는다. 사이클이 있으면 트리의 정의를 위반한다.', false),
       (1260, 464, '간선 가중치의 합이 최소이고 n개의 정점에 대해 n-1개의 간선만 사용하며 사이클이 포함되지 않는다', '최소 신장 트리는 1) 간선 가중치의 합이 최소, 2) n개의 정점에 n-1개의 간선, 3) 사이클 없음의 세 가지 핵심 특징을 모두 만족한다.', true),
       (1261, 464, 'n개 정점에 n개 간선을 사용한다', '트리는 n개의 정점에 대해 n-1개의 간선을 가진다. n개의 간선을 가지면 사이클이 형성되어 트리가 아니다.', false),
       (1262, 464, '가중치의 합이 최대이다', '최소 신장 트리는 가중치 합이 최소인 트리이다. 최대가 아니라 최소를 추구한다.', false),

       (1263, 466, '정렬 알고리즘', '정렬 알고리즘은 데이터를 순서대로 배열하는 것으로, 최소 신장 트리의 활용 사례가 아니다.', false),
       (1264, 466, '해시 테이블', '해시 테이블은 키-값 쌍을 저장하는 자료구조로, 최소 신장 트리의 활용 사례가 아니다.', false),
       (1265, 466, '도로 건설 시 도시들을 연결하면서 도로 길이 최소화와 전기 회로에서 단자들을 연결하면서 전선 길이 최소화', '최소 신장 트리는 모든 지점을 최소 비용으로 연결해야 하는 문제에 활용된다. 도로 건설, 전기 회로 설계, 통신망 구축, 배관 설치 등이 대표적인 예이다.', true),
       (1266, 466, '이진 탐색', '이진 탐색은 정렬된 데이터에서 특정 값을 찾는 알고리즘으로, 최소 신장 트리의 활용 사례가 아니다.', false),

       (1267, 467, 'n개의 정점을 n-1개의 간선으로 연결하면 필연적으로 트리 형태가 되며 사이클을 포함하지 않기 때문이다', 'n개의 정점을 연결하는 데 필요한 최소 간선 개수는 n-1개이다. n-1개의 간선으로 모든 정점을 연결하면 사이클 없이 연결된 구조, 즉 트리가 된다.', true),
       (1268, 467, '사이클이 많아서', '신장 트리는 사이클이 없는 것이 특징이다. 사이클이 많다는 설명은 잘못되었다.', false),
       (1269, 467, 'n개 간선을 사용하기 때문에', '신장 트리는 n개가 아니라 n-1개의 간선을 사용한다. 이 개수가 트리 형태를 만드는 핵심이다.', false),
       (1270, 467, '방향 그래프이기 때문에', '방향성 여부는 트리 형태가 되는 이유와 직접적인 관련이 없다. n-1개의 간선으로 n개의 정점을 연결하는 것이 핵심이다.', false),

       (1271, 468, 'DFS와 BFS', 'DFS와 BFS는 그래프 탐색 알고리즘으로, 최소 신장 트리를 구하는 알고리즘이 아니다.', false),
       (1272, 468, 'Prim 알고리즘과 Kruskal 알고리즘', 'Prim 알고리즘과 Kruskal 알고리즘이 최소 신장 트리를 구하는 대표적인 두 알고리즘이다. Prim은 정점 선택 기반, Kruskal은 간선 선택 기반으로 동작한다.', true),
       (1273, 468, 'Dijkstra 알고리즘', 'Dijkstra 알고리즘은 최단 경로를 찾는 알고리즘으로, 최소 신장 트리를 구하는 알고리즘이 아니다.', false),
       (1274, 468, '퀵 정렬', '퀵 정렬은 데이터를 정렬하는 알고리즘으로, 최소 신장 트리를 구하는 알고리즘이 아니다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (147, 462, 'n-1,n - 1,(n-1)',
        'n개의 정점을 가지는 그래프의 신장 트리는 n-1개의 간선으로 연결된다. 이는 트리의 기본 성질로, n개의 정점을 사이클 없이 모두 연결하는 데 필요한 최소 간선 개수가 n-1개이기 때문이다.'),
       (148, 465, '가중치,weight,웨이트,비용,cost',
        '최소 신장 트리는 간선 가중치의 합이 최소인 트리이다. 각 간선에 부여된 가중치(비용, 거리 등)의 총합을 최소화하는 것이 목표이며, 이를 통해 네트워크 설계 비용을 최소화할 수 있다.');

-- =====================================================
-- Lesson 75: Prim 알고리즘 문제집
-- =====================================================

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (469, 75, '아래 제시한 개념에 대한 설명으로 옳은 것은?', 'Prim 알고리즘은 최소 신장 트리를 구하는 방법이다.', 'OBJECTIVE'),
       (470, 75, '빈칸에 들어갈 알맞은 말을 작성하시오', 'Prim 알고리즘은 ___을 기준으로 신장 트리를 확장하는 알고리즘이다.', 'SUBJECTIVE'),
       (471, 75, '제시된 내용과 관련하여 옳은 것은?', 'Prim 알고리즘은 단계적으로 확장한다.', 'OBJECTIVE'),
       (472, 75, '제시된 내용과 관련하여 옳은 것은?', 'Prim 알고리즘은 특정 방식으로 동작한다.', 'OBJECTIVE'),
       (473, 75, '빈칸에 들어갈 알맞은 말을 작성하시오', 'Prim 알고리즘의 시간 복잡도는 ___이다. (우선순위 큐 사용 시)', 'SUBJECTIVE'),
       (474, 75, '제시된 내용과 관련하여 옳은 것은?', 'Prim은 특정 기준으로 선택한다.', 'OBJECTIVE'),
       (475, 75, '제시된 내용과 관련하여 옳은 것은?', 'Prim은 정점을 중심으로 확장한다.', 'OBJECTIVE'),
       (476, 75, '제시된 내용과 관련하여 옳은 것은?', 'Prim은 특정 조건에서 종료한다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (1275, 469, '사이클을 포함하는 알고리즘', 'Prim 알고리즘은 트리를 구성하므로 사이클을 포함하지 않는다. 사이클이 생기는 간선은 선택하지 않는다.', false),
       (1276, 469, '시작 정점에서 출발하여 신장 트리 집합을 단계적으로 확장하는 정점 선택 기반 알고리즘', 'Prim 알고리즘은 시작 정점에서 출발하여 인접한 정점 중 최소 가중치 간선으로 연결된 정점을 선택하면서 단계적으로 MST를 확장하는 정점 선택 기반 알고리즘이다.', true),
       (1277, 469, '모든 간선을 정렬하여 선택하는 알고리즘', '모든 간선을 정렬하여 선택하는 것은 Kruskal 알고리즘의 접근 방식이다. Prim은 정점을 중심으로 확장한다.', false),
       (1278, 469, '최단 경로를 찾는 알고리즘', 'Prim 알고리즘은 최단 경로가 아닌 최소 신장 트리를 구하는 알고리즘이다. 최단 경로는 Dijkstra나 Bellman-Ford 알고리즘이 사용된다.', false),

       (1279, 471, '사이클을 만든다', 'Prim 알고리즘은 트리를 구성하므로 사이클을 만들지 않는다. 사이클이 형성되지 않도록 정점을 선택한다.', false),
       (1280, 471, '시작 정점만 MST 집합에 포함하고 MST 집합에 인접한 정점들 중 최소 간선으로 연결된 정점 선택하며 n-1개의 간선을 가질 때까지 반복한다', 'Prim 알고리즘의 동작 과정은 1) 시작 정점을 MST 집합에 포함, 2) MST 집합에 인접한 정점 중 최소 가중치 간선으로 연결된 정점 선택, 3) n-1개 간선을 가질 때까지 반복한다.', true),
       (1281, 471, 'Union-Find를 사용한다', 'Union-Find 자료구조는 Kruskal 알고리즘에서 사이클 검사를 위해 사용된다. Prim 알고리즘은 Union-Find를 사용하지 않는다.', false),
       (1282, 471, '모든 간선을 정렬한다', '모든 간선을 정렬하는 것은 Kruskal 알고리즘의 첫 단계이다. Prim은 간선을 미리 정렬하지 않는다.', false),

       (1283, 472, '정렬을 먼저 수행한다', '간선 정렬을 먼저 수행하는 것은 Kruskal 알고리즘의 특징이다. Prim은 우선순위 큐를 사용하여 매 단계마다 최소 간선을 찾는다.', false),
       (1284, 472, '이전 단계에서 만들어진 신장 트리를 확장하는 방식이며 매 단계마다 가장 낮은 가중치의 간선을 선택한다', 'Prim 알고리즘은 이전 단계에서 만들어진 신장 트리에 인접한 정점 중 최소 가중치 간선으로 연결된 정점을 선택하여 트리를 확장하는 탐욕적(greedy) 방식을 사용한다.', true),
       (1285, 472, 'Union-Find가 필수이다', 'Union-Find는 Kruskal 알고리즘에서 사이클 검사를 위해 필수적으로 사용된다. Prim 알고리즘은 Union-Find를 사용하지 않는다.', false),
       (1286, 472, '간선을 독립적으로 선택한다', '간선을 독립적으로 선택하는 것은 Kruskal 알고리즘의 특징이다. Prim은 이전에 만들어진 트리를 확장하는 방식이다.', false),

       (1287, 474, 'MST 집합에 인접한 정점들 중 최소 간선으로 연결된 정점', 'Prim 알고리즘은 매 단계마다 현재 MST 집합에 포함된 정점들과 인접한 정점들 중에서 가장 작은 가중치의 간선으로 연결된 정점을 선택하여 MST를 확장한다.', true),
       (1288, 474, '가중치가 가장 큰 간선', 'Prim 알고리즘은 최소 신장 트리를 구하므로 가중치가 가장 작은 간선을 선택한다. 가장 큰 간선을 선택하면 최대 신장 트리가 된다.', false),
       (1289, 474, '무작위 정점', 'Prim 알고리즘은 무작위로 정점을 선택하지 않는다. 항상 최소 가중치 간선으로 연결된 정점을 선택하는 탐욕적 방식을 사용한다.', false),
       (1290, 474, '사이클을 만드는 정점', 'Prim 알고리즘은 트리를 구성하므로 사이클을 만들지 않는다. MST 집합에 이미 포함된 정점은 다시 선택하지 않는다.', false),

       (1291, 475, '간선만 고려하기 때문이다', 'Prim 알고리즘은 간선만 독립적으로 고려하는 것이 아니라 정점을 중심으로 MST를 확장한다. 간선만 고려하는 것은 Kruskal 알고리즘이다.', false),
       (1292, 475, '사이클을 만들기 위해서', 'Prim 알고리즘은 사이클을 만들지 않는다. 오히려 사이클이 형성되지 않도록 MST 집합에 인접한 정점만 선택한다.', false),
       (1293, 475, 'MST 집합에 속한 정점들과 인접한 정점 중에서 선택하기 때문이다', 'Prim 알고리즘은 현재 MST 집합에 속한 정점들과 인접한 정점들 중에서 최소 가중치 간선으로 연결된 정점을 선택한다. 이러한 방식으로 정점을 중심으로 트리를 확장하기 때문에 정점 선택 기반 알고리즘이다.', true),
       (1294, 475, '정렬이 필요하기 때문이다', 'Prim 알고리즘은 사전 정렬이 필수가 아니다. 우선순위 큐를 사용하여 매 단계마다 최소 간선을 찾는 방식으로 동작한다.', false),

       (1295, 476, '사이클이 생겼을 때', 'Prim 알고리즘은 사이클이 생기지 않도록 정점을 선택한다. 사이클 발생은 종료 조건이 아니라 방지해야 할 상황이다.', false),
       (1296, 476, 'n-1개의 간선을 선택했을 때', 'Prim 알고리즘은 n개의 정점에 대해 n-1개의 간선을 선택하면 모든 정점이 연결된 트리가 완성되므로 종료한다. 이는 트리의 기본 성질이다.', true),
       (1297, 476, '모든 간선을 확인했을 때', 'Prim 알고리즘은 모든 간선을 확인하는 것이 종료 조건이 아니다. n-1개의 간선을 선택하면 종료한다.', false),
       (1298, 476, '정렬이 끝났을 때', 'Prim 알고리즘은 사전 정렬을 필수로 하지 않으며, 정렬 완료가 종료 조건이 아니다. n-1개 간선 선택이 종료 조건이다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (149, 470, '정점,vertex,vertices,버텍스,노드,node',
        'Prim 알고리즘은 정점(vertex)을 기준으로 신장 트리를 확장하는 알고리즘이다. 시작 정점에서 출발하여 MST 집합에 인접한 정점들 중 최소 가중치로 연결된 정점을 하나씩 추가하면서 트리를 확장한다.'),
       (150, 473, 'o(e log v),O(ElogV),o(elog v),O(E log V),o(elgv),O(ELgV)',
        'Prim 알고리즘의 시간 복잡도는 우선순위 큐를 사용할 때 O(E log V)이다. 여기서 E는 간선의 개수, V는 정점의 개수를 의미한다. 각 간선에 대해 우선순위 큐 연산(log V)을 수행하기 때문이다.');

-- =====================================================
-- Lesson 76: Kruskal 알고리즘 문제집
-- =====================================================

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (477, 76, '아래 제시한 개념에 대한 설명으로 옳은 것은?', 'Kruskal 알고리즘은 최소 신장 트리를 구하는 방법이다.', 'OBJECTIVE'),
       (478, 76, '빈칸에 들어갈 알맞은 말을 작성하시오', 'Kruskal 알고리즘은 ___을 기준으로 간선을 선택하는 알고리즘이다.', 'SUBJECTIVE'),
       (479, 76, '제시된 내용과 관련하여 옳은 것은?', 'Kruskal 알고리즘은 특정 순서로 동작한다.', 'OBJECTIVE'),
       (480, 76, '아래 제시한 개념에 대한 설명으로 옳은 것은?', 'Union-Find는 Kruskal에서 중요한 역할을 한다.', 'OBJECTIVE'),
       (481, 76, '빈칸에 들어갈 알맞은 말을 작성하시오', 'Kruskal 알고리즘의 시간 복잡도는 ___이다. (Union-Find 사용 시)', 'SUBJECTIVE'),
       (482, 76, '제시된 내용과 관련하여 옳은 것은?', 'Kruskal은 특정 방식으로 동작한다.', 'OBJECTIVE'),
       (483, 76, '제시된 내용과 관련하여 옳은 것은?', '두 알고리즘은 접근 방식이 다르다.', 'OBJECTIVE'),
       (484, 76, '제시된 내용과 관련하여 옳은 것은?', 'Find 연산은 집합을 찾는다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (1299, 477, '우선순위 큐가 필수인 알고리즘', '우선순위 큐는 Prim 알고리즘에서 주로 사용된다. Kruskal 알고리즘은 간선을 정렬한 후 순차적으로 선택한다.', false),
       (1300, 477, '탐욕적 방법을 이용하여 모든 정점을 최소 비용으로 연결하는 간선 선택 기반 알고리즘', 'Kruskal 알고리즘은 탐욕적(greedy) 방법을 사용하여 가중치가 작은 간선부터 선택하면서 모든 정점을 최소 비용으로 연결하는 간선 선택 기반 알고리즘이다.', true),
       (1301, 477, '최단 경로를 찾는 알고리즘', 'Kruskal 알고리즘은 최단 경로가 아닌 최소 신장 트리를 구하는 알고리즘이다. 최단 경로는 Dijkstra나 Bellman-Ford 알고리즘이 사용된다.', false),
       (1302, 477, '정점을 선택하는 알고리즘', '정점을 선택하는 것은 Prim 알고리즘의 방식이다. Kruskal 알고리즘은 간선을 선택한다.', false),

       (1303, 479, '정렬하지 않는다', 'Kruskal 알고리즘은 첫 단계에서 모든 간선을 가중치 기준으로 정렬한다. 이는 Kruskal의 핵심 단계 중 하나이다.', false),
       (1304, 479, '정점부터 선택한다', '정점부터 선택하는 것은 Prim 알고리즘의 방식이다. Kruskal 알고리즘은 간선을 정렬한 후 선택한다.', false),
       (1305, 479, '사이클을 만든다', 'Kruskal 알고리즘은 사이클을 만들지 않는다. Union-Find를 사용하여 사이클이 형성되는 간선은 선택하지 않는다.', false),
       (1306, 479, '간선들을 가중치 오름차순으로 정렬하고 정렬된 순서대로 사이클을 형성하지 않는 간선 선택하며 n-1개의 간선을 선택할 때까지 반복한다', 'Kruskal 알고리즘의 동작 과정은 1) 모든 간선을 가중치 오름차순으로 정렬, 2) 정렬된 순서대로 사이클을 형성하지 않는 간선 선택, 3) n-1개의 간선을 선택할 때까지 반복한다.', true),

       (1307, 480, '정점을 선택하는 연산', 'Union-Find는 정점을 선택하는 연산이 아니라 집합 연산을 수행하는 자료구조이다. 두 원소가 같은 집합에 속하는지 확인하고 두 집합을 합친다.', false),
       (1308, 480, '간선 추가 시 사이클 형성 여부를 판단하기 위한 연산으로 두 정점이 같은 집합에 속하는지 검사한다', 'Union-Find는 간선 추가 시 사이클 형성 여부를 판단하기 위한 자료구조이다. Find 연산으로 두 정점이 같은 집합에 속하는지 검사하고, Union 연산으로 두 집합을 합친다.', true),
       (1309, 480, '간선을 정렬하는 연산', 'Union-Find는 간선 정렬과는 무관하다. 간선 정렬은 Kruskal 알고리즘의 첫 단계에서 별도로 수행된다.', false),
       (1310, 480, '최단 경로를 찾는 연산', 'Union-Find는 최단 경로 탐색이 아니라 집합 관리를 위한 자료구조이다. 두 원소의 집합 소속 여부를 확인하고 집합을 합치는 연산을 제공한다.', false),

       (1311, 482, '정점을 중심으로 확장한다', '정점을 중심으로 확장하는 것은 Prim 알고리즘의 특징이다. Kruskal 알고리즘은 간선을 독립적으로 선택한다.', false),
       (1312, 482, '최적 해답이 보장되지 않는다', 'Kruskal 알고리즘은 탐욕적 방법을 사용하지만 최소 신장 트리를 정확히 찾는 최적 해답이 보장되는 알고리즘이다.', false),
       (1313, 482, '이전 신장 트리와 무관하게 최소 간선만 선택하고 Union-Find 연산으로 사이클 여부를 판단하며 최적 해답이 보장된다', 'Kruskal 알고리즘은 이전 단계의 신장 트리와 무관하게 가중치가 작은 간선부터 독립적으로 선택하며, Union-Find 연산으로 사이클 여부를 판단한다. 탐욕적 방법이지만 최적 해답이 보장된다.', true),
       (1314, 482, '우선순위 큐가 필수이다', '우선순위 큐는 Prim 알고리즘에서 주로 사용된다. Kruskal 알고리즘은 간선을 정렬한 후 순차적으로 선택하므로 우선순위 큐가 필수가 아니다.', false),

       (1315, 483, '두 알고리즘은 동일하다', 'Prim과 Kruskal 알고리즘은 모두 최소 신장 트리를 구하지만 접근 방식이 완전히 다르다. Prim은 정점 선택 기반, Kruskal은 간선 선택 기반이다.', false),
       (1316, 483, 'Prim은 정점 선택 기반이고 Kruskal은 간선 선택 기반이며 Prim은 이전 트리를 확장하고 Kruskal은 간선을 독립 선택한다', 'Prim 알고리즘은 정점 선택 기반으로 이전 트리를 확장하는 방식이고, Kruskal 알고리즘은 간선 선택 기반으로 간선을 독립적으로 선택하는 방식이다. 두 알고리즘 모두 최소 신장 트리를 구하지만 접근 방식이 다르다.', true),
       (1317, 483, 'Kruskal은 정점을 선택한다', 'Kruskal 알고리즘은 정점이 아닌 간선을 선택하는 간선 선택 기반 알고리즘이다. 정점을 선택하는 것은 Prim 알고리즘이다.', false),
       (1318, 483, 'Prim이 항상 더 빠르다', '어느 알고리즘이 더 빠른지는 그래프의 특성(간선과 정점의 개수)에 따라 다르다. 일반적으로 간선이 적으면 Kruskal이, 간선이 많으면 Prim이 유리할 수 있다.', false),

       (1319, 484, '사이클을 만드는 연산', 'Find 연산은 사이클을 만드는 것이 아니라 사이클 형성 여부를 판단하는 데 사용된다. 두 정점의 대표 원소가 같으면 사이클이 형성된다.', false),
       (1320, 484, '간선을 정렬하는 연산', 'Find 연산은 간선 정렬과 무관하다. Find는 원소가 속한 집합의 대표 원소를 찾는 연산이다.', false),
       (1321, 484, '원소가 속한 집합의 대표 원소를 찾는 연산', 'Find 연산은 주어진 원소가 속한 집합의 대표 원소(root)를 찾는 연산이다. 두 원소의 Find 결과가 같으면 같은 집합에 속하므로, 사이클 여부를 판단할 수 있다.', true),
       (1322, 484, '두 집합을 합치는 연산', '두 집합을 합치는 것은 Union 연산의 역할이다. Find 연산은 원소가 속한 집합의 대표 원소를 찾는다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (151, 478, '간선,edge,가중치,weight,웨이트,에지',
        'Kruskal 알고리즘은 간선(edge)을 기준으로 간선을 선택하는 알고리즘이다. 모든 간선을 가중치 오름차순으로 정렬한 후, 가중치가 작은 간선부터 순차적으로 선택하면서 MST를 구성한다.'),
       (152, 481, 'o(e log e),O(ElogE),o(elog e),O(E log E),o(elge),O(ElgE)',
        'Kruskal 알고리즘의 시간 복잡도는 Union-Find 사용 시 O(E log E)이다. 간선 정렬에 O(E log E)가 소요되며, 이것이 전체 시간 복잡도를 결정한다. Union-Find 연산은 거의 O(1)에 가까운 시간에 수행된다.');
