-- Unit: 합병 정렬 (Unit ID: 18)
-- Chapter: 알고리즘 (Chapter ID: 2)

-- Lesson 생성
INSERT INTO lesson (id, unit_id, title)
VALUES (51, 18, '합병 정렬 기초 문제집'),
       (52, 18, '합병 정렬 동작 과정 문제집'),
       (53, 18, '합병 정렬 분석 문제집');

-- =====================================================
-- Lesson 51: 합병 정렬 기초 문제집
-- =====================================================

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (301, 51, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '합병 정렬은 특정한 방식으로 동작하는 정렬 알고리즘이다.', 'OBJECTIVE'),
       (302, 51, '빈칸에 들어갈 알맞은 말을 작성하시오', '합병 정렬은 ___방식을 사용하여 배열을 절반씩 나누어 정렬한 후 합병하며 정렬한다.', 'SUBJECTIVE'),
       (303, 51, '제시된 내용과 관련하여 옳은 것은?', '합병 정렬은 특정한 특징을 가진다.', 'OBJECTIVE'),
       (304, 51, '제시된 내용과 관련하여 옳은 것은?', '합병 정렬은 특정한 시간 복잡도를 가진다.', 'OBJECTIVE'),
       (305, 51, '빈칸에 들어갈 알맞은 말을 작성하시오', '합병 정렬은 모든 경우에 ___의 안정적인 성능을 보인다.', 'SUBJECTIVE'),
       (306, 51, '제시된 내용과 관련하여 옳은 것은?', '합병 정렬은 안정성과 관련된 특성을 가진다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (801, 301, '가장 작은 값을 찾아 앞으로 이동시키는 알고리즘이다',
        '이는 선택 정렬의 특징이다. 합병 정렬은 분할 정복 방식을 사용한다.', false),
       (802, 301, '분할 정복 방식을 사용하여 배열을 절반씩 나누어 정렬한 후 합병하며 정렬하는 알고리즘이다',
        '합병 정렬은 분할 정복(Divide and Conquer) 방식을 사용하여, 배열을 절반씩 나누어 정렬한 후 합병하며 정렬하는 알고리즘이다. 재귀적 구조로 구현되며 추가 메모리가 필요하다.',
        true),
       (803, 301, '인접한 두 원소를 비교하여 교환하는 알고리즘이다',
        '이는 버블 정렬의 특징이다. 합병 정렬은 배열을 분할하여 정렬 후 합병한다.', false),
       (804, 301, '피벗을 기준으로 비균등 분할하는 알고리즘이다',
        '이는 퀵 정렬의 특징이다. 합병 정렬은 균등하게 절반씩 분할한다.', false),

       (805, 303, '분할 정복 알고리즘의 대표적인 예시이며 재귀적 구조로 문제를 해결하고 안정 정렬이다',
        '합병 정렬은 분할 정복 알고리즘의 대표적인 예시이며, 재귀적 구조로 문제를 해결하고, 배열을 절반씩 분할하여 크기 1이 될 때까지 나눈다. 안정 정렬로 동일한 값의 순서를 유지한다.',
        true),
       (806, 303, '비균등하게 분할한다',
        '합병 정렬은 균등하게 절반씩 분할한다. 비균등 분할은 퀵 정렬의 특징이다.', false),
       (807, 303, '제자리 정렬이다',
        '합병 정렬은 추가 메모리가 필요하다. 제자리 정렬이 아니다.', false),
       (808, 303, '불안정 정렬이다',
        '합병 정렬은 안정 정렬이다. 동일한 값의 순서를 유지한다.', false),

       (809, 304, '최선 O(n), 평균 O(n²), 최악 O(n²)이다',
        '합병 정렬은 모든 경우에 O(n log n)이다. O(n²)이 아니다.', false),
       (810, 304, '모든 경우에 O(n log n)이다',
        '합병 정렬의 시간 복잡도는 최선, 평균, 최악의 경우 모두 O(n log n)이다. 모든 경우에 O(n log n)의 안정적인 성능을 보이며, 데이터 분포에 영향을 덜 받는다.',
        true),
       (811, 304, '최선 O(n log n), 평균 O(n log n), 최악 O(n²)이다',
        '합병 정렬은 최악의 경우에도 O(n log n)이다. O(n²)이 되지 않는다.', false),
       (812, 304, '모든 경우에 O(n²)이다',
        '합병 정렬은 O(n log n)이다. O(n²)이 아니다.', false),

       (813, 306, '안정 정렬이며 동일한 값의 순서를 유지한다',
        '합병 정렬은 안정 정렬(Stable Sort)이다. 동일한 값의 순서가 유지되므로 동일한 키를 가진 데이터의 상대적 순서가 변하지 않는다.',
        true),
       (814, 306, '불안정 정렬이며 동일한 값의 순서가 바뀔 수 있다',
        '합병 정렬은 안정 정렬이다. 동일한 값의 순서가 유지된다.', false),
       (815, 306, '동일한 값을 처리할 수 없다',
        '합병 정렬은 동일한 값을 처리할 수 있으며 순서를 유지한다.', false),
       (816, 306, '동일한 값은 항상 제거된다',
        '합병 정렬은 동일한 값을 유지한다. 제거하지 않는다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (101, 302, '분할 정복,분할정복,divide and conquer,divide&conquer,분할-정복',
        '합병 정렬은 분할 정복(Divide and Conquer) 방식을 사용하여 배열을 절반씩 나누어 정렬한 후 합병하며 정렬한다. 문제를 작은 문제로 나누어 해결하는 방식이다.'),
       (102, 305, 'o(n log n),o(nlogn),nlogn,n log n',
        '합병 정렬은 모든 경우에 O(n log n)의 안정적인 성능을 보인다. 최선, 평균, 최악의 경우 모두 동일한 시간 복잡도를 가진다.');

-- =====================================================
-- Lesson 52: 합병 정렬 동작 과정 문제집
-- =====================================================

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (307, 52, '제시된 내용과 관련하여 옳은 것은?', '합병 정렬은 분할 단계를 포함한다.', 'OBJECTIVE'),
       (308, 52, '빈칸에 들어갈 알맞은 말을 작성하시오', '합병 정렬은 배열을 ___이 될 때까지 반복적으로 분할한다.', 'SUBJECTIVE'),
       (309, 52, '제시된 내용과 관련하여 옳은 것은?', '합병 정렬은 정복 단계를 포함한다.', 'OBJECTIVE'),
       (310, 52, '제시된 내용과 관련하여 옳은 것은?', '합병 정렬은 결합 단계를 포함한다.', 'OBJECTIVE'),
       (311, 52, '빈칸에 들어갈 알맞은 말을 작성하시오', '합병 정렬의 ___단계에서 실제 정렬이 이루어진다.', 'SUBJECTIVE'),
       (312, 52, '제시된 내용과 관련하여 옳은 것은?', '합병 정렬은 특정한 방식으로 합병한다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (817, 307, '인접한 원소를 비교하여 분할한다',
        '합병 정렬은 중간 지점을 기준으로 기계적으로 분할한다. 원소 비교로 분할하지 않는다.', false),
       (818, 307, '최솟값을 찾아 분리한다',
        '이는 선택 정렬의 특징이다. 합병 정렬은 중간 지점을 기준으로 분할한다.', false),
       (819, 307, '피벗을 기준으로 비균등하게 분할한다',
        '이는 퀵 정렬의 특징이다. 합병 정렬은 균등하게 절반씩 분할한다.', false),
       (820, 307, '배열을 같은 크기의 2개 부분 배열로 분할하고 크기가 1이 될 때까지 반복한다',
        '합병 정렬의 분할 단계는 배열을 같은 크기의 2개 부분 배열로 분할한다. 배열의 크기가 1이 될 때까지 반복하며, 크기가 1인 배열은 이미 정렬된 것으로 간주한다.',
        true),

       (821, 309, '각 부분 배열을 재귀적으로 정렬하고 크기가 1인 배열은 이미 정렬된 것으로 간주한다',
        '합병 정렬의 정복 단계는 각 부분 배열을 재귀적으로 정렬한다. 크기가 1인 배열은 이미 정렬된 것으로 간주하며, 이것이 재귀의 기저 조건이 된다.',
        true),
       (822, 309, '인접한 원소를 교환한다',
        '이는 버블 정렬의 특징이다. 합병 정렬은 재귀적으로 정렬 후 합병한다.', false),
       (823, 309, '피벗을 확정한다',
        '이는 퀵 정렬의 특징이다. 합병 정렬은 재귀적으로 부분 배열을 정렬한다.', false),
       (824, 309, '최솟값을 앞으로 이동시킨다',
        '이는 선택 정렬의 특징이다. 합병 정렬은 재귀적으로 정렬한다.', false),

       (825, 310, '정렬된 2개의 부분 배열을 하나의 정렬된 배열로 합병하며 이 단계에서 실제 정렬이 이루어진다',
        '합병 정렬의 결합 단계는 정렬된 2개의 부분 배열을 하나의 정렬된 배열로 합병한다. 이 단계에서 실제 정렬이 이루어지며, 별도 병합 과정이 필요하지 않다.',
        true),
       (826, 310, '결합 단계가 없다',
        '합병 정렬은 결합 단계에서 실제 정렬이 이루어진다. 결합 단계가 필수이다.', false),
       (827, 310, '교환 없이 단순히 연결한다',
        '합병 정렬은 정렬하면서 합병한다. 단순히 연결하는 것이 아니다.', false),
       (828, 310, '피벗을 기준으로 재배치한다',
        '이는 퀵 정렬의 특징이다. 합병 정렬은 정렬된 배열들을 합병한다.', false),

       (829, 312, '큰 값부터 추가한다',
        '합병 정렬은 작은 값부터 순서대로 추가한다. 큰 값부터가 아니다.', false),
       (830, 312, '합병 없이 단순 연결한다',
        '합병 정렬은 비교하며 정렬된 순서로 합병한다. 단순 연결이 아니다.', false),
       (831, 312, '두 부분 배열의 원소를 순차적으로 비교하여 작은 값부터 정렬된 배열에 추가한다',
        '합병 정렬은 두 부분 배열의 원소를 순차적으로 비교하여 작은 값부터 정렬된 배열에 추가한다. 한쪽 배열이 모두 소진되면 나머지 배열의 원소들을 순서대로 추가한다.',
        true),
       (832, 312, '무작위로 선택하여 합병한다',
        '합병 정렬은 체계적으로 작은 값부터 선택하여 합병한다. 무작위가 아니다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (103, 308, '1,크기 1,size 1,크기가 1',
        '합병 정렬은 배열을 크기가 1이 될 때까지 반복적으로 분할한다. 크기가 1인 배열은 이미 정렬된 것으로 간주하며, 이것이 재귀의 기저 조건이다.'),
       (104, 311, '결합,합병,combine,merge,병합',
        '합병 정렬의 결합(Combine) 단계에서 실제 정렬이 이루어진다. 정렬된 두 부분 배열을 하나의 정렬된 배열로 합병하면서 정렬한다.');

-- =====================================================
-- Lesson 53: 합병 정렬 분석 문제집
-- =====================================================

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (313, 53, '제시된 내용과 관련하여 옳은 것은?', '합병 정렬의 시간 복잡도는 특정하게 계산된다.', 'OBJECTIVE'),
       (314, 53, '빈칸에 들어갈 알맞은 말을 작성하시오', '합병 정렬의 공간 복잡도는 합병 과정에서 임시 배열이 필요하므로 ___이다.', 'SUBJECTIVE'),
       (315, 53, '제시된 내용과 관련하여 옳은 것은?', '합병 정렬은 특정한 장점을 가진다.', 'OBJECTIVE'),
       (316, 53, '제시된 내용과 관련하여 옳은 것은?', '합병 정렬은 단점도 가지고 있다.', 'OBJECTIVE'),
       (317, 53, '빈칸에 들어갈 알맞은 말을 작성하시오', '합병 정렬은 ___분할을 수행하며 중간 지점을 기준으로 나눈다.', 'SUBJECTIVE'),
       (318, 53, '제시된 내용과 관련하여 옳은 것은?', '합병 정렬은 실무에서 특정하게 활용된다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (833, 313, '상황에 따라 O(n)부터 O(n²)까지 다르다',
        '합병 정렬은 모든 경우에 O(n log n)으로 일정하다.', false),
       (834, 313, '분할 단계는 log n 깊이이고 합병 단계는 각 단계에서 n번 연산하므로 O(n log n)이다',
        '합병 정렬의 시간 복잡도는 분할 단계에서 배열을 절반씩 나누므로 깊이는 log₂n이고, 합병 단계에서 각 단계마다 모든 원소를 비교하고 이동하므로 n번 연산한다. 전체는 O(n) × O(log n) = O(n log n)이다.',
        true),
       (835, 313, '최선의 경우 O(n)이다',
        '합병 정렬은 모든 경우에 O(n log n)이다. 최선의 경우도 O(n log n)이다.', false),
       (836, 313, '모든 경우에 O(n²)이다',
        '합병 정렬은 O(n log n)이다. O(n²)이 아니다.', false),

       (837, 315, '제자리 정렬이다',
        '합병 정렬은 추가 메모리가 필요하다. 제자리 정렬이 아니다.', false),
       (838, 315, '추가 메모리가 불필요하다',
        '합병 정렬은 O(n)의 추가 메모리가 필요하다.', false),
       (839, 315, '안정적인 시간 복잡도로 모든 경우 O(n log n)을 보장하고 안정 정렬이며 데이터 분포에 영향을 덜 받는다',
        '합병 정렬의 장점은 안정적인 시간 복잡도로 모든 경우 O(n log n)을 보장하고, 안정 정렬로 동일한 값의 순서를 유지하며, 데이터 분포에 영향을 덜 받고, 연결 리스트로 구현 시 효율적이고, 대용량 데이터 정렬에 적합하다.',
        true),
       (840, 315, '작은 데이터에서 가장 빠르다',
        '작은 데이터에서는 삽입 정렬이 더 빠를 수 있다. 합병 정렬은 대용량 데이터에 적합하다.', false),

       (841, 316, '추가 메모리가 필요하며 제자리 정렬이 아니고 작은 데이터에서는 삽입 정렬보다 느릴 수 있다',
        '합병 정렬의 단점은 추가 메모리가 필요하고(O(n)의 공간 복잡도), 제자리 정렬이 아니며, 작은 데이터에서는 삽입 정렬보다 느릴 수 있다는 것이다.',
        true),
       (842, 316, '불안정 정렬이다',
        '합병 정렬은 안정 정렬이다. 동일한 값의 순서를 유지한다.', false),
       (843, 316, '데이터 분포에 크게 영향을 받는다',
        '합병 정렬은 데이터 분포에 영향을 덜 받는다. 이는 장점이다.', false),
       (844, 316, '시간 복잡도가 O(n²)이다',
        '합병 정렬은 O(n log n)이다. O(n²)이 아니다.', false),

       (845, 318, 'Python의 Timsort와 Java의 정렬은 합병 정렬을 기반으로 한다',
        '합병 정렬은 안정성과 예측 가능한 성능이 중요한 경우에 적합하다. Python의 Timsort와 Java의 정렬은 합병 정렬을 기반으로 한다. 하지만 일반적인 경우 퀵 정렬이 더 빠른 경향이 있다.',
        true),
       (846, 318, '작은 데이터에만 사용된다',
        '합병 정렬은 대용량 데이터 정렬에 적합하다. 작은 데이터에만 사용되지 않는다.', false),
       (847, 318, '실무에서 전혀 사용되지 않는다',
        '합병 정렬은 Python, Java 등의 표준 정렬에서 사용된다. 실무에서 활용된다.', false),
       (848, 318, '네트워크 라우팅에만 사용된다',
        '합병 정렬은 다양한 정렬 상황에서 사용된다. 네트워크 라우팅에만 국한되지 않는다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (105, 314, 'o(n),공간 복잡도 o(n),O(n)',
        '합병 정렬의 공간 복잡도는 합병 과정에서 임시 배열이 필요하므로 O(n)이다. 배열 크기만큼의 추가 메모리를 사용한다.'),
       (106, 317, '균등,균등 분할,equal,even,균등한',
        '합병 정렬은 균등 분할을 수행하며 중간 지점을 기준으로 나눈다. 항상 절반씩 동일한 크기로 분할한다. 이는 퀵 정렬의 비균등 분할과 차이가 있다.');
