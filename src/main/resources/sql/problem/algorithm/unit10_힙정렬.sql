-- Unit: 힙 정렬 (Unit ID: 20)
-- Chapter: 알고리즘 (Chapter ID: 2)

-- Lesson 생성
INSERT INTO lesson (id, unit_id, title)
VALUES (57, 20, '힙 정렬 기초 문제집'),
       (58, 20, '힙 정렬 동작 과정 문제집'),
       (59, 20, '힙 정렬 분석 문제집');

-- =====================================================
-- Lesson 57: 힙 정렬 기초 문제집
-- =====================================================

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (337, 57, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '힙 정렬은 특정한 자료구조를 활용하는 정렬 알고리즘이다.', 'OBJECTIVE'),
       (338, 57, '빈칸에 들어갈 알맞은 말을 작성하시오', '힙 정렬은 완전 이진 트리 기반의 ___을 활용하는 정렬 알고리즘이다.', 'SUBJECTIVE'),
       (339, 57, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '힙 정렬은 여러 가지 특징을 가진다.', 'OBJECTIVE'),
       (340, 57, '제시된 내용과 관련하여 옳은 것은?', '힙 정렬은 특정한 시간 복잡도를 가진다.', 'OBJECTIVE'),
       (341, 57, '빈칸에 들어갈 알맞은 말을 작성하시오', '힙 정렬은 ___이므로 추가 메모리를 최소화할 수 있다.', 'SUBJECTIVE'),
       (342, 57, '제시된 내용과 관련하여 옳은 것은?', '힙 정렬은 안정성과 관련된 특징을 가진다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (897, 337, '배열을 균등하게 분할하는 알고리즘이다',
        '이는 합병 정렬의 특징이다. 힙 정렬은 힙 자료구조를 활용한다.', false),
       (898, 337, '인접한 원소를 비교하여 정렬하는 알고리즘이다',
        '이는 버블 정렬의 특징이다. 힙 정렬은 힙 자료구조를 활용한다.', false),
       (899, 337, '완전 이진 트리 기반의 힙 자료구조를 활용하며 제자리 정렬이 가능하고 최악의 경우에도 O(n log n)을 보장하는 선택 정렬의 개선 형태이다',
        '힙 정렬은 완전 이진 트리 기반의 힙(Heap) 자료구조를 활용하는 정렬 알고리즘이다. 선택 정렬의 개선 형태로, 제자리 정렬이 가능하며 최악의 경우에도 O(n log n)을 보장한다.',
        true),
       (900, 337, '피벗을 기준으로 분할하는 알고리즘이다',
        '이는 퀵 정렬의 특징이다. 힙 정렬은 힙 자료구조를 활용한다.', false),

       (901, 339, '추가 메모리가 O(n) 필요하다',
        '힙 정렬은 제자리 정렬로 추가 메모리가 O(1)이다. O(n)이 아니다.', false),
       (902, 339, '안정 정렬이다',
        '힙 정렬은 불안정 정렬이다. 동일한 값의 순서가 바뀔 수 있다.', false),
       (903, 339, '최악의 경우 O(n²)이다',
        '힙 정렬은 최악의 경우에도 O(n log n)을 보장한다. O(n²)이 아니다.', false),
       (904, 339, '완전 이진 트리 기반의 힙 자료구조를 활용하며 제자리 정렬이 가능하고 불안정 정렬이며 최악의 경우에도 O(n log n)을 보장한다',
        '힙 정렬은 완전 이진 트리 기반의 힙 자료구조를 활용하고, 제자리 정렬(In-place Sort)로 추가 메모리를 최소화하며, 불안정 정렬(Unstable Sort)로 동일 값의 순서가 바뀔 수 있고, 최악의 경우에도 O(n log n)을 보장하며, 우선순위 큐의 구현 원리와 동일하다.',
        true),

       (905, 340, '평균 O(n log n), 최악 O(n²)이다',
        '힙 정렬은 최악의 경우에도 O(n log n)이다. O(n²)이 아니다.', false),
       (906, 340, '최선/평균/최악 모두 O(n log n)이다',
        '힙 정렬의 시간 복잡도는 최선, 평균, 최악 모두 O(n log n)이다. 힙 구축은 O(n)이고, 정렬 단계는 O(n log n)이므로 총 시간 복잡도는 O(n log n)이다.',
        true),
       (907, 340, '최선 O(n), 평균 O(n log n), 최악 O(n²)이다',
        '힙 정렬은 모든 경우에 O(n log n)이다. 최선이 O(n)이 아니다.', false),
       (908, 340, '모든 경우에 O(n²)이다',
        '힙 정렬은 모든 경우에 O(n log n)이다. O(n²)이 아니다.', false),

       (909, 342, '불안정 정렬이며 동일한 값의 순서가 바뀔 수 있다',
        '힙 정렬은 불안정 정렬(Unstable Sort)이다. 동일한 값의 순서가 바뀔 수 있으므로 동일한 키를 가진 데이터의 상대적 순서가 변할 수 있다.',
        true),
       (910, 342, '동일한 값을 처리할 수 없다',
        '힙 정렬은 동일한 값을 처리할 수 있지만 순서가 바뀔 수 있다.', false),
       (911, 342, '안정 정렬이며 동일한 값의 순서를 유지한다',
        '힙 정렬은 불안정 정렬이다. 동일한 값의 순서가 바뀔 수 있다.', false),
       (912, 342, '동일한 값은 항상 제거된다',
        '힙 정렬은 동일한 값을 유지한다. 제거하지 않는다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (113, 338, '힙,heap,Heap,HEAP',
        '힙 정렬은 완전 이진 트리 기반의 힙(Heap) 자료구조를 활용하는 정렬 알고리즘이다. 최대 힙 또는 최소 힙을 구축하여 정렬한다.'),
       (114, 341, '제자리 정렬,in-place sort,in place sort,inplace sort,제자리정렬',
        '힙 정렬은 제자리 정렬(In-place Sort)이므로 추가 메모리를 최소화할 수 있다. 추가 배열이 불필요하여 공간 복잡도가 O(1)이다.');

-- =====================================================
-- Lesson 58: 힙 정렬 동작 과정 문제집
-- =====================================================

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (343, 58, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '힙 정렬은 힙 구축 단계를 포함한다.', 'OBJECTIVE'),
       (344, 58, '빈칸에 들어갈 알맞은 말을 작성하시오', '오름차순 정렬을 위해서는 ___을 구축하고 내림차순 정렬을 위해서는 최소 힙을 구축한다.', 'SUBJECTIVE'),
       (345, 58, '제시된 내용과 관련하여 옳은 것은?', '힙 정렬은 정렬 단계를 포함한다.', 'OBJECTIVE'),
       (346, 58, '아래 제시한 개념에 대한 설명으로 옳은 것은?', 'Heapify는 힙 정렬의 핵심 과정이다.', 'OBJECTIVE'),
       (347, 58, '빈칸에 들어갈 알맞은 말을 작성하시오', '힙 정렬은 루트 노드를 삭제한 후 마지막 노드를 루트 위치로 이동시키고 ___을 수행한다.', 'SUBJECTIVE'),
       (348, 58, '제시된 내용과 관련하여 옳은 것은?', '힙 정렬은 특정한 방법으로 최댓값을 추출한다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (913, 343, '피벗을 선택한다',
        '이는 퀵 정렬의 특징이다. 힙 정렬은 힙을 구축한다.', false),
       (914, 343, '정렬되지 않은 배열을 최대 힙 또는 최소 힙으로 변환한다',
        '힙 정렬의 힙 구축 단계는 정렬되지 않은 배열을 최대 힙(Max Heap) 또는 최소 힙(Min Heap)으로 변환한다. 오름차순 정렬은 최대 힙, 내림차순 정렬은 최소 힙을 사용한다.',
        true),
       (915, 343, '배열을 균등하게 분할한다',
        '이는 합병 정렬의 특징이다. 힙 정렬은 힙 자료구조로 변환한다.', false),
       (916, 343, '최솟값을 찾는다',
        '힙 구축은 전체 배열을 힙 구조로 만드는 것이다. 최솟값만 찾는 것이 아니다.', false),

       (917, 345, '힙의 루트를 배열의 마지막 원소와 교환한 후 힙 크기를 줄이고 힙을 재구성하며 배열 크기가 1이 될 때까지 반복한다',
        '힙 정렬의 정렬 단계는 힙의 루트(최댓값 또는 최솟값)를 배열의 마지막 원소와 교환한 후, 힙 크기를 줄이고 힙을 재구성한다. 배열 크기가 1이 될 때까지 반복한다.',
        true),
       (918, 345, '한 번만 수행하고 종료한다',
        '힙 정렬은 배열 크기가 1이 될 때까지 반복한다. 한 번만 수행하지 않는다.', false),
       (919, 345, '배열을 합병한다',
        '이는 합병 정렬의 특징이다. 힙 정렬은 루트를 교환하고 힙을 재구성한다.', false),
       (920, 345, '피벗을 기준으로 분할한다',
        '이는 퀵 정렬의 특징이다. 힙 정렬은 루트를 교환한다.', false),

       (921, 346, '배열을 분할하는 과정이다',
        'Heapify는 힙 속성을 유지하는 과정이다. 배열을 분할하지 않는다.', false),
       (922, 346, '정렬을 완성하는 과정이다',
        'Heapify는 힙 속성을 유지하는 보조 과정이다. 정렬을 직접 완성하지 않는다.', false),
       (923, 346, '최솟값을 찾는 과정이다',
        'Heapify는 힙 속성을 재구성하는 과정이다. 최솟값만 찾는 것이 아니다.', false),
       (924, 346, '특정 노드를 루트로 하는 부분 트리를 힙 속성에 맞게 재구성하는 과정이다',
        'Heapify는 특정 노드를 루트로 하는 부분 트리를 힙 속성에 맞게 재구성하는 과정이다. 부모 노드와 자식 노드를 비교하며 힙 속성을 만족할 때까지 교환한다.',
        true),

       (925, 348, '최대 힙의 루트 노드에 항상 최댓값이 위치하므로 O(1) 시간에 접근 가능하다',
        '힙 정렬에서 최댓값을 추출하는 방법은 최대 힙의 루트 노드에 항상 최댓값이 위치하므로 O(1) 시간에 접근 가능하다. 루트를 제거한 후 힙을 재구성한다.',
        true),
       (926, 348, '배열 전체를 순회해야 한다',
        '최댓값은 루트 노드에 위치하므로 순회가 불필요하다.', false),
       (927, 348, '리프 노드에서 찾는다',
        '최댓값은 루트 노드에 위치한다. 리프 노드가 아니다.', false),
       (928, 348, '중간 노드에서 찾는다',
        '최댓값은 항상 루트 노드에 위치한다. 중간 노드가 아니다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (115, 344, '최대 힙,max heap,Max Heap,MAX HEAP,최대힙,맥스힙',
        '오름차순 정렬을 위해서는 최대 힙(Max Heap)을 구축하고 내림차순 정렬을 위해서는 최소 힙을 구축한다. 최대 힙의 루트에는 항상 최댓값이 위치한다.'),
       (116, 347, 'heapify,Heapify,HEAPIFY,힙 재구성,힙재구성,재구성',
        '힙 정렬은 루트 노드를 삭제한 후 마지막 노드를 루트 위치로 이동시키고 Heapify를 수행한다. Heapify는 힙 속성을 재구성하는 과정이다.');

-- =====================================================
-- Lesson 59: 힙 정렬 분석 문제집
-- =====================================================

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (349, 59, '제시된 내용과 관련하여 옳은 것은?', '힙 정렬은 특정한 시간 복잡도를 가진다.', 'OBJECTIVE'),
       (350, 59, '빈칸에 들어갈 알맞은 말을 작성하시오', '힙 정렬은 제자리 정렬이므로 추가 메모리가 ___이다.', 'SUBJECTIVE'),
       (351, 59, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '힙 정렬은 여러 가지 장점을 가진다.', 'OBJECTIVE'),
       (352, 59, '제시된 내용과 관련하여 옳은 것은?', '힙 정렬은 단점도 가지고 있다.', 'OBJECTIVE'),
       (353, 59, '빈칸에 들어갈 알맞은 말을 작성하시오', '힙 정렬은 같은 O(n log n)인 ___보다 2~3배 느리다.', 'SUBJECTIVE'),
       (354, 59, '제시된 내용과 관련하여 옳은 것은?', '힙 정렬과 퀵 정렬은 차이가 있다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (929, 349, '모든 경우에 O(n²)이다',
        '힙 정렬은 모든 경우에 O(n log n)이다. O(n²)이 아니다.', false),
       (930, 349, '힙 구축은 O(n log n)이다',
        '힙 구축은 O(n)이다. O(n log n)이 아니다.', false),
       (931, 349, '힙 구축은 O(n)이고 정렬 단계는 O(n log n)이므로 총 시간 복잡도는 O(n log n)이다',
        '힙 정렬의 시간 복잡도는 힙 구축 O(n)과 정렬 단계 O(n log n)으로 구성되며, 총 시간 복잡도는 O(n) + O(n log n) = O(n log n)이다. 모든 경우에 O(n log n)을 보장한다.',
        true),
       (932, 349, '평균 O(n log n), 최악 O(n²)이다',
        '힙 정렬은 최악의 경우에도 O(n log n)이다. O(n²)이 아니다.', false),

       (933, 351, '안정 정렬이다',
        '힙 정렬은 불안정 정렬이다. 동일한 값의 순서가 바뀔 수 있다.', false),
       (934, 351, '캐시 효율성이 매우 높다',
        '힙 정렬은 캐시 지역성이 낮다. 부모-자식 노드 간 메모리 주소가 멀어 캐시 효율이 저하된다.', false),
       (935, 351, '안정적인 시간 복잡도로 최악의 경우에도 O(n log n)을 보장하고 제자리 정렬로 추가 메모리가 O(1)이며 예측 가능하고 최댓값이나 최솟값 추출에 효율적이다',
        '힙 정렬의 장점은 안정적인 성능으로 최악의 경우에도 O(n log n)을 보장하고, 제자리 정렬로 추가 메모리가 O(1)이며, 예측 가능하여 입력 데이터에 관계없이 일정한 성능을 보이고, 최댓값/최솟값 추출 시 효율적이다.',
        true),
       (936, 351, '퀵 정렬보다 빠르다',
        '힙 정렬은 같은 O(n log n)인 퀵 정렬보다 2~3배 느리다.', false),

       (937, 352, '구현이 매우 복잡하다',
        '힙 정렬의 구현은 중간 수준의 복잡도이다. 매우 복잡하지 않다.', false),
       (938, 352, '최악의 경우 O(n²)이다',
        '힙 정렬은 최악의 경우에도 O(n log n)이다. O(n²)이 아니다.', false),
       (939, 352, '추가 메모리가 O(n) 필요하다',
        '힙 정렬은 제자리 정렬로 추가 메모리가 O(1)이다. O(n)이 아니다.', false),
       (940, 352, '불안정 정렬이며 캐시 지역성이 낮고 실제 수행 시간이 같은 O(n log n)인 퀵 정렬보다 2~3배 느리다',
        '힙 정렬의 단점은 불안정 정렬로 동일 값의 순서가 보장되지 않고, 캐시 지역성이 낮아 부모-자식 노드 간 메모리 주소가 멀어 캐시 효율이 저하되며, 실제 수행 시간이 같은 O(n log n)인 퀵 정렬보다 2~3배 느리다.',
        true),

       (941, 354, '힙 정렬이 항상 퀵 정렬보다 빠르다',
        '일반적으로 퀵 정렬이 힙 정렬보다 2~3배 빠르다.', false),
       (942, 354, '힙 정렬은 평균 O(n log n)이고 퀵 정렬도 평균 O(n log n)이지만 힙 정렬은 최악의 경우에도 O(n log n)을 보장하고 퀵 정렬은 최악 O(n²)이다',
        '힙 정렬은 평균/최악 모두 O(n log n)이고, 공간 복잡도는 O(1)이며, 불안정 정렬이고, 수행 속도는 느리지만, 최악 보장이 필요한 경우 적합하다. 퀵 정렬은 평균 O(n log n), 최악 O(n²)이고, 공간 복잡도는 O(log n)이며, 불안정 정렬이고, 수행 속도는 빠르며, 평균 케이스에 적합하다.',
        true),
       (943, 354, '힙 정렬과 퀵 정렬은 완전히 동일하다',
        '힙 정렬과 퀵 정렬은 최악의 경우 시간 복잡도, 수행 속도 등에서 차이가 있다.', false),
       (944, 354, '힙 정렬은 최악 O(n²)이고 퀵 정렬은 최악 O(n log n)이다',
        '반대이다. 힙 정렬은 최악 O(n log n)이고 퀵 정렬은 최악 O(n²)이다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (117, 350, 'o(1),O(1),상수,constant,상수 시간,constant time',
        '힙 정렬은 제자리 정렬이므로 추가 메모리가 O(1)이다. 재귀 구현 시 O(log n)의 스택 공간이 필요하지만, 반복 구현 시 O(1)이다.'),
       (118, 353, '퀵 정렬,quick sort,Quick Sort,QUICK SORT,퀵정렬,빠른 정렬',
        '힙 정렬은 같은 O(n log n)인 퀵 정렬보다 2~3배 느리다. 캐시 지역성이 낮고 실제 수행 시간이 길다. 하지만 최악의 경우를 보장한다.');
