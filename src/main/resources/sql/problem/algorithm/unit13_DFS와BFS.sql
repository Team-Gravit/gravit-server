-- Unit: DFS와 BFS (Unit ID: 23)
-- Chapter: 알고리즘 (Chapter ID: 2)

-- Lesson 생성
INSERT INTO lesson (id, unit_id, title)
VALUES (65, 23, 'DFS 기초 문제집'),
       (66, 23, 'BFS 기초 문제집'),
       (67, 23, 'DFS와 BFS 비교 문제집');

-- =====================================================
-- Lesson 65: DFS 기초 문제집
-- =====================================================

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (389, 65, '아래 제시한 개념에 대한 설명으로 옳은 것은?', 'DFS(깊이 우선 탐색)는 그래프 탐색 알고리즘이다.', 'OBJECTIVE'),
       (390, 65, '빈칸에 들어갈 알맞은 말을 작성하시오', 'DFS는 ___을 사용하여 구현하거나 재귀 함수로 구현한다.', 'SUBJECTIVE'),
       (391, 65, '제시된 내용과 관련하여 옳은 것은?', 'DFS는 여러 가지 특징을 가진 탐색 알고리즘이다.', 'OBJECTIVE'),
       (392, 65, '제시된 내용과 관련하여 옳은 것은?', 'DFS의 시간 복잡도를 고려한다. V는 정점의 개수, E는 간선의 개수를 의미한다.', 'OBJECTIVE'),
       (393, 65, '빈칸에 들어갈 알맞은 말을 작성하시오', 'DFS는 한 방향으로 끝까지 탐색 후 다른 방향을 탐색하는 ___ 방식이다.', 'SUBJECTIVE'),
       (394, 65, '제시된 내용과 관련하여 옳은 것은?', 'DFS의 공간 복잡도는 재귀 깊이에 영향을 받는다.', 'OBJECTIVE'),
       (395, 65, '제시된 내용과 관련하여 옳은 것은?', 'DFS는 다양한 분야에서 활용된다.', 'OBJECTIVE'),
       (396, 65, '제시된 내용과 관련하여 옳은 것은?', 'DFS는 여러 가지 장점을 가진다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (1039, 389, '모든 정점을 동시에 탐색하는 방식이다', 'DFS는 순차적으로 탐색하며 동시에 여러 정점을 탐색하지 않으므로 오답이다.', false),
       (1040, 389, '갈 수 있는 곳까지 최대한 깊이 들어가고 더 이상 갈 곳이 없으면 이전 정점으로 돌아가 다른 경로를 탐색하는 방식이다', 'DFS는 한 방향으로 끝까지 탐색 후 백트래킹하여 다른 경로를 탐색한다. 이는 깊이 우선 탐색의 핵심 개념이다.', true),
       (1041, 389, '시작 정점에서 가까운 정점부터 차례대로 탐색하는 방식이다', '이는 BFS의 설명이다. DFS는 깊이를 우선으로 탐색하므로 오답이다.', false),
       (1042, 389, '가중치가 가장 작은 간선부터 탐색하는 방식이다', '이는 최단 경로 알고리즘의 설명이다. DFS는 가중치와 무관하게 깊이를 우선으로 탐색하므로 오답이다.', false),

       (1043, 391, '스택 또는 재귀 함수로 구현하고 백트래킹 방식으로 동작하며 모든 경로를 탐색해야 하는 문제에 유리하고 구현이 BFS보다 간단하다', 'DFS는 스택이나 재귀로 구현하고, 백트래킹 방식으로 동작하며, 모든 경로 탐색에 유리하고, 구현이 간단하다. 이는 DFS의 핵심 특징들이다.', true),
       (1044, 391, '레벨 순서대로 탐색한다', '이는 BFS의 특징이다. DFS는 깊이 우선으로 탐색하므로 오답이다.', false),
       (1045, 391, '최단 경로를 보장한다', 'DFS는 최단 경로를 보장하지 않는다. 최단 경로를 보장하는 것은 BFS이므로 오답이다.', false),
       (1046, 391, '큐를 사용하여 구현한다', 'DFS는 스택 또는 재귀를 사용하여 구현한다. 큐를 사용하는 것은 BFS이므로 오답이다.', false),

       (1047, 392, '인접 리스트 기준 O(V + E)', 'DFS의 시간 복잡도는 인접 리스트 기준 O(V + E)이다. 모든 정점을 한 번씩 방문하고 모든 간선을 한 번씩 확인하기 때문이다.', true),
       (1048, 392, 'O(V log E)', 'DFS의 시간 복잡도는 O(V + E)이다. O(V log E)는 다른 그래프 알고리즘의 복잡도이므로 오답이다.', false),
       (1049, 392, 'O(E log V)', 'DFS의 시간 복잡도는 O(V + E)이다. O(E log V)는 다른 그래프 알고리즘의 복잡도이므로 오답이다.', false),
       (1050, 392, 'O(V²)', '인접 행렬 기준은 O(V²)이지만 일반적으로 DFS의 시간 복잡도는 인접 리스트 기준으로 표현하므로 오답이다.', false),

       (1051, 394, 'O(V²)', 'DFS의 공간 복잡도는 O(V)이다. O(V²)는 과도하게 큰 값이므로 오답이다.', false),
       (1052, 394, 'O(V)', '재귀 호출 스택의 최대 깊이가 V이므로 O(V)가 정답이다. 최악의 경우 모든 정점을 깊이 방향으로 탐색할 수 있다.', true),
       (1053, 394, 'O(1)', 'DFS는 재귀 스택 공간이 필요하다. 상수 공간만 사용하는 것이 아니므로 오답이다.', false),
       (1054, 394, 'O(E)', 'DFS의 공간 복잡도는 정점 수에 비례한다. 간선 수와는 직접적인 관계가 없으므로 오답이다.', false),

       (1055, 395, '정렬 문제', '정렬은 DFS의 주요 활용 사례가 아니다. 정렬 알고리즘은 별도로 존재하므로 오답이다.', false),
       (1056, 395, '경로 탐색, 사이클 검출, 위상 정렬, 연결 요소 찾기, 백트래킹 문제', 'DFS는 경로 탐색, 사이클 검출, 위상 정렬, 연결 요소 찾기, 백트래킹 문제 등에 활용된다. 이는 DFS의 주요 활용 사례들이다.', true),
       (1057, 395, '레벨별 탐색', '레벨별 탐색은 BFS가 더 적합하다. DFS는 깊이 우선으로 탐색하므로 오답이다.', false),
       (1058, 395, '최단 거리 문제', '최단 거리는 BFS가 더 적합하다. DFS는 최단 경로를 보장하지 않으므로 오답이다.', false),

       (1059, 396, '메모리 사용량이 BFS보다 많다', 'DFS는 현재 경로만 기억하므로 메모리 효율적이다. BFS보다 메모리 사용량이 적으므로 오답이다.', false),
       (1060, 396, '레벨별 탐색이 가능하다', '레벨별 탐색은 BFS의 장점이다. DFS는 깊이 우선으로 탐색하므로 오답이다.', false),
       (1061, 396, '최단 경로를 보장한다', 'DFS는 최단 경로를 보장하지 않는다. 이는 BFS의 장점이므로 오답이다.', false),
       (1062, 396, '구현이 간단하고 현재 경로상의 노드만 기억하므로 메모리 효율적이며 모든 경로를 탐색해야 하는 문제에 적합하고 백트래킹 기법과 함께 사용하기 용이하다', 'DFS는 구현이 간단하고, 메모리 효율적이며, 모든 경로 탐색과 백트래킹에 적합하다. 이러한 특성들이 DFS의 주요 장점이다.', true);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (129, 390, '스택,stack',
        'DFS는 스택을 사용하여 구현하거나 재귀 함수로 구현한다. 재귀 함수도 내부적으로 호출 스택을 사용하므로 본질적으로는 스택을 활용하는 것이다. 스택의 LIFO(Last In First Out) 특성이 깊이 우선 탐색의 핵심 원리이다.'),
       (130, 393, '백트래킹,backtracking,back tracking',
        'DFS는 한 방향으로 끝까지 탐색 후 다른 방향을 탐색하는 백트래킹 방식이다. 더 이상 갈 곳이 없으면 이전 정점으로 되돌아가서 다른 경로를 탐색하는 것이 백트래킹의 핵심 개념이다.');

-- =====================================================
-- Lesson 66: BFS 기초 문제집
-- =====================================================

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (397, 66, '아래 제시한 개념에 대한 설명으로 옳은 것은?', 'BFS(너비 우선 탐색)는 그래프 탐색 알고리즘이다.', 'OBJECTIVE'),
       (398, 66, '빈칸에 들어갈 알맞은 말을 작성하시오', 'BFS는 ___를 사용하여 구현한다.', 'SUBJECTIVE'),
       (399, 66, '제시된 내용과 관련하여 옳은 것은?', 'BFS는 여러 가지 특징을 가진 탐색 알고리즘이다.', 'OBJECTIVE'),
       (400, 66, '제시된 내용과 관련하여 옳은 것은?', 'BFS의 시간 복잡도를 고려한다. V는 정점의 개수, E는 간선의 개수를 의미한다.', 'OBJECTIVE'),
       (401, 66, '빈칸에 들어갈 알맞은 말을 작성하시오', 'BFS는 가중치가 없는 그래프에서 ___를 보장한다.', 'SUBJECTIVE'),
       (402, 66, '제시된 내용과 관련하여 옳은 것은?', 'BFS의 공간 복잡도는 큐의 크기에 영향을 받는다.', 'OBJECTIVE'),
       (403, 66, '제시된 내용과 관련하여 옳은 것은?', 'BFS는 다양한 분야에서 활용된다.', 'OBJECTIVE'),
       (404, 66, '제시된 내용과 관련하여 옳은 것은?', 'BFS는 여러 가지 장점을 가진다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (1063, 397, '가중치가 가장 작은 간선부터 탐색하는 방식이다', '이는 최단 경로 알고리즘의 설명이다. BFS는 가중치와 무관하게 가까운 정점부터 탐색하므로 오답이다.', false),
       (1064, 397, '백트래킹 방식으로 탐색하는 알고리즘이다', '백트래킹은 DFS의 특징이다. BFS는 레벨 순서로 탐색하므로 오답이다.', false),
       (1065, 397, '시작 정점에서 가까운 정점부터 차례대로 탐색하고 같은 깊이의 노드를 모두 탐색한 후 다음 깊이로 넘어가는 방식이다', 'BFS는 레벨 순서대로 가까운 정점부터 탐색한다. 같은 거리에 있는 노드를 모두 방문한 후 다음 거리의 노드로 이동하는 것이 BFS의 핵심 개념이다.', true),
       (1066, 397, '갈 수 있는 곳까지 최대한 깊이 들어가는 방식이다', '이는 DFS의 설명이다. BFS는 너비를 우선으로 탐색하므로 오답이다.', false),

       (1067, 399, '백트래킹 방식으로 동작한다', '백트래킹은 DFS의 특징이다. BFS는 레벨 순서로 탐색하므로 오답이다.', false),
       (1068, 399, '재귀로만 구현 가능하다', 'BFS는 큐를 사용하며 재귀로는 구현하기 어렵다. 일반적으로 반복문과 큐를 사용하므로 오답이다.', false),
       (1069, 399, '큐를 사용하고 레벨 순서대로 탐색하며 최단 거리를 보장하고 시작점으로부터의 거리 계산이 가능하며 메모리 사용량이 DFS보다 많을 수 있다', 'BFS는 큐를 사용하고, 레벨 순서 탐색, 최단 거리 보장, 거리 계산 가능, 메모리 사용량이 많은 특징을 가진다. 이는 BFS의 핵심 특징들이다.', true),
       (1070, 399, '스택을 사용하여 구현한다', 'BFS는 큐를 사용하여 구현한다. 스택을 사용하는 것은 DFS이므로 오답이다.', false),

       (1071, 400, 'O(V log E)', 'BFS의 시간 복잡도는 O(V + E)이다. O(V log E)는 다른 그래프 알고리즘의 복잡도이므로 오답이다.', false),
       (1072, 400, '인접 리스트 기준 O(V + E)', 'BFS의 시간 복잡도는 인접 리스트 기준 O(V + E)이다. 모든 정점을 한 번씩 방문하고 모든 간선을 한 번씩 확인하기 때문이다.', true),
       (1073, 400, 'O(E log V)', 'BFS의 시간 복잡도는 O(V + E)이다. O(E log V)는 다른 그래프 알고리즘의 복잡도이므로 오답이다.', false),
       (1074, 400, 'O(V²)', '인접 행렬 기준은 O(V²)이지만 일반적으로 BFS의 시간 복잡도는 인접 리스트 기준으로 표현하므로 오답이다.', false),

       (1075, 402, 'O(1)', 'BFS는 큐 공간이 필요하다. 상수 공간만 사용하는 것이 아니므로 오답이다.', false),
       (1076, 402, 'O(V)', '큐에 최악의 경우 모든 정점이 저장될 수 있으므로 O(V)가 정답이다. 특히 트리 구조에서 마지막 레벨의 노드들이 모두 큐에 들어갈 수 있다.', true),
       (1077, 402, 'O(V²)', 'BFS의 공간 복잡도는 O(V)이다. O(V²)는 과도하게 큰 값이므로 오답이다.', false),
       (1078, 402, 'O(E)', 'BFS의 공간 복잡도는 정점 수에 비례한다. 간선 수와는 직접적인 관계가 없으므로 오답이다.', false),

       (1079, 403, '모든 경로 탐색', '모든 경로 탐색은 DFS가 더 적합하다. BFS는 최단 경로 찾기에 더 유리하므로 오답이다.', false),
       (1080, 403, '정렬 문제', '정렬은 BFS의 주요 활용 사례가 아니다. 정렬 알고리즘은 별도로 존재하므로 오답이다.', false),
       (1081, 403, '백트래킹 문제', '백트래킹은 DFS가 더 적합하다. BFS는 레벨 순서로 탐색하므로 오답이다.', false),
       (1082, 403, '최단 거리 문제, 레벨별 탐색, 연결 요소 찾기, 가중치 없는 최단 경로', 'BFS는 최단 거리 문제, 레벨별 탐색, 연결 요소 찾기, 가중치 없는 최단 경로 등에 활용된다. 이는 BFS의 주요 활용 사례들이다.', true),

       (1083, 404, '모든 경로 탐색이 용이하다', '모든 경로 탐색은 DFS가 더 적합하다. BFS는 최단 경로 찾기에 더 유리하므로 오답이다.', false),
       (1084, 404, '재귀로 구현이 간단하다', 'BFS는 재귀 구현이 불가능하다. 반복문과 큐를 사용하여 구현하므로 오답이다.', false),
       (1085, 404, '메모리 사용량이 적다', 'BFS는 큐에 많은 노드를 저장할 수 있어 메모리 사용량이 많다. 이는 BFS의 단점이므로 오답이다.', false),
       (1086, 404, '최단 경로를 보장하고 레벨별 탐색이 명확하여 특정 깊이까지만 탐색 가능하다', 'BFS는 최단 경로를 보장하고 레벨별 탐색이 명확하다. 이러한 특성으로 최단 거리 문제나 레벨별 처리가 필요한 문제에 적합하다.', true);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (131, 398, '큐,queue',
        'BFS는 큐(Queue)를 사용하여 구현한다. 먼저 들어간 노드를 먼저 처리하는 FIFO(First In First Out) 방식이 BFS의 레벨 순서 탐색을 가능하게 한다.'),
       (132, 401, '최단 경로,최단 거리,최단경로,최단거리,shortest path',
        'BFS는 가중치가 없는 그래프에서 최단 경로를 보장한다. 가까운 노드부터 순차적으로 탐색하므로 처음 도착한 경로가 항상 최단 경로가 된다.');

-- =====================================================
-- Lesson 67: DFS와 BFS 비교 문제집
-- =====================================================

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (405, 67, '제시된 내용과 관련하여 옳은 것은?', 'DFS와 BFS는 탐색 방향이 다르다.', 'OBJECTIVE'),
       (406, 67, '빈칸에 들어갈 알맞은 말을 작성하시오', '최단 경로를 보장하는 탐색 알고리즘은 ___이다.', 'SUBJECTIVE'),
       (407, 67, '제시된 내용과 관련하여 옳은 것은?', 'DFS와 BFS는 각각 유리한 상황이 다르다. DFS가 BFS보다 유리한 경우를 고려한다.', 'OBJECTIVE'),
       (408, 67, '제시된 내용과 관련하여 옳은 것은?', 'BFS와 DFS는 각각 적합한 문제가 다르다. BFS가 DFS보다 유리한 경우를 고려한다.', 'OBJECTIVE'),
       (409, 67, '빈칸에 들어갈 알맞은 말을 작성하시오', '메모리 사용량이 더 적은 탐색 알고리즘은 ___이다.', 'SUBJECTIVE'),
       (410, 67, '제시된 내용과 관련하여 옳은 것은?', 'DFS와 BFS는 공통점도 가지고 있다.', 'OBJECTIVE'),
       (411, 67, '제시된 내용과 관련하여 옳은 것은?', '미로 탈출에서 최소 이동 횟수를 구해야 하는 경우를 고려한다.', 'OBJECTIVE'),
       (412, 67, '제시된 내용과 관련하여 옳은 것은?', '모든 경로를 탐색하여 조건을 만족하는 경로를 찾아야 하는 경우를 고려한다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (1087, 405, 'DFS는 깊이 우선이고 BFS는 너비 우선이며 DFS는 스택을 사용하고 BFS는 큐를 사용한다', 'DFS는 깊이 우선으로 스택을 사용하고, BFS는 너비 우선으로 큐를 사용한다. 이는 두 알고리즘의 핵심 차이점이다.', true),
       (1088, 405, 'DFS는 최단 경로를 보장하고 BFS는 보장하지 않는다', 'BFS가 최단 경로를 보장하고 DFS는 보장하지 않는다. 반대로 설명되어 있으므로 오답이다.', false),
       (1089, 405, 'DFS는 큐를 사용하고 BFS는 스택을 사용한다', 'DFS는 스택, BFS는 큐를 사용한다. 자료구조가 반대로 설명되어 있으므로 오답이다.', false),
       (1090, 405, 'DFS와 BFS는 동일한 탐색 방향을 가진다', 'DFS와 BFS는 탐색 방향이 다르다. DFS는 깊이 우선, BFS는 너비 우선이므로 오답이다.', false),

       (1091, 407, '가까운 노드부터 탐색해야 하는 문제', '가까운 노드부터는 BFS가 더 적합하다. BFS는 거리 순서로 탐색하므로 오답이다.', false),
       (1092, 407, '레벨별로 탐색해야 하는 문제', '레벨별 탐색은 BFS가 더 적합하다. BFS는 거리별로 탐색하므로 오답이다.', false),
       (1093, 407, '모든 경로를 탐색해야 하는 문제', 'DFS는 모든 경로 탐색에 유리하다. 백트래킹 방식으로 모든 가능한 경로를 탐색할 수 있기 때문이다.', true),
       (1094, 407, '최단 거리를 구하는 문제', '최단 거리는 BFS가 더 적합하다. DFS는 최단 거리를 보장하지 않으므로 오답이다.', false),

       (1095, 408, '깊은 곳까지 탐색해야 하는 문제', '깊은 곳 탐색은 DFS가 더 적합하다. DFS는 깊이 우선으로 탐색하므로 오답이다.', false),
       (1096, 408, '모든 경로를 탐색하는 문제', '모든 경로 탐색은 DFS가 더 적합하다. BFS는 최단 경로 찾기에 더 유리하므로 오답이다.', false),
       (1097, 408, '최단 거리를 구하는 문제', 'BFS는 최단 거리 문제에 유리하다. 가중치가 없는 그래프에서 최단 경로를 보장하기 때문이다.', true),
       (1098, 408, '백트래킹이 필요한 문제', '백트래킹은 DFS가 더 적합하다. DFS의 재귀적 특성이 백트래킹에 유리하므로 오답이다.', false),

       (1099, 410, '탐색 순서가 동일하다', 'DFS와 BFS는 탐색 순서가 다르다. DFS는 깊이 우선, BFS는 너비 우선이므로 오답이다.', false),
       (1100, 410, '시간 복잡도가 O(V + E)로 동일하고 모든 정점을 방문한다', 'DFS와 BFS는 시간 복잡도가 동일하고 모든 정점을 방문한다. 두 알고리즘 모두 모든 정점과 간선을 한 번씩 확인하므로 시간 복잡도가 같다.', true),
       (1101, 410, '사용하는 자료구조가 동일하다', 'DFS는 스택, BFS는 큐를 사용한다. 자료구조가 다르므로 오답이다.', false),
       (1102, 410, '최단 경로를 보장한다', 'DFS는 최단 경로를 보장하지 않는다. BFS만 최단 경로를 보장하므로 오답이다.', false),

       (1103, 411, 'DFS', 'DFS는 최단 거리를 보장하지 않는다. 최소 이동 횟수는 최단 거리 문제이므로 오답이다.', false),
       (1104, 411, 'BFS', 'BFS는 최단 거리를 보장한다. 최소 이동 횟수를 구하는 문제는 최단 거리 문제이므로 BFS가 적합하다.', true),

       (1105, 412, 'BFS', 'BFS는 모든 경로 탐색에는 적합하지 않다. BFS는 최단 경로 찾기에 더 유리하므로 오답이다.', false),
       (1106, 412, 'DFS', 'DFS는 모든 경로를 탐색하는 데 적합하다. 백트래킹 방식으로 모든 가능한 경로를 탐색할 수 있기 때문이다.', true);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (133, 406, 'bfs,너비 우선 탐색,breadth first search,breadth-first search',
        'BFS는 가중치가 없는 그래프에서 최단 경로를 보장한다. 가까운 노드부터 순차적으로 탐색하므로 처음 도착한 경로가 항상 최단 경로가 된다.'),
       (134, 409, 'dfs,깊이 우선 탐색,depth first search,depth-first search',
        'DFS는 현재 경로상의 노드만 기억하므로 메모리 사용량이 적다. BFS는 큐에 같은 레벨의 모든 노드를 저장할 수 있어 메모리 사용량이 더 많다.');
