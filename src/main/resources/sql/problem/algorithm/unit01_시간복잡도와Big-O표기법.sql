-- Unit: 시간복잡도 & Big-O 표기법 (Unit ID: 11)
-- Chapter: 알고리즘 (Chapter ID: 2)

-- Lesson 생성
INSERT INTO lesson (id, unit_id, title)
VALUES (30, 11, '시간 복잡도 기초 문제집'),
       (31, 11, 'Big-O 표기법 문제집'),
       (32, 11, '시간 복잡도 비교 문제집');

-- =====================================================
-- Lesson 30: 시간 복잡도 기초 문제집
-- =====================================================

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (175, 30, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '시간 복잡도는 알고리즘의 성능을 분석하는 척도이다.', 'OBJECTIVE'),
       (176, 30, '빈칸에 들어갈 알맞은 말을 작성하시오', '시간 복잡도는 알고리즘이 문제를 해결하는 데 걸리는 시간을 입력 크기 ___의 함수로 나타낸 것이다.', 'SUBJECTIVE'),
       (177, 30, '아래 제시한 개념에 대한 설명으로 옳은 것은?', 'O(1)은 시간 복잡도 표기법 중 하나이다.', 'OBJECTIVE'),
       (178, 30, '아래 제시한 개념에 대한 설명으로 옳은 것은?', 'O(n)은 선형 시간 복잡도를 의미한다.', 'OBJECTIVE'),
       (179, 30, '빈칸에 들어갈 알맞은 말을 작성하시오', '배열의 특정 인덱스에 접근하는 연산의 시간 복잡도는 ___이다.', 'SUBJECTIVE'),
       (180, 30, '제시된 내용과 관련하여 옳은 것은?', '시간 복잡도는 알고리즘 선택에 중요한 기준이 된다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (465, 175, '알고리즘의 코드 길이를 나타낸 것이다',
        '시간 복잡도는 실행 시간을 나타낸다. 코드 길이와는 무관하다.', false),
       (466, 175, '알고리즘이 사용하는 메모리 양을 나타낸 것이다',
        '이는 공간 복잡도의 정의이다. 시간 복잡도는 실행 시간을 나타낸다.', false),
       (467, 175, '알고리즘이 문제를 해결하는 데 걸리는 시간을 입력 크기 n의 함수로 나타낸 것이다',
        '시간 복잡도는 알고리즘이 문제를 해결하는 데 걸리는 시간을 입력 크기 n의 함수로 나타낸 것이다. 입력이 커질수록 실행 시간이 얼마나 증가하는지 예측할 수 있다.',
        true),
       (468, 175, '알고리즘의 정확성을 나타내는 척도이다',
        '시간 복잡도는 성능을 나타내는 척도이다. 정확성과는 다른 개념이다.', false),

       (469, 177, '입력 크기의 제곱에 비례하여 시간이 증가한다',
        '이는 O(n²)의 특징이다. O(1)은 입력 크기와 무관하다.', false),
       (470, 177, '입력 크기와 상관없이 일정한 시간이 소요된다',
        'O(1)은 상수 시간 복잡도로, 입력 크기와 상관없이 항상 일정한 시간이 소요됨을 의미한다. 배열의 인덱스 접근, 해시 테이블의 조회 등이 대표적인 예시이다.',
        true),
       (471, 177, '입력 크기에 비례하여 시간이 증가한다',
        '이는 O(n)의 특징이다. O(1)은 입력 크기와 무관하게 일정한 시간이 소요된다.', false),
       (472, 177, '로그 시간이 소요된다',
        '이는 O(log n)의 특징이다. O(1)은 상수 시간이다.', false),

       (473, 178, '배열의 특정 인덱스에 접근하는 경우',
        '배열의 인덱스 접근은 O(1)이다. O(n)이 아니다.', false),
       (474, 178, '이중 반복문으로 배열을 순회하는 경우',
        '이중 반복문은 O(n²)이다. O(n)이 아니다.', false),
       (475, 178, '이진 탐색을 수행하는 경우',
        '이진 탐색은 O(log n)이다. O(n)이 아니다.', false),
       (476, 178, '단순 반복문으로 배열을 순회하는 경우',
        'O(n)은 선형 시간 복잡도로, 입력 개수만큼 순회하는 경우를 의미한다. 단순 반복문으로 배열을 순회하거나 선형 탐색을 수행하는 경우가 대표적이다.',
        true),

       (477, 180, '코드를 짧게 작성하기 위해서이다',
        '시간 복잡도는 실행 시간 분석을 위한 것이다. 코드 길이와는 무관하다.', false),
       (478, 180, '알고리즘의 정확성을 보장하기 위해서이다',
        '시간 복잡도는 성능 분석을 위한 것이다. 정확성 보장과는 다른 개념이다.', false),
       (479, 180, '메모리 사용량을 줄이기 위해서이다',
        '이는 공간 복잡도와 관련된 이유이다. 시간 복잡도는 실행 시간과 관련이 있다.', false),
       (480, 180, '입력 크기가 커질수록 실행 시간 차이가 급격히 벌어지므로 효율적인 알고리즘 선택이 필수적이다',
        '시간 복잡도는 알고리즘의 효율성을 정량적으로 비교하기 위한 기준이다. 같은 기능을 수행하더라도 입력 크기가 커지면 성능 차이가 급격히 벌어진다. 대규모 데이터나 실시간 시스템에서는 복잡도가 낮은 알고리즘 선택이 필수적이다.',
        true);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (59, 176, 'n,엔',
        '시간 복잡도는 알고리즘이 문제를 해결하는 데 걸리는 시간을 입력 크기 n의 함수로 나타낸 것이다. 입력이 커질수록 실행 시간이 얼마나 증가하는지를 예측할 수 있다.'),
       (60, 179, 'o(1),상수 시간,상수시간,constant time,constant',
        '배열의 특정 인덱스에 접근하는 연산의 시간 복잡도는 O(1)이다. 인덱스를 통해 직접 접근할 수 있으므로 입력 크기와 무관하게 일정한 시간이 소요된다.');

-- =====================================================
-- Lesson 31: Big-O 표기법 문제집
-- =====================================================

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (181, 31, '아래 제시한 개념에 대한 설명으로 옳은 것은?', 'Big-O 표기법은 점근적 표기법의 한 종류이다.', 'OBJECTIVE'),
       (182, 31, '빈칸에 들어갈 알맞은 말을 작성하시오', 'Big-O 표기법은 입력 크기 n이 커질 때 알고리즘이 수행하는 연산 수의 ___을 표현한다.', 'SUBJECTIVE'),
       (183, 31, '아래 제시한 개념에 대한 설명으로 옳은 것은?', 'O(log n)은 로그 시간 복잡도를 의미한다.', 'OBJECTIVE'),
       (184, 31, '아래 제시한 개념에 대한 설명으로 옳은 것은?', 'O(n²)은 제곱 시간 복잡도를 의미한다.', 'OBJECTIVE'),
       (185, 31, '빈칸에 들어갈 알맞은 말을 작성하시오', '병합 정렬과 퀵 정렬의 평균 시간 복잡도는 ___이다.', 'SUBJECTIVE'),
       (186, 31, '제시된 내용과 관련하여 옳은 것은?', 'Big-O 표기법은 특정한 규칙을 따른다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (481, 181, '알고리즘의 코드 줄 수를 나타낸다',
        'Big-O 표기법은 연산 수의 증가율을 나타낸다. 코드 줄 수와는 무관하다.', false),
       (482, 181, '입력 크기 n이 커질 때 알고리즘의 실행 시간 상한을 표현하는 표기법이다',
        'Big-O 표기법은 입력 크기 n이 커질 때 알고리즘이 수행하는 연산 수의 상한(최악의 경우)을 표현한다. 알고리즘의 효율성을 비교하고 예측할 수 있게 해준다.',
        true),
       (483, 181, '알고리즘의 정확한 실행 시간을 초 단위로 표현한다',
        'Big-O 표기법은 증가율을 표현한다. 정확한 실행 시간을 초 단위로 표현하지 않는다.', false),
       (484, 181, '알고리즘의 메모리 사용량만 표현한다',
        'Big-O 표기법은 시간 복잡도와 공간 복잡도 모두 표현할 수 있다. 메모리만 표현하는 것이 아니다.', false),

       (485, 183, '배열의 인덱스 접근',
        '배열의 인덱스 접근은 O(1)이다. O(log n)이 아니다.', false),
       (486, 183, '이중 반복문',
        '이중 반복문은 O(n²)이다. O(log n)이 아니다.', false),
       (487, 183, '이진 탐색과 힙 연산',
        'O(log n)은 로그 시간 복잡도로, 매 단계마다 입력을 절반으로 줄이는 경우를 의미한다. 이진 탐색, 힙의 삽입/삭제 연산 등이 대표적인 예시이다.',
        true),
       (488, 183, '단순 반복문으로 배열 순회',
        '단순 반복문은 O(n)이다. O(log n)이 아니다.', false),

       (489, 184, '배열의 인덱스에 접근하는 경우',
        '배열의 인덱스 접근은 O(1)이다. O(n²)이 아니다.', false),
       (490, 184, '단순 반복문으로 배열을 순회하는 경우',
        '단순 반복문은 O(n)이다. O(n²)이 아니다.', false),
       (491, 184, '이진 탐색을 수행하는 경우',
        '이진 탐색은 O(log n)이다. O(n²)이 아니다.', false),
       (492, 184, '이중 반복문 구조로 배열을 순회하는 경우',
        'O(n²)은 제곱 시간 복잡도로, 이중 반복문 구조를 의미한다. 버블 정렬, 선택 정렬, 삽입 정렬 등이 대표적인 예시이다.',
        true),

       (493, 186, '최선의 경우만 표현한다',
        'Big-O 표기법은 상한(최악의 경우)을 표현한다. 최선의 경우는 Ω(오메가) 표기법이다.', false),
       (494, 186, '알고리즘의 정확성을 보장한다',
        'Big-O 표기법은 성능 분석을 위한 것이다. 정확성 보장과는 무관하다.', false),
       (495, 186, '상수나 작은 항들은 무시하고 증가율에만 집중한다',
        'Big-O 표기법은 상수나 작은 항들은 무시하고 증가율에만 집중한다. 예를 들어 3n² + 2n + 1은 O(n²)로 표기한다. 가장 빠르게 증가하는 항만 고려한다.',
        true),
       (496, 186, '모든 상수와 계수를 정확히 표현한다',
        'Big-O 표기법은 상수와 낮은 차수의 항을 무시한다. 모든 것을 정확히 표현하지 않는다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (61, 182, '상한,최악,상한선,upper bound,최악의 경우',
        'Big-O 표기법은 입력 크기 n이 커질 때 알고리즘이 수행하는 연산 수의 상한(최악의 경우)을 표현한다. 알고리즘의 실행 시간이 이 값보다 느리지 않음을 보장한다.'),
       (62, 185, 'o(n log n),o(nlogn),n log n,nlogn,o(n*logn),o(n*log n),엔로그엔',
        '병합 정렬과 퀵 정렬의 평균 시간 복잡도는 O(n log n)이다. 이는 선형과 로그의 복합 형태로, 효율적인 정렬 알고리즘의 대표적인 시간 복잡도이다.');

-- =====================================================
-- Lesson 32: 시간 복잡도 비교 문제집
-- =====================================================

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (187, 32, '제시된 내용과 관련하여 옳은 것은?', '시간 복잡도는 효율성 순서가 존재한다.', 'OBJECTIVE'),
       (188, 32, '빈칸에 들어갈 알맞은 말을 작성하시오', '입력 크기가 10일 때 O(2ⁿ)의 실행 횟수는 ___이다.', 'SUBJECTIVE'),
       (189, 32, '제시된 내용과 관련하여 옳은 것은?', '일부 시간 복잡도는 실용적이지 않다.', 'OBJECTIVE'),
       (190, 32, '아래 제시한 개념에 대한 설명으로 옳은 것은?', 'O(2ⁿ)은 지수 시간 복잡도이다.', 'OBJECTIVE'),
       (191, 32, '빈칸에 들어갈 알맞은 말을 작성하시오', '모든 순열을 탐색하는 외판원 문제의 시간 복잡도는 ___이다.', 'SUBJECTIVE'),
       (192, 32, '제시된 내용과 관련하여 옳은 것은?', '시간 복잡도는 입력 크기에 따라 차이가 발생한다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (497, 187, 'O(n²) < O(n) < O(log n) < O(1)',
        '순서가 반대이다. O(1)이 가장 효율적이고 O(n²)이 덜 효율적이다.', false),
       (498, 187, '모든 시간 복잡도는 동일하다',
        '시간 복잡도는 서로 다른 효율성을 가진다.', false),
       (499, 187, 'O(1) < O(log n) < O(n) < O(n log n) < O(n²) < O(2ⁿ) < O(n!)',
        '시간 복잡도를 효율적인 순서대로 나열하면 O(1) < O(log n) < O(n) < O(n log n) < O(n²) < O(2ⁿ) < O(n!)이다. 위로 갈수록 효율적이고 아래로 갈수록 비효율적이다.',
        true),
       (500, 187, 'O(n!) < O(2ⁿ) < O(n²) < O(n log n)',
        '순서가 반대이다. O(n!)이 가장 비효율적이다.', false),

       (501, 189, 'O(2ⁿ)과 O(n!)',
        'O(2ⁿ)과 O(n!)은 입력이 조금만 커져도 실행 시간이 급격히 증가하여 비실용적이다.', false),
       (502, 189, '모든 시간 복잡도가 실용적이다',
        'O(2ⁿ), O(n!) 등은 비실용적이다.', false),
       (503, 189, 'O(n log n) 이하의 복잡도',
        '현실적으로 O(n log n) 이하의 시간 복잡도만 실용적이다. O(1), O(log n), O(n), O(n log n)은 대규모 데이터 처리에 적합하다. O(2ⁿ), O(n!)은 입력이 조금만 커져도 현실적으로 불가능해진다.',
        true),
       (504, 189, 'O(n²)만 실용적이다',
        'O(n²)은 작은 데이터에서는 사용 가능하지만, O(n log n) 이하가 더 실용적이다.', false),

       (505, 190, '로그 시간 복잡도이다',
        'O(2ⁿ)은 지수 시간 복잡도이다. 로그 시간이 아니다.', false),
       (506, 190, 'O(n)보다 효율적이다',
        'O(2ⁿ)은 O(n)보다 훨씬 비효율적이다.', false),
       (507, 190, '가능한 모든 경우를 탐색하며 입력이 조금만 커져도 실행 시간이 급격히 증가한다',
        'O(2ⁿ)은 지수 시간 복잡도로, 가능한 모든 경우를 탐색한다. 입력 크기가 10일 때 1,024번, 20일 때 1,048,576번 실행되어 입력이 조금만 커져도 현실적으로 불가능해진다.',
        true),
       (508, 190, '매우 효율적인 알고리즘이다',
        'O(2ⁿ)은 비효율적이다. 입력이 조금만 커져도 실행 시간이 급격히 증가한다.', false),

       (509, 192, 'O(1)이 가장 비효율적이다',
        'O(1)은 가장 효율적인 시간 복잡도이다.', false),
       (510, 192, '모든 시간 복잡도는 입력 크기와 무관하게 동일하다',
        '시간 복잡도는 입력 크기에 따라 크게 달라진다.', false),
       (511, 192, '입력 크기가 커질수록 O(1)~O(n log n)은 실용적이지만 O(2ⁿ), O(n!)은 불가능해진다',
        '입력이 커질수록 시간 복잡도에 따른 성능 차이가 급격히 벌어진다. 입력 크기 20일 때 O(n)은 20번, O(n²)은 400번이지만 O(2ⁿ)은 1,048,576번 실행된다. 따라서 효율적인 알고리즘 선택이 중요하다.',
        true),
       (512, 192, 'O(2ⁿ)이 가장 효율적이다',
        'O(2ⁿ)은 가장 비효율적인 시간 복잡도 중 하나이다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (63, 188, '1024,천이십사,1,024,천24,천 이십사',
        '입력 크기가 10일 때 O(2ⁿ)의 실행 횟수는 2¹⁰ = 1024이다. 입력이 20이면 2²⁰ = 1,048,576번으로 급격히 증가한다. 이는 지수 함수의 특징이다.'),
       (64, 191, 'o(n!),n!,팩토리얼,factorial,엔 팩토리얼,엔팩토리얼',
        '모든 순열을 탐색하는 외판원 문제(TSP)의 시간 복잡도는 O(n!)이다. 이는 팩토리얼 시간 복잡도로 가장 비효율적인 시간 복잡도 중 하나이며, 입력이 조금만 커져도 실행이 불가능하다.');
