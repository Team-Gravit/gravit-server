-- Unit: 기수 정렬 (Unit ID: 21)
-- Chapter: 알고리즘 (Chapter ID: 2)

-- Lesson 생성
INSERT INTO lesson (id, unit_id, title)
VALUES (60, 21, '기수 정렬 기초 문제집'),
       (61, 21, '기수 정렬 동작 과정 문제집'),
       (62, 21, '기수 정렬 분석 문제집');

-- =====================================================
-- Lesson 60: 기수 정렬 기초 문제집
-- =====================================================

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (355, 60, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '기수 정렬은 특정한 방식으로 동작하는 정렬 알고리즘이다.', 'OBJECTIVE'),
       (356, 60, '빈칸에 들어갈 알맞은 말을 작성하시오', '기수 정렬은 ___부터 비교하여 정렬하는 알고리즘이다.', 'SUBJECTIVE'),
       (357, 60, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '기수 정렬은 여러 가지 특징을 가진다.', 'OBJECTIVE'),
       (358, 60, '제시된 내용과 관련하여 옳은 것은?', '기수 정렬은 다른 정렬과 차이가 있다.', 'OBJECTIVE'),
       (359, 60, '빈칸에 들어갈 알맞은 말을 작성하시오', '기수 정렬은 비교 연산을 수행하지 않는 ___이다.', 'SUBJECTIVE'),
       (360, 60, '제시된 내용과 관련하여 옳은 것은?', '기수 정렬은 안정성과 관련된 특징을 가진다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (945, 355, '높은 자리수부터 비교하여 정렬한다',
        '기수 정렬은 낮은 자리수부터 비교한다. 높은 자리수부터가 아니다.', false),
       (946, 355, '인접한 원소를 비교하여 정렬하는 알고리즘이다',
        '기수 정렬은 비교 연산을 수행하지 않는다. 자릿수를 이용한다.', false),
       (947, 355, '낮은 자리수부터 비교하여 정렬하며 비교 연산을 수행하지 않고 자릿수를 이용해 정렬하는 알고리즘이다',
        '기수 정렬은 낮은 자리수부터 비교하여 정렬하는 알고리즘이다. 다른 정렬 알고리즘과 달리 비교 연산을 수행하지 않고 자릿수를 이용해 정렬한다. 안정 정렬이며, 자릿수가 고정된 정수나 문자열 정렬에 효율적이다.',
        true),
       (948, 355, '피벗을 기준으로 분할하는 알고리즘이다',
        '이는 퀵 정렬의 특징이다. 기수 정렬은 자릿수를 이용한다.', false),

       (949, 357, '높은 자리수부터 정렬한다',
        '기수 정렬은 낮은 자리수부터 정렬한다. 높은 자리수부터가 아니다.', false),
       (950, 357, '불안정 정렬이다',
        '기수 정렬은 안정 정렬이다. 동일한 값의 순서가 유지된다.', false),
       (951, 357, '비교 연산을 수행하지 않는 정렬이며 낮은 자리수부터 높은 자리수로 순차적으로 정렬하고 안정 정렬이며 0부터 9까지의 버킷을 사용한다',
        '기수 정렬은 비교 연산을 수행하지 않는 정렬(Non-Comparison Sort)이고, 낮은 자리수부터 높은 자리수로 순차적으로 정렬하며(LSD - Least Significant Digit), 안정 정렬(Stable Sort)로 동일한 값의 순서가 유지되고, 0~9까지의 버킷(Bucket) 또는 큐(Queue)를 사용하며, 정렬할 수들의 최대 자릿수(d)에 영향을 받고, 내부적으로 계수 정렬(Counting Sort)을 활용한다.',
        true),
       (952, 357, '비교 연산을 수행한다',
        '기수 정렬은 비교 연산을 수행하지 않는다. 자릿수를 이용한다.', false),

       (953, 358, '기수 정렬은 비교 연산을 수행하지 않고 자릿수를 이용하며 다른 정렬은 대부분 비교 연산을 수행한다',
        '기수 정렬은 비교 연산을 수행하지 않는 정렬(Non-Comparison Sort)로 자릿수를 이용해 정렬한다. 다른 정렬 알고리즘은 대부분 원소 간 비교 연산을 수행하여 정렬한다.',
        true),
       (954, 358, '기수 정렬은 비교 연산을 수행하고 다른 정렬은 비교 연산을 수행하지 않는다',
        '반대이다. 기수 정렬은 비교 연산을 수행하지 않는다.', false),
       (955, 358, '기수 정렬은 피벗을 사용한다',
        '기수 정렬은 자릿수를 이용한다. 피벗을 사용하지 않는다.', false),
       (956, 358, '기수 정렬과 다른 정렬은 완전히 동일하다',
        '기수 정렬은 비교 연산 수행 여부에서 다른 정렬과 차이가 있다.', false),

       (957, 360, '동일한 값은 항상 제거된다',
        '기수 정렬은 동일한 값을 유지한다. 제거하지 않는다.', false),
       (958, 360, '동일한 값을 처리할 수 없다',
        '기수 정렬은 동일한 값을 처리할 수 있으며 순서를 유지한다.', false),
       (959, 360, '안정 정렬이며 동일한 값의 순서가 유지된다',
        '기수 정렬은 안정 정렬(Stable Sort)이다. 동일한 값의 순서가 유지되므로 동일한 키를 가진 데이터의 상대적 순서가 보존된다.',
        true),
       (960, 360, '불안정 정렬이며 동일한 값의 순서가 바뀔 수 있다',
        '기수 정렬은 안정 정렬이다. 동일한 값의 순서가 유지된다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (119, 356, '낮은 자리수,1의 자리,낮은자리수',
        '기수 정렬은 낮은 자리수부터 비교하여 정렬하는 알고리즘이다. LSD(Least Significant Digit) 방식으로 1의 자리부터 시작하여 높은 자리수로 순차적으로 정렬한다.'),
       (120, 359, '비교 연산을 수행하지 않는 정렬,non-comparison sort,비교연산을수행하지않는정렬',
        '기수 정렬은 비교 연산을 수행하지 않는 정렬(Non-Comparison Sort)이다. 원소 간 비교 없이 자릿수를 이용하여 정렬한다.');

-- =====================================================
-- Lesson 61: 기수 정렬 동작 과정 문제집
-- =====================================================

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (361, 61, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '기수 정렬은 버킷 준비 단계를 포함한다.', 'OBJECTIVE'),
       (362, 61, '빈칸에 들어갈 알맞은 말을 작성하시오', '기수 정렬은 0부터 9까지 ___개의 버킷을 준비한다.', 'SUBJECTIVE'),
       (363, 61, '제시된 내용과 관련하여 옳은 것은?', '기수 정렬은 분배 단계를 포함한다.', 'OBJECTIVE'),
       (364, 61, '제시된 내용과 관련하여 옳은 것은?', '기수 정렬은 수집 단계를 포함한다.', 'OBJECTIVE'),
       (365, 61, '빈칸에 들어갈 알맞은 말을 작성하시오', '기수 정렬은 가장 높은 자릿수까지 분배와 수집 과정을 ___한다.', 'SUBJECTIVE'),
       (366, 61, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '기수 정렬의 버킷은 특정한 역할을 한다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (961, 361, '1개의 버킷만 사용한다',
        '기수 정렬은 0~9까지 10개의 버킷을 사용한다. 1개가 아니다.', false),
       (962, 361, '버킷을 준비하지 않는다',
        '기수 정렬은 버킷 시스템을 사용한다. 버킷 준비가 필수이다.', false),
       (963, 361, '0부터 9까지 10개의 버킷 또는 큐를 준비한다',
        '기수 정렬의 버킷 준비 단계는 0부터 9까지 10개의 버킷(큐)을 준비한다. 각 버킷은 해당 자릿수 값(0~9)에 해당하는 데이터를 임시로 저장한다.',
        true),
       (964, 361, '5개의 버킷을 준비한다',
        '기수 정렬은 10개의 버킷을 준비한다. 5개가 아니다.', false),

       (965, 363, '데이터를 무작위로 배치한다',
        '기수 정렬은 자릿수를 기준으로 체계적으로 분배한다. 무작위가 아니다.', false),
       (966, 363, '현재 자릿수를 기준으로 각 데이터를 해당 버킷에 넣는다',
        '기수 정렬의 분배 단계는 현재 자릿수를 기준으로 각 데이터를 해당 버킷에 넣는다. 예를 들어, 1의 자리를 처리할 때 1의 자리 값이 2인 데이터는 버킷 2에 삽입한다.',
        true),
       (967, 363, '데이터를 절반으로 나눈다',
        '기수 정렬은 자릿수를 기준으로 10개의 버킷에 분배한다. 절반으로 나누지 않는다.', false),
       (968, 363, '가장 큰 값만 선택한다',
        '기수 정렬은 모든 데이터를 자릿수에 따라 버킷에 분배한다. 가장 큰 값만 선택하지 않는다.', false),

       (969, 364, '9번 버킷부터 역순으로 가져온다',
        '기수 정렬은 0번 버킷부터 순서대로 가져온다. 역순이 아니다.', false),
       (970, 364, '0번 버킷부터 순서대로 데이터를 다시 가져온다',
        '기수 정렬의 수집 단계는 0번 버킷부터 순서대로 데이터를 다시 가져온다. 버킷에 저장된 순서를 유지하며 원래 배열에 다시 넣는다.',
        true),
       (971, 364, '무작위로 가져온다',
        '기수 정렬은 0번부터 순서대로 체계적으로 가져온다. 무작위가 아니다.', false),
       (972, 364, '수집 단계가 없다',
        '기수 정렬은 분배 후 반드시 수집 단계를 수행한다.', false),

       (973, 366, '버킷은 하나의 자료구조만 사용한다',
        '버킷은 큐 또는 계수 정렬 등 다양한 방식으로 구현 가능하다.', false),
       (974, 366, '버킷은 각 자릿수의 값에 해당하는 임시 저장 공간이며 FIFO 구조의 큐 또는 계수 정렬을 사용하여 구현한다',
        '기수 정렬에서 버킷은 각 자릿수의 값(0~9)에 해당하는 임시 저장 공간이다. 버킷 인덱스는 (숫자 / 10^현재자리) % 10으로 계산되며, FIFO 구조의 큐로 순서를 유지하거나 계수 정렬(카운팅 배열 + 누적합)로 구현한다.',
        true),
       (975, 366, '버킷은 사용하지 않는다',
        '기수 정렬은 버킷 시스템을 핵심으로 사용한다.', false),
       (976, 366, '버킷은 데이터를 영구 저장한다',
        '버킷은 임시 저장 공간이다. 영구 저장하지 않는다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (121, 362, '10,열,십,10개',
        '기수 정렬은 0부터 9까지 10개의 버킷을 준비한다. 각 버킷은 해당 자릿수 값(0~9)에 해당하는 데이터를 임시로 저장한다.'),
       (122, 365, '반복,repeat,계속,되풀이',
        '기수 정렬은 가장 높은 자릿수까지 분배와 수집 과정을 반복한다. 모든 자릿수를 처리할 때까지 분배-수집을 반복하여 정렬을 완성한다.');

-- =====================================================
-- Lesson 62: 기수 정렬 분석 문제집
-- =====================================================

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (367, 62, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '기수 정렬은 특정한 시간 복잡도를 가진다.', 'OBJECTIVE'),
       (368, 62, '빈칸에 들어갈 알맞은 말을 작성하시오', '기수 정렬은 버킷 공간과 출력 배열로 ___의 공간 복잡도를 가진다.', 'SUBJECTIVE'),
       (369, 62, '제시된 내용과 관련하여 옳은 것은?', '기수 정렬은 여러 가지 장점을 가진다.', 'OBJECTIVE'),
       (370, 62, '제시된 내용과 관련하여 옳은 것은?', '기수 정렬은 단점도 가지고 있다.', 'OBJECTIVE'),
       (371, 62, '빈칸에 들어갈 알맞은 말을 작성하시오', '기수 정렬은 정수나 ___에만 사용 가능하여 적용 범위가 제한적이다.', 'SUBJECTIVE'),
       (372, 62, '제시된 내용과 관련하여 옳은 것은?', '기수 정렬은 특정한 조건에서 사용 가능하다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (977, 367, '평균 O(n log n), 최악 O(n²)이다',
        '기수 정렬은 O(d × n)이다. O(n log n)이 아니다.', false),
       (978, 367, '최선/평균/최악 모두 O(d × n)이다',
        '기수 정렬의 시간 복잡도는 최선, 평균, 최악 모두 O(d × (n + b))이다. d는 최대 자릿수, n은 데이터 개수, b는 기수(10)이다. 일반적으로 b는 상수로 취급하므로 O(d × n) 또는 O(dn)으로 표현한다. 자릿수가 적을 때 O(n)에 가까운 성능을 보인다.',
        true),
       (979, 367, '모든 경우에 O(n²)이다',
        '기수 정렬은 O(d × n)이다. O(n²)이 아니다.', false),
       (980, 367, '모든 경우에 O(n)이다',
        '기수 정렬은 O(d × n)이다. 자릿수 d에 영향을 받는다.', false),

       (981, 369, '불안정 정렬이다',
        '기수 정렬은 안정 정렬이다. 동일한 값의 순서가 유지된다.', false),
       (982, 369, '추가 메모리가 불필요하다',
        '기수 정렬은 O(n + b)의 추가 메모리가 필요하다.', false),
       (983, 369, '비교 연산을 수행한다',
        '기수 정렬은 비교 연산을 수행하지 않는다. 자릿수를 이용한다.', false),
       (984, 369, '빠른 속도로 자릿수가 적을 때 O(n)에 가까운 성능이며 안정 정렬로 동일한 값의 순서가 유지되고 예측 가능한 성능으로 입력 데이터 분포에 영향을 받지 않으며 비교 연산이 없어 구현이 직관적이다',
        '기수 정렬의 장점은 빠른 속도로 자릿수가 적을 때 O(n)에 가까운 성능을 보이고, 안정 정렬로 동일한 값의 순서가 유지되며, 예측 가능한 성능으로 입력 데이터의 분포에 영향을 받지 않고, 단순한 구조로 비교 연산이 없어 구현이 직관적이다.',
        true),

       (985, 370, '추가 메모리가 O(1)이다',
        '기수 정렬은 O(n + b)의 추가 메모리가 필요하다. O(1)이 아니다.', false),
       (986, 370, '자릿수에 영향을 받지 않는다',
        '기수 정렬은 자릿수가 클수록 성능이 저하된다. 자릿수에 크게 영향을 받는다.', false),
       (987, 370, '모든 데이터 타입에 사용 가능하다',
        '기수 정렬은 정수나 고정 길이 문자열에만 사용 가능하다. 적용 범위가 제한적이다.', false),
       (988, 370, '제한적 사용으로 정수나 고정 길이 문자열에만 사용 가능하고 높은 공간 복잡도로 O(n + b)의 추가 메모리가 필요하며 자릿수 의존성으로 자릿수가 클수록 성능이 저하되고 부동소수점이나 음수 처리에 추가 전처리가 필요하다',
        '기수 정렬의 단점은 제한적 사용으로 정수나 고정 길이 문자열에만 사용 가능하고, 높은 공간 복잡도로 O(n + b)의 추가 메모리가 필요하며, 자릿수 의존성으로 자릿수가 클수록 성능이 저하되고, 부동소수점/음수 처리에 추가적인 전처리가 필요하다.',
        true),

       (989, 372, '부동소수점에 바로 사용 가능하다',
        '부동소수점은 전처리가 필요하다. 바로 사용할 수 없다.', false),
       (990, 372, '정수 데이터, 고정 길이 문자열, 자릿수가 적은 데이터에 사용 가능하다',
        '기수 정렬은 정수 데이터, 고정 길이 문자열, 자릿수가 적은 데이터에 사용 가능하다. 부동소수점 숫자는 전처리가 필요하고, 음수는 오프셋 처리가 필요하며, 가변 길이 데이터나 비교 기반 정렬이 필요한 경우는 사용 불가능하다.',
        true),
       (991, 372, '가변 길이 데이터에 적합하다',
        '기수 정렬은 고정 길이 데이터에만 적합하다. 가변 길이는 사용 불가능하다.', false),
       (992, 372, '모든 데이터 타입에 적용 가능하다',
        '기수 정렬은 정수나 고정 길이 문자열에만 사용 가능하다. 적용 범위가 제한적이다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (123, 368, 'o(n + b),o(n),o(n+b)',
        '기수 정렬은 버킷 공간 O(n + b)의 공간 복잡도를 가진다. n개의 데이터를 담을 출력 배열과 b개의 카운팅 배열이 필요하다. 일반적으로 b(기수=10)는 상수로 취급하므로 O(n)으로 표현한다.'),
       (124, 371, '고정 길이 문자열,문자열,고정길이문자열,string',
        '기수 정렬은 정수나 고정 길이 문자열에만 사용 가능하여 적용 범위가 제한적이다. 부동소수점, 음수, 가변 길이 데이터는 추가 처리가 필요하거나 사용 불가능하다.');
