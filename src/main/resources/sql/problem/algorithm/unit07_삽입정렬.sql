-- Unit: 삽입 정렬 (Unit ID: 17)
-- Chapter: 알고리즘 (Chapter ID: 2)

-- Lesson 생성
INSERT INTO lesson (id, unit_id, title)
VALUES (48, 17, '삽입 정렬 기초 문제집'),
       (49, 17, '삽입 정렬 동작 과정 문제집'),
       (50, 17, '삽입 정렬 분석 문제집');

-- =====================================================
-- Lesson 48: 삽입 정렬 기초 문제집
-- =====================================================

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (283, 48, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '삽입 정렬은 특정한 방식으로 동작하는 정렬 알고리즘이다.', 'OBJECTIVE'),
       (284, 48, '빈칸에 들어갈 알맞은 말을 작성하시오', '삽입 정렬은 ___된 부분과 정렬되지 않은 부분으로 나누어 정렬한다.', 'SUBJECTIVE'),
       (285, 48, '제시된 내용과 관련하여 옳은 것은?', '삽입 정렬은 특정한 특징을 가진다.', 'OBJECTIVE'),
       (286, 48, '제시된 내용과 관련하여 옳은 것은?', '삽입 정렬은 특정 상황에서 효율적이다.', 'OBJECTIVE'),
       (287, 48, '빈칸에 들어갈 알맞은 말을 작성하시오', '삽입 정렬은 거의 정렬된 배열에서 ___의 효율적인 성능을 보인다.', 'SUBJECTIVE'),
       (288, 48, '제시된 내용과 관련하여 옳은 것은?', '삽입 정렬은 안정성과 관련된 특성을 가진다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (753, 283, '인접한 두 원소를 비교하여 교환하는 알고리즘이다',
        '이는 버블 정렬의 특징이다. 삽입 정렬은 정렬된 부분에 원소를 삽입한다.', false),
       (754, 283, '정렬된 부분과 정렬되지 않은 부분으로 나누어 정렬되지 않은 부분에서 원소를 하나씩 꺼내 정렬된 부분의 올바른 위치에 삽입하는 알고리즘이다',
        '삽입 정렬은 배열을 정렬된 부분과 정렬되지 않은 부분으로 나누어, 정렬되지 않은 부분에서 원소를 하나씩 꺼내 정렬된 부분의 올바른 위치에 삽입하는 알고리즘이다. 손안의 카드를 정렬하는 방법과 유사하다.',
        true),
       (755, 283, '피벗을 기준으로 분할하는 알고리즘이다',
        '이는 퀵 정렬의 특징이다. 삽입 정렬은 정렬된 부분에 원소를 삽입한다.', false),
       (756, 283, '가장 작은 값을 찾아 앞으로 이동시키는 알고리즘이다',
        '이는 선택 정렬의 특징이다. 삽입 정렬은 원소를 정렬된 부분에 삽입한다.', false),

       (757, 285, '교환 횟수가 최대 n-1번이다',
        '이는 선택 정렬의 특징이다. 삽입 정렬은 상황에 따라 교환 횟수가 다르다.', false),
       (758, 285, '항상 인접한 원소만 비교한다',
        '삽입 정렬은 정렬된 부분의 원소들과 비교한다. 인접한 원소만 비교하는 것은 아니다.', false),
       (759, 285, '배열을 정렬된 부분과 정렬되지 않은 부분으로 구분하고 정렬된 부분의 맨 뒤 원소부터 비교하며 적절한 위치를 찾는다',
        '삽입 정렬은 배열을 정렬된 부분과 정렬되지 않은 부분으로 구분하고, 정렬되지 않은 부분에서 원소를 하나씩 선택하여 삽입한다. 정렬된 부분의 맨 뒤 원소부터 비교하며 적절한 위치를 찾는다.',
        true),
       (760, 285, '불안정 정렬이다',
        '삽입 정렬은 안정 정렬이다. 동일한 값의 순서를 유지한다.', false),

       (761, 286, '무작위 배열에서 가장 빠르다',
        '무작위 배열에서는 퀵 정렬이나 병합 정렬이 더 빠르다. 삽입 정렬은 거의 정렬된 데이터에 효율적이다.', false),
       (762, 286, '역순으로 정렬된 배열에서 빠르다',
        '역순 정렬된 배열은 삽입 정렬의 최악의 경우이다. O(n²)의 성능을 보인다.', false),
       (763, 286, '대용량 데이터에서 효율적이다',
        '삽입 정렬은 작은 배열이나 거의 정렬된 데이터에 효율적이다. 대용량 데이터에는 부적합하다.', false),
       (764, 286, '거의 정렬된 데이터에서 O(n)의 효율적인 성능을 보인다',
        '삽입 정렬은 거의 정렬된 배열에서 매우 효율적이며 O(n)의 성능을 보인다. 각 원소가 거의 제자리에 있으면 비교와 이동이 최소화된다. TimSort와 IntroSort는 작은 부분 배열에서 삽입 정렬을 사용한다.',
        true),

       (765, 288, '동일한 값을 처리할 수 없다',
        '삽입 정렬은 동일한 값을 처리할 수 있으며 순서를 유지한다.', false),
       (766, 288, '동일한 값은 항상 제거된다',
        '삽입 정렬은 동일한 값을 유지한다. 제거하지 않는다.', false),
       (767, 288, '안정 정렬이며 동일한 값의 순서를 유지한다',
        '삽입 정렬은 안정 정렬(Stable Sort)이다. 동일한 값의 순서가 유지되므로 동일한 키를 가진 데이터의 상대적 순서가 변하지 않는다.',
        true),
       (768, 288, '불안정 정렬이며 동일한 값의 순서가 바뀔 수 있다',
        '삽입 정렬은 안정 정렬이다. 동일한 값의 순서가 유지된다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (95, 284, '정렬,정렬된,sorted,sort',
        '삽입 정렬은 정렬된 부분과 정렬되지 않은 부분으로 나누어 정렬한다. 배열의 첫 번째 요소는 정렬이 되어 있다고 가정하고, 두 번째 요소부터 시작한다.'),
       (96, 287, 'o(n),선형 시간,선형시간,linear time,선형,n',
        '삽입 정렬은 거의 정렬된 배열에서 O(n)의 효율적인 성능을 보인다. 각 원소가 거의 제자리에 있으면 비교만 하고 이동이 최소화되므로 선형 시간에 정렬된다.');

-- =====================================================
-- Lesson 49: 삽입 정렬 동작 과정 문제집
-- =====================================================

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (289, 49, '제시된 내용과 관련하여 옳은 것은?', '삽입 정렬은 단계적으로 동작한다.', 'OBJECTIVE'),
       (290, 49, '빈칸에 들어갈 알맞은 말을 작성하시오', '삽입 정렬은 배열의 ___요소는 정렬이 되어 있다고 가정하고 두 번째 요소부터 시작한다.', 'SUBJECTIVE'),
       (291, 49, '제시된 내용과 관련하여 옳은 것은?', '삽입 정렬은 특정한 방향으로 비교한다.', 'OBJECTIVE'),
       (292, 49, '제시된 내용과 관련하여 옳은 것은?', '삽입 정렬은 특정 조건에서 원소를 이동시킨다.', 'OBJECTIVE'),
       (293, 49, '빈칸에 들어갈 알맞은 말을 작성하시오', '삽입 정렬은 현재 요소보다 작거나 같은 요소를 만나면 그 ___위치에 현재 요소를 삽입한다.', 'SUBJECTIVE'),
       (294, 49, '제시된 내용과 관련하여 옳은 것은?', '삽입 정렬은 특정 조건에서 종료한다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (769, 289, '배열을 절반으로 나누어 정렬한다',
        '이는 병합 정렬의 동작이다. 삽입 정렬은 정렬된 부분에 원소를 삽입한다.', false),
       (770, 289, '인접한 두 원소를 순차적으로 비교하여 교환한다',
        '이는 버블 정렬의 동작이다. 삽입 정렬은 정렬된 부분에 원소를 삽입한다.', false),
       (771, 289, '정렬되지 않은 부분의 첫 번째 요소를 현재 요소로 선택하고 정렬된 부분의 요소들과 뒤에서부터 비교한다',
        '삽입 정렬은 정렬되지 않은 부분의 첫 번째 요소를 현재 요소로 선택한다. 현재 요소를 정렬된 부분의 요소들과 뒤에서부터 차례대로 비교하고, 현재 요소보다 큰 요소들을 오른쪽으로 한 칸씩 이동시킨다.',
        true),
       (772, 289, '가장 작은 값을 찾아 첫 번째 위치로 이동시킨다',
        '이는 선택 정렬의 동작이다. 삽입 정렬은 현재 요소를 정렬된 부분에 삽입한다.', false),

       (773, 291, '중간부터 양쪽으로 비교한다',
        '삽입 정렬은 맨 뒤부터 앞으로 순차적으로 비교한다. 중간부터 시작하지 않는다.', false),
       (774, 291, '정렬된 부분의 맨 뒤 원소부터 앞쪽으로 비교한다',
        '삽입 정렬은 현재 요소를 정렬된 부분의 맨 뒤 원소부터 앞쪽으로 차례대로 비교한다. 뒤에서부터 비교하면서 적절한 삽입 위치를 찾는다.',
        true),
       (775, 291, '정렬된 부분의 맨 앞 원소부터 뒤쪽으로 비교한다',
        '삽입 정렬은 뒤에서부터 앞으로 비교한다. 앞에서부터 비교하지 않는다.', false),
       (776, 291, '무작위로 비교한다',
        '삽입 정렬은 체계적으로 뒤에서부터 앞으로 비교한다. 무작위가 아니다.', false),

       (777, 292, '요소를 전혀 이동시키지 않는다',
        '현재 요소보다 큰 요소들은 오른쪽으로 이동한다.', false),
       (778, 292, '현재 요소보다 큰 요소들을 오른쪽으로 한 칸씩 이동시킨다',
        '삽입 정렬은 현재 요소보다 큰 요소들을 오른쪽으로 한 칸씩 이동시킨다. 이렇게 공간을 만들어 현재 요소를 올바른 위치에 삽입한다.',
        true),
       (779, 292, '모든 요소를 항상 이동시킨다',
        '현재 요소보다 큰 요소만 이동시킨다. 모든 요소를 이동하지 않는다.', false),
       (780, 292, '현재 요소보다 작은 요소들을 이동시킨다',
        '현재 요소보다 큰 요소들을 이동시킨다. 작은 요소는 이동하지 않는다.', false),

       (781, 294, '절반만 정렬하면 종료한다',
        '삽입 정렬은 모든 원소가 정렬될 때까지 반복한다.', false),
       (782, 294, '모든 원소가 정렬될 때까지 반복한다',
        '삽입 정렬은 정렬되지 않은 부분의 모든 원소를 정렬된 부분에 삽입할 때까지, 즉 모든 원소가 정렬될 때까지 반복한다. N개의 원소가 있으면 N-1번 반복한다.',
        true),
       (783, 294, '한 번만 수행하고 종료한다',
        '삽입 정렬은 모든 원소가 정렬될 때까지 반복한다.', false),
       (784, 294, '첫 번째 원소만 정렬하면 종료한다',
        '삽입 정렬은 모든 원소가 정렬될 때까지 반복한다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (97, 290, '첫 번째,1번째,first,첫번째,1',
        '삽입 정렬은 배열의 첫 번째 요소는 정렬이 되어 있다고 가정하고, 두 번째 요소부터 시작한다. 첫 번째 요소는 이미 정렬된 것으로 간주한다.'),
       (98, 293, '오른쪽,right,다음,뒤,옆',
        '삽입 정렬은 현재 요소보다 작거나 같은 요소를 만나면, 그 오른쪽 위치에 현재 요소를 삽입한다. 큰 요소들을 오른쪽으로 이동시켜 공간을 만든 후 삽입한다.');

-- =====================================================
-- Lesson 50: 삽입 정렬 분석 문제집
-- =====================================================

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (295, 50, '제시된 내용과 관련하여 옳은 것은?', '삽입 정렬은 상황에 따라 다른 시간 복잡도를 가진다.', 'OBJECTIVE'),
       (296, 50, '빈칸에 들어갈 알맞은 말을 작성하시오', '삽입 정렬의 최선의 경우 시간 복잡도는 ___이다.', 'SUBJECTIVE'),
       (297, 50, '제시된 내용과 관련하여 옳은 것은?', '삽입 정렬의 비교 횟수는 상황에 따라 다르다.', 'OBJECTIVE'),
       (298, 50, '제시된 내용과 관련하여 옳은 것은?', '삽입 정렬은 특정한 장점을 가진다.', 'OBJECTIVE'),
       (299, 50, '빈칸에 들어갈 알맞은 말을 작성하시오', '삽입 정렬은 추가 메모리가 불필요한 ___ 정렬이다.', 'SUBJECTIVE'),
       (300, 50, '제시된 내용과 관련하여 옳은 것은?', '삽입 정렬은 실무에서 특정하게 활용된다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (785, 295, '최선 O(1), 평균 O(n), 최악 O(n²)이다',
        '삽입 정렬의 최선은 O(n)이다. O(1)이 아니다.', false),
       (786, 295, '최선 O(n), 평균 O(n²), 최악 O(n²)이다',
        '삽입 정렬의 시간 복잡도는 최선의 경우(이미 정렬된 경우) O(n), 평균과 최악의 경우(역순 정렬) O(n²)이다. 거의 정렬된 배열에서 매우 효율적이다.',
        true),
       (787, 295, '모든 경우에 O(n²)이다',
        '삽입 정렬은 최선의 경우 O(n)이다. 모든 경우가 O(n²)은 아니다.', false),
       (788, 295, '모든 경우에 O(n log n)이다',
        '삽입 정렬은 평균과 최악의 경우 O(n²)이다. O(n log n)이 아니다.', false),

       (789, 297, '항상 n번만 비교한다',
        '삽입 정렬의 비교 횟수는 상황에 따라 다르다. 최선 n-1번, 최악 n(n-1)/2번이다.', false),
       (790, 297, '최선의 경우 n-1번, 최악의 경우 n(n-1)/2번 비교한다',
        '삽입 정렬의 비교 횟수는 최선의 경우(이미 정렬된 경우) n-1번(각 원소당 1번씩만 비교), 최악의 경우(역순 정렬) n(n-1)/2번이다. 상황에 따라 비교 횟수가 크게 달라진다.',
        true),
       (791, 297, '비교를 전혀 하지 않는다',
        '삽입 정렬은 정렬된 부분과 비교하여 위치를 찾는다. 비교를 수행한다.', false),
       (792, 297, '항상 n(n-1)/2번 비교한다',
        '삽입 정렬의 비교 횟수는 상황에 따라 다르다. 최선의 경우 n-1번만 비교한다.', false),

       (793, 298, '불안정 정렬이다',
        '삽입 정렬은 안정 정렬이다. 동일한 값의 순서를 유지한다.', false),
       (794, 298, '구현이 간단하고 거의 정렬된 배열에서 매우 효율적이며 제자리 정렬이고 안정 정렬이다',
        '삽입 정렬의 장점은 구현이 간단하고 직관적이며, 거의 정렬된 배열에서 매우 효율적(O(n))이고, 제자리 정렬로 추가 메모리가 불필요하며, 안정 정렬로 동일한 값의 순서를 유지한다는 것이다.',
        true),
       (795, 298, '항상 O(n log n)이다',
        '삽입 정렬은 평균과 최악의 경우 O(n²)이다. 항상 O(n log n)은 아니다.', false),
       (796, 298, '대용량 데이터에서 가장 빠르다',
        '삽입 정렬은 작은 배열이나 거의 정렬된 데이터에 효율적이다. 대용량 데이터에는 퀵 정렬이나 병합 정렬이 더 빠르다.', false),

       (797, 300, '네트워크 라우팅에 주로 사용된다',
        '삽입 정렬은 정렬 알고리즘이다. 네트워크 라우팅과는 직접적인 관련이 없다.', false),
       (798, 300, 'TimSort와 IntroSort는 작은 부분 배열에서 삽입 정렬을 사용한다',
        '실제로 TimSort(Python, Java 기본 정렬)와 IntroSort(C++ STL)는 작은 부분 배열에서 삽입 정렬을 사용한다. 거의 정렬된 데이터나 작은 배열에서 매우 효율적이기 때문이다. 하지만 큰 무작위 배열에는 퀵 정렬이나 병합 정렬이 더 적합하다.',
        true),
       (799, 300, '데이터베이스 인덱싱에만 사용된다',
        '삽입 정렬은 다양한 정렬 알고리즘에서 부분적으로 사용된다. 데이터베이스 인덱싱에만 사용되지 않는다.', false),
       (800, 300, '삽입 정렬은 실무에서 전혀 사용되지 않는다',
        '삽입 정렬은 TimSort, IntroSort 등에서 작은 부분 배열 정렬에 사용된다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (99, 296, 'o(n),선형 시간,선형시간,linear time,선형,n',
        '삽입 정렬의 최선의 경우(이미 정렬된 경우) 시간 복잡도는 O(n)이다. 각 원소를 한 번씩만 비교하면 되므로 선형 시간에 정렬된다.'),
       (100, 299, '제자리,in-place,in place,inplace,제자리 정렬',
        '삽입 정렬은 추가 메모리가 불필요한 제자리(in-place) 정렬이다. 원본 배열 내에서 삽입과 이동만으로 정렬하므로 추가 메모리가 거의 필요하지 않다.');
