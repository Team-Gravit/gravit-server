-- Unit: 그리디 알고리즘 (Unit ID: 24)
-- Chapter: 알고리즘 (Chapter ID: 2)

-- Lesson 생성
INSERT INTO lesson (id, unit_id, title)
VALUES (68, 24, '그리디 알고리즘 기초 문제집'),
       (69, 24, '그리디 알고리즘 예시 문제집'),
       (70, 24, '그리디 알고리즘 한계 문제집');

-- =====================================================
-- Lesson 68: 그리디 알고리즘 기초 문제집
-- =====================================================

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (413, 68, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '그리디 알고리즘은 특정한 방식으로 문제를 해결한다.', 'OBJECTIVE'),
       (414, 68, '빈칸에 들어갈 알맞은 말을 작성하시오', '그리디 알고리즘은 각 단계에서 ___을 선택하여 전역 최적을 기대한다.', 'SUBJECTIVE'),
       (415, 68, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '그리디 알고리즘은 두 가지 주요 속성을 가진다.', 'OBJECTIVE'),
       (416, 68, '제시된 내용과 관련하여 옳은 것은?', '탐욕 선택 속성은 그리디 알고리즘의 핵심 개념이다.', 'OBJECTIVE'),
       (417, 68, '빈칸에 들어갈 알맞은 말을 작성하시오', '그리디 알고리즘에서 전체 문제의 최적해가 부분 문제의 최적해로 구성될 수 있는 경우를 ___라고 한다.', 'SUBJECTIVE'),
       (418, 68, '제시된 내용과 관련하여 옳은 것은?', '그리디 알고리즘은 여러 가지 특징을 가진다.', 'OBJECTIVE'),
       (419, 68, '제시된 내용과 관련하여 옳은 것은?', '그리디 알고리즘은 장점을 가지고 있다.', 'OBJECTIVE'),
       (420, 68, '제시된 내용과 관련하여 옳은 것은?', '그리디 알고리즘은 단점도 가지고 있다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (1107, 413, '분할 정복 방식을 사용하는 알고리즘이다', '분할 정복은 병합 정렬 등에서 사용하는 방식으로, 그리디 알고리즘과는 다른 접근법이다. 그리디는 각 단계에서 지역 최적을 선택하는 방식을 사용한다.', false),
       (1108, 413, '이전 결과를 저장하여 재사용하는 알고리즘이다', '이전 결과를 저장하여 재사용하는 것은 다이내믹 프로그래밍의 특징이다. 그리디는 각 단계에서 독립적으로 최선의 선택을 한다.', false),
       (1109, 413, '매 순간 지금 당장 가장 좋아 보이는 선택을 하면서 답을 만드는 알고리즘이다', '그리디 알고리즘은 각 단계에서 지역 최적을 선택하여 전역 최적을 기대하는 방식으로, 매 순간 가장 좋아 보이는 선택을 하면서 답을 만든다.', true),
       (1110, 413, '모든 경우의 수를 탐색하는 알고리즘이다', '모든 경우의 수를 탐색하는 것은 브루트 포스 알고리즘의 특징이다. 그리디는 각 단계에서 최선의 선택만 하므로 모든 경우를 탐색하지 않는다.', false),

       (1111, 415, '탐욕 선택 속성과 최적 부분 구조', '그리디 알고리즘이 최적해를 보장하려면 탐욕 선택 속성과 최적 부분 구조를 모두 만족해야 한다. 이 두 가지는 그리디 알고리즘의 핵심 속성이다.', true),
       (1112, 415, '백트래킹과 가지치기', '백트래킹과 가지치기는 탐색 공간을 줄이는 백트래킹 알고리즘의 속성이다. 그리디 알고리즘의 주요 속성은 탐욕 선택 속성과 최적 부분 구조이다.', false),
       (1113, 415, '순환 구조와 재귀 호출', '순환 구조와 재귀 호출은 알고리즘 구현 방식이지, 그리디 알고리즘의 주요 속성이 아니다. 그리디의 핵심은 탐욕 선택 속성과 최적 부분 구조이다.', false),
       (1114, 415, '분할 정복과 메모이제이션', '분할 정복과 메모이제이션은 각각 다른 알고리즘 기법의 속성이다. 분할 정복은 문제를 나누어 해결하고, 메모이제이션은 다이내믹 프로그래밍에서 사용한다.', false),

       (1115, 416, '이전 결과를 재사용하는 것', '이전 결과를 재사용하는 것은 다이내믹 프로그래밍의 특징이다. 탐욕 선택 속성은 각 단계에서 최선의 선택을 했을 때 전체 문제의 최적해를 구할 수 있는 경우를 말한다.', false),
       (1116, 416, '각 단계에서 최선의 선택을 했을 때 전체 문제의 최적해를 구할 수 있는 경우', '탐욕 선택 속성은 각 단계의 최선 선택이 전체적으로 최적의 결과를 가져오는 경우를 의미한다. 이는 그리디 알고리즘이 최적해를 보장하기 위한 필수 조건이다.', true),
       (1117, 416, '모든 경우의 수를 탐색하는 것', '모든 경우의 수를 탐색하는 것은 브루트 포스 방식이다. 탐욕 선택 속성은 각 단계에서 최선의 선택만으로 전체 최적해를 구할 수 있는 성질을 말한다.', false),
       (1118, 416, '문제를 분할하여 해결하는 것', '문제를 분할하여 해결하는 것은 분할 정복 알고리즘의 특징이다. 탐욕 선택 속성은 각 단계에서의 최선 선택이 전체 최적해로 이어지는 성질을 의미한다.', false),

       (1119, 418, '구현이 복잡하다', '그리디 알고리즘은 구현이 단순하고 직관적이다. 각 단계에서 최선의 선택을 하는 방식이므로 복잡한 구현이 필요하지 않다.', false),
       (1120, 418, '빠르고 구현이 단순하지만 항상 최적해를 보장하지는 않는다', '그리디 알고리즘은 빠르고 구현이 단순하다는 장점이 있지만, 탐욕 선택 속성과 최적 부분 구조를 만족하지 않으면 항상 최적해를 보장하지는 않는다.', true),
       (1121, 418, '메모리 사용량이 많다', '그리디 알고리즘은 각 단계에서 선택만 하므로 메모리 사용량이 적다. 메모리 효율성은 그리디 알고리즘의 장점 중 하나이다.', false),
       (1122, 418, '항상 최적해를 보장한다', '그리디 알고리즘은 탐욕 선택 속성과 최적 부분 구조를 만족하지 않으면 최적해를 보장하지 않는다. 항상 최적해를 보장하는 것은 아니다.', false),

       (1123, 419, '항상 최적해를 보장한다', '그리디 알고리즘은 탐욕 선택 속성과 최적 부분 구조를 만족하지 않으면 최적해를 보장하지 않는다. 이는 그리디의 단점 중 하나이다.', false),
       (1124, 419, '구현이 복잡하다', '그리디 알고리즘의 장점 중 하나는 구현이 직관적이고 단순하다는 것이다. 각 단계에서 최선의 선택을 하는 방식이므로 이해하기 쉽다.', false),
       (1125, 419, '메모리 사용량이 많다', '그리디 알고리즘은 각 단계에서 선택만 하고 이전 결과를 저장하지 않으므로 메모리 효율적이다. 메모리 사용량이 많다는 것은 잘못된 설명이다.', false),
       (1126, 419, '구현이 직관적이고 빠른 실행 시간을 가진다', '그리디 알고리즘은 각 단계에서 최선의 선택을 하는 방식으로 구현이 직관적이고, 복잡한 탐색 없이 빠르게 실행되므로 실행 시간이 빠르다는 장점이 있다.', true),

       (1127, 420, '메모리 사용량이 많다', '그리디 알고리즘은 각 단계에서 선택만 하고 이전 결과를 저장하지 않으므로 메모리 효율적이다. 메모리 사용량이 많다는 것은 단점이 아니다.', false),
       (1128, 420, '실행 시간이 매우 느리다', '그리디 알고리즘은 각 단계에서 최선의 선택만 하므로 실행 시간이 빠르다. 실행 시간이 느리다는 것은 그리디의 단점이 아니다.', false),
       (1129, 420, '항상 최적해를 보장하지 않는다', '그리디 알고리즘은 탐욕 선택 속성과 최적 부분 구조를 만족하지 않으면 최적해를 보장하지 못한다. 이는 그리디 알고리즘의 주요 단점이다.', true),
       (1130, 420, '구현이 매우 복잡하다', '그리디 알고리즘은 구현이 단순하고 직관적이다. 구현이 복잡하다는 것은 그리디의 단점이 아니라 오히려 구현이 단순한 것이 장점이다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (135, 414, '지역 최적,local optimum,최선의 선택,지역최적,로컬 옵티멈,국소 최적,로컬최적',
        '그리디 알고리즘은 각 단계에서 지역 최적(Local Optimum)을 선택하여 전역 최적을 기대한다. 이는 그리디 알고리즘의 핵심 전략으로, 매 순간 가장 좋아 보이는 선택을 한다.'),
       (136, 417, '최적 부분 구조,optimal substructure,최적부분구조,부분 구조의 최적성,최적부분구조 속성',
        '전체 문제의 최적해가 부분 문제의 최적해로 구성될 수 있는 경우를 최적 부분 구조라고 한다. 이는 그리디 알고리즘이 최적해를 보장하기 위해 필요한 두 가지 속성 중 하나이다.');

-- =====================================================
-- Lesson 69: 그리디 알고리즘 예시 문제집
-- =====================================================

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (421, 69, '제시된 내용과 관련하여 옳은 것은?', '동전 종류가 500, 100, 50, 10원이고 1260원을 거슬러 준다.', 'OBJECTIVE'),
       (422, 69, '빈칸에 들어갈 알맞은 말을 작성하시오', '코인 거스름돈 문제에서 500, 100, 50, 10원으로 1260원을 거슬러 줄 때 필요한 최소 동전 개수는 ___개이다.', 'SUBJECTIVE'),
       (423, 69, '제시된 내용과 관련하여 옳은 것은?', '코인이 500, 100, 50, 10원인 경우를 고려한다.', 'OBJECTIVE'),
       (424, 69, '제시된 내용과 관련하여 옳은 것은?', '여러 회의를 하나의 회의실에 배정해야 한다.', 'OBJECTIVE'),
       (425, 69, '빈칸에 들어갈 알맞은 말을 작성하시오', '회의실 배정 문제에서 모든 회의를 ___으로 정렬한 후 그리디 알고리즘을 적용한다.', 'SUBJECTIVE'),
       (426, 69, '제시된 내용과 관련하여 옳은 것은?', '그리디 알고리즘은 체계적인 단계로 진행된다.', 'OBJECTIVE'),
       (427, 69, '제시된 내용과 관련하여 옳은 것은?', '선택 기준은 그리디의 핵심 요소이다.', 'OBJECTIVE'),
       (428, 69, '제시된 내용과 관련하여 옳은 것은?', '그리디는 데이터를 사전에 정렬하거나 우선순위 구조를 준비한다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (1131, 421, '가장 작은 동전부터 사용한다', '그리디 전략에서는 가장 작은 동전부터 사용하는 것이 아니라 가장 큰 동전부터 사용한다. 큰 동전을 우선 사용하여 동전 개수를 최소화한다.', false),
       (1132, 421, '남은 금액을 넘지 않는 가장 큰 동전부터 최대한 많이 사용한다', '그리디 전략은 남은 금액을 넘지 않는 가장 큰 동전부터 최대한 많이 사용하는 것이다. 이를 통해 동전의 개수를 최소화할 수 있다.', true),
       (1133, 421, '무작위로 동전을 선택한다', '그리디 알고리즘은 체계적으로 큰 동전부터 선택하는 방식이다. 무작위 선택은 그리디의 방식이 아니다.', false),
       (1134, 421, '모든 경우의 수를 탐색한다', '그리디 알고리즘은 모든 경우의 수를 탐색하지 않고 각 단계에서 최선의 선택만 한다. 모든 경우를 탐색하는 것은 브루트 포스 방식이다.', false),

       (1135, 423, '모든 경우를 탐색하기 때문이다', '그리디 알고리즘은 모든 경우를 탐색하지 않는다. 각 단계에서 최선의 선택만 하므로 이는 올바른 설명이 아니다.', false),
       (1136, 423, '큰 동전이 작은 동전의 배수 구조이므로 탐욕 선택 속성과 최적 부분 구조를 모두 만족한다', '500, 100, 50, 10원은 배수 관계를 가지므로 큰 동전을 최대한 사용해도 최적해를 보장한다. 탐욕 선택 속성과 최적 부분 구조를 만족하기 때문이다.', true),
       (1137, 423, '무작위로 선택하기 때문이다', '그리디 알고리즘은 무작위로 선택하지 않고 체계적으로 큰 동전부터 선택한다. 무작위 선택은 그리디의 특징이 아니다.', false),
       (1138, 423, '작은 동전부터 사용하기 때문이다', '그리디 알고리즘은 큰 동전부터 사용하는 것이 원칙이다. 작은 동전부터 사용하면 최적해를 보장할 수 없다.', false),

       (1139, 424, '종료 시간이 늦은 순서대로 배정한다', '종료 시간이 늦은 순서로 배정하면 회의실을 효율적으로 사용할 수 없다. 시작 시간 기준으로 정렬하여 배정해야 한다.', false),
       (1140, 424, '시작 시간 오름차순으로 정렬하고 현재 회의보다 이전에 끝난 회의실을 찾아 배정한다', '회의실 배정 문제는 시작 시간 오름차순으로 정렬한 후, 각 회의에 대해 현재 시간보다 이전에 끝난 회의실을 찾아 배정하는 방식으로 해결한다.', true),
       (1141, 424, '무작위로 배정한다', '그리디 알고리즘은 체계적으로 배정하는 방식이다. 무작위 배정은 최적해를 보장할 수 없다.', false),
       (1142, 424, '회의 시간이 긴 순서대로 배정한다', '회의 시간의 길이는 회의실 배정 문제의 주요 기준이 아니다. 시작 시간을 기준으로 정렬하여 배정해야 한다.', false),

       (1143, 426, '해답 검사 → 선택 기준 정의 → 문제 구조 파악', '그리디 알고리즘의 단계 순서가 잘못되었다. 문제 구조 파악이 먼저 이루어져야 한다.', false),
       (1144, 426, '정렬 → 문제 구조 파악 → 선택 기준 정의', '그리디 알고리즘의 단계 순서가 잘못되었다. 문제 구조 파악이 먼저, 그 다음 선택 기준 정의, 이후 정렬이 진행된다.', false),
       (1145, 426, '문제 구조 파악 → 선택 기준 정의 → 정렬 또는 우선순위 구조 준비 → 반복 선택 및 적절성 검사 → 해답 검사', '그리디 알고리즘은 먼저 문제 구조를 파악하고, 선택 기준을 정의한 후, 정렬 또는 우선순위 구조를 준비하며, 반복 선택 및 적절성 검사를 거쳐 최종 해답을 검사하는 순서로 진행된다.', true),
       (1146, 426, '반복 선택 → 문제 구조 파악 → 해답 검사', '그리디 알고리즘의 단계 순서가 잘못되었다. 반복 선택 전에 문제 구조 파악과 선택 기준 정의가 먼저 이루어져야 한다.', false),

       (1147, 427, '이전 결과를 저장한다', '이전 결과를 저장하는 것은 다이내믹 프로그래밍의 특징이다. 선택 기준 정의는 현재 상태에서 최선의 선택을 결정하는 것이다.', false),
       (1148, 427, '문제를 분할한다', '문제를 분할하는 것은 분할 정복 알고리즘의 특징이다. 선택 기준 정의는 현재 상태에서 가장 좋은 선택의 기준을 정하는 것이다.', false),
       (1149, 427, '모든 경우의 수를 나열한다', '모든 경우의 수를 나열하는 것은 브루트 포스 방식이다. 선택 기준 정의는 각 단계에서 최선의 선택을 결정하는 기준을 정하는 것이다.', false),
       (1150, 427, '현재 상태에서 가장 좋은 선택의 기준을 정한다', '선택 기준 정의는 그리디 알고리즘에서 각 단계마다 현재 상태에서 가장 좋은 선택을 결정하는 기준을 정하는 것이다. 이는 그리디의 핵심 요소이다.', true),

       (1151, 428, '문제를 분할한다', '문제를 분할하는 것은 분할 정복 알고리즘의 특징이다. 정렬 또는 우선순위 구조 준비는 선택을 용이하게 하기 위한 것이다.', false),
       (1152, 428, '기준에 맞게 정렬하거나 우선순위 큐를 사용하여 선택을 용이하게 한다', '정렬 또는 우선순위 구조 준비는 선택 기준에 맞게 데이터를 정렬하거나 우선순위 큐를 사용하여 각 단계에서 최선의 선택을 쉽게 할 수 있도록 한다.', true),
       (1153, 428, '이전 결과를 재사용한다', '이전 결과를 재사용하는 것은 다이내믹 프로그래밍의 특징이다. 정렬은 선택을 용이하게 하기 위한 준비 단계이다.', false),
       (1154, 428, '모든 경우의 수를 저장한다', '모든 경우의 수를 저장하는 것은 그리디의 방식이 아니다. 정렬 또는 우선순위 구조는 선택을 효율적으로 하기 위한 것이다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (137, 422, '6,6개,여섯,여섯 개,6 개,육',
        '500원 2개, 100원 2개, 50원 1개, 10원 1개로 총 6개의 동전이 필요하다. 그리디 알고리즘을 적용하여 큰 동전부터 최대한 사용하면 최소 개수를 구할 수 있다.'),
       (138, 425, '시작 시간 오름차순,시작 시간,시작시간,시작 시간의 오름차순,시작시간 오름차순',
        '회의실 배정 문제에서 모든 회의를 시작 시간 오름차순으로 정렬한 후 그리디 알고리즘을 적용한다. 이를 통해 가능한 많은 회의를 배정할 수 있다.');

-- =====================================================
-- Lesson 70: 그리디 알고리즘 한계 문제집
-- =====================================================

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (429, 70, '제시된 내용과 관련하여 옳은 것은?', '특정 조건에서 그리디는 최적해를 보장하지 못한다.', 'OBJECTIVE'),
       (430, 70, '빈칸에 들어갈 알맞은 말을 작성하시오', '동전이 16, 5, 1원이고 20원을 만들 때 그리디로 구한 답은 5개이지만 실제 최적해는 ___개이다.', 'SUBJECTIVE'),
       (431, 70, '제시된 내용과 관련하여 옳은 것은?', '이 경우 그리디는 최적해를 찾지 못한다.', 'OBJECTIVE'),
       (432, 70, '제시된 내용과 관련하여 옳은 것은?', '그리디의 한계는 다른 방법으로 극복할 수 있다.', 'OBJECTIVE'),
       (433, 70, '빈칸에 들어갈 알맞은 말을 작성하시오', '그리디가 최적해를 보장하지 못하는 이유는 ___가 깨지기 때문이다.', 'SUBJECTIVE'),
       (434, 70, '제시된 내용과 관련하여 옳은 것은?', '그리디는 특정 조건을 만족하는 문제에 적합하다.', 'OBJECTIVE'),
       (435, 70, '제시된 내용과 관련하여 옳은 것은?', '일부 문제는 그리디로 해결할 수 없다.', 'OBJECTIVE'),
       (436, 70, '제시된 내용과 관련하여 옳은 것은?', '그리디 사용 전 특정 조건을 확인해야 한다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (1155, 429, '탐욕 선택 속성이나 최적 부분 구조를 만족하지 않는 경우', '그리디 알고리즘은 탐욕 선택 속성과 최적 부분 구조 두 가지 속성을 모두 만족해야 최적해를 보장한다. 둘 중 하나라도 만족하지 않으면 최적해를 보장하지 못한다.', true),
       (1156, 429, '문제가 너무 단순한 경우', '문제의 단순성은 그리디 알고리즘의 실패 원인이 아니다. 그리디는 두 가지 속성의 만족 여부에 따라 성공 여부가 결정된다.', false),
       (1157, 429, '입력 크기가 작은 경우', '입력 크기는 그리디 알고리즘의 성공 여부와 관련이 없다. 그리디는 탐욕 선택 속성과 최적 부분 구조의 만족 여부에 따라 최적해 보장 여부가 결정된다.', false),
       (1158, 429, '정렬이 필요한 경우', '정렬의 필요 여부는 그리디 알고리즘의 실패 원인이 아니다. 오히려 정렬은 그리디 알고리즘에서 자주 사용되는 전처리 단계이다.', false),

       (1159, 431, '동전의 개수가 부족하다', '동전은 무한히 사용할 수 있다고 가정하므로 동전 개수 부족은 문제가 아니다. 16원을 먼저 선택하면 최적해를 구할 수 없다는 것이 핵심이다.', false),
       (1160, 431, '16원을 먼저 선택하면 남은 4원을 1원으로만 채울 수 있어 전체 최적해의 일부라고 보장할 수 없다', '16원을 먼저 선택하는 것이 각 단계에서는 최선이지만, 전체 최적해로 이어지지 않는다. 5원 4개를 사용하는 것이 더 적은 개수로 20원을 만들 수 있다.', true),
       (1161, 431, '정렬이 잘못되었다', '정렬은 올바르게 되어 있다. 문제는 큰 동전을 먼저 선택하는 것이 전체 최적해로 이어지지 않는다는 점이다.', false),
       (1162, 431, '계산이 복잡하다', '계산의 복잡도는 문제가 아니다. 그리디로 구한 답이 최적해가 아닌 이유는 탐욕 선택 속성이 깨지기 때문이다.', false),

       (1163, 432, '다이내믹 프로그래밍을 사용하여 모든 경우를 고려한다', '그리디 알고리즘의 한계는 다이내믹 프로그래밍을 사용하여 극복할 수 있다. 다이내믹 프로그래밍은 모든 부분 문제의 최적해를 구하여 전체 최적해를 찾는다.', true),
       (1164, 432, '정렬을 생략한다', '정렬을 생략하는 것은 그리디의 한계를 극복하는 방법이 아니다. 오히려 정렬은 그리디 알고리즘에서 중요한 전처리 단계이다.', false),
       (1165, 432, '더 빠른 컴퓨터를 사용한다', '하드웨어 성능 개선은 그리디의 한계를 극복하는 방법이 아니다. 알고리즘적 접근 방식을 변경해야 한다.', false),
       (1166, 432, '더 큰 메모리를 사용한다', '메모리 용량을 늘리는 것은 그리디의 한계를 극복하는 방법이 아니다. 다이내믹 프로그래밍 등 다른 알고리즘 기법을 사용해야 한다.', false),

       (1167, 434, '모든 경우를 고려해야 하는 문제', '모든 경우를 고려해야 하는 문제는 그리디 알고리즘에 적합하지 않다. 브루트 포스나 다이내믹 프로그래밍 등 다른 방법이 필요하다.', false),
       (1168, 434, '탐욕 선택 속성과 최적 부분 구조를 만족하는 문제', '그리디 알고리즘은 탐욕 선택 속성과 최적 부분 구조를 모두 만족하는 문제에 적합하다. 이 두 조건을 만족하면 최적해를 보장할 수 있다.', true),
       (1169, 434, '복잡한 계산이 필요한 문제', '복잡한 계산이 필요한 문제는 그리디 알고리즘의 특징이 아니다. 그리디는 단순하고 직관적인 선택을 하는 알고리즘이다.', false),
       (1170, 434, '이전 결과에 의존하는 문제', '이전 결과에 의존하는 문제는 다이내믹 프로그래밍에 적합하다. 그리디는 각 단계에서 독립적으로 최선의 선택을 한다.', false),

       (1171, 435, '동전이 배수 구조인 거스름돈 문제', '동전이 배수 구조를 이루는 거스름돈 문제는 탐욕 선택 속성과 최적 부분 구조를 만족하므로 그리디 알고리즘으로 해결할 수 있다.', false),
       (1172, 435, '회의실 배정 문제', '회의실 배정 문제는 시작 시간 기준으로 정렬하여 그리디 알고리즘으로 해결할 수 있다. 탐욕 선택 속성과 최적 부분 구조를 만족한다.', false),
       (1173, 435, '배낭 문제에서 물건을 쪼갤 수 없는 경우', '0-1 배낭 문제는 물건을 쪼갤 수 없어 탐욕 선택 속성이 성립하지 않는다. 그리디 알고리즘으로는 최적해를 보장할 수 없으며 다이내믹 프로그래밍이 필요하다.', true),
       (1174, 435, '물건을 쪼갤 수 있는 배낭 문제', '물건을 쪼갤 수 있는 배낭 문제는 단위 무게당 가치가 높은 물건부터 선택하는 그리디 알고리즘으로 최적해를 구할 수 있다.', false),

       (1175, 436, '정렬 가능 여부만 확인한다', '정렬 가능 여부만으로는 그리디 알고리즘의 적용 가능성을 판단할 수 없다. 탐욕 선택 속성과 최적 부분 구조를 확인해야 한다.', false),
       (1176, 436, '입력 크기만 확인한다', '입력 크기만으로는 그리디 알고리즘의 적용 가능성을 판단할 수 없다. 문제의 구조적 특성을 분석해야 한다.', false),
       (1177, 436, '메모리 용량만 확인한다', '메모리 용량만으로는 그리디 알고리즘의 적용 가능성을 판단할 수 없다. 탐욕 선택 속성과 최적 부분 구조의 만족 여부를 확인해야 한다.', false),
       (1178, 436, '탐욕 선택 속성과 최적 부분 구조를 만족하는지 확인한다', '그리디 알고리즘을 사용하기 전에 반드시 탐욕 선택 속성과 최적 부분 구조를 만족하는지 확인해야 한다. 이 두 조건을 만족해야 최적해를 보장할 수 있다.', true);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (139, 430, '4,4개,넷,네 개,4 개,사',
        '5원 동전 4개를 사용하면 총 4개로 20원을 만들 수 있어 그리디의 5개(16원 1개, 1원 4개)보다 최적이다. 이는 그리디 알고리즘이 항상 최적해를 보장하지 않는다는 것을 보여주는 예시이다.'),
       (140, 433, '탐욕 선택 속성,greedy choice property,탐욕선택속성,그리디 선택 속성,탐욕적 선택 속성',
        '16원을 먼저 선택하는 것이 전체 최적해의 일부라고 보장할 수 없어 탐욕 선택 속성이 깨진다. 탐욕 선택 속성은 각 단계에서 최선의 선택을 했을 때 전체 문제의 최적해를 구할 수 있는 경우를 말한다.');
