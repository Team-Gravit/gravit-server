-- Unit: CPU스케줄링 (Unit ID: 62)
-- Chapter: 운영체제 (Chapter ID: 7)

-- Lesson 생성
INSERT INTO lesson (id, unit_id, title)
VALUES (182, 62, '스케줄링 기초'),
       (183, 62, '주요 스케줄링 알고리즘'),
       (184, 62, '고급 스케줄링 알고리즘');

-- ===== Lesson 1: 스케줄링 기초 =====
INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (1265, 182, '아래 제시한 개념에 대한 설명으로 옳은 것은?', 'CPU 스케줄링은 운영체제의 핵심 기능이다.', 'OBJECTIVE'),
       (1266, 182, '빈칸에 들어갈 알맞은 말을 작성하시오', '실행 중인 프로세스를 강제로 중단하고 다른 프로세스에 CPU를 할당하는 방식을 _____ 스케줄링이라고 한다.', 'SUBJECTIVE'),
       (1267, 182, '제시된 내용과 관련하여 옳은 것은?', '선점형 스케줄링은 프로세스를 강제로 중단할 수 있다.', 'OBJECTIVE'),
       (1268, 182, '다음 중 비선점형 스케줄링의 장단점으로 올바른 것은?', '비선점형 스케줄링은 자발적 CPU 반납을 기다린다.', 'OBJECTIVE'),
       (1269, 182, '빈칸에 들어갈 알맞은 말을 작성하시오', 'FCFS에서 실행 시간이 긴 프로세스가 먼저 실행되면 짧은 프로세스들이 대기하는 현상을 _____라고 한다.', 'SUBJECTIVE'),
       (1270, 182, '다음 중 선점형 스케줄링 알고리즘이 아닌 것은?', '스케줄링 알고리즘은 선점/비선점으로 구분된다.', 'OBJECTIVE'),
       (1271, 182, '다음 중 스케줄링의 목적으로 올바른 것은?', '스케줄링은 여러 목적을 가진다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES
-- 문제 1265
(3603, 1265, 'CPU 스케줄링은 하드웨어가 자동으로 수행한다', '운영체제가 수행한다.', false),
(3604, 1265, '여러 프로세스 중 어떤 프로세스에 CPU를 할당할지 결정하는 메커니즘이다', 'CPU 스케줄링은 운영체제가 한정된 CPU 자원을 여러 프로세스에 효율적이고 공평하게 분배하는 메커니즘이다.', true),
(3605, 1265, '단일 프로세스 시스템에서만 필요하다', '다중 프로세스 환경에서 필요하다.', false),
(3606, 1265, '메모리 할당만 담당한다', '메모리 관리와는 별개의 기능이다.', false),

-- 문제 1267
(3607, 1267, '컨텍스트 스위칭이 발생하지 않는다', '선점형은 컨텍스트 스위칭이 자주 발생한다.', false),
(3608, 1267, '우선순위가 높은 프로세스를 즉시 실행할 수 있지만 오버헤드가 증가한다', '선점형 스케줄링은 인터럽트 등으로 실행 중인 프로세스를 강제로 중단할 수 있다. 실시간 시스템에 적합하지만 컨텍스트 스위칭 오버헤드가 증가한다.', true),
(3609, 1267, 'CPU를 독점할 수 있다', '비선점형의 단점이다.', false),
(3610, 1267, '프로세스가 자발적으로 반납할 때까지 기다린다', '비선점형의 특징이다.', false),

-- 문제 1268
(3611, 1268, '장점은 우선순위 처리가 빠르고 단점은 오버헤드가 크다', '선점형의 특징이다.', false),
(3612, 1268, '장점은 컨텍스트 스위칭 오버헤드가 작고 단점은 CPU를 독점할 수 있다', '비선점형은 프로세스가 자발적으로 CPU를 반납할 때까지 기다린다. 컨텍스트 스위칭 오버헤드가 작지만 한 프로세스가 CPU를 독점할 수 있다.', true),
(3613, 1268, '실시간 시스템에 가장 적합하다', '선점형이 실시간 시스템에 적합하다.', false),
(3614, 1268, '모든 프로세스를 동시에 실행한다', '시분할로 순차 실행한다.', false),

-- 문제 1270
(3615, 1270, 'Round Robin', '선점형 알고리즘이다.', false),
(3616, 1270, 'SRTF', '선점형 알고리즘이다.', false),
(3617, 1270, 'Priority (선점형)', '선점형 알고리즘이다.', false),
(3618, 1270, 'FCFS', 'FCFS는 비선점형 스케줄링 알고리즘이다. 선입선출로 먼저 도착한 프로세스가 먼저 실행되며 자발적으로 반납할 때까지 기다린다.', true),

-- 문제 1271
(3619, 1271, '특정 프로세스만 우선 실행', '공평한 분배가 목적이다.', false),
(3620, 1271, '한정된 자원을 효율적이고 공평하게 분배', 'CPU 스케줄링은 한정된 CPU 자원을 여러 프로세스에 효율적이고 공평하게 분배하는 것을 목적으로 한다.', true),
(3621, 1271, '메모리 사용량 최소화만', '메모리 관리와는 별개이다.', false),
(3622, 1271, '디스크 I/O 최적화만', 'CPU 할당이 주 목적이다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (363, 1266, '선점형, preemptive', '실행 중인 프로세스를 강제로 중단하고 다른 프로세스에 CPU를 할당하는 방식을 선점형(Preemptive) 스케줄링이라고 한다. 인터럽트 등으로 강제 중단한다.'),
       (364, 1269, 'Convoy Effect, 호위 효과, 호송 효과', 'FCFS에서 실행 시간이 긴 프로세스가 먼저 실행되면 짧은 프로세스들이 뒤에서 대기하는 현상을 Convoy Effect(호위 효과)라고 한다.');


-- ===== Lesson 2: 주요 스케줄링 알고리즘 =====
INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (1272, 183, '제시된 내용과 관련하여 옳은 것은?', 'SJF는 실행 시간이 짧은 프로세스를 우선 실행한다.', 'OBJECTIVE'),
       (1273, 183, '빈칸에 들어갈 알맞은 말을 작성하시오', 'SJF에서 긴 프로세스가 계속 실행이 연기되는 현상을 _____라고 한다.', 'SUBJECTIVE'),
       (1274, 183, '아래 제시한 개념에 대한 설명으로 옳은 것은?', 'SRTF는 SJF의 변형 알고리즘이다.', 'OBJECTIVE'),
       (1275, 183, '아래 제시한 개념에 대한 설명으로 옳은 것은?', 'Time Slice는 RR의 핵심 파라미터이다.', 'OBJECTIVE'),
       (1276, 183, '빈칸에 들어갈 기법 이름을 작성하시오.', 'Priority 스케줄링에서 기아 현상을 방지하기 위해 대기 시간이 길어질수록 우선순위를 증가시키는 기법을 _____라고 한다.', 'SUBJECTIVE'),
       (1277, 183, '제시된 내용과 관련하여 옳은 것은?', 'HRN은 SJF의 문제점을 개선한 알고리즘이다.', 'OBJECTIVE'),
       (1278, 183, '다음 중 Round Robin의 특징으로 올바르지 않은 것은?', 'Round Robin은 시분할 시스템에 적합하다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES
-- 문제 1272
(3623, 1272, '평균 대기 시간이 최대이다', '평균 대기 시간이 이론적으로 최소이다.', false),
(3624, 1272, '이론적으로 평균 대기 시간이 최소이지만 기아 현상이 발생할 수 있다', 'SJF는 CPU 실행 시간이 가장 짧은 프로세스를 먼저 실행하는 비선점형 알고리즘이다. 이론적으로 평균 대기 시간이 최소이지만 긴 프로세스는 기아 현상이 발생할 수 있다.', true),
(3625, 1272, '선점형 알고리즘이다', 'SJF는 비선점형이다.', false),
(3626, 1272, 'CPU 실행 시간을 정확히 알 수 있다', 'CPU 실행 시간을 예측하기 어렵다.', false),

-- 문제 1274
(3627, 1274, 'SJF의 비선점형 버전이다', 'SRTF는 선점형이다.', false),
(3628, 1274, 'SJF의 선점형 버전으로 남은 실행 시간이 짧은 프로세스를 먼저 실행한다', 'SRTF(Shortest Remaining Time First)는 SJF의 선점형 버전이다. 남은 실행 시간이 가장 짧은 프로세스를 먼저 실행하며 기아 현상이 발생할 수 있다.', true),
(3629, 1274, '기아 현상이 발생하지 않는다', 'SRTF도 기아 현상이 발생할 수 있다.', false),
(3630, 1274, 'Time Slice를 사용한다', 'SRTF는 남은 시간 기준이지 Time Slice를 사용하지 않는다.', false),

-- 문제 1275
(3631, 1275, 'Time Slice는 클수록 좋다', '너무 크면 FCFS처럼 된다.', false),
(3632, 1275, 'Time Slice가 너무 크면 FCFS와 유사하고 너무 작으면 오버헤드가 증가한다', 'Time Slice가 너무 크면 FCFS와 유사해지고, 너무 작으면 컨텍스트 스위칭 오버헤드가 증가한다. 적절한 값(10-100ms)을 선택해야 한다.', true),
(3633, 1275, 'Time Slice는 작을수록 좋다', '너무 작으면 오버헤드가 증가한다.', false),
(3634, 1275, 'Time Slice는 성능에 영향이 없다', 'Time Slice는 성능에 큰 영향을 준다.', false),

-- 문제 1277
(3635, 1277, '선점형 알고리즘이다', 'HRN은 비선점형이다.', false),
(3636, 1277, 'SJF의 기아 현상을 해결하기 위해 대기 시간과 실행 시간을 고려한다', 'HRN(Highest Response Ratio Next)은 SJF의 기아 현상을 해결하기 위한 비선점형 알고리즘이다. 응답률 = (대기 시간 + CPU 사용 시간) / CPU 사용 시간으로 우선순위를 계산한다.', true),
(3637, 1277, '실행 시간만 고려한다', '대기 시간과 실행 시간을 모두 고려한다.', false),
(3638, 1277, '실시간 시스템에 주로 사용된다', '주로 비실시간 시스템에 사용된다.', false),

-- 문제 1278
(3639, 1278, '선점형 스케줄링이다', 'Round Robin의 특징이다.', false),
(3640, 1278, '응답 시간이 보장된다', 'Round Robin의 특징이다.', false),
(3641, 1278, '대화형 시스템에 적합하다', 'Round Robin의 특징이다.', false),
(3642, 1278, '평균 대기 시간이 항상 최소이다', '평균 대기 시간이 항상 최소인 것은 아니다. SJF가 이론적으로 최소이다. RR은 응답 시간 보장과 공평성이 장점이다.', true);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (365, 1273, 'starvation, 기아, 기아 현상', 'SJF에서 긴 프로세스가 짧은 프로세스들에 밀려 계속 실행이 연기되는 현상을 Starvation(기아 현상)이라고 한다. HRN이나 에이징으로 해결한다.'),
       (366, 1276, 'Aging, 에이징', 'Priority 스케줄링에서 기아 현상을 방지하기 위해 대기 시간이 길어질수록 우선순위를 점진적으로 증가시키는 기법을 에이징(Aging)이라고 한다.');


-- ===== Lesson 3: 고급 스케줄링 알고리즘 =====
INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (1279, 184, '아래 제시한 개념에 대한 설명으로 옳은 것은?', 'MLQ는 여러 큐를 사용하는 스케줄링 알고리즘이다.', 'OBJECTIVE'),
       (1280, 184, '빈칸에 들어갈 알맞은 말을 작성하시오', 'MLQ에서 큐 간 이동이 허용되어 동적으로 우선순위를 조정할 수 있는 알고리즘을 _____라고 한다.', 'SUBJECTIVE'),
       (1281, 184, '제시된 내용과 관련하여 옳은 것은?', 'MLFQ는 MLQ의 개선된 버전이다.', 'OBJECTIVE'),
       (1282, 184, '다음 중 MLQ의 단점으로 올바른 것은?', 'MLQ는 프로세스를 여러 큐로 분류한다.', 'OBJECTIVE'),
       (1283, 184, '빈칸에 들어갈 알맞은 말을 작성하시오', 'CPU 명령을 실행하는 것을 CPU _____라고 하고, I/O 입력을 대기하는 것을 I/O _____라고 한다.', 'SUBJECTIVE'),
       (1284, 184, '다음 중 MLFQ에서 프로세스 이동 규칙으로 올바른 것은?', 'MLFQ는 프로세스를 동적으로 이동시킨다.', 'OBJECTIVE'),
       (1285, 184, '다음 중 MLFQ의 큐 설계로 올바른 것은?', 'MLFQ는 여러 단계의 큐를 가진다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES
-- 문제 1279
(3643, 1279, '프로세스가 큐 간 자유롭게 이동할 수 있다', 'MLQ는 큐 간 이동이 불가능하다.', false),
(3644, 1279, '프로세스를 작업별로 여러 큐로 분류하고 각 큐는 독립적인 알고리즘을 사용한다', 'MLQ(Multi-Level Queue)는 프로세스를 시스템, 대화형 등 작업별로 여러 큐로 분류한다. 각 큐는 독립적인 스케줄링 알고리즘을 사용하며 프로세스는 최초 배정된 큐를 벗어날 수 없다.', true),
(3645, 1279, '단일 큐만 사용한다', '여러 큐를 사용한다.', false),
(3646, 1279, '기아 현상이 발생하지 않는다', '낮은 우선순위 큐에서 기아 현상이 발생할 수 있다.', false),

-- 문제 1281
(3647, 1281, '프로세스는 한 큐에 고정된다', 'MLFQ는 큐 간 이동이 가능하다.', false),
(3648, 1281, '항상 가장 높은 우선순위 큐에서 시작하고 Time Slice를 다 쓰면 하위 큐로 이동한다', 'MLFQ(Multi-Level Feedback Queue)는 큐 간 이동이 허용된 MLQ이다. 프로세스는 최상위 큐에서 시작하여 Time Slice를 다 쓰면 하위로, I/O 작업 후 상위로 이동한다.', true),
(3649, 1281, 'Time Slice가 모든 큐에서 동일하다', '하위로 갈수록 Time Slice가 증가한다.', false),
(3650, 1281, '비선점형 알고리즘이다', 'MLFQ는 선점형이다.', false),

-- 문제 1282
(3651, 1282, '구현이 매우 간단하다', 'MLQ는 여러 큐 관리로 복잡하다.', false),
(3652, 1282, '프로세스가 큐를 벗어날 수 없어 기아 현상이 발생하고 오버헤드가 있다', 'MLQ는 프로세스가 최초 배정된 큐를 벗어날 수 없어 낮은 우선순위 큐에서 기아 현상이 발생할 수 있다. 여러 큐 관리로 스케줄링 오버헤드도 발생한다.', true),
(3653, 1282, 'CPU 효율성이 매우 낮다', '큐 간 우선순위로 효율적으로 관리한다.', false),
(3654, 1282, '모든 프로세스를 동등하게 처리한다', '큐 간 우선순위가 존재한다.', false),

-- 문제 1284
(3655, 1284, 'Time Slice를 다 쓰면 상위 큐로 이동한다', '하위 큐로 이동한다.', false),
(3656, 1284, 'Time Slice를 다 쓰면 하위 큐로, I/O 작업 후 상위 큐로 이동한다', 'MLFQ에서 프로세스는 할당된 Time Slice를 모두 사용하면 하위 큐로 강등되고, I/O 작업 후에는 상위 큐로 승격될 수 있다. 에이징으로 기아를 방지한다.', true),
(3657, 1284, '한 번 하위 큐로 이동하면 돌아올 수 없다', 'I/O 작업 후 상위로 이동 가능하다.', false),
(3658, 1284, '모든 프로세스가 같은 큐에 머문다', 'MLFQ는 동적으로 큐를 이동한다.', false),

-- 문제 1285
(3659, 1285, '모든 큐가 Round Robin을 사용한다', '가장 하위 큐는 FCFS를 사용한다.', false),
(3660, 1285, '가장 하위 큐는 FCFS를 사용하고 하위로 갈수록 Time Slice가 증가한다', 'MLFQ에서 가장 하위 큐는 FCFS 스케줄링을 사용한다. 단계가 내려갈수록 Time Slice가 증가하고, CPU Burst는 낮은 우선순위 큐에, I/O Burst는 높은 우선순위 큐에 배치된다.', true),
(3661, 1285, '하위로 갈수록 Time Slice가 감소한다', 'Time Slice는 증가한다.', false),
(3662, 1285, 'I/O Burst 프로세스를 낮은 우선순위에 배치한다', 'I/O Burst는 높은 우선순위에 배치한다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (367, 1280, 'mlfq, multi-level feedback queue, 다단계 피드백 큐', 'MLQ에서 큐 간 이동이 허용되어 동적으로 우선순위를 조정할 수 있는 알고리즘을 MLFQ(Multi-Level Feedback Queue)라고 한다.'),
       (368, 1283, 'Burst, 버스트', 'CPU 명령을 실행하는 것을 CPU Burst라고 하고, I/O 입력을 대기하는 것을 I/O Burst라고 한다. MLFQ는 CPU/I/O Burst 특성에 따라 큐를 조정한다.');

-- unit7

