-- Unit: 메모리관리기초 (Unit ID: 65)
-- Chapter: 운영체제 (Chapter ID: 7)

-- Lesson 생성
INSERT INTO lesson (id, unit_id, title)
VALUES (191, 65, '메모리 관리 기초'),
       (192, 65, '주소 바인딩과 메모리 할당'),
       (193, 65, '단편화와 해결');

-- ===== Lesson 1: 메모리 관리 =====
INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (1325, 191, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '프로세스가 실행될 때 메모리는 코드, 데이터, 힙, 스택 영역으로 구성된다.', 'OBJECTIVE'),
       (1326, 191, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '메모리 계층 구조는 속도, 용량, 특징에 따라 레지스터, 캐시, 주기억장치, 보조기억장치로 구성된다.', 'OBJECTIVE'),
       (1327, 191, '빈칸에 들어갈 용어를 작성하시오', '힙 영역에서 할당된 메모리를 해제하지 않으면 계속 메모리가 유지되어 ___가 발생한다.', 'SUBJECTIVE'),
       (1328, 191, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '프로세스에는 코드 영역, 데이터 영역, 힙 영역, 스택 영역이 있다.', 'OBJECTIVE'),
       (1329, 191, '빈칸에 들어갈 용어를 작성하시오', '프로세스 메모리 구조에서 전역 변수와 정적 변수가 저장되는 영역을 ___라고 한다.', 'SUBJECTIVE'),
       (1330, 191, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '프로세스는 실행 시 코드, 데이터, 힙, 스택 영역으로 구성된다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES
-- 문제 1325
(3767, 1325, '스택 영역은 낮은 주소에서 높은 주소 방향으로 증가한다.', '스택 영역은 높은 주소에서 낮은 주소 방향으로 증가한다. 낮은 주소에서 높은 주소 방향으로 증가하는 것은 힙 영역이다.', false),
(3768, 1325, '힙 영역은 동적 메모리 할당 영역으로 런타임 시 크기가 결정된다.', '힙 영역은 사용자에 의해 동적으로 할당 및 해제되며, 유일하게 런타임 시 크기가 결정되는 영역이다. malloc, free 등을 통해 관리된다.', true),
(3769, 1325, '데이터 영역에는 지역 변수와 매개 변수가 저장된다.', '지역 변수와 매개 변수는 스택 영역에 저장된다. 데이터 영역에는 전역 변수와 정적 변수가 저장된다.', false),
(3770, 1325, '코드 영역은 함수 호출 완료 시 메모리에서 해제된다.', '코드 영역은 실행할 프로그램의 기계어 코드가 저장되는 곳으로, 프로그램이 실행되는 동안 유지된다. 함수 호출 완료 시 메모리가 해제되는 것은 스택 영역이다.', false),

-- 문제 1326
(3771, 1326, '보조기억장치는 휘발성 메모리로 전원이 꺼지면 데이터가 사라진다', '보조기억장치는 비휘발성 메모리로 전원이 꺼져도 데이터가 유지된다. 휘발성 메모리는 주기억장치(RAM)이다.', false),
(3772, 1326, '캐시는 L1, L2, L3로 구성되며 주기억장치보다 용량이 크다', '캐시는 L1, L2, L3로 구성되지만 주기억장치보다 용량이 작다. 속도는 매우 빠르지만 용량은 작은 것이 특징이다.', false),
(3773, 1326, '레지스터는 CPU 내부에 위치하며 가장 빠른 속도를 가진다', '레지스터는 CPU 내부에 위치하며 메모리 계층 구조에서 가장 빠른 속도를 가진다. 다만 용량은 매우 작다.', true),
(3774, 1326, '주기억장치는 보조기억장치보다 속도가 느리지만 용량이 크다', '주기억장치(RAM)는 보조기억장치보다 속도가 빠르지만 용량은 작다. 보조기억장치가 속도는 느리지만 용량이 크다.', false),

-- 문제 1328
(3775, 1328, '힙 영역과 스택 영역 모두 낮은 주소에서 높은 주소 방향으로 증가한다', '힙 영역은 낮은 주소에서 높은 주소 방향으로 증가하지만, 스택 영역은 높은 주소에서 낮은 주소 방향으로 증가한다.', false),
(3776, 1328, '힙 영역은 높은 주소에서 낮은 주소로, 스택 영역은 낮은 주소에서 높은 주소로 증가한다', '힙 영역은 낮은 주소에서 높은 주소 방향으로 증가하고, 스택 영역은 높은 주소에서 낮은 주소 방향으로 증가한다.', false),
(3777, 1328, '힙 영역은 낮은 주소에서 높은 주소로, 스택 영역은 높은 주소에서 낮은 주소로 증가한다', '힙 영역은 낮은 주소에서 높은 주소 방향으로 증가하고, 스택 영역은 높은 주소에서 낮은 주소 방향으로 증가한다. 두 영역은 서로 반대 방향으로 증가한다.', true),
(3778, 1328, '힙 영역과 스택 영역의 증가 방향은 운영체제마다 다르다', '힙 영역과 스택 영역의 증가 방향은 일반적으로 정해져 있다. 힙은 낮은 주소에서 높은 주소로, 스택은 높은 주소에서 낮은 주소로 증가한다.', false),

-- 문제 1330
(3779, 1330, '코드 영역은 실행할 프로그램의 기계어 코드가 저장되며 cpu가 명령어를 실행한다', '코드 영역은 프로그램의 코드가 기계어 형태로 저장되는 공간이며, cpu는 이 영역에 저장된 명령어를 실행한다.', true),
(3780, 1330, '데이터 영역에는 지역 변수가 저장되며 함수 호출 완료 시 해제된다', '지역 변수는 스택 영역에 저장되며 함수 호출 완료 시 해제된다. 데이터 영역에는 전역 변수와 정적 변수가 저장된다.', false),
(3781, 1330, '힙 영역은 컴파일 타임에 크기가 결정되며 정적으로 할당된다', '힙 영역은 유일하게 런타임 시 크기가 결정되며, 사용자에 의해 동적으로 할당 및 해제된다.', false),
(3782, 1330, '스택 영역은 낮은 주소에서 높은 주소 방향으로 증가한다', '스택 영역은 높은 주소에서 낮은 주소 방향으로 증가한다. 낮은 주소에서 높은 주소로 증가하는 것은 힙 영역이다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (382, 1327, '메모리 누수', '힙 영역에서 동적으로 할당된 메모리를 해제하지 않아 계속 메모리가 유지되는 현상이다.'),
       (383, 1329, '데이터 영역', '전역 변수와 정적 변수가 저장되는 공간으로, 프로그램 시작과 동시에 할당되며 종료 시까지 유지된다.');


-- ===== Lesson 2: 주소 바인딩과 메모리 할당 =====
INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (1331, 192, '다음 중 주소 바인딩 방식에 대한 설명으로 올바르지 않은 것은?', '프로그램의 논리 주소를 물리 주소로 변환하는 과정을 주소 바인딩이라고 한다.', 'OBJECTIVE'),
       (1332, 192, '빈칸에 들어갈 용어를 작성하시오', '실행 타임 바인딩에서 논리 주소를 물리 주소로 변환하기 위해 사용하는 하드웨어 장치를 ___라고 한다.', 'SUBJECTIVE'),
       (1333, 192, '다음 중 연속 할당 방식에 대한 설명으로 올바르지 않은 것은?', '연속 할당은 프로세스가 메모리의 연속된 공간을 차지하는 할당 방식이다.', 'OBJECTIVE'),
       (1334, 192, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '가변 분할 방식에서는 프로세스를 어디에 배치할지 결정하는 배치 전략이 필요하다.', 'OBJECTIVE'),
       (1335, 192, '다음 중 메모리 배치 전략에 대한 설명으로 올바르지 않은 것은?', '프로세스를 메모리에 배치하기 위한 다양한 전략이 있다.', 'OBJECTIVE'),
       (1336, 192, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '주소 바인딩은 논리 주소를 물리 주소로 변환하는 과정이다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES
-- 문제 1331
(3783, 1331, '컴파일 타임 바인딩은 컴파일 시 물리 주소가 결정된다.', '컴파일 타임 바인딩은 컴파일 시 물리 주소가 결정되며, 물리 주소를 변경하려면 다시 컴파일해야 한다.', false),
(3784, 1331, '실행 타임 바인딩은 가장 유연하며 MMU를 사용한다', '실행 타임 바인딩은 실행 중 주소 변환이 이루어지며 가장 유연한 방식으로 MMU를 사용한다.', false),
(3785, 1331, '로드 타임 바인딩은 프로그램 실행 중에 주소가 결정된다', '로드 타임 바인딩은 프로그램 로딩 시에 주소가 결정된다. 실행 중에 주소가 결정되는 것은 실행 타임 바인딩이다.', true),
(3786, 1331, '실행 타임 바인딩은 프로그램 실행 중에 주소가 결정된다.', '실행 타임 바인딩은 실행 중 주소 변환이 이루어진다.', false),

-- 문제 1333
(3787, 1333, '고정 분할 방식은 메모리를 고정 크기로 분할하며 내부 단편화가 발생한다', '고정 분할 방식은 할당된 공간이 실제 사용 공간보다 클 때 내부 단편화가 발생한다.', false),
(3788, 1333, '가변 분할 방식은 프로세스 크기에 맞춰 동적으로 할당하며 외부 단편화가 발생한다', '가변 분할 방식은 총 여유 공간은 충분하지만 연속되지 않아 외부 단편화가 발생한다.', false),
(3789, 1333, '연속 할당 방식은 내부 단편화와 외부 단편화를 모두 방지할 수 있다', '고정 분할에서 내부 단편화, 가변 분할에서 외부 단편화가 발생한다.', true),
(3790, 1333, '연속 할당은 프로세스가 메모리의 연속된 공간을 차지한다', '연속 할당의 기본 정의이다.', false),

-- 문제 1334
(3791, 1334, 'First Fit은 가장 작은 적합한 공간에 할당하여 공간 효율적이다', '가장 작은 적합한 공간에 할당하는 것은 Best Fit이다.', false),
(3792, 1334, 'Best Fit은 공간 효율적이지만 탐색 속도가 느리다', 'Best Fit은 가장 작은 적합한 공간을 찾기 위해 탐색이 길어질 수 있다.', true),
(3793, 1334, 'Worst Fit은 가장 작은 공간에 할당하여 작은 빈 공간을 유지한다', 'Worst Fit은 가장 큰 공간에 할당하는 전략이다.', false),
(3794, 1334, 'First Fit은 탐색 속도가 느리지만 공간 효율이 가장 좋다', 'First Fit은 첫 번째 적합한 공간에 할당하므로 탐색 속도가 빠르다.', false),

-- 문제 1335
(3795, 1335, 'first fit은 첫 번째 적합한 공간에 할당하여 탐색 속도가 빠르다', 'first fit은 첫 번째로 발견한 적합한 공간에 할당한다.', false),
(3796, 1335, 'worst fit은 가장 큰 공간에 할당하여 큰 빈 공간을 유지한다', 'worst fit은 가장 큰 공간을 선택한다.', false),
(3797, 1335, 'best fit은 가장 큰 적합한 공간에 할당하여 탐색 속도가 빠르다', 'best fit은 가장 작은 적합한 공간에 할당하며 탐색이 느릴 수 있다.', true),
(3798, 1335, 'best fit은 공간 효율적이지만 모든 공간을 탐색해야 한다', '공간 효율적이지만 탐색 비용이 커질 수 있다.', false),

-- 문제 1336
(3799, 1336, '프로그램 로딩 시 주소가 결정되며, 실행 전에 물리 주소로 재배치된다', '로드 타임 바인딩은 프로그램 로딩 시 주소가 결정된다.', true),
(3800, 1336, '컴파일 시 물리 주소가 결정되므로 다시 컴파일하지 않아도 주소를 바꿀 수 있다', '이는 컴파일 타임 바인딩 설명이며, 주소 변경 시 재컴파일이 필요하다.', false),
(3801, 1336, '실행 중에만 주소가 변환되며 MMU 없이 동작한다', '실행 타임 바인딩은 MMU를 사용한다.', false),
(3802, 1336, '주소 바인딩은 필요 없고 운영체제는 물리 주소만 사용한다', '프로그램은 논리 주소를 사용하며 바인딩이 필요하다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (384, 1332, 'mmu,memory management unit', '실행 타임 바인딩에서 논리 주소를 물리 주소로 변환하는 하드웨어 장치이다.');


-- ===== Lesson 3: 단편화와 해결 =====
INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (1337, 193, '빈칸에 들어갈 알맞은 말을 작성하시오', '고정 분할 방식에서 할당된 메모리 공간이 실제 사용하는 공간보다 클 때 발생하는 단편화를 ___라고 한다.', 'SUBJECTIVE'),
       (1338, 193, '빈칸에 들어갈 용어를 작성하시오', '총 여유 메모리 공간은 충분하지만 연속되지 않아 프로세스를 할당할 수 없는 현상을 ___라고 한다.', 'SUBJECTIVE'),
       (1339, 193, '다음 중 외부 단편화를 해결하는 방법으로 올바른 것은?', '외부 단편화는 남아있는 메모리 크기는 충분하나 연속되지 않아 실제로는 할당할 수 없는 현상이다.', 'OBJECTIVE'),
       (1340, 193, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '페이징과 세그먼테이션은 단편화 문제를 해결하기 위한 메모리 관리 기법이다.', 'OBJECTIVE'),
       (1341, 193, '빈칸에 들어갈 용어를 작성하시오', '외부 단편화 해결을 위해 흩어진 빈 공간들을 한곳으로 모으는 기법을 ___라고 한다.', 'SUBJECTIVE'),
       (1342, 193, '빈칸에 들어갈 용어를 작성하시오', '메모리가 부족할 때 프로세스를 디스크로 이동시키는 것을 ___라고 한다.', 'SUBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES
-- 문제 1339
(3803, 1339, '세그먼테이션을 사용하여 프로그램을 논리적 단위로 분할한다', '세그먼테이션은 내부 단편화를 해결하는 방법이다. 외부 단편화는 여전히 발생할 수 있다.', false),
(3804, 1339, '압축을 통해 흩어진 빈 공간들을 한곳으로 모은다', '압축은 흩어진 빈 공간들을 한곳으로 모아 외부 단편화를 해결한다. 단, 오버헤드가 크고 프로세스 이동이 필요하다.', true),
(3805, 1339, '고정 분할 방식을 사용하여 메모리를 고정 크기로 분할한다', '고정 분할은 내부 단편화를 발생시킨다.', false),
(3806, 1339, '힙 영역의 크기를 런타임에 동적으로 조정한다', '외부 단편화 해결 방법이 아니다.', false),

-- 문제 1340
(3807, 1340, '페이징은 프로그램을 논리적 단위로 분할하여 내부 단편화를 해결한다', '논리적 단위로 분할하는 것은 세그먼테이션이다.', false),
(3808, 1340, '세그먼테이션은 메모리를 고정 크기로 나누어 외부 단편화를 해결한다', '고정 크기로 나누는 것은 페이징이다.', false),
(3809, 1340, '페이징은 메모리를 고정 크기로 나누어 비연속 할당하며 외부 단편화를 해결한다', '페이징은 고정 크기 페이지/프레임으로 나누어 비연속 할당해 외부 단편화를 해결한다.', true),
(3810, 1340, '세그먼테이션은 메모리를 동일한 크기로 분할하여 관리한다', '세그먼테이션은 논리적 단위로 분할하므로 크기가 동일하지 않다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (385, 1337, '내부 단편화', '필요한 크기보다 더 큰 메모리가 할당되어 공간이 낭비되는 현상이다.'),
       (386, 1338, '외부 단편화', '총 여유 공간은 충분하지만 연속되지 않아 실제로 할당할 수 없는 현상이다.'),
       (387, 1341, '압축', '흩어진 빈 공간을 한곳으로 모아 외부 단편화를 해결하는 기법이다.'),
       (388, 1342, '스와핑,swapping', '메모리 부족 시 프로세스를 디스크로 이동시켰다가 나중에 다시 메모리로 로드하는 기법이다.');


