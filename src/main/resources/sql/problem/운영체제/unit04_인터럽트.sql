-- Unit: 인터럽트 (Unit ID: 59)
-- Chapter: 운영체제 (Chapter ID: 7)

-- Lesson 생성
INSERT INTO lesson (id, unit_id, title)
VALUES (173, 59, '인터럽트 기초'),
       (174, 59, '인터럽트 종류와 동작'),
       (175, 59, '인터럽트 우선순위와 최적화');

-- ===== Lesson 1: 인터럽트 기초 =====

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (1202, 173, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '인터럽트는 CPU의 효율적인 동작을 위한 메커니즘이다.', 'OBJECTIVE'),
       (1203, 173, '빈칸에 들어갈 알맞은 말을 작성하시오', 'CPU가 인터럽트를 처리하기 위해 실행하는 루틴을 _____라고 한다.', 'SUBJECTIVE'),
       (1204, 173, '제시된 내용과 관련하여 옳은 것은?', '인터럽트는 여러 목적으로 사용된다.', 'OBJECTIVE'),
       (1205, 173, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '인터럽트와 폴링은 이벤트 처리 방식이 다르다.', 'OBJECTIVE'),
       (1206, 173, '빈칸에 들어갈 알맞은 말을 작성하시오', '각 인터럽트에 대응하는 ISR의 주소를 담은 테이블을 _____ 테이블이라고 한다.', 'SUBJECTIVE'),
       (1207, 173, '제시된 내용과 관련하여 옳은 것은?', '인터럽트 발생 시 CPU 모드가 전환된다.', 'OBJECTIVE'),
       (1208, 173, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '인터럽트 처리 후 복귀를 위해 정보를 저장해야 한다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES
-- 문제 1202
(3423, 1202, '인터럽트는 CPU가 계속 대기하도록 만든다', '인터럽트는 CPU 유휴 시간을 최소화한다.', false),
(3424, 1202, 'CPU가 예기치 않은 상황 발생 시 현재 작업을 중단하고 처리한 후 복귀하는 메커니즘이다', '인터럽트는 우선순위가 높은 작업이나 예기치 않은 상황 발생 시 현재 작업을 중단하고 해당 상황을 처리한 후 원래 작업으로 돌아간다. CPU 효율성을 극대화한다.', true),
(3425, 1202, '인터럽트는 하드웨어에서만 발생한다', '소프트웨어 인터럽트도 존재한다.', false),
(3426, 1202, '인터럽트 발생 시 복귀가 불가능하다', '인터럽트 처리 후 원래 작업으로 복귀한다.', false),

-- 문제 1204
(3427, 1204, 'CPU 유휴 시간 최소화', '인터럽트의 핵심 목적이다.', false),
(3428, 1204, '비동기 이벤트 처리', '인터럽트를 통해 I/O 완료, 타이머 등을 처리한다.', false),
(3429, 1204, '우선순위가 높은 작업의 즉각 처리', '인터럽트의 목적이다.', false),
(3430, 1204, 'CPU 성능 저하', 'I/O 작업은 CPU보다 수천~수만 배 느리다. 인터럽트를 사용하면 CPU가 I/O 완료를 기다리지 않고 다른 작업을 수행하여 효율성을 높인다.', true),

-- 문제 1205
(3431, 1205, '인터럽트는 주기적으로 확인하고 폴링은 이벤트 발생 시 알림받는다', '반대이다. 인터럽트가 이벤트 발생 시 알림받는다.', false),
(3432, 1205, '인터럽트는 이벤트 발생 시 알림받고 폴링은 주기적으로 상태를 확인한다', '인터럽트는 필요할 때만 처리하여 CPU 효율이 높고 응답이 빠르다. 폴링은 계속 확인해야 하므로 CPU 낭비가 크지만 구현이 간단하다.', true),
(3433, 1205, '폴링이 인터럽트보다 CPU 효율이 높다', '인터럽트가 CPU 효율이 더 높다.', false),
(3434, 1205, '인터럽트가 폴링보다 구현이 간단하다', '폴링이 구현이 더 간단하다.', false),

-- 문제 1207
(3435, 1207, '커널 모드에서 사용자 모드로 전환', 'ISR 실행 시 커널 모드로 전환된다.', false),
(3436, 1207, '사용자 모드에서 커널 모드로 전환', '인터럽트 발생 시 모드 비트가 1에서 0으로 변경되어 사용자 모드에서 커널 모드로 전환된다. ISR 실행 후 다시 사용자 모드로 복귀한다.', true),
(3437, 1207, '모드 전환이 발생하지 않는다', '인터럽트는 모드 전환이 발생한다.', false),
(3438, 1207, '항상 커널 모드를 유지한다', 'ISR 실행 후 사용자 모드로 복귀한다.', false),

-- 문제 1208
(3439, 1208, '프로그램 카운터(PC)와 레지스터 값', '인터럽트 처리 후 복귀하기 위해 PC, 레지스터 값, 프로세서 상태를 PCB에 저장한다. IRET 명령으로 저장된 상태를 복원한다.', true),
(3440, 1208, '다른 프로세스의 메모리 내용', '현재 프로세스의 상태만 저장한다.', false),
(3441, 1208, '디스크의 모든 파일', '프로세스 상태 정보만 저장한다.', false),
(3442, 1208, '네트워크 연결 정보만', 'PC, 레지스터 등 프로세스 실행 상태를 저장한다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (345, 1203, 'isr,interrupt service routine,인터럽트 서비스 루틴,인터럽트 핸들러,interrupt handler', 'CPU가 인터럽트를 처리하기 위해 실행하는 루틴을 ISR(Interrupt Service Routine) 또는 인터럽트 핸들러라고 한다.'),
       (346, 1206, '인터럽트 벡터,interrupt vector,인터럽트벡터', '각 인터럽트에 대응하는 ISR의 주소를 담은 테이블을 인터럽트 벡터 테이블이라고 한다. 인터럽트 종류별로 번호가 할당된다.');


-- ===== Lesson 2: 인터럽트 종류와 동작 =====

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (1209, 174, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '하드웨어 인터럽트는 외부 장치에 의해 발생한다.', 'OBJECTIVE'),
       (1210, 174, '빈칸에 들어갈 알맞은 말을 작성하시오', '프로그램 실행 중 명령어에 의해 발생하는 인터럽트를 _____라고 한다.', 'SUBJECTIVE'),
       (1211, 174, '제시된 내용과 관련하여 옳은 것은?', '소프트웨어 인터럽트는 프로그램 실행 중 발생한다.', 'OBJECTIVE'),
       (1212, 174, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '하드웨어 인터럽트는 마스킹 가능 여부에 따라 분류된다.', 'OBJECTIVE'),
       (1213, 174, '빈칸에 들어갈 알맞은 말을 작성하시오', '시스템 콜과 하드웨어 인터럽트의 차이점은 시스템 콜은 _____으로 발생하고 하드웨어 인터럽트는 비동기적으로 발생한다는 것이다.', 'SUBJECTIVE'),
       (1214, 174, '제시된 내용과 관련하여 옳은 것은?', '인터럽트는 정해진 순서대로 처리된다.', 'OBJECTIVE'),
       (1215, 174, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '타이머 인터럽트는 운영체제에서 중요한 역할을 한다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES
-- 문제 1209
(3443, 1209, 'I/O 작업 완료, 키보드 입력', '하드웨어 인터럽트는 외부 하드웨어 장치가 CPU에 신호를 보내 발생한다. I/O 완료, 타이머, 전원 장애, 하드웨어 오류 등이 있다.', true),
(3444, 1209, '시스템 콜 (read, write)', '시스템 콜은 소프트웨어 인터럽트이다.', false),
(3445, 1209, 'Division by zero', '예외는 소프트웨어 인터럽트이다.', false),
(3446, 1209, 'Segmentation fault', '예외는 소프트웨어 인터럽트이다.', false),

-- 문제 1211
(3447, 1211, '시스템 콜 - 프로그램의 의도적 요청', '소프트웨어 인터럽트의 종류이다.', false),
(3448, 1211, '예외 - 프로그램 오류', '소프트웨어 인터럽트의 종류이다.', false),
(3449, 1211, '트랩 - 디버깅, 브레이크포인트', '소프트웨어 인터럽트의 종류이다.', false),
(3450, 1211, 'I/O 완료 인터럽트', 'I/O 완료는 하드웨어 인터럽트이다. 소프트웨어 인터럽트는 시스템 콜, 예외, 트랩으로 분류된다.', true),

-- 문제 1212
(3451, 1212, '마스커블 인터럽트는 CPU가 무시할 수 없다', '논마스커블 인터럽트가 무시할 수 없다.', false),
(3452, 1212, '마스커블 인터럽트는 비활성화 가능하고 논마스커블은 절대 무시할 수 없다', '마스커블 인터럽트는 인터럽트 마스크 레지스터로 비활성화 가능하며 대부분의 I/O 인터럽트가 해당한다. 논마스커블은 치명적인 하드웨어 오류를 처리한다.', true),
(3453, 1212, '논마스커블 인터럽트는 일반 I/O 작업에 사용된다', '일반 I/O는 마스커블 인터럽트를 사용한다.', false),
(3454, 1212, '둘 다 동일하다', '마스킹 가능 여부에서 차이가 있다.', false),

-- 문제 1214
(3455, 1214, '인터럽트 발생 → ISR 실행 → 상태 저장 → 복귀', '상태 저장이 ISR 실행보다 먼저 이루어진다.', false),
(3456, 1214, '인터럽트 발생 → 상태 저장 → 인터럽트 벡터 조회 → ISR 실행 → 상태 복원 → 복귀', '인터럽트가 발생하면 현재 상태(PC, 레지스터)를 PCB에 저장하고, 인터럽트 벡터 테이블에서 ISR 주소를 찾아 실행한 후, 저장된 상태를 복원하여 원래 위치로 복귀한다.', true),
(3457, 1214, 'ISR 실행 → 인터럽트 발생 → 복귀', '인터럽트 발생이 먼저이다.', false),
(3458, 1214, '상태 복원 → ISR 실행 → 복귀', 'ISR 실행 후 상태를 복원한다.', false),

-- 문제 1215
(3459, 1215, 'CPU 시간 분할', '타이머 인터럽트의 역할이다.', false),
(3460, 1215, '프로세스 스케줄링', '타이머 인터럽트의 역할이다.', false),
(3461, 1215, '시스템 시간 관리', '타이머 인터럽트의 역할이다.', false),
(3462, 1215, '파일 시스템 관리', '파일 시스템 관리는 타이머 인터럽트의 역할이 아니다. 타이머 인터럽트는 CPU 시간 분할, 스케줄링, 시간 관리, 타임아웃 처리를 담당한다.', true);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (347, 1210, '소프트웨어 인터럽트,software interrupt,트랩,trap,예외,exception', '프로그램 실행 중 명령어에 의해 발생하는 인터럽트를 소프트웨어 인터럽트 또는 트랩, 예외라고 한다.'),
       (348, 1213, '동기적,동기,synchronous', '시스템 콜은 프로그램 실행 중 동기적으로 발생하고, 하드웨어 인터럽트는 예측할 수 없는 시점에 비동기적으로 발생한다.');


-- ===== Lesson 3: 인터럽트 우선순위와 최적화 =====

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (1216, 175, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '인터럽트는 우선순위에 따라 처리된다.', 'OBJECTIVE'),
       (1217, 175, '빈칸에 들어갈 알맞은 말을 작성하시오', '인터럽트 발생부터 ISR 실행 시작까지의 시간을 _____라고 한다.', 'SUBJECTIVE'),
       (1218, 175, '제시된 내용과 관련하여 옳은 것은?', '인터럽트 우선순위 처리에는 여러 방법이 있다.', 'OBJECTIVE'),
       (1219, 175, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '인터럽트 네스팅은 우선순위 처리 방법 중 하나이다.', 'OBJECTIVE'),
       (1220, 175, '빈칸에 들어갈 알맞은 말을 작성하시오', '모든 인터럽트가 문맥 교환을 일으키는 것은 아니다. _____를 호출할 때만 문맥 교환이 발생한다.', 'SUBJECTIVE'),
       (1221, 175, '제시된 내용과 관련하여 옳은 것은?', '인터럽트 지연 시간은 시스템 성능에 영향을 준다.', 'OBJECTIVE'),
       (1222, 175, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '일부 상황에서는 인터럽트를 비활성화해야 한다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES
-- 문제 1216
(3463, 1216, '외부 신호 인터럽트', '우선순위가 가장 낮다.', false),
(3464, 1216, 'I/O 완료 인터럽트', '중간 우선순위이다.', false),
(3465, 1216, '타이머 인터럽트', '높은 우선순위이다.', false),
(3466, 1216, '전원 장애 인터럽트', '일반적으로 전원 장애(Power Failure)와 기계 고장(Machine Check)이 가장 높은 우선순위를 가진다. 시스템 안전을 위해 즉각 처리해야 한다.', true),

-- 문제 1218
(3467, 1218, '폴링 - 순차적으로 각 장치 확인', '인터럽트 우선순위 처리 방법이다.', false),
(3468, 1218, '벡터 인터럽트 - 장치가 벡터 번호 전송', '인터럽트 우선순위 처리 방법이다.', false),
(3469, 1218, '인터럽트 네스팅 - 높은 우선순위가 낮은 우선순위 중단', '인터럽트 우선순위 처리 방법이다.', false),
(3470, 1218, '라운드 로빈 - 순환 방식으로 처리', '라운드 로빈은 프로세스 스케줄링 알고리즘이지 인터럽트 우선순위 처리 방법이 아니다. 폴링, 벡터 인터럽트, 네스팅이 사용된다.', true),

-- 문제 1219
(3471, 1219, '높은 우선순위 인터럽트는 낮은 우선순위 ISR을 중단할 수 없다', '중단할 수 있다. 이것이 네스팅이다.', false),
(3472, 1219, '낮은 우선순위 ISR 실행 중 높은 우선순위 인터럽트 발생 시 현재 ISR을 중단하고 처리한다', '인터럽트 네스팅은 낮은 우선순위 ISR 실행 중 더 높은 우선순위의 인터럽트가 발생하면 현재 ISR을 중단하고 높은 우선순위 인터럽트를 먼저 처리한다.', true),
(3473, 1219, '모든 ISR을 동시에 실행한다', 'ISR은 순차적으로 실행된다.', false),
(3474, 1219, '인터럽트를 무시한다', '네스팅은 우선순위에 따라 처리한다.', false),

-- 문제 1221
(3475, 1221, '짧은 ISR 작성', 'ISR을 짧게 작성하면 지연 시간이 줄어든다.', true),
(3476, 1221, 'ISR을 최대한 길게 작성', '짧은 ISR이 지연 시간을 최소화한다.', false),
(3477, 1221, '모든 인터럽트 비활성화', '필요 없는 인터럽트만 비활성화해야 한다.', false),
(3478, 1221, '하드웨어 버퍼를 사용하지 않음', '하드웨어 버퍼 활용이 지연 시간 감소에 도움된다.', false),

-- 문제 1222
(3479, 1222, '임계 영역에서는 인터럽트를 비활성화할 수 있다', '임계 영역에서 데이터 일관성을 위해 인터럽트를 일시적으로 비활성화할 수 있다. 단, 최소 시간만 비활성화해야 시스템 응답성이 유지된다.', true),
(3480, 1222, '인터럽트는 절대 비활성화할 수 없다', '일부 상황에서는 비활성화가 필요하다.', false),
(3481, 1222, '인터럽트를 오래 비활성화해도 문제없다', '오래 비활성화하면 시스템 응답성이 저하된다.', false),
(3482, 1222, '실시간 시스템에서는 고려하지 않아도 된다', '실시간 시스템에서는 특히 중요하다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (349, 1217, '인터럽트 지연 시간,interrupt latency,인터럽트 레이턴시,인터럽트지연시간', '인터럽트 발생부터 ISR 실행 시작까지의 시간을 인터럽트 지연 시간 또는 인터럽트 레이턴시라고 한다. 명령 완료, 감지, 상태 저장, ISR 주소 조회 시간이 포함된다.'),
       (350, 1220, '스케줄러,scheduler', '모든 인터럽트가 문맥 교환을 일으키는 것은 아니다. ISR만 실행하고 같은 프로세스로 복귀하면 문맥 교환이 없고, 스케줄러를 호출할 때만 문맥 교환이 발생한다.');
