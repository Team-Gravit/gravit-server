-- Unit: 동기화와병행성 (Unit ID: 63)
-- Chapter: 운영체제 (Chapter ID: 7)

-- Lesson 생성
INSERT INTO lesson (id, unit_id, title)
VALUES (185, 63, '동기화 기초'),
       (186, 63, '동기화 도구'),
       (187, 63, '고전적 동기화 문제');

-- ===== Lesson 1: 동기화 기초 =====
INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (1286, 185, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '동기화는 공유 자원 접근을 제어하는 메커니즘이다.', 'OBJECTIVE'),
       (1287, 185, '빈칸에 들어갈 알맞은 말을 작성하시오', '여러 프로세스가 공유하는 데이터에 접근하는 코드 영역을 _____라고 한다.', 'SUBJECTIVE'),
       (1288, 185, '다음 중 임계 영역 문제 해결 조건이 아닌 것은?', '임계 영역 문제는 3가지 조건을 만족해야 한다.', 'OBJECTIVE'),
       (1289, 185, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '상호 배제는 임계 영역 문제 해결의 핵심 조건이다.', 'OBJECTIVE'),
       (1290, 185, '빈칸에 들어갈 알맞은 말을 작성하시오', 'TestAndSet에서 CPU를 계속 사용하면서 대기하는 방식을 _____라고 한다.', 'SUBJECTIVE'),
       (1291, 185, '제시된 내용과 관련하여 옳은 것은?', '하드웨어 기반 동기화는 원자적 연산을 사용한다.', 'OBJECTIVE'),
       (1292, 185, '제시된 내용과 관련하여 옳은 것은?', 'CAS는 현대 프로세서에서 사용하는 원자적 명령어이다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES
-- 문제 1286
(3663, 1286, '단일 프로세스에서만 필요하다', '여러 프로세스나 스레드가 있을 때 필요하다.', false),
(3664, 1286, '여러 프로세스나 스레드가 공유 자원에 접근할 때 데이터 일관성을 유지하는 메커니즘이다', '동기화는 여러 프로세스나 스레드가 공유 자원에 접근할 때 데이터의 일관성을 유지하기 위한 메커니즘이다. 병행성 문제를 해결하는 핵심 기법이다.', true),
(3665, 1286, '메모리 할당만 담당한다', '메모리 관리와는 별개이다.', false),
(3666, 1286, 'CPU 스케줄링과 같은 개념이다', '스케줄링과는 다른 개념이다.', false),

-- 문제 1288
(3667, 1288, '상호 배제 (Mutual Exclusion)', '임계 영역 해결 조건이다.', false),
(3668, 1288, '진행 (Progress)', '임계 영역 해결 조건이다.', false),
(3669, 1288, '한정 대기 (Bounded Waiting)', '임계 영역 해결 조건이다.', false),
(3670, 1288, '선점 (Preemption)', '선점은 임계 영역 문제 해결 조건이 아니다. 3가지 조건은 상호 배제, 진행, 한정 대기이다.', true),

-- 문제 1289
(3671, 1289, '여러 프로세스가 동시에 임계 영역에 진입할 수 있다', '한 번에 하나만 진입 가능하다.', false),
(3672, 1289, '한 프로세스가 임계 영역을 실행 중이면 다른 프로세스는 진입할 수 없다', '상호 배제는 한 프로세스가 임계 영역을 실행 중이면 다른 프로세스는 진입할 수 없도록 하는 조건이다. 데이터 일관성을 보장한다.', true),
(3673, 1289, '프로세스가 무한정 대기할 수 있다', '한정 대기 조건 위반이다.', false),
(3674, 1289, '임계 영역이 비어있어도 진입을 막을 수 있다', '진행 조건 위반이다.', false),

-- 문제 1291
(3675, 1291, '소프트웨어만으로 구현된다', '하드웨어 명령어를 사용한다.', false),
(3676, 1291, 'TestAndSet, CAS 같은 원자적 연산을 사용하여 중단 없이 실행된다', '하드웨어 기반 동기화는 TestAndSet, Compare-And-Swap 같은 원자적(Atomic) 연산을 사용한다. 여러 단계가 중단 없이 실행되어 상호 배제를 보장한다.', true),
(3677, 1291, 'Busy Waiting이 발생하지 않는다', '하드웨어 기반도 Busy Waiting이 발생한다.', false),
(3678, 1291, '단일 프로세서에서만 동작한다', '다중 프로세서에서도 동작한다.', false),

-- 문제 1292
(3679, 1292, 'TestAndSet보다 기능이 제한적이다', 'CAS가 더 유연하다.', false),
(3680, 1292, '현재 값이 예상값과 같으면 새 값으로 변경하는 원자적 명령어이다', 'CAS(Compare-And-Swap)는 현재 값이 예상값과 같은지 확인하고 같으면 새 값으로 변경한다. Lock-Free 자료구조 구현에 활용되며 Java의 AtomicInteger 등에 사용된다.', true),
(3681, 1292, '단순 읽기 연산만 수행한다', '읽기와 쓰기를 원자적으로 수행한다.', false),
(3682, 1292, '2개 프로세스만 지원한다', '제한이 없다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (369, 1287, 'critical section,임계 영역,임계구역', '여러 프로세스가 공유하는 데이터에 접근하는 코드 영역을 임계 영역(Critical Section)이라고 한다. 한 번에 하나의 프로세스만 실행되어야 한다.'),
       (370, 1290, 'Busy Waiting,바쁜 대기,스핀락,spinlock', 'TestAndSet에서 CPU를 계속 사용하면서 대기하는 방식을 Busy Waiting 또는 스핀락이라고 한다. CPU 자원을 낭비하는 단점이 있다.');


-- ===== Lesson 2: 동기화 도구 =====
INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (1293, 186, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '세마포어는 동기화를 위한 소프트웨어 도구이다.', 'OBJECTIVE'),
       (1294, 186, '빈칸에 들어갈 연산 이름을 작성하시오.', '세마포어에서 값을 감소시키고 0 미만이면 대기하는 연산을 _____라고 한다.', 'SUBJECTIVE'),
       (1295, 186, '다음 중 Binary Semaphore와 Counting Semaphore의 차이로 올바른 것은?', '세마포어는 두 가지 종류가 있다.', 'OBJECTIVE'),
       (1296, 186, '제시된 내용과 관련하여 옳은 것은?', '모니터는 고수준 동기화 도구이다.', 'OBJECTIVE'),
       (1297, 186, '빈칸에 들어갈 알맞은 말을 작성하시오', 'Java에서 모니터 개념을 지원하는 키워드는 _____이다.', 'SUBJECTIVE'),
       (1298, 186, '다음 중 세마포어의 장점으로 올바른 것은?', '세마포어는 여러 장점을 가진다.', 'OBJECTIVE'),
       (1299, 186, '다음 중 동기화 기법의 비교로 올바르지 않은 것은?', '동기화 기법마다 장단점이 다르다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES
-- 문제 1293
(3683, 1293, '하드웨어 명령어만 사용한다', '소프트웨어 도구이다.', false),
(3684, 1293, '정수 변수와 wait(), signal() 두 원자적 연산으로 구성된다', '세마포어는 정수 변수와 wait()(P 연산), signal()(V 연산) 두 원자적 연산으로 구성된다. Block/Wakeup 방식으로 Busy Waiting을 제거한다.', true),
(3685, 1293, '2개 프로세스만 지원한다', '여러 프로세스를 지원한다.', false),
(3686, 1293, '자동으로 상호 배제를 보장하지 않는다', '올바르게 사용하면 상호 배제를 보장한다.', false),

-- 문제 1295
(3687, 1295, 'Binary는 여러 자원을 관리한다', 'Binary는 0 또는 1만 가진다.', false),
(3688, 1295, 'Binary는 0 또는 1이고 Counting은 여러 자원 개수를 관리한다', 'Binary Semaphore(Mutex)는 값이 0 또는 1로 상호 배제에 사용된다. Counting Semaphore는 여러 개의 자원을 관리하며 데이터베이스 연결 풀 등에 사용된다.', true),
(3689, 1295, '둘 다 동일한 기능이다', '용도와 값의 범위가 다르다.', false),
(3690, 1295, 'Counting이 Binary보다 간단하다', 'Binary가 더 간단하다.', false),

-- 문제 1296
(3691, 1296, '저수준 동기화 도구이다', '모니터는 고수준 도구이다.', false),
(3692, 1296, '공유 데이터와 접근 함수를 캡슐화하여 자동으로 상호 배제를 보장한다', '모니터는 공유 데이터와 접근 함수를 하나로 캡슐화한다. 한 번에 하나의 프로세스만 모니터 내부를 실행하여 자동으로 상호 배제를 보장하고 프로그래밍 오류를 줄인다.', true),
(3693, 1296, '세마포어보다 사용하기 어렵다', '모니터가 더 사용하기 쉽다.', false),
(3694, 1296, 'Busy Waiting이 필수이다', '모니터는 Block/Wakeup을 사용한다.', false),

-- 문제 1298
(3695, 1298, 'Busy Waiting이 발생한다', 'Block/Wakeup으로 Busy Waiting을 제거한다.', false),
(3696, 1298, 'Busy Waiting을 제거하고 사용법이 간단하다', '세마포어는 Block/Wakeup 방식으로 Busy Waiting을 제거하여 CPU를 효율적으로 사용한다. wait()와 signal() 연산으로 간단하게 사용할 수 있다.', true),
(3697, 1298, '언어 차원의 지원이 필요하다', '모니터의 특징이다.', false),
(3698, 1298, '프로그래밍 오류가 절대 발생하지 않는다', '오류 가능성은 있지만 감소한다.', false),

-- 문제 1299
(3699, 1299, 'TestAndSet은 간단하지만 Busy Waiting이 발생한다', '올바른 비교이다.', false),
(3700, 1299, '세마포어는 Busy Waiting을 제거하지만 프로그래밍 오류 가능성이 있다', '올바른 비교이다.', false),
(3701, 1299, '모니터는 사용이 편리하고 오류가 적다', '올바른 비교이다.', false),
(3702, 1299, 'TestAndSet이 모니터보다 사용하기 쉽다', 'TestAndSet은 저수준이라 더 어렵다. 모니터가 고수준이라 사용하기 쉽고 프로그래밍 오류가 적다.', true);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (371, 1294, 'wait,p,p 연산,p연산', '세마포어에서 값을 감소시키고 0 미만이면 대기하는 연산을 wait() 또는 P 연산이라고 한다. signal()(V 연산)은 값을 증가시킨다.'),
       (372, 1297, 'synchronized', 'Java에서 모니터 개념을 언어 차원에서 지원하는 키워드는 synchronized이다. synchronized 블록이나 메서드로 자동 동기화를 구현한다.');


-- ===== Lesson 3: 고전적 동기화 문제 =====
INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (1300, 187, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '생산자-소비자 문제는 고전적 동기화 문제 중 하나이다.', 'OBJECTIVE'),
       (1301, 187, '빈칸에 들어갈 알맞은 말을 작성하시오', '프로세스들이 서로 자원을 기다리며 무한정 대기하는 상태를 _____라고 한다.', 'SUBJECTIVE'),
       (1302, 187, '다음 중 교착 상태 발생 조건이 아닌 것은?', '교착 상태는 4가지 조건이 모두 만족될 때 발생한다.', 'OBJECTIVE'),
       (1303, 187, '다음 중 식사하는 철학자 문제의 해결 방법으로 올바르지 않은 것은?', '식사하는 철학자 문제는 교착 상태를 설명하는 고전적 문제이다.', 'OBJECTIVE'),
       (1304, 187, '빈칸에 들어갈 알맞은 말을 작성하시오', '낮은 우선순위 프로세스가 높은 우선순위 프로세스를 지연시키는 현상을 _____라고 한다.', 'SUBJECTIVE'),
       (1305, 187, '다음 중 우선순위 역전 해결 방법으로 올바른 것은?', '우선순위 역전은 실시간 시스템에서 문제가 된다.', 'OBJECTIVE'),
       (1306, 187, '다음 중 독자-저자 문제의 규칙으로 올바른 것은?', '독자-저자 문제는 데이터 읽기/쓰기 동기화 문제이다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES
-- 문제 1300
(3703, 1300, '무한 버퍼를 사용한다', '한정 버퍼를 사용한다.', false),
(3704, 1300, '한정 버퍼를 공유하며 생산자는 데이터 추가, 소비자는 데이터 제거를 한다', '생산자-소비자 문제는 한정 버퍼를 공유한다. empty(빈 슬롯), full(찬 슬롯), mutex(버퍼 접근) 세마포어를 사용하며 순서가 중요하다.', true),
(3705, 1300, '생산자만 버퍼에 접근한다', '생산자와 소비자 모두 접근한다.', false),
(3706, 1300, '동기화가 필요없다', '동기화가 필수적이다.', false),

-- 문제 1302
(3707, 1302, '상호 배제 (Mutual Exclusion)', '교착 상태 발생 조건이다.', false),
(3708, 1302, '점유와 대기 (Hold and Wait)', '교착 상태 발생 조건이다.', false),
(3709, 1302, '비선점 (No Preemption)', '교착 상태 발생 조건이다.', false),
(3710, 1302, '선점 (Preemption)', '선점은 교착 상태 발생 조건이 아니다. 4가지 조건은 상호 배제, 점유와 대기, 비선점, 순환 대기이다. 4가지가 모두 만족되어야 교착 상태가 발생한다.', true),

-- 문제 1303
(3711, 1303, '비대칭 접근 - 짝수는 왼쪽→오른쪽, 홀수는 오른쪽→왼쪽', '교착 상태 해결 방법이다.', false),
(3712, 1303, '최대 4명만 동시 식사', '교착 상태 해결 방법이다.', false),
(3713, 1303, '두 젓가락을 동시에 집기', '교착 상태 해결 방법이다.', false),
(3714, 1303, '모든 철학자가 동시에 왼쪽 젓가락을 집도록 한다', '이것은 교착 상태를 유발하는 방법이다. 모든 철학자가 왼쪽을 동시에 집으면 오른쪽을 영원히 기다려 교착 상태가 발생한다.', true),

-- 문제 1305
(3715, 1305, '낮은 우선순위 프로세스를 종료시킨다', '해결 방법이 아니다.', false),
(3716, 1305, '높은 우선순위 프로세스가 대기할 때 낮은 우선순위를 임시 상승시킨다', '우선순위 역전은 낮은 우선순위 L이 자원을 점유한 상태에서 높은 우선순위 H가 대기하고 중간 우선순위 M이 L을 선점하는 상황이다. 우선순위 상속으로 L을 H와 같게 상승시켜 해결한다.', true),
(3717, 1305, '중간 우선순위를 제거한다', '우선순위 시스템 자체를 바꿀 수 없다.', false),
(3718, 1305, '모든 프로세스를 같은 우선순위로 만든다', '우선순위 시스템의 의미가 없어진다.', false),

-- 문제 1306
(3719, 1306, '저자만 읽기가 가능하다', '독자가 읽기를 수행한다.', false),
(3720, 1306, '여러 독자는 동시에 읽기 가능하지만 저자는 배타적 접근이 필요하다', '독자-저자 문제는 여러 독자가 동시에 읽기 가능하지만 저자는 배타적 접근이 필요하다. readcount(독자 수), mutex(readcount 보호), wrt(저자 배제) 변수를 사용한다.', true),
(3721, 1306, '독자와 저자가 동시에 접근할 수 있다', '저자는 배타적 접근이 필요하다.', false),
(3722, 1306, '한 번에 한 독자만 읽을 수 있다', '여러 독자가 동시에 읽을 수 있다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (373, 1301, 'deadlock,교착 상태,데드락, dead lock', '프로세스들이 서로 상대방이 가진 자원을 기다리며 무한정 대기하는 상태를 교착 상태(Deadlock)라고 한다. 4가지 조건이 모두 만족될 때 발생한다.'),
       (374, 1304, 'priority inversion,우선순위 역전', '낮은 우선순위 프로세스가 높은 우선순위 프로세스를 지연시키는 현상을 우선순위 역전(Priority Inversion)이라고 한다. 우선순위 상속으로 해결한다.');


