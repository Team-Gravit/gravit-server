-- Unit: 프로세스관리 (Unit ID: 60)
-- Chapter: 운영체제 (Chapter ID: 5)

-- Lesson 생성
INSERT INTO lesson (id, unit_id, title)
VALUES (176, 60, '프로세스 생성과 종료'),
       (177, 60, '프로세스 간 통신'),
       (178, 60, 'CPU 스케줄링');

-- ===== Lesson 1: 프로세스 생성과 종료 =====
INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (1223, 176, '아래 제시한 개념에 대한 설명으로 옳은 것은?', 'fork()와 exec()는 새로운 프로그램을 실행하기 위해 함께 사용된다.', 'OBJECTIVE'),
       (1224, 176, '빈칸에 들어갈 알맞은 말을 작성하시오', '자식 프로세스가 종료되었지만 부모가 wait()를 호출하지 않아 PCB가 남아있는 상태를 _____라고 한다.', 'SUBJECTIVE'),
       (1225, 176, '제시된 내용과 관련하여 옳은 것은?', '좀비 프로세스는 종료되었지만 정리되지 않은 상태이다.', 'OBJECTIVE'),
       (1226, 176, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '고아 프로세스는 부모가 먼저 종료된 자식 프로세스이다.', 'OBJECTIVE'),
       (1227, 176, '빈칸에 들어갈 기법 이름을 작성하시오.', 'fork() 직후 메모리를 완전히 복사하지 않고 부모와 자식이 같은 메모리를 공유하다가 수정 시에만 복사하는 최적화 기법을 _____라고 한다.', 'SUBJECTIVE'),
       (1228, 176, '다음 중 exit()와 _exit()의 차이로 올바른 것은?', 'exit()와 _exit()는 프로세스 종료 방식이 다르다.', 'OBJECTIVE'),
       (1229, 176, '제시된 내용과 관련하여 옳은 것은?', 'exec() 함수는 프로세스를 새로운 프로그램으로 교체한다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES
-- 문제 1223
(3483, 1223, 'fork()만으로 새로운 프로그램을 실행할 수 있다', 'fork()는 현재 프로세스를 복제할 뿐이다.', false),
(3484, 1223, 'fork()로 자식 프로세스를 생성하고 exec()로 새 프로그램을 실행한다', 'fork()로 자식 프로세스를 생성한 후 자식이 exec()로 새로운 프로그램을 실행한다. 이것이 쉘이 명령어를 실행하는 방식이다. 부모는 wait()로 자식 종료를 대기한다.', true),
(3485, 1223, 'exec()만으로 새로운 프로세스를 생성할 수 있다', 'exec()는 프로세스를 교체할 뿐 새로 생성하지 않는다.', false),
(3486, 1223, 'fork()와 exec()는 함께 사용할 수 없다', '함께 사용하는 것이 일반적이다.', false),

-- 문제 1225
(3487, 1225, '메모리와 리소스를 계속 점유하고 있다', '메모리와 리소스는 반환되었다.', false),
(3488, 1225, '프로세스 테이블 항목은 남아있고 ps 명령어에서 Z로 표시된다', '좀비 프로세스는 메모리와 리소스는 반환되었지만 프로세스 테이블 항목(PCB)이 남아있다. ps 명령어에서 상태가 Z로 표시되며 wait()나 waitpid()로 정리해야 한다.', true),
(3489, 1225, '자동으로 제거되므로 문제없다', 'wait()를 호출해야 정리된다.', false),
(3490, 1225, '실행 중인 프로세스이다', '좀비는 이미 종료된 상태이다.', false),

-- 문제 1226
(3491, 1226, '시스템에 해를 끼치며 좀비 프로세스가 된다', '고아 프로세스는 init이 입양하여 정리되므로 문제없다.', false),
(3492, 1226, 'init 프로세스가 새로운 부모가 되어 자동으로 wait() 처리한다', '부모가 자식보다 먼저 종료되면 자식은 고아 프로세스가 된다. 운영체제는 init 프로세스(PID 1)가 입양하도록 하여 자동으로 정리한다.', true),
(3493, 1226, '영구적으로 실행 불가능하다', '고아 프로세스는 정상적으로 실행 가능하다.', false),
(3494, 1226, '부모 프로세스를 강제로 재시작한다', '부모를 재시작하지 않고 init이 입양한다.', false),

-- 문제 1228
(3495, 1228, '둘 다 버퍼를 flush한다', '_exit()는 버퍼를 flush하지 않는다.', false),
(3496, 1228, 'exit()는 버퍼를 flush하고 atexit() 핸들러를 실행하지만 _exit()는 하지 않는다', 'exit()는 표준 I/O 버퍼를 flush하고 atexit() 핸들러를 실행한다. _exit()는 즉시 종료하므로 긴급 종료나 fork() 후 자식에서 사용한다.', true),
(3497, 1228, '_exit()가 더 안전하다', 'exit()가 일반적인 종료에 더 적합하다.', false),
(3498, 1228, '둘 다 동일하게 동작한다', '버퍼 처리와 핸들러 실행에서 차이가 있다.', false),

-- 문제 1229
(3499, 1229, '새로운 프로세스를 생성한다', 'fork()가 새로운 프로세스를 생성한다.', false),
(3500, 1229, '현재 프로세스의 메모리를 새로운 프로그램으로 교체하고 PID는 유지된다', 'exec()는 현재 프로세스의 메모리 공간을 새로운 프로그램으로 완전히 교체한다. PID는 유지되지만 프로그램이 바뀌므로 성공 시 원래 코드로 돌아올 수 없다.', true),
(3501, 1229, 'exec() 성공 시 원래 프로그램으로 복귀한다', 'exec() 성공 시 원래 프로그램으로 돌아오지 않는다.', false),
(3502, 1229, 'PID가 변경된다', 'PID는 유지된다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (351, 1224, '좀비 프로세스,좀비프로세스,zombie process', '자식 프로세스가 종료되었지만 부모가 wait()를 호출하지 않아 PCB가 남아있는 상태를 좀비 프로세스라고 한다. 프로세스 테이블 슬롯을 차지한다.'),
       (352, 1227, 'cow,copy on write', 'fork() 직후 메모리를 완전히 복사하지 않고 부모와 자식이 같은 물리 메모리를 공유하다가 수정 시에만 복사하는 최적화 기법을 Copy-on-Write(COW)라고 한다.');


-- ===== Lesson 2: 프로세스 간 통신 =====
INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (1230, 177, '아래 제시한 개념에 대한 설명으로 옳은 것은?', 'IPC는 프로세스 간 데이터를 공유하기 위한 메커니즘이다.', 'OBJECTIVE'),
       (1231, 177, '빈칸에 들어갈 알맞은 말을 작성하시오', '부모-자식 프로세스 간 단방향 통신에 사용되는 IPC 방법으로 fd[0]은 읽기, fd[1]은 쓰기에 사용되는 것을 _____라고 한다.', 'SUBJECTIVE'),
       (1232, 177, '제시된 내용과 관련하여 옳은 것은?', '공유 메모리는 가장 빠른 IPC 방법이다.', 'OBJECTIVE'),
       (1233, 177, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '시그널은 프로세스에게 이벤트를 알리는 메커니즘이다.', 'OBJECTIVE'),
       (1234, 177, '빈칸에 들어갈 시그널 이름을 작성하시오.', 'Ctrl+C를 눌렀을 때 발생하여 프로세스를 종료시키는 시그널은 _____이다.', 'SUBJECTIVE'),
       (1235, 177, '제시된 내용과 관련하여 옳은 것은?', 'Named Pipe는 일반 파이프와 달리 파일 시스템에 존재한다.', 'OBJECTIVE'),
       (1236, 177, '다음 중 IPC 방법과 특징이 올바르게 연결된 것은?', 'IPC 방법마다 장단점이 다르다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES
-- 문제 1230
(3503, 1230, '프로세스는 기본적으로 메모리를 공유하므로 IPC가 불필요하다', '프로세스는 독립된 메모리 공간을 가진다.', false),
(3504, 1230, '프로세스는 독립된 메모리 공간을 가지므로 데이터 공유를 위해 IPC가 필요하다', '프로세스는 기본적으로 독립된 메모리 공간을 가지므로 데이터를 공유하려면 IPC(Inter-Process Communication)를 사용해야 한다.', true),
(3505, 1230, 'IPC는 네트워크 통신에만 사용된다', 'IPC는 같은 시스템의 프로세스 간에도 사용된다.', false),
(3506, 1230, 'IPC는 단일 프로세스 내에서만 사용된다', 'IPC는 프로세스 간 통신이다.', false),

-- 문제 1232
(3507, 1232, '가장 느린 IPC 방법이다', '공유 메모리가 가장 빠르다.', false),
(3508, 1232, '커널 개입이 최소화되어 가장 빠르지만 동기화 문제 주의가 필요하다', '공유 메모리는 여러 프로세스가 같은 메모리 영역을 공유한다. 커널 개입이 최소화되어 가장 빠르지만 동기화 문제를 위해 세마포어와 함께 사용해야 한다.', true),
(3509, 1232, '단방향 통신만 가능하다', '양방향 통신이 가능하다.', false),
(3510, 1232, '소량의 데이터 전송에만 적합하다', '대용량 데이터 전송에 적합하다.', false),

-- 문제 1233
(3511, 1233, '동기적인 통신 방법이다', '시그널은 비동기적이다.', false),
(3512, 1233, '프로세스에게 이벤트를 알리는 비동기 메커니즘이다', '시그널은 프로세스에게 이벤트를 알리는 비동기 메커니즘이다. SIGINT(Ctrl+C), SIGKILL(강제 종료), SIGCHLD(자식 상태 변화) 등이 있다.', true),
(3513, 1233, '대용량 데이터 전송에 적합하다', '시그널은 간단한 이벤트 알림에 사용된다.', false),
(3514, 1233, '파일 시스템에 존재한다', 'Named Pipe의 특징이다.', false),

-- 문제 1235
(3515, 1235, '부모-자식 간에만 사용 가능하다', '일반 파이프의 특징이다.', false),
(3516, 1235, '파일 시스템에 이름을 가진 파일로 존재하여 관련 없는 프로세스 간 통신이 가능하다', 'Named Pipe(FIFO)는 파일 시스템에 이름을 가진 파일로 존재한다. mkfifo()로 생성하며 관련 없는 프로세스 간 통신이 가능하다. 단방향 통신이다.', true),
(3517, 1235, '양방향 통신이 가능하다', 'Named Pipe는 단방향이다.', false),
(3518, 1235, '가장 빠른 IPC 방법이다', '공유 메모리가 가장 빠르다.', false),

-- 문제 1236
(3519, 1236, '파이프 - 양방향 통신, 가장 빠름', '파이프는 단방향이고 속도는 보통이다.', false),
(3520, 1236, '메시지 큐 - 구조화된 메시지 전달, 비동기 통신 지원', '메시지 큐는 프로세스 간 메시지를 전송하는 큐 자료구조이다. 메시지 타입별 선택적 수신이 가능하고 비동기 통신을 지원한다.', true),
(3521, 1236, '공유 메모리 - 가장 느림, 동기화 불필요', '공유 메모리는 가장 빠르지만 동기화가 필요하다.', false),
(3522, 1236, '시그널 - 대용량 데이터 전송에 적합', '시그널은 간단한 이벤트 알림에 사용된다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (353, 1231, '파이프,pipe', '부모-자식 프로세스 간 단방향 통신에 사용되는 IPC 방법으로 fd[0]은 읽기, fd[1]은 쓰기에 사용되는 것을 파이프라고 한다. pipe() 시스템 콜로 생성한다.'),
       (354, 1234, 'SIGINT,sigint', 'Ctrl+C를 눌렀을 때 발생하여 프로세스를 종료시키는 시그널은 SIGINT(시그널 번호 2)이다. 인터럽트 시그널로 프로세스를 정상 종료시킨다.');


-- ===== Lesson 3: CPU 스케줄링 =====
INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (1237, 178, '다음 중 fcfs 스케줄링의 단점으로 올바른 것은?', 'FCFS는 가장 간단한 스케줄링 알고리즘이다.', 'OBJECTIVE'),
       (1238, 178, '빈칸에 들어갈 알맞은 말을 작성하시오', 'SJF에서 긴 프로세스가 짧은 프로세스들에 밀려 무한정 대기하는 현상을 _____라고 한다.', 'SUBJECTIVE'),
       (1239, 178, '아래 제시한 개념에 대한 설명으로 옳은 것은?', 'Time Quantum은 RR 스케줄링의 핵심 파라미터이다.', 'OBJECTIVE'),
       (1240, 178, '제시된 내용과 관련하여 옳은 것은?', 'SJF는 실행 시간이 짧은 프로세스를 우선 실행한다.', 'OBJECTIVE'),
       (1241, 178, '빈칸에 들어갈 기법 이름을 작성하시오.', 'Priority Scheduling에서 기아 현상을 방지하기 위해 대기 시간에 비례하여 우선순위를 점진적으로 높이는 기법을 _____라고 한다.', 'SUBJECTIVE'),
       (1242, 178, '제시된 내용과 관련하여 옳은 것은?', 'MLFQ는 프로세스가 큐 간 이동 가능한 동적 스케줄링이다.', 'OBJECTIVE'),
       (1243, 178, '다음 중 스케줄링 성능 평가 지표로 최소화해야 하는 것은?', '스케줄링 성능은 여러 지표로 평가된다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES
-- 문제 1237
(3523, 1237, '구현이 복잡하다', 'FCFS는 구현이 간단하다.', false),
(3524, 1237, 'Convoy Effect가 발생하여 평균 대기 시간이 증가한다', 'FCFS는 긴 프로세스 뒤에 짧은 프로세스들이 대기하는 Convoy Effect가 발생한다. 이로 인해 평균 대기 시간이 증가한다.', true),
(3525, 1237, '기아 현상이 발생한다', 'FCFS는 기아 현상이 없다.', false),
(3526, 1237, '문맥 교환 오버헤드가 크다', '비선점이므로 문맥 교환이 적다.', false),

-- 문제 1239
(3527, 1239, 'Time Quantum이 클수록 좋다', '너무 크면 FCFS와 동일해진다.', false),
(3528, 1239, '너무 크면 FCFS처럼 되고 너무 작으면 문맥 교환 오버헤드가 증가한다', 'Time Quantum이 너무 크면 FCFS와 동일해지고, 너무 작으면 문맥 교환 오버헤드가 증가한다. 일반적으로 10-100ms가 적정값이다.', true),
(3529, 1239, 'Time Quantum이 작을수록 좋다', '너무 작으면 오버헤드가 증가한다.', false),
(3530, 1239, 'Time Quantum은 영향이 없다', 'Time Quantum은 성능에 큰 영향을 준다.', false),

-- 문제 1240
(3531, 1240, '기아 현상이 발생하지 않는다', 'SJF는 긴 프로세스에 기아 현상이 발생한다.', false),
(3532, 1240, '평균 대기 시간을 최소화하지만 기아 현상이 발생할 수 있다', 'SJF는 실행 시간이 짧은 프로세스를 먼저 실행하여 평균 대기 시간을 최소화한다. 하지만 긴 프로세스가 무한정 대기하는 기아 현상이 발생할 수 있다.', true),
(3533, 1240, '실행 시간을 정확히 알 수 있다', '실행 시간을 미리 알기 어려워 예측이 필요하다.', false),
(3534, 1240, '선점형 알고리즘이다', '기본 SJF는 비선점이다.', false),

-- 문제 1242
(3535, 1242, '프로세스는 한 큐에 고정된다', 'Multilevel Queue의 특징이다.', false),
(3536, 1242, '새 프로세스는 최상위 큐에 진입하고 Time quantum을 다 쓰면 하위 큐로 이동한다', 'MLFQ는 프로세스가 큐 간 이동 가능하다. 새 프로세스는 최상위 큐에서 시작하고, Time quantum을 다 쓰면 하위 큐로 강등된다. I/O 작업 후 상위 큐로 승격 가능하다.', true),
(3537, 1242, '모든 큐가 동일한 알고리즘을 사용한다', '각 큐는 독립적인 알고리즘을 사용할 수 있다.', false),
(3538, 1242, 'CPU bound 프로세스를 우대한다', 'I/O bound 프로세스를 우대한다.', false),

-- 문제 1243
(3539, 1243, 'CPU 이용률', 'CPU 이용률은 최대화해야 한다.', false),
(3540, 1243, '처리량', '처리량은 최대화해야 한다.', false),
(3541, 1243, '대기 시간', '대기 시간은 Ready Queue에서 대기한 총 시간으로 최소화해야 하는 지표이다. 반환 시간과 응답 시간도 최소화 대상이다.', true),
(3542, 1243, '위의 모든 지표를 최소화해야 한다', 'CPU 이용률과 처리량은 최대화해야 한다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (355, 1238, '기아,starvation,기아 현상,기아현상', 'SJF에서 긴 프로세스가 짧은 프로세스들에 밀려 무한정 대기하는 현상을 기아(Starvation) 현상이라고 한다. 에이징으로 해결할 수 있다.'),
       (356, 1241, '에이징,aging', 'Priority Scheduling에서 기아 현상을 방지하기 위해 대기 시간에 비례하여 우선순위를 점진적으로 높이는 기법을 에이징(Aging)이라고 한다.');
