-- Unit: 페이지관리 (Unit ID: 67)
-- Chapter: 운영체제 (Chapter ID: 7)

-- Lesson 생성
INSERT INTO lesson (id, unit_id, title)
VALUES (197, 67, '페이지 교체'),
       (198, 67, '페이지 관리 1'),
       (199, 67, '페이지 관리 2');

-- ===== Lesson 1: 페이지 교체 =====
INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (1361, 197, '빈칸에 들어갈 용어를 작성하시오', 'FIFO 알고리즘에서 프레임 수가 증가했는데도 페이지 폴트가 오히려 증가하는 현상을 ___라고 한다.', 'SUBJECTIVE'),
       (1362, 197, '빈칸에 들어갈 용어를 작성하시오', '___는 앞으로 가장 오랫동안 사용되지 않을 페이지를 교체하는 알고리즘으로 이론적 최적해이지만 미래 예측이 필요하여 실제 구현이 불가능하다.', 'SUBJECTIVE'),
       (1363, 197, '아래 제시한 개념에 대한 설명으로 옳은 것은?', 'LRU는 페이지 교체 알고리즘 중 하나로 실용적이고 효율적인 알고리즘이다.', 'OBJECTIVE'),
       (1364, 197, '빈칸에 들어갈 용어를 작성하시오', '___는 FIFO와 참조 비트를 활용한 페이지 교체 알고리즘으로, 순환 리스트 형태로 포인터가 순회하며 참조 비트가 1이면 0으로 변경하고, 0이면 해당 페이지를 교체한다.', 'SUBJECTIVE'),
       (1365, 197, '아래 제시한 개념에 대한 설명으로 옳은 것은?', 'LFU는 페이지를 교체하는 알고리즘이다.', 'OBJECTIVE'),
       (1366, 197, '빈칸에 들어갈 용어를 작성하시오', 'LRU 알고리즘 구현 방법으로는 ___를 사용하거나 스택, 카운터 등을 활용할 수 있다.', 'SUBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES
-- 문제 1363
(3847, 1363, '가장 먼저 들어온 페이지를 교체한다', '가장 먼저 들어온 페이지를 교체하는 것은 FIFO 알고리즘이다.', false),
(3848, 1363, '가장 오랫동안 사용되지 않은 페이지를 교체한다', 'LRU는 Least Recently Used의 약자로, 가장 오랫동안 사용되지 않은 페이지를 교체하며 시간 지역성을 활용한다.', true),
(3849, 1363, '참조 횟수가 가장 적은 페이지를 교체한다', '참조 횟수가 가장 적은 페이지를 교체하는 것은 LFU 알고리즘이다.', false),
(3850, 1363, '앞으로 가장 오랫동안 사용되지 않을 페이지를 교체한다', '앞으로 가장 오랫동안 사용되지 않을 페이지를 교체하는 것은 OPT 알고리즘이다.', false),

-- 문제 1365
(3851, 1365, '가장 최근에 사용된 페이지를 교체한다', 'LFU는 참조 횟수가 가장 적은 페이지를 교체한다.', false),
(3852, 1365, '참조 횟수가 가장 적은 페이지를 교체한다', 'LFU(Least Frequently Used)는 참조 횟수가 가장 적은 페이지를 교체하는 알고리즘이다.', true),
(3853, 1365, '가장 먼저 들어온 페이지를 교체한다', '가장 먼저 들어온 페이지를 교체하는 것은 FIFO 알고리즘이다.', false),
(3854, 1365, '참조 비트를 활용하여 순환 리스트로 교체한다', '참조 비트와 순환 리스트를 활용하는 것은 Clock 알고리즘이다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (399, 1361, 'belady''s anomaly,벨라디의 모순,벨라디의 역설, 벨라디의 이상현상', 'Belady''s Anomaly는 FIFO 알고리즘에서 프레임 수 증가 시 페이지 폴트가 증가할 수 있는 현상이다.'),
       (400, 1362, 'opt,optimal', 'OPT(Optimal) 알고리즘은 미래에 가장 오랫동안 사용되지 않을 페이지를 교체하여 이론적으로 최적이지만 실제 구현은 불가능하다.'),
       (401, 1364, 'clock,second chance', 'Clock(Second Chance) 알고리즘은 FIFO에 참조 비트를 활용하여 LRU를 근사하는 효율적인 알고리즘이다.'),
       (402, 1366, '타임스탬프,time stamp', 'LRU 알고리즘은 타임스탬프, 스택, 카운터 등의 방법으로 구현할 수 있다.');


-- ===== Lesson 2: 페이지 관리 1 =====
INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (1367, 198, '다음 중 전역 교체와 지역 교체에 대한 설명으로 올바르지 않은 것은?', '전역 교체와 지역 교체는 페이지 교체 시 교체 대상을 선택하는 범위에 따른 분류이다.', 'OBJECTIVE'),
       (1368, 198, '빈칸에 들어갈 용어를 작성하시오', '___는 페이지 폴트가 과도하게 발생하여 CPU 이용률이 급격히 낮아지는 현상으로, 프로세스들에게 할당된 프레임이 부족할 때 발생한다.', 'SUBJECTIVE'),
       (1369, 198, '빈칸에 들어갈 용어를 작성하시오', '비례 할당은 ___에 비례하여 프레임을 할당하는 방식으로, 큰 프로세스에 더 많은 프레임을 제공한다.', 'SUBJECTIVE'),
       (1370, 198, '빈칸에 들어갈 용어를 작성하시오', '스레싱 해결 방법 중 하나로, 최근 일정 시간 동안 참조한 페이지 집합을 유지하는 모델을 ___라고 한다.', 'SUBJECTIVE'),
       (1371, 198, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '균등 할당은 프로세스에 프레임을 할당하는 정책 중 하나이다.', 'OBJECTIVE'),
       (1372, 198, '빈칸에 들어갈 용어를 작성하시오', '스레싱 해결 방법 중 하나로, ___를 모니터링하여 프레임을 조정하는 방법이 있으며, 이는 페이지 폴트 비율을 추적한다.', 'SUBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES
-- 문제 1367
(3855, 1367, '전역 교체는 모든 프로세스의 페이지 중에서 교체 대상을 선택한다', '전역 교체는 모든 프로세스의 페이지를 대상으로 교체할 페이지를 선택한다.', false),
(3856, 1367, '지역 교체는 각 프로세스가 자신의 프레임 내에서만 교체한다', '지역 교체는 각 프로세스가 할당받은 프레임 내에서만 교체 대상을 선택한다.', false),
(3857, 1367, '전역 교체는 프로세스 간 간섭이 없어 안정적이다', '전역 교체는 프로세스 간 간섭이 발생할 수 있으며, 프로세스 간 간섭이 없는 것은 지역 교체이다.', true),
(3858, 1367, '지역 교체는 메모리 효율성이 떨어질 수 있다', '지역 교체는 각 프로세스가 자신의 프레임 내에서만 교체하므로 메모리 효율성이 떨어질 수 있다.', false),

-- 문제 1371
(3859, 1371, '프로세스 크기에 비례하여 프레임을 할당한다', '프로세스 크기에 비례하여 할당하는 것은 비례 할당이다.', false),
(3860, 1371, '모든 프로세스에 동일한 프레임 수를 할당한다', '균등 할당은 모든 프로세스에 동일한 수의 프레임을 할당하는 방식이다. 공평하지만 비효율적일 수 있다.', true),
(3861, 1371, '프로세스 우선순위에 따라 프레임을 할당한다', '프로세스 우선순위에 따라 할당하는 것은 우선순위 할당이다.', false),
(3862, 1371, '가장 효율적인 프레임 할당 방식이다', '균등 할당은 공평하지만 프로세스 크기를 고려하지 않아 비효율적일 수 있다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (403, 1368, '스레싱,thrashing', '스레싱은 페이지 폴트가 과도하게 발생하여 시스템 성능이 급격히 저하되는 현상이다.'),
       (404, 1369, '프로세스 크기', '비례 할당은 프로세스 크기에 비례하여 프레임을 할당하는 정책이다.'),
       (405, 1370, 'working set model,워킹 셋 모델', 'Working Set Model은 최근 일정 시간 동안 참조한 페이지 집합을 유지하여 스레싱을 방지한다.'),
       (406, 1372, 'page fault frequency,pff', 'Page Fault Frequency(PFF)는 페이지 폴트 비율을 모니터링하여 프레임 수를 동적으로 조정하는 기법이다.');


-- ===== Lesson 3: 페이지 관리 2 =====
INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (1373, 199, '다음 중 계층적 페이징에 대한 설명으로 올바르지 않은 것은?', '계층적 페이징은 페이지 테이블이 너무 클 때 페이지 테이블을 여러 단계로 분할하는 기법이다.', 'OBJECTIVE'),
       (1374, 199, '빈칸에 들어갈 용어를 작성하시오', '___는 프로세스 생성 시 부모와 자식이 처음에는 동일한 페이지를 공유하다가 페이지가 수정될 때만 복사본을 생성하여 불필요한 복사를 방지하는 기법이다.', 'SUBJECTIVE'),
       (1375, 199, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '페이지 크기는 시스템 성능과 메모리 효율성에 영향을 미친다.', 'OBJECTIVE'),
       (1376, 199, '빈칸에 들어갈 용어를 작성하시오', '2단계 페이지 테이블에서 ___에 실제 프레임 번호가 저장된다.', 'SUBJECTIVE'),
       (1377, 199, '다음 중 스레싱 해결 방법으로 올바르지 않은 것은?', '스레싱은 페이지 폴트가 과도하게 발생하여 시스템 성능이 저하되는 현상이다.', 'OBJECTIVE'),
       (1378, 199, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '균등 할당은 프로세스에 프레임을 할당하는 정책 중 하나이다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES
-- 문제 1373
(3863, 1373, '2단계 페이지 테이블에서 1단계는 페이지 디렉토리로 2단계 페이지 테이블 주소를 저장한다', '2단계 페이지 테이블에서 1단계(페이지 디렉토리)는 2단계 페이지 테이블의 주소를 저장한다.', false),
(3864, 1373, '사용하지 않는 주소 공간의 2단계 테이블은 생성하지 않아 메모리를 절약할 수 있다', '사용하지 않는 주소 공간에 대해서는 2단계 테이블을 생성하지 않아 메모리를 크게 절약할 수 있다.', false),
(3865, 1373, '계층적 페이징을 사용하면 메모리 접근 횟수가 감소한다', '계층적 페이징은 페이지 테이블 단계가 늘어나므로 메모리 접근 횟수가 증가한다. 이는 TLB로 완화할 수 있다.', true),
(3866, 1373, '2단계 페이지 테이블의 논리 주소는 p1, p2, 오프셋으로 구성된다', '2단계 페이지 테이블에서 논리 주소는 p1(1단계 인덱스), p2(2단계 인덱스), 오프셋으로 구성된다.', false),

-- 문제 1375
(3867, 1375, '작은 페이지는 내부 단편화가 증가하고 페이지 테이블 크기가 감소한다', '작은 페이지는 내부 단편화가 감소하지만 페이지 테이블 크기는 증가한다.', false),
(3868, 1375, '큰 페이지는 페이지 테이블 크기가 감소하고 I/O 효율이 증가한다', '큰 페이지는 페이지 수가 줄어 페이지 테이블 크기가 감소하고, 한 번에 더 많은 데이터를 읽을 수 있어 I/O 효율이 증가한다.', true),
(3869, 1375, '큰 페이지는 내부 단편화가 감소한다', '큰 페이지는 마지막 페이지에서 사용하지 않는 공간이 늘어나 내부 단편화가 증가한다.', false),
(3870, 1375, '일반적으로 현대 시스템은 64KB 페이지를 사용한다', '일반적으로 4KB 페이지를 사용하며, 필요에 따라 Huge Page 등을 지원한다.', false),

-- 문제 1377
(3871, 1377, 'Working Set Model을 사용하여 최근 참조한 페이지 집합을 유지한다', 'Working Set Model은 최근 일정 시간 동안 참조한 페이지 집합을 유지하여 스레싱을 방지한다.', false),
(3872, 1377, 'Page Fault Frequency를 모니터링하여 프레임을 조정한다', 'PFF는 페이지 폴트 비율을 추적하여 동적으로 프레임을 조정하는 방법이다.', false),
(3873, 1377, '다중 프로그래밍 수준을 증가시켜 더 많은 프로세스를 실행한다', '스레싱 해결을 위해서는 다중 프로그래밍 수준을 감소시켜 프로세스 일부를 일시 중지해야 한다. 증가시키면 스레싱이 악화된다.', true),
(3874, 1377, '프로세스 일부를 일시 중지하여 활성 프로세스 수를 줄인다', '다중 프로그래밍 수준을 감소시켜 프로세스를 일시 중지하는 것은 스레싱 해결 방법 중 하나이다.', false),

-- 문제 1378
(3875, 1378, '프로세스 크기에 비례하여 프레임을 할당한다', '프로세스 크기에 비례하여 할당하는 것은 비례 할당이다.', false),
(3876, 1378, '모든 프로세스에 동일한 프레임 수를 할당한다', '균등 할당은 모든 프로세스에 동일한 수의 프레임을 할당하는 방식이다. 공평하지만 비효율적일 수 있다.', true),
(3877, 1378, '프로세스 우선순위에 따라 프레임을 할당한다', '프로세스 우선순위에 따라 할당하는 것은 우선순위 할당이다.', false),
(3878, 1378, '가장 효율적인 프레임 할당 방식이다', '균등 할당은 공평하지만 프로세스 크기를 고려하지 않아 비효율적일 수 있다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (407, 1374, 'copy on write,cow', 'Copy-on-Write(COW)는 페이지 수정 시에만 복사본을 생성하여 성능을 향상시키는 기법이다.'),
       (408, 1376, '2단계', '2단계 페이지 테이블 구조에서 1단계는 2단계 테이블의 주소를 저장하고, 2단계에 실제 프레임 번호가 저장된다.');


