-- Unit: 스레드와멀티스레딩 (Unit ID: 61)
-- Chapter: 운영체제 (Chapter ID: 5)

-- Lesson 생성
INSERT INTO lesson (id, unit_id, title)
VALUES (179, 61, '스레드 기초'),
       (180, 61, '스레드 동기화'),
       (181, 61, '멀티스레딩 최적화');

-- ===== Lesson 1: 스레드 기초 =====
INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (1244, 179, '다음 중 프로세스와 스레드의 차이로 올바른 것은?', '프로세스와 스레드는 자원 관리 측면에서 차이가 있다.', 'OBJECTIVE'),
       (1245, 179, '빈칸에 들어갈 알맞은 말을 작성하시오', '스레드는 프로세스의 Code, Data, Heap 영역을 공유하지만 _____는 독립적으로 가진다.', 'SUBJECTIVE'),
       (1246, 179, '다음 중 스레드가 공유하는 자원으로 올바른 것은?', '스레드는 프로세스의 자원을 공유한다.', 'OBJECTIVE'),
       (1247, 179, '다음 중 병렬성과 동시성의 차이로 올바른 것은?', '병렬성과 동시성은 다른 개념이다.', 'OBJECTIVE'),
       (1248, 179, '빈칸에 들어갈 기법 이름을 작성하시오.', '1개의 물리 코어가 2개의 논리 코어처럼 동작하는 기술을 _____라고 한다.', 'SUBJECTIVE'),
       (1249, 179, '다음 중 멀티스레딩의 장점으로 올바르지 않은 것은?', '멀티스레딩은 여러 장점을 가진다.', 'OBJECTIVE'),
       (1250, 179, '제시된 내용과 관련하여 옳은 것은?', '스레드 문맥 교환은 프로세스 문맥 교환과 다르다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES
-- 문제 1244
(3543, 1244, '프로세스와 스레드는 자원을 동일하게 사용한다', '프로세스는 독립적이고 스레드는 공유한다.', false),
(3544, 1244, '프로세스는 독립적인 메모리 공간을 가지고 스레드는 프로세스 자원을 공유한다', '프로세스는 독립적인 메모리 공간을 가지며 생성 비용이 높다. 스레드는 프로세스 내에서 자원을 공유하며 생성 비용이 낮고 문맥 교환이 빠르다.', true),
(3545, 1244, '스레드가 프로세스보다 생성 비용이 높다', '스레드가 생성 비용이 낮다.', false),
(3546, 1244, '프로세스 문맥 교환이 더 빠르다', '스레드 문맥 교환이 더 빠르다.', false),

-- 문제 1246
(3547, 1246, 'Stack 영역', 'Stack은 각 스레드가 독립적으로 가진다.', false),
(3548, 1246, 'Program Counter', 'PC는 각 스레드가 독립적으로 가진다.', false),
(3549, 1246, 'Code, Data, Heap 영역', '스레드는 프로세스의 Code(프로그램 코드), Data(전역 변수), Heap(동적 할당 메모리)을 공유한다. Stack, PC, 레지스터는 독립적으로 가진다.', true),
(3550, 1246, 'Registers', '레지스터는 각 스레드가 독립적으로 가진다.', false),

-- 문제 1247
(3551, 1247, '병렬성과 동시성은 같은 개념이다', '서로 다른 개념이다.', false),
(3552, 1247, '병렬성은 여러 코어에서 실제로 동시 실행이고 동시성은 빠른 전환으로 동시처럼 보이는 것이다', '병렬성은 여러 코어에서 정말로 동시에 실행되는 것이다. 동시성은 1개 코어에서 빠른 Context Switch로 동시에 실행되는 것처럼 보이는 것이다.', true),
(3553, 1247, '동시성이 병렬성보다 성능이 좋다', '병렬성이 실제 동시 실행이므로 더 빠르다.', false),
(3554, 1247, '단일 코어에서 병렬성을 구현할 수 있다', '병렬성은 여러 코어가 필요하다.', false),

-- 문제 1249
(3555, 1249, 'I/O 대기 중에도 다른 작업 수행 가능', '멀티스레딩의 장점이다.', false),
(3556, 1249, 'CPU 활용률 향상', '멀티스레딩의 장점이다.', false),
(3557, 1249, '자원 공유로 메모리 효율성 증가', '멀티스레딩의 장점이다.', false),
(3558, 1249, '한 스레드 오류 시 다른 스레드에 영향 없음', '멀티스레딩의 단점이다. 한 스레드의 오류가 전체 프로세스에 영향을 줄 수 있다. 이것은 멀티프로세스의 장점이다.', true),

-- 문제 1250
(3559, 1250, '프로세스 문맥 교환보다 느리다', '스레드 문맥 교환이 더 빠르다.', false),
(3560, 1250, '스택과 레지스터만 교환하므로 프로세스보다 빠르다', '스레드 문맥 교환은 Stack과 레지스터만 교환하면 되므로 프로세스 문맥 교환(전체 컨텍스트)보다 빠르다. Code, Data, Heap은 공유하므로 교환 불필요하다.', true),
(3561, 1250, '메모리 전체를 교환해야 한다', '공유 자원은 교환이 불필요하다.', false),
(3562, 1250, '문맥 교환이 발생하지 않는다', '스레드 간에도 문맥 교환이 발생한다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (357, 1245, 'stack,스택', '스레드는 프로세스의 Code, Data, Heap 영역을 공유하지만 Stack은 독립적으로 가진다. 각 스레드는 자신만의 지역 변수와 함수 호출 정보를 유지한다.'),
       (358, 1248, 'Hyper-Threading,hyper threading,하이퍼스레딩,하이퍼 스레딩', '1개의 물리 코어가 2개의 논리 코어처럼 동작하는 기술을 하이퍼스레딩이라고 한다. 4코어 8스레드 CPU는 물리 코어 4개, 논리 코어 8개이다.');


-- ===== Lesson 2: 스레드 동기화 =====
INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (1251, 180, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '경쟁 조건은 멀티스레드 환경에서 발생하는 문제이다.', 'OBJECTIVE'),
       (1252, 180, '빈칸에 들어갈 알맞은 말을 작성하시오', '한 번에 하나의 스레드만 임계 영역에 접근할 수 있도록 하는 상호 배제 메커니즘을 _____라고 한다.', 'SUBJECTIVE'),
       (1253, 180, '다음 중 뮤텍스와 세마포어의 차이로 올바른 것은?', '뮤텍스와 세마포어는 용도가 다르다.', 'OBJECTIVE'),
       (1254, 180, '다음 중 교착 상태 발생 조건이 아닌 것은?', '교착 상태는 4가지 조건이 모두 만족될 때 발생한다.', 'OBJECTIVE'),
       (1255, 180, '빈칸에 들어갈 알맞은 말을 작성하시오', '두 개 이상의 스레드가 서로 상대방이 가진 자원을 기다리며 무한정 대기하는 상태를 _____라고 한다.', 'SUBJECTIVE'),
       (1256, 180, '다음 중 교착 상태 해결 방법으로 올바르지 않은 것은?', '교착 상태는 여러 방법으로 해결할 수 있다.', 'OBJECTIVE'),
       (1257, 180, '제시된 내용과 관련하여 옳은 것은?', '세마포어는 제한된 자원 관리에 사용된다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES
-- 문제 1251
(3563, 1251, '단일 스레드에서만 발생한다', '멀티스레드 환경에서 발생한다.', false),
(3564, 1251, '여러 스레드가 동시에 공유 자원에 접근할 때 발생하는 문제이다', '경쟁 조건은 여러 스레드가 동시에 공유 자원에 접근할 때 발생한다. counter++ 같은 연산이 실제로는 읽기-연산-쓰기 3단계로 이루어져 동시 실행 시 값이 손실될 수 있다.', true),
(3565, 1251, '뮤텍스를 사용하면 발생하지 않는다', '뮤텍스로 해결할 수 있지만 사용하지 않으면 발생한다.', false),
(3566, 1251, '성능에 영향을 주지 않는다', '경쟁 조건은 데이터 일관성과 성능에 영향을 준다.', false),

-- 문제 1253
(3567, 1253, '뮤텍스는 여러 스레드가 동시 접근 가능하다', '뮤텍스는 1개 스레드만 접근 가능하다.', false),
(3568, 1253, '뮤텍스는 1개 스레드만 접근하고 세마포어는 N개 스레드가 접근 가능하다', '뮤텍스는 이진 세마포어로 1개 스레드만 임계 영역에 접근하고 잠근 스레드만 해제 가능하다. 세마포어는 N개 스레드가 동시 접근 가능하며 자원 개수를 제한한다.', true),
(3569, 1253, '세마포어는 소유권 개념이 있다', '뮤텍스가 소유권 개념이 있다.', false),
(3570, 1253, '뮤텍스가 데이터베이스 연결 풀에 적합하다', '세마포어가 자원 개수 제한에 적합하다.', false),

-- 문제 1254
(3571, 1254, '상호 배제 (Mutual Exclusion)', '교착 상태 발생 조건이다.', false),
(3572, 1254, '점유와 대기 (Hold and Wait)', '교착 상태 발생 조건이다.', false),
(3573, 1254, '비선점 (No Preemption)', '교착 상태 발생 조건이다.', false),
(3574, 1254, '우선순위 역전 (Priority Inversion)', '우선순위 역전은 교착 상태 발생 조건이 아니다. 교착 상태 발생 4조건은 상호 배제, 점유와 대기, 비선점, 순환 대기이다.', true),

-- 문제 1256
(3575, 1256, '자원 획득 순서 통일', '교착 상태 해결 방법이다.', false),
(3576, 1256, '타임아웃 설정', '교착 상태 해결 방법이다.', false),
(3577, 1256, '교착 상태 감지 및 회복', '교착 상태 해결 방법이다.', false),
(3578, 1256, '자원을 무한정 할당', '자원을 무한정 할당하는 것은 해결 방법이 아니다. 자원 획득 순서 통일, 타임아웃 설정, 교착 상태 감지 및 회복, 은행원 알고리즘 등으로 해결한다.', true),

-- 문제 1257
(3579, 1257, '한 번에 1개 스레드만 접근 가능하다', '뮤텍스의 특징이다.', false),
(3580, 1257, '여러 스레드가 제한된 수만큼 동시 접근 가능하다', '세마포어는 wait()로 값을 감소시키고 signal()로 값을 증가시킨다. 값이 0이면 대기한다. 데이터베이스 연결 풀처럼 자원 개수를 제한하는 데 사용된다.', true),
(3581, 1257, '소유권 개념이 있다', '세마포어는 소유권 개념이 없다.', false),
(3582, 1257, '임계 영역 보호에만 사용된다', '자원 개수 제한에 주로 사용된다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (359, 1252, 'mutex,뮤텍스,mutual exclusion', '한 번에 하나의 스레드만 임계 영역에 접근할 수 있도록 하는 상호 배제 메커니즘을 Mutex(뮤텍스)라고 한다. lock()으로 잠그고 unlock()으로 해제한다.'),
       (360, 1255, 'deadlock,교착 상태,데드락', '두 개 이상의 스레드가 서로 상대방이 가진 자원을 기다리며 무한정 대기하는 상태를 교착 상태(Deadlock)라고 한다. 4가지 조건이 모두 만족될 때 발생한다.');


-- ===== Lesson 3: 멀티스레딩 최적화 =====
INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (1258, 181, '다음 중 스레드 풀의 장점으로 올바른 것은?', '스레드 풀은 스레드를 재사용하는 패턴이다.', 'OBJECTIVE'),
       (1259, 181, '빈칸에 들어갈 알맞은 말을 작성하시오', '스레드를 미리 생성해두고 재사용하는 패턴을 _____ 패턴이라고 한다.', 'SUBJECTIVE'),
       (1260, 181, '다음 중 멀티프로세스와 멀티스레드의 선택 기준으로 올바른 것은?', '멀티프로세스와 멀티스레드는 적합한 경우가 다르다.', 'OBJECTIVE'),
       (1261, 181, '다음 중 스레드 수와 성능의 관계로 올바른 것은?', '스레드 수는 성능에 영향을 준다.', 'OBJECTIVE'),
       (1262, 181, '빈칸에 들어갈 알맞은 말을 작성하시오', 'CPU 집약적 작업의 적정 스레드 수는 CPU 코어 수와 _____배 정도이다.', 'SUBJECTIVE'),
       (1263, 181, '다음 중 멀티프로세스가 멀티스레드보다 적합한 경우는?', '멀티프로세스와 멀티스레드는 각각 장단점이 있다.', 'OBJECTIVE'),
       (1264, 181, '다음 중 스레드가 너무 많을 때 발생하는 문제로 올바르지 않은 것은?', '스레드를 무한정 늘리면 문제가 발생한다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES
-- 문제 1258
(3583, 1258, '스레드 생성/제거 오버헤드 증가', '오히려 감소한다.', false),
(3584, 1258, '스레드 생성/제거 오버헤드 감소와 동시 실행 스레드 수 제한 가능', '스레드 풀은 스레드를 미리 생성해두고 재사용한다. 생성/제거 오버헤드가 감소하고, 고정된 개수로 자원을 관리하며, 작업 큐를 통해 효율적으로 관리한다.', true),
(3585, 1258, '메모리 사용량 증가', '오히려 효율적으로 관리된다.', false),
(3586, 1258, '동기화 문제가 없어진다', '동기화 문제는 여전히 존재한다.', false),

-- 문제 1260
(3587, 1260, '멀티프로세스가 항상 더 빠르다', '멀티스레드가 더 빠른 경우가 많다.', false),
(3588, 1260, '안정성이 중요하면 멀티프로세스, 빠른 응답과 자원 공유가 필요하면 멀티스레드', '멀티프로세스는 독립적이라 안정성이 높지만 생성이 느리고 메모리 사용이 많다. 멀티스레드는 빠르고 자원을 공유하지만 한 스레드 오류가 전체에 영향을 준다.', true),
(3589, 1260, '멀티스레드는 IPC가 필요하다', '멀티프로세스가 IPC가 필요하다.', false),
(3590, 1260, '멀티프로세스가 문맥 교환이 빠르다', '멀티스레드가 문맥 교환이 빠르다.', false),

-- 문제 1261
(3591, 1261, '스레드를 많이 쓸수록 항상 성능이 좋아진다', '일정 수 이상은 오히려 성능이 저하된다.', false),
(3592, 1261, '스레드가 많아지면 컨텍스트 스위칭 오버헤드가 증가한다', '스레드가 너무 많으면 컨텍스트 스위칭 오버헤드가 증가하고 메모리 사용량이 늘어나며 동기화가 복잡해진다. 적정 스레드 수를 유지해야 한다.', true),
(3593, 1261, '스레드 수는 성능에 영향을 주지 않는다', '스레드 수는 성능에 큰 영향을 준다.', false),
(3594, 1261, '단일 스레드가 항상 최고 성능이다', '적절한 멀티스레드가 성능이 좋다.', false),

-- 문제 1263
(3595, 1263, '빠른 응답 속도가 필요한 GUI 프로그램', '멀티스레드가 적합하다.', false),
(3596, 1263, '자원 공유가 많이 필요한 웹 서버', '멀티스레드가 적합하다.', false),
(3597, 1263, '안정성이 최우선인 경우나 완전히 독립적인 작업', '멀티프로세스는 독립적으로 실행되어 안정성이 높다. 크롬 브라우저 탭처럼 안정성이 중요하거나 완전히 독립적인 작업에 적합하다.', true),
(3598, 1263, '가벼운 작업 분산', '멀티스레드가 적합하다.', false),

-- 문제 1264
(3599, 1264, '컨텍스트 스위칭 오버헤드 증가', '스레드가 많으면 발생하는 문제이다.', false),
(3600, 1264, '메모리 사용량 증가', '각 스레드마다 스택이 할당되어 메모리가 증가한다.', false),
(3601, 1264, '동기화 복잡도 증가', '스레드가 많으면 발생하는 문제이다.', false),
(3602, 1264, 'CPU 성능이 자동으로 향상된다', 'CPU 성능이 자동으로 향상되지 않는다. 오히려 스레드가 너무 많으면 오버헤드로 인해 성능이 저하된다.', true);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (361, 1259, 'thread pool,스레드 풀', '스레드를 미리 생성해두고 재사용하는 패턴을 스레드 풀(Thread Pool) 패턴이라고 한다. 작업 큐에서 작업을 가져와 처리하고 다시 대기 상태가 된다.'),
       (362, 1262, '1', 'CPU 집약적 작업의 적정 스레드 수는 CPU 코어 수와 1배 정도이다. I/O 집약적 작업은 CPU 코어 수 × 2~4배가 적정하다.');
