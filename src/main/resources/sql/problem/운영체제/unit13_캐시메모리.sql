-- Unit: 캐시메모리 (Unit ID: 68)
-- Chapter: 운영체제 (Chapter ID: 5)

-- Lesson 생성
INSERT INTO lesson (id, unit_id, title)
VALUES (200, 68, '캐시 메모리 기초'),
       (201, 68, '캐시 메모리 성능'),
       (202, 68, '캐시 매핑 기법');

-- ===== Lesson 1: 캐시 메모리 기초 =====
INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (1379, 200, '빈칸에 들어갈 용어를 작성하시오', '캐시 레벨 중 CPU 코어 내부에 위치하며 용량이 가장 작지만 속도가 가장 빠른 캐시는 ___이다.', 'SUBJECTIVE'),
       (1380, 200, '아래 제시한 개념에 대한 설명으로 옳은 것은?', 'L3 캐시는 CPU의 캐시 계층 구조 중 하나이다.', 'OBJECTIVE'),
       (1381, 200, '아래 제시한 개념에 대한 설명으로 옳은 것은?', 'L2 캐시는 CPU의 캐시 계층 구조에서 중간 단계에 위치한다.', 'OBJECTIVE'),
       (1382, 200, '다음 중 캐시 메모리의 역할로 올바르지 않은 것은?', '캐시 메모리는 CPU와 메인 메모리 사이에서 성능을 향상시키는 역할을 한다.', 'OBJECTIVE'),
       (1383, 200, '빈칸에 들어갈 용어를 작성하시오', '캐시 메모리는 용량이 작고 비싸지만 CPU와 메인 메모리 사이의 ___ 현상을 완화하기 위해 사용된다.', 'SUBJECTIVE'),
       (1384, 200, '제시된 내용과 관련하여 옳은 것은?', '캐시 메모리는 고속 메모리로 시스템 성능 향상을 위해 사용된다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES
-- 문제 1380
(3879, 1380, 'CPU 코어 내부에 위치하며 KB 단위의 용량을 가진다', 'CPU 코어 내부에 위치하고 KB 단위 용량을 가지는 것은 L1 캐시이다.', false),
(3880, 1380, '가장 빠른 접근 속도를 제공한다', '가장 빠른 접근 속도를 제공하는 것은 L1 캐시이다.', false),
(3881, 1380, 'CPU 코어 외부에 위치하며 MB 단위의 가장 큰 용량을 가진다', 'L3 캐시는 CPU 코어 외부에 위치하며 L1, L2에 비해 가장 큰 MB 단위의 용량을 가지지만, 수십 사이클의 느린 속도를 제공한다.', true),
(3882, 1380, 'L1보다 크고 L2보다 작은 용량을 가진다', 'L3는 용량이 가장 크다.', false),

-- 문제 1381
(3883, 1381, 'L1보다 느리고 L3보다 빠른 접근 속도를 가진다', 'L2 캐시는 L1보다는 느리지만 L3보다는 빠른 접근 속도를 제공하며, 용량도 L1보다 크고 L3보다 작다.', true),
(3884, 1381, '항상 CPU 코어 외부에 위치한다', 'L2 캐시는 CPU 코어 내부 또는 외부에 위치할 수 있다.', false),
(3885, 1381, 'MB 단위의 가장 큰 용량을 가진다', '가장 큰 용량을 가지는 것은 L3 캐시이다.', false),
(3886, 1381, '가장 빠른 접근 속도를 제공한다', '가장 빠른 접근 속도를 제공하는 것은 L1 캐시이다.', false),

-- 문제 1382
(3887, 1382, '메인 메모리에서 자주 사용하는 데이터를 저장한다', '캐시 메모리는 자주 사용하는 프로그램이나 데이터를 저장하여 접근 속도를 향상시킨다.', false),
(3888, 1382, '메모리 병목 현상을 해결한다', '캐시 메모리는 빠른 CPU와 느린 메인 메모리 사이의 속도 차이를 줄여 병목 현상을 완화한다.', false),
(3889, 1382, '대용량 저장 공간을 저렴한 비용으로 제공한다', '캐시 메모리는 용량이 작고 비싸다. 대용량 저장 공간을 제공하는 것은 캐시의 역할이 아니다.', true),
(3890, 1382, '지역성의 원리를 활용하여 적중률을 향상시킨다', '캐시 메모리는 시간 지역성과 공간 지역성을 활용하여 자주 사용될 데이터를 예측하고 저장한다.', false),

-- 문제 1384
(3891, 1384, '용량이 크고 가격이 저렴하다', '캐시 메모리는 용량이 작고 가격이 비싸다.', false),
(3892, 1384, 'CPU에서 멀수록 접근 속도가 빠르다', '캐시는 CPU에 가까울수록 빠르고 작다.', false),
(3893, 1384, '자주 사용하는 데이터나 프로그램을 저장한다', '캐시는 메인 메모리에서 자주 사용하는 데이터나 프로그램을 저장하여 성능을 향상시킨다.', true),
(3894, 1384, '메인 메모리를 완전히 대체한다', '캐시는 메인 메모리를 대체하는 것이 아니라 보조적으로 사용된다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (409, 1379, 'l1', 'L1 캐시는 CPU 코어 내부에 위치하며 KB 단위의 가장 작은 용량을 가지지만 수 사이클의 가장 빠른 속도를 제공한다.'),
       (410, 1383, '메모리 병목', '캐시 메모리는 CPU와 메인 메모리 간 속도 차이로 발생하는 메모리 병목 현상을 줄이기 위한 고속 메모리이다.');


-- ===== Lesson 2: 캐시 메모리 성능 =====
INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (1385, 201, '빈칸에 들어갈 용어를 작성하시오', '캐시 메모리는 속도가 빠른 메모리와 느린 메모리의 속도 차이를 줄이기 위한 고속 메모리로, ___를 활용하여 적중률을 향상시킨다.', 'SUBJECTIVE'),
       (1386, 201, '빈칸에 들어갈 용어를 작성하시오', '가장 최근에 사용한 데이터에 다시 접근하려는 경향을 ___라고 하며, 함수 내 지역 변수나 루프 변수가 대표적인 예이다.', 'SUBJECTIVE'),
       (1387, 201, '다음 중 공간 지역성에 해당하는 예시로 올바른 것은?', '공간 지역성은 가장 최근에 접근한 공간에 다시 접근하려는 경향을 의미한다.', 'OBJECTIVE'),
       (1388, 201, '빈칸에 들어갈 용어를 작성하시오', '캐시 적중률은 ''히트수 / (히트수 + ___)'' 공식으로 계산된다.', 'SUBJECTIVE'),
        (1389, 201, '빈칸에 들어갈 용어를 작성하시오', '캐시에서 원하는 데이터를 찾지 못한 경우를 ___라고 한다.', 'SUBJECTIVE'),
       (1390, 201, '다음 중 캐시 적중률을 높이기 위한 방법으로 올바른 것은?', '캐시 적중률은 캐시 성능을 나타내는 중요한 지표이다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES
-- 문제 1387
(3895, 1387, '함수 내 지역 변수', '함수 내 지역 변수는 시간 지역성의 예시이다.', false),
(3896, 1387, '루프 변수', '루프 변수는 시간 지역성의 예시이다.', false),
(3897, 1387, '배열 원소의 순차적 접근', '배열은 메모리 상에 연속적으로 배치되어 있어 공간 지역성의 대표적인 예시이다.', true),
(3898, 1387, '반복문 내에서 동일한 변수 재참조', '동일한 변수의 반복적 참조는 시간 지역성의 예시이다.', false),

-- 문제 1390
(3899, 1390, '캐시 용량을 최대한 작게 유지한다', '캐시 용량을 너무 작게 하면 필요한 데이터를 충분히 저장할 수 없어 적중률이 낮아진다.', false),
(3900, 1390, '시간 지역성과 공간 지역성을 활용한다', '자주 사용되는 데이터와 인접한 데이터를 캐시에 유지하는 지역성의 원리를 활용하면 적중률을 높일 수 있다.', true),
(3901, 1390, '무작위로 데이터를 캐시에 저장한다', '무작위 저장은 지역성을 고려하지 않아 적중률을 낮춘다.', false),
(3902, 1390, '캐시 미스가 발생하면 데이터를 저장하지 않는다', '캐시 미스 발생 시 해당 데이터를 캐시에 저장해야 이후 접근 시 적중할 수 있다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (411, 1385, '지역성의 원리', '캐시 메모리는 지역성의 원리를 활용하여 자주 사용하는 데이터를 예측하고 저장함으로써 적중률을 높인다.'),
       (412, 1386, '시간 지역성', '시간 지역성은 최근에 참조된 데이터가 가까운 미래에 다시 참조될 가능성이 높다는 특성을 의미한다.'),
       (413, 1388, '미스수, cache miss', '캐시 적중률은 전체 접근 횟수 중 캐시 히트가 발생한 비율을 나타내며, 히트수를 전체 접근 횟수(히트수+미스수)로 나눈 값이다.'),
       (414, 1389, '캐시 미스, cache miss', '캐시 미스는 요청한 데이터가 캐시에 없어 메인 메모리에서 가져와야 하는 상황을 의미한다.');


-- ===== Lesson 3: 캐시 매핑 기법 =====
INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (1391, 202, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '직접 매핑은 캐싱 매핑 기법 중 하나이다.', 'OBJECTIVE'),
       (1392, 202, '빈칸에 들어갈 용어를 작성하시오', '직접 매핑에서 여러 메모리 블록이 같은 인덱스에 매핑될 때 발생하는 캐시 미스를 ___라고 한다.', 'SUBJECTIVE'),
       (1393, 202, '빈칸에 들어갈 용어를 작성하시오', '___는 직접 매핑과 연관 매핑을 합친 방식으로, 메모리 주소는 태그, 집합 인덱스, 블록 오프셋으로 구성된다.', 'SUBJECTIVE'),
       (1394, 202, '빈칸에 들어갈 용어를 작성하시오', '직접 매핑 방식에서 메모리 주소는 태그, ___, 블록 오프셋으로 구성된다.', 'SUBJECTIVE'),
       (1395, 202, '다음 중 집합 연관 매핑에 대한 설명으로 올바르지 않은 것은?', '집합 연관 매핑은 직접 매핑과 연관 매핑을 결합한 방식이다.', 'OBJECTIVE'),
       (1396, 202, '다음 중 연관 매핑 방식의 특징으로 올바르지 않은 것은?', '연관 매핑은 메모리 블록을 캐시에 자유롭게 배치할 수 있는 매핑 방식이다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES
-- 문제 1391
(3903, 1391, '메모리 블록을 캐시의 어느 위치에나 자유롭게 저장할 수 있다', '메모리 블록을 자유롭게 저장할 수 있는 방식은 연관 매핑이다.', false),
(3904, 1391, '메모리 주소는 태그와 블록 오프셋으로만 구성된다', '직접 매핑에서 메모리 주소는 태그, 인덱스, 블록 오프셋으로 구성된다.', false),
(3905, 1391, '구현이 단순하고 주소 변환이 빠르지만 충돌 미스가 발생할 수 있다', '직접 매핑은 각 메모리 블록이 고정된 캐시 위치에 매핑되어 구현이 단순하고 빠르지만, 같은 인덱스를 가진 블록들이 충돌하여 캐시 교체가 반복될 수 있다.', true),
(3906, 1391, '모든 캐시 라인을 비교해야 하므로 검색 비용이 크다', '모든 캐시 라인을 비교하는 방식은 연관 매핑이다.', false),

-- 문제 1395
(3907, 1395, '캐시를 여러 집합으로 나누고 각 메모리 블록은 특정 집합에 매핑된다', '집합 연관 매핑은 캐시를 집합으로 구분하고 메모리 블록을 특정 집합에 매핑한다.', false),
(3908, 1395, '집합 내에서는 메모리 블록을 자유롭게 배치할 수 있다', '지정된 집합 내에서는 연관 매핑처럼 자유로운 배치가 가능하다.', false),
(3909, 1395, '직접 매핑보다 하드웨어가 단순하다', '집합 연관 매핑은 집합 내에서 여러 위치를 비교해야 하므로 직접 매핑보다 하드웨어가 복잡하다.', true),
(3910, 1395, '지정된 집합 내에서만 검색하므로 비교 범위가 제한된다', '모든 라인을 검색하는 연관 매핑과 달리 특정 집합 내에서만 검색하므로 비교 범위가 줄어든다.', false),

-- 문제 1396
(3911, 1396, '충돌 미스가 거의 발생하지 않는다', '연관 매핑은 자유로운 배치가 가능하여 충돌 미스가 거의 발생하지 않는다.', false),
(3912, 1396, '필요한 데이터 위주로 캐시에 유지하여 적중률이 높다', '연관 매핑은 유연한 배치로 필요한 데이터를 효율적으로 유지할 수 있어 적중률이 높다.', false),
(3913, 1396, '구현이 단순하고 주소 변환이 빠르다', '연관 매핑은 모든 캐시 라인을 비교해야 하므로 하드웨어가 복잡하고 검색 비용이 크다.', true),
(3914, 1396, '캐시의 모든 라인을 대상으로 태그를 비교하여 데이터를 검색한다', '연관 매핑은 고정된 위치가 없어 모든 캐시 라인의 태그를 비교해야 한다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (415, 1392, '충돌 미스, conflict miss', '충돌 미스는 직접 매핑에서 동일한 인덱스를 공유하는 메모리 블록들이 번갈아 접근될 때 캐시 교체가 반복되며 발생한다.'),
       (416, 1393, '집합 연관 매핑', '집합 연관 매핑은 캐시를 여러 집합으로 나누고 각 메모리 블록을 특정 집합에 매핑하되, 집합 내에서는 자유롭게 배치하는 방식이다.'),
       (417, 1394, '인덱스, index', '직접 매핑에서는 각 메모리 블록이 고정된 캐시 위치에 매핑되므로 인덱스가 필요하며, 메모리 주소는 태그, 인덱스, 블록 오프셋으로 구성된다.');


