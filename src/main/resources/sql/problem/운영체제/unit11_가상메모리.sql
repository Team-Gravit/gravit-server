-- Unit: 가상메모리 (Unit ID: 66)
-- Chapter: 운영체제 (Chapter ID: 5)

-- Lesson 생성
INSERT INTO lesson (id, unit_id, title)
VALUES (194, 66, '가상메모리'),
       (195, 66, '페이징 1'),
       (196, 66, '페이징 2');

-- ===== Lesson 1: 가상메모리 =====
INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (1343, 194, '아래 제시한 개념에 대한 설명으로 옳은 것은?', 'MMU는 논리 주소를 물리 주소로 변환하는 하드웨어이다.', 'OBJECTIVE'),
       (1344, 194, '빈칸에 들어갈 용어를 작성하시오', '논리 주소를 물리 주소로 변환할 때 ''물리 주소 = 논리 주소 + ___'' 공식을 사용한다.', 'SUBJECTIVE'),
       (1345, 194, '다음 중 논리 주소와 물리 주소에 대한 설명으로 올바르지 않은 것은?', '가상 메모리 시스템에서 프로세스는 논리 주소를 사용하고 이는 물리 주소로 변환된다.', 'OBJECTIVE'),
       (1346, 194, '빈칸에 들어갈 용어를 작성하시오', '페이징 시스템에서 물리 메모리를 페이지와 같은 크기로 나눈 블록을 ___라고 하며, 논리 메모리를 고정 크기로 나눈 블록은 페이지라고 한다.', 'SUBJECTIVE'),
       (1347, 194, '제시된 내용과 관련하여 옳은 것은?', '가상 메모리는 물리 메모리 크기의 제약을 줄이기 위해 사용되는 메모리 관리 기법이다.', 'OBJECTIVE'),
       (1348, 194, '빈칸에 들어갈 용어를 작성하시오', '각 프로세스가 자신만의 연속된 주소 공간을 가진 것처럼 인식하는 주소를 ___ 주소라고 한다.', 'SUBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES
-- 문제 1343
(3811, 1343, 'Base Register는 프로세스 메모리 크기를 저장하여 보호 목적으로 사용된다', '프로세스 메모리 크기를 저장하여 보호 목적으로 사용되는 것은 Limit Register이다. Base Register는 시작 물리 주소를 저장한다.', false),
(3812, 1343, '물리 주소는 논리 주소에서 Base Register 값을 뺀 값이다', '물리 주소는 논리 주소에 Base Register 값을 더한 값이다. 즉, 물리 주소 = 논리 주소 + Base Register이다.', false),
(3813, 1343, 'Limit Register는 CPU가 요청한 논리 주소 값이 저장된 값 이내인지 검사한다', 'Limit Register는 프로세스 메모리 크기를 저장하며, CPU가 요청한 논리 주소 값이 이 범위 이내인지 검사하여 보호 목적으로 사용된다.', true),
(3814, 1343, 'Base Register와 Limit Register는 모두 물리 주소 변환에만 사용된다', 'Base Register는 물리 주소 변환에 사용되지만, Limit Register는 메모리 보호 목적으로 논리 주소의 범위를 검사하는 데 사용된다.', false),

-- 문제 1345
(3815, 1345, '논리 주소는 각 프로세스마다 0번지부터 시작한다', '논리 주소는 각 프로세스마다 0번지부터 시작하며, 프로세스는 자신만의 연속된 주소 공간을 가진 것처럼 인식한다.', false),
(3816, 1345, '물리 주소는 실제 메모리의 주소로 여러 프로세스가 공유한다', '물리 주소는 실제 메모리의 주소이며 여러 프로세스가 공유한다.', false),
(3817, 1345, '논리 주소와 물리 주소는 항상 같은 값을 가진다', '논리 주소와 물리 주소는 다른 값을 가지며, MMU를 통해 변환이 필요하다. 이것이 가상 메모리의 핵심 개념이다.', true),
(3818, 1345, '프로세스는 자신만의 연속된 주소 공간을 가진 것처럼 인식한다', '각 프로세스는 독립적인 논리 주소 공간을 가지며 연속된 주소 공간을 가진 것처럼 인식한다.', false),

-- 문제 1347
(3819, 1347, '각 프로세스는 동일한 논리 주소 공간을 공유한다', '각 프로세스는 독립적인 논리 주소 공간을 가진다.', false),
(3820, 1347, '프로세스는 실제 물리 메모리보다 큰 주소 공간을 사용할 수 있다', '가상 메모리는 물리 메모리 크기보다 큰 논리 주소 공간을 제공하여 프로그램 실행을 가능하게 한다.', true),
(3821, 1347, '모든 논리 주소는 항상 물리 메모리에 적재되어 있어야 한다', '가상 메모리에서는 실제로 필요한 부분만 물리 메모리에 적재한다.', false),
(3822, 1347, '가상 메모리는 MMU 없이 운영체제 소프트웨어만으로 구현된다', '논리 주소에서 물리 주소로의 변환은 MMU라는 하드웨어를 사용한다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (389, 1344, 'base register', 'Base Register(재배치 레지스터)는 시작 물리 주소를 저장하며, 물리 주소는 논리 주소에 Base Register 값을 더하여 계산한다.'),
       (390, 1346, '프레임,frame', '프레임(Frame)은 물리 메모리를 페이지와 같은 고정 크기로 나눈 블록이다.'),
       (391, 1348, '논리', '논리 주소(Virtual Address)는 각 프로세스마다 독립적으로 0번지부터 시작하며, 실제 물리 메모리와는 분리된 주소 공간이다.');


-- ===== Lesson 2: 페이징 1 =====
INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (1349, 195, '다음 중 페이징에 대한 설명으로 올바르지 않은 것은?', '페이징은 메모리를 고정 크기로 나누어 관리하는 기법이다.', 'OBJECTIVE'),
       (1350, 195, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '페이지 테이블 엔트리는 여러 비트와 정보로 구성되어 페이지 관리에 사용된다.', 'OBJECTIVE'),
       (1351, 195, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '유효 비트는 페이지의 상태를 나타내는 비트이다.', 'OBJECTIVE'),
       (1352, 195, '빈칸에 들어갈 용어를 작성하시오', '물리 메모리를 페이지와 같은 크기로 나눈 블록을 ___라고 한다.', 'SUBJECTIVE'),
       (1353, 195, '빈칸에 들어갈 용어를 작성하시오', 'CPU가 논리 주소를 생성하면 TLB에서 해당 페이지 번호를 검색하여 찾으면 TLB ___이(가) 발생하고, 찾지 못하면 TLB Miss이(가) 발생한다.', 'SUBJECTIVE'),
       (1354, 195, '다음 중 페이지 폴트 처리 과정을 순서대로 나열한 것은?', '페이지 폴트는 프로세스가 접근하려는 페이지가 물리 메모리에 없을 때 발생하는 예외 상황이다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES
-- 문제 1349
(3823, 1349, '페이지는 논리 메모리를 고정 크기로 나눈 블록이고, 프레임은 물리 메모리를 페이지와 같은 크기로 나눈 블록이다', '페이지는 논리 메모리를, 프레임은 물리 메모리를 동일한 고정 크기로 나눈 블록이다. 이는 페이징의 기본 개념이다.', false),
(3824, 1349, '페이징은 외부 단편화를 해결하지만 내부 단편화가 발생할 수 있다', '페이징은 비연속 할당으로 외부 단편화를 해결하지만, 프로세스의 마지막 페이지가 페이지 크기보다 작을 경우 내부 단편화가 발생할 수 있다.', false),
(3825, 1349, '페이지 테이블의 유효 비트가 1이면 페이지가 디스크에 있음을 의미한다', '유효 비트가 1이면 페이지가 메모리에 있음을 의미하고, 0이면 디스크에 있음을 의미한다.', true),
(3826, 1349, '각 프로세스마다 독립적인 페이지 테이블을 보유한다', '각 프로세스는 독립적인 논리 주소 공간을 가지므로 각각 독립적인 페이지 테이블을 보유한다.', false),

-- 문제 1350
(3827, 1350, '수정 비트(Dirty Bit)는 최근에 페이지에 접근했는지 여부를 나타낸다', '최근 접근 여부를 나타내는 것은 참조 비트(Reference Bit)이다. 수정 비트는 페이지 내용이 수정되었는지 여부를 나타낸다.', false),
(3828, 1350, '보호 비트(Protection Bit)는 페이지가 메모리에 있는지 디스크에 있는지를 표시한다', '페이지가 메모리에 있는지 여부를 나타내는 것은 유효 비트(Valid Bit)이다. 보호 비트는 읽기/쓰기/실행 권한을 나타낸다.', false),
(3829, 1350, '프레임 번호는 해당 페이지가 적재된 물리 메모리 위치를 나타낸다', '프레임 번호는 해당 페이지가 물리 메모리의 어느 프레임에 적재되었는지를 나타낸다. 이는 논리 주소를 물리 주소로 변환하는 데 사용된다.', true),
(3830, 1350, '참조 비트(Reference Bit)는 페이지 내용이 수정되었는지를 표시한다', '페이지 내용의 수정 여부를 나타내는 것은 수정 비트(Dirty Bit)이다. 참조 비트는 최근 접근 여부를 나타낸다.', false),

-- 문제 1351
(3831, 1351, '유효 비트가 0이면 페이지가 물리 메모리에 있음을 의미한다', '유효 비트가 0이면 페이지가 디스크에 있음을 의미한다. 1일 때 물리 메모리에 있다.', false),
(3832, 1351, '유효 비트가 1이면 페이지가 메모리에 있고, 0이면 디스크에 있음을 의미한다', '유효 비트는 페이지가 메모리에 있는지 여부를 나타낸다. 1은 메모리, 0은 디스크를 의미한다.', true),
(3833, 1351, '유효 비트는 페이지의 읽기/쓰기/실행 권한을 나타낸다', '읽기/쓰기/실행 권한을 나타내는 것은 보호 비트이다.', false),
(3834, 1351, '유효 비트가 0일 때 CPU는 정상적으로 메모리에 접근할 수 있다', '유효 비트가 0이면 페이지가 디스크에 있으므로 페이지 폴트가 발생한다.', false),

-- 문제 1354
(3835, 1354, 'trap 발생 → 페이지 테이블 갱신 → 디스크에서 페이지 탐색 → 프레임에 로드 → CPU 재시작', '페이지 테이블 갱신은 페이지를 프레임에 로드한 후에 이루어진다. 올바른 순서는 trap 발생 → 디스크에서 페이지 탐색 → 프레임에 로드 → 페이지 테이블 갱신 → CPU 재시작이다.', false),
(3836, 1354, 'trap 발생 → 디스크에서 페이지 탐색 → 프레임에 로드 → 페이지 테이블 갱신 → CPU 재시작', '올바른 페이지 폴트 처리 순서이다. CPU가 유효 비트 0인 페이지에 접근하면 trap이 발생하고, 디스크에서 페이지를 찾아 빈 프레임에 로드한 후 페이지 테이블을 갱신하고 CPU를 재시작한다.', true),
(3837, 1354, '디스크에서 페이지 탐색 → trap 발생 → 프레임에 로드 → CPU 재시작 → 페이지 테이블 갱신', 'trap 발생이 먼저 일어나야 하며, 페이지 테이블 갱신은 CPU 재시작 전에 이루어져야 한다.', false),
(3838, 1354, '프레임에 로드 → trap 발생 → 디스크에서 페이지 탐색 → 페이지 테이블 갱신 → CPU 재시작', '프레임에 로드하기 전에 먼저 trap이 발생하고 디스크에서 페이지를 탐색해야 한다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (392, 1352, '프레임,frame', '프레임(Frame)은 물리 메모리를 페이지와 같은 고정 크기로 나눈 블록이다.'),
       (393, 1353, 'hit', 'TLB Hit은 TLB에서 프레임 번호를 찾아 즉시 물리 주소를 생성하는 경우이고, TLB Miss는 TLB에 없어서 페이지 테이블에서 찾아야 하는 경우이다.');


-- ===== Lesson 3: 페이징 2 =====
INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (1355, 196, '빈칸에 들어갈 용어를 작성하시오', '프로그램 실행 시 모든 페이지를 저장하는 것이 아닌 실제 접근이 발생할 때만 해당 페이지를 메모리에 저장하는 기법을 ___라고 한다.', 'SUBJECTIVE'),
       (1356, 196, '빈칸에 들어갈 용어를 작성하시오', '프로세스가 접근하려는 페이지의 유효 비트가 0일 때 발생하는 예외 상황을 ___라고 한다.', 'SUBJECTIVE'),
       (1357, 196, '빈칸에 들어갈 용어를 작성하시오', '요구 페이징에서 프로세스가 접근하려는 페이지의 ___가 0일 때 페이지 폴트가 발생한다.', 'SUBJECTIVE'),
       (1358, 196, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '페이징은 메모리를 고정 크기로 나누어 관리하는 기법이다.', 'OBJECTIVE'),
       (1359, 196, '다음 중 세그먼테이션에 대한 설명으로 올바르지 않은 것은?', '세그먼테이션은 프로그램을 논리적 단위로 분할하는 메모리 관리 기법이다.', 'OBJECTIVE'),
       (1360, 196, '빈칸에 들어갈 용어를 작성하시오', '세그먼테이션은 ___를 해결하지만, 서로 다른 크기의 세그먼트의 할당과 해제가 반복되면 외부 단편화가 발생할 수 있다.', 'SUBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES
-- 문제 1358
(3839, 1358, '페이징은 외부 단편화와 내부 단편화를 모두 완전히 해결한다', '페이징은 외부 단편화를 해결하지만 내부 단편화는 발생할 수 있다.', false),
(3840, 1358, '페이징은 외부 단편화를 해결하지만 프로세스의 마지막 페이지에서 내부 단편화가 발생할 수 있다', '페이징은 외부 단편화를 해결하지만, 프로세스의 마지막 페이지가 페이지 크기보다 작을 경우 남은 공간이 낭비되어 내부 단편화가 발생할 수 있다.', true),
(3841, 1358, '페이징은 내부 단편화를 해결하지만 외부 단편화가 발생한다', '반대로, 페이징은 외부 단편화를 해결하고 내부 단편화가 발생할 수 있다.', false),
(3842, 1358, '페이징에서는 어떠한 단편화도 발생하지 않는다', '페이징에서도 마지막 페이지에서 내부 단편화가 발생할 수 있다.', false),

-- 문제 1359
(3843, 1359, '세그먼트는 코드, 데이터, 스택 등 논리적 단위로 분할된다', '세그먼테이션은 프로그램을 논리적 단위인 세그먼트(코드, 데이터, 스택 등)로 분할한다.', false),
(3844, 1359, '세그먼테이션은 내부 단편화를 해결한다', '세그먼테이션은 프로그램을 필요한 크기만큼만 할당하므로 내부 단편화를 해결한다.', false),
(3845, 1359, '세그먼테이션은 외부 단편화 문제를 완전히 방지한다', '세그먼테이션은 서로 다른 크기의 세그먼트의 할당과 해제가 반복되면 외부 단편화가 발생할 수 있다.', true),
(3846, 1359, '세그먼트 테이블은 세그먼트 번호를 시작 주소와 크기로 매핑한다', '세그먼트 테이블은 세그먼트 번호를 해당 세그먼트의 시작 주소와 크기로 매핑한다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (394, 1355, '요구 페이징', '프로그램 실행 시 필요한 페이지만 메모리에 저장하는 기법으로, 실제 접근이 발생할 때만 해당 페이지를 저장한다.'),
       (395, 1356, '페이지 폴트,page fault', '프로세스가 접근하려는 페이지가 물리 메모리에 없을 때(유효 비트가 0일 때) 발생하는 예외 상황이다.'),
       (396, 1357, '유효 비트', '유효 비트는 페이지가 메모리에 있는지(1) 디스크에 있는지(0)를 나타내며, 0이면 페이지 폴트가 발생한다.'),
       (397, 1360, '내부 단편화', '세그먼테이션은 필요한 크기만큼만 할당하므로 내부 단편화를 해결하지만, 외부 단편화는 발생할 수 있다.');


