-- Unit: 퀵 정렬 (Unit ID: 19)
-- Chapter: 알고리즘 (Chapter ID: 2)

-- Lesson 생성
INSERT INTO lesson (id, unit_id, title)
VALUES (54, 19, '퀵 정렬 기초 문제집'),
       (55, 19, '퀵 정렬 동작 과정 문제집'),
       (56, 19, '퀵 정렬 분석 문제집');

-- =====================================================
-- Lesson 54: 퀵 정렬 기초 문제집
-- =====================================================

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (319, 54, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '퀵 정렬(Quick Sort)은 분할 정복 알고리즘 기반의 정렬 방식이다.', 'OBJECTIVE'),
       (320, 54, '빈칸에 들어갈 알맞은 말을 작성하시오', '퀵 정렬은 ___을 기준으로 배열을 비균등 분할하는 분할 정복 알고리즘이다.', 'SUBJECTIVE'),
       (321, 54, '제시된 내용과 관련하여 옳은 것은?', '퀵 정렬은 다양한 특징을 가진 정렬 알고리즘이다.', 'OBJECTIVE'),
       (322, 54, '제시된 내용과 관련하여 옳은 것은?', '퀵 정렬은 특정한 시간 복잡도를 가진다.', 'OBJECTIVE'),
       (323, 54, '빈칸에 들어갈 알맞은 말을 작성하시오', '퀵 정렬은 평균적으로 ___의 시간 복잡도를 가지지만 최악의 경우 O(n²)으로 저하된다.', 'SUBJECTIVE'),
       (324, 54, '제시된 내용과 관련하여 옳은 것은?', '퀵 정렬은 안정성과 관련된 특성을 가진다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (849, 319, '인접한 두 원소를 비교하여 교환하는 알고리즘이다',
        '이는 버블 정렬의 특징이다. 퀵 정렬은 피벗을 기준으로 분할한다.', false),
       (850, 319, '배열을 균등하게 절반씩 분할하는 알고리즘이다',
        '이는 합병 정렬의 특징이다. 퀵 정렬은 피벗을 기준으로 비균등하게 분할한다.', false),
       (851, 319, '피벗을 기준으로 배열을 비균등 분할하며 제자리 정렬이 가능한 분할 정복 알고리즘이다',
        '퀵 정렬은 분할 정복 알고리즘 기반 정렬 방식이다. 피벗(Pivot)을 기준으로 배열을 비균등 분할하며, 제자리 정렬이 가능하다. 평균적으로 O(n log n) 시간 복잡도를 가지지만, 최악의 경우 O(n²)으로 저하된다.',
        true),
       (852, 319, '정렬된 부분에 원소를 삽입하는 알고리즘이다',
        '이는 삽입 정렬의 특징이다. 퀵 정렬은 분할 정복 방식을 사용한다.', false),

       (853, 321, '추가 메모리가 O(n) 필요하다',
        '퀵 정렬은 제자리 정렬로 추가 메모리가 O(log n)이다. O(n)은 합병 정렬의 공간 복잡도이다.', false),
       (854, 321, '분할 정복 방식으로 피벗을 기준으로 비균등 분할하고 제자리 정렬이 가능하며 불안정 정렬이다',
        '퀵 정렬은 분할 정복 방식으로 피벗을 기준으로 배열을 비균등하게 분할하며, 제자리 정렬(In-place Sort)이 가능하여 추가 메모리 공간을 최소화한다. 불안정 정렬로 동일 값의 순서가 바뀔 수 있고, 평균적으로 다른 O(n log n) 알고리즘보다 빠르며, 캐시 효율성이 높아 실무에서 많이 사용된다.',
        true),
       (855, 321, '균등 분할을 수행한다',
        '퀵 정렬은 피벗을 기준으로 비균등 분할한다. 균등 분할은 합병 정렬의 특징이다.', false),
       (856, 321, '안정 정렬이다',
        '퀵 정렬은 불안정 정렬이다. 동일한 값의 순서가 바뀔 수 있다.', false),

       (857, 322, '최선 O(n), 평균 O(n²), 최악 O(n²)이다',
        '퀵 정렬은 평균 O(n log n)이다. 평균이 O(n²)이 아니다.', false),
       (858, 322, '모든 경우에 O(n log n)이다',
        '퀵 정렬은 최악의 경우 O(n²)이다. 모든 경우가 O(n log n)은 아니다.', false),
       (859, 322, '모든 경우에 O(n²)이다',
        '퀵 정렬은 평균적으로 O(n log n)이다. 최악의 경우에만 O(n²)이다.', false),
       (860, 322, '평균 O(n log n), 최악 O(n²)이다',
        '퀵 정렬의 시간 복잡도는 평균적으로 O(n log n)이지만, 최악의 경우(정렬된 배열에서 첫/끝 피벗 선택 시) O(n²)으로 저하된다. 이는 합병 정렬과의 주요 차이점이다.',
        true),

       (861, 324, '동일한 값을 처리할 수 없다',
        '퀵 정렬은 동일한 값을 처리할 수 있지만 순서가 바뀔 수 있다.', false),
       (862, 324, '안정 정렬이며 동일한 값의 순서를 유지한다',
        '퀵 정렬은 불안정 정렬이다. 동일한 값의 순서가 바뀔 수 있다.', false),
       (863, 324, '불안정 정렬이며 동일한 값의 순서가 바뀔 수 있다',
        '퀵 정렬은 불안정 정렬(Unstable Sort)이다. 동일한 값의 순서가 바뀔 수 있으므로 동일한 키를 가진 데이터의 상대적 순서가 변할 수 있다.',
        true),
       (864, 324, '동일한 값은 항상 제거된다',
        '퀵 정렬은 동일한 값을 유지한다. 제거하지 않는다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (107, 320, '피벗,pivot,피봇',
        '퀵 정렬은 피벗(Pivot)을 기준으로 배열을 비균등 분할하는 분할 정복 알고리즘이다. 피벗보다 작은 원소는 왼쪽, 큰 원소는 오른쪽으로 배치한다.'),
       (108, 323, 'o(n log n),o(nlogn),onlogn,o(n*logn)',
        '퀵 정렬은 평균적으로 O(n log n)의 시간 복잡도를 가지지만 최악의 경우 O(n²)으로 저하된다. 피벗 선택에 따라 성능이 달라진다.');

-- =====================================================
-- Lesson 55: 퀵 정렬 동작 과정 문제집
-- =====================================================

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (325, 55, '제시된 내용과 관련하여 옳은 것은?', '퀵 정렬은 분할 단계를 포함하는 알고리즘이다.', 'OBJECTIVE'),
       (326, 55, '빈칸에 들어갈 알맞은 말을 작성하시오', '퀵 정렬의 분할 과정은 ___을 기준으로 배열을 2개의 부분 배열로 나눈다.', 'SUBJECTIVE'),
       (327, 55, '제시된 내용과 관련하여 옳은 것은?', '퀵 정렬은 정복 단계를 포함하는 알고리즘이다.', 'OBJECTIVE'),
       (328, 55, '제시된 내용과 관련하여 옳은 것은?', '퀵 정렬은 결합 단계와 관련된 특징을 가진다.', 'OBJECTIVE'),
       (329, 55, '빈칸에 들어갈 알맞은 말을 작성하시오', '퀵 정렬의 분할 과정은 ___개의 포인터를 사용하여 배열을 분할한다.', 'SUBJECTIVE'),
       (330, 55, '제시된 내용과 관련하여 옳은 것은?', '퀵 정렬은 특정한 방식으로 분할 과정을 수행한다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (865, 325, '인접한 원소를 비교하여 분할한다',
        '퀵 정렬은 피벗과 비교하여 분할한다. 인접한 원소끼리 비교하지 않는다.', false),
       (866, 325, '피벗을 선택하고 피벗보다 작은 원소는 왼쪽 큰 원소는 오른쪽으로 배치하여 배열을 2개의 부분 배열로 분할한다',
        '퀵 정렬의 분할 단계는 피벗을 선택하고, 피벗보다 작은 원소는 왼쪽, 큰 원소는 오른쪽으로 배치하여 배열을 2개의 부분 배열로 분할한다. 이는 비균등 분할이다.',
        true),
       (867, 325, '배열을 균등하게 절반으로 나눈다',
        '이는 합병 정렬의 특징이다. 퀵 정렬은 피벗을 기준으로 비균등하게 분할한다.', false),
       (868, 325, '최솟값을 찾아 분리한다',
        '이는 선택 정렬의 특징이다. 퀵 정렬은 피벗을 기준으로 분할한다.', false),

       (869, 327, '정렬된 배열을 합병한다',
        '이는 합병 정렬의 특징이다. 퀵 정렬은 제자리에서 정렬하므로 합병 과정이 없다.', false),
       (870, 327, '한 번만 수행하고 종료한다',
        '퀵 정렬은 재귀적으로 반복한다. 한 번만 수행하지 않는다.', false),
       (871, 327, '최솟값을 앞으로 이동시킨다',
        '이는 선택 정렬의 특징이다. 퀵 정렬은 재귀적으로 부분 배열을 정렬한다.', false),
       (872, 327, '분할된 부분 배열에 대해 재귀적으로 퀵 정렬을 반복한다',
        '퀵 정렬의 정복 단계는 분할된 부분 배열에 대해 재귀적으로 퀵 정렬을 반복한다. 배열 크기가 1이 될 때까지 반복하며, 크기가 1이면 정렬된 것으로 간주한다.',
        true),

       (873, 328, '추가 배열을 사용하여 합병한다',
        '퀵 정렬은 제자리 정렬로 추가 배열이 불필요하다.', false),
       (874, 328, '정렬된 배열들을 합병하는 과정이 필수이다',
        '퀵 정렬은 제자리 정렬이므로 별도 합병 과정이 불필요하다.', false),
       (875, 328, '결합 단계가 가장 많은 시간이 걸린다',
        '퀵 정렬은 분할 과정에서 정렬이 이루어진다. 결합은 별도 과정이 불필요하다.', false),
       (876, 328, '정렬된 부분 배열을 하나로 합치는 별도 병합 과정이 불필요하다',
        '퀵 정렬의 결합 단계는 정렬된 부분 배열을 하나로 합친다. 별도 병합 과정은 불필요하며, 제자리에서 정렬되므로 자연스럽게 정렬된 배열이 완성된다.',
        true),

       (877, 330, '무작위로 원소를 선택한다',
        '퀵 정렬은 체계적으로 포인터를 이동하며 탐색한다. 무작위가 아니다.', false),
       (878, 330, '한 개의 포인터만 사용한다',
        '퀵 정렬은 두 개의 포인터(low, high)를 사용한다.', false),
       (879, 330, '중간부터 양쪽으로 탐색한다',
        '퀵 정렬은 양 끝에서 중앙으로 탐색한다. 중간부터 시작하지 않는다.', false),
       (880, 330, 'low 포인터는 왼쪽에서 오른쪽으로 피벗보다 큰 값을 찾고 high 포인터는 오른쪽에서 왼쪽으로 피벗보다 작은 값을 찾아 교환한다',
        '퀵 정렬의 분할 과정은 두 개의 포인터(low, high)를 사용한다. low는 왼쪽에서 오른쪽으로 피벗보다 큰 값을 탐색하고, high는 오른쪽에서 왼쪽으로 피벗보다 작은 값을 탐색한다. 두 값을 교환하고 low > high가 될 때까지 반복한다.',
        true);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (109, 326, '피벗,pivot,피봇',
        '퀵 정렬의 분할 과정은 피벗(Pivot)을 기준으로 배열을 2개의 부분 배열로 나눈다. 피벗보다 작은 원소는 왼쪽, 큰 원소는 오른쪽으로 배치한다.'),
       (110, 329, '2,두,둘,2개,두개,두 개',
        '퀵 정렬의 분할 과정은 2개의 포인터(low, high)를 사용하여 배열을 분할한다. low는 왼쪽에서, high는 오른쪽에서 탐색한다.');

-- =====================================================
-- Lesson 56: 퀵 정렬 분석 문제집
-- =====================================================

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (331, 56, '제시된 내용과 관련하여 옳은 것은?', '퀵 정렬은 다양한 피벗 선택 전략을 사용할 수 있다.', 'OBJECTIVE'),
       (332, 56, '빈칸에 들어갈 알맞은 말을 작성하시오', '퀵 정렬은 제자리 정렬로 재귀 호출 스택에 ___의 공간이 필요하다.', 'SUBJECTIVE'),
       (333, 56, '제시된 내용과 관련하여 옳은 것은?', '퀵 정렬은 다양한 장점을 가진 정렬 알고리즘이다.', 'OBJECTIVE'),
       (334, 56, '제시된 내용과 관련하여 옳은 것은?', '퀵 정렬은 단점도 가지고 있다.', 'OBJECTIVE'),
       (335, 56, '빈칸에 들어갈 알맞은 말을 작성하시오', '퀵 정렬은 평균적으로 같은 O(n log n)인 ___보다 2~3배 빠르다.', 'SUBJECTIVE'),
       (336, 56, '제시된 내용과 관련하여 옳은 것은?', '퀵 정렬과 합병 정렬은 여러 차이점이 있다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (881, 331, '항상 첫 번째 원소만 사용한다',
        '피벗 선택 전략은 다양하다. 첫 번째 원소만 사용하는 것은 아니다.', false),
       (882, 331, '첫/마지막 원소, 중간 원소, 무작위 선택, 중앙값 등 다양한 전략이 있다',
        '퀵 정렬의 피벗 선택 전략은 첫/마지막 원소(구현 간단하지만 정렬된 배열에 취약), 중간 원소(균등 분할 가능성 증가), 무작위 선택(최악의 경우 확률 감소), 중앙값(최적 분할이지만 연산 비용 증가) 등이 있다.',
        true),
       (883, 331, '가장 큰 값만 피벗으로 선택한다',
        '피벗은 다양한 전략으로 선택된다. 가장 큰 값만 선택하는 것은 아니다.', false),
       (884, 331, '피벗을 선택하지 않는다',
        '퀵 정렬은 피벗 선택이 필수이다. 피벗이 없으면 분할할 수 없다.', false),

       (885, 333, '추가 메모리가 O(n) 필요하다',
        '퀵 정렬은 제자리 정렬로 추가 메모리가 O(log n)이다. O(n)이 아니다.', false),
       (886, 333, '안정 정렬이다',
        '퀵 정렬은 불안정 정렬이다. 동일한 값의 순서가 바뀔 수 있다.', false),
       (887, 333, '빠른 속도로 평균적으로 O(n log n) 알고리즘 중 가장 빠르고 캐시 효율성이 높으며 제자리 정렬이다',
        '퀵 정렬의 장점은 빠른 속도로 평균적으로 O(n log n) 알고리즘 중 가장 빠르고, 캐시 효율성이 높아 인접 데이터 비교로 캐시 히트율이 높으며, 제자리 정렬로 추가 메모리 공간을 최소화한다는 것이다.',
        true),
       (888, 333, '최악의 경우에도 O(n log n)이다',
        '퀵 정렬은 최악의 경우 O(n²)이다. 항상 O(n log n)이 아니다.', false),

       (889, 334, '제자리 정렬이 불가능하다',
        '퀵 정렬은 제자리 정렬이 가능하다. 이는 장점이다.', false),
       (890, 334, '평균적으로 매우 느리다',
        '퀵 정렬은 평균적으로 가장 빠른 정렬 알고리즘 중 하나이다.', false),
       (891, 334, '최악의 경우 O(n²)으로 정렬된 배열에서 첫/끝 피벗 선택 시 성능이 저하되고 불안정 정렬이며 재귀 오버헤드가 있다',
        '퀵 정렬의 단점은 최악의 경우 O(n²)으로 정렬된 배열에서 첫/끝 피벗 선택 시 성능이 저하되고, 불안정 정렬로 동일 값의 순서가 보장되지 않으며, 재귀 오버헤드로 인한 스택 사용이 있다는 것이다.',
        true),
       (892, 334, '구현이 매우 복잡하다',
        '퀵 정렬의 기본 구현은 비교적 간단하다. 매우 복잡하지 않다.', false),

       (893, 336, '합병 정렬이 항상 더 빠르다',
        '평균적으로 퀵 정렬이 더 빠르다. 하지만 최악의 경우 합병 정렬이 안정적이다.', false),
       (894, 336, '퀵 정렬과 합병 정렬은 완전히 동일하다',
        '퀵 정렬과 합병 정렬은 분할 방식, 안정성, 공간 복잡도 등에서 차이가 있다.', false),
       (895, 336, '퀵 정렬은 안정 정렬이고 합병 정렬은 불안정 정렬이다',
        '반대이다. 퀵 정렬은 불안정 정렬이고 합병 정렬은 안정 정렬이다.', false),
       (896, 336, '퀵 정렬은 비균등 분할이고 합병 정렬은 균등 분할이며 퀵 정렬은 평균적으로 더 빠르다',
        '퀵 정렬은 비균등 분할(피벗)을 하고 합병 정렬은 균등 분할(중간)을 한다. 퀵 정렬의 추가 메모리는 O(log n)이고 합병 정렬은 O(n)이다. 퀵 정렬은 불안정 정렬이고 합병 정렬은 안정 정렬이다. 퀵 정렬은 평균적으로 더 빠르지만 최악의 경우는 O(n²)이고 합병 정렬은 항상 O(n log n)이다.',
        true);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (111, 332, 'o(log n),o(logn),ologn,o(log(n))',
        '퀵 정렬은 제자리 정렬로 재귀 호출 스택에 O(log n)의 공간이 필요하다. 최악의 경우 O(n)까지 증가할 수 있지만 평균적으로 O(log n)이다.'),
       (112, 335, '합병 정렬,병합 정렬,합병정렬,병합정렬,merge sort,머지소트,머지 소트',
        '퀵 정렬은 평균적으로 같은 O(n log n)인 합병 정렬보다 2~3배 빠르다. 캐시 효율성이 높고 실제 수행 시간이 짧다. 하지만 일반적인 경우에 한정된다.');
