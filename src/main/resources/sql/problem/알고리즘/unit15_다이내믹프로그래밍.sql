-- Unit: 다이내믹 프로그래밍 (Unit ID: 25)
-- Chapter: 알고리즘 (Chapter ID: 2)

-- Lesson 생성
INSERT INTO lesson (id, unit_id, title)
VALUES (71, 25, '다이내믹 프로그래밍 기초 문제집'),
       (72, 25, '다이내믹 프로그래밍 예시 문제집'),
       (73, 25, '다이내믹 프로그래밍 접근법 문제집');

-- =====================================================
-- Lesson 71: 다이내믹 프로그래밍 기초 문제집
-- =====================================================

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (437, 71, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '다이내믹 프로그래밍은 특정한 방식으로 문제를 해결한다.', 'OBJECTIVE'),
       (438, 71, '빈칸에 들어갈 알맞은 말을 작성하시오', '다이내믹 프로그래밍은 큰 문제를 작은 부분 문제로 쪼개고 각 부분 문제의 해를 ___에 저장해두었다가 재사용한다.', 'SUBJECTIVE'),
       (439, 71, '제시된 내용과 관련하여 옳은 것은?', '다이내믹 프로그래밍은 두 가지 핵심 개념을 가진다.', 'OBJECTIVE'),
       (440, 71, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '최적 부분 구조는 DP의 필수 조건이다.', 'OBJECTIVE'),
       (441, 71, '빈칸에 들어갈 알맞은 말을 작성하시오', '문제를 풀다 보면 같은 부분 문제를 여러 번 다시 풀어야 하는 구조를 ___라고 한다.', 'SUBJECTIVE'),
       (442, 71, '제시된 내용과 관련하여 옳은 것은?', '다이내믹 프로그래밍은 여러 가지 특징을 가진다.', 'OBJECTIVE'),
       (443, 71, '제시된 내용과 관련하여 옳은 것은?', '다이내믹 프로그래밍과 그리디는 접근 방식이 다르다.', 'OBJECTIVE'),
       (444, 71, '제시된 내용과 관련하여 옳은 것은?', '다이내믹 프로그래밍은 장점을 가지고 있다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (1179, 437, '분할 정복만 사용하는 알고리즘이다', 'DP는 분할 정복과 메모이제이션을 함께 사용하는 기법이다. 분할 정복만으로는 중복되는 부분 문제를 효율적으로 처리할 수 없으므로 메모이제이션을 결합한 것이 다이내믹 프로그래밍이다.', false),
       (1180, 437, '매 순간 최선의 선택을 하는 알고리즘이다', '매 순간 지역적으로 최선의 선택을 하는 것은 그리디 알고리즘의 접근 방식이다. 다이내믹 프로그래밍은 모든 가능한 경우를 고려하여 전역 최적해를 구한다는 점에서 그리디와 차이가 있다.', false),
       (1181, 437, '큰 문제를 작은 부분 문제로 쪼개고 각 부분 문제의 해를 저장해두었다가 재사용하면서 전체 문제의 최적해를 구하는 알고리즘 설계 기법이다', '다이내믹 프로그래밍의 핵심은 부분 문제의 해를 메모리에 저장(메모이제이션)하고 재사용함으로써 중복 계산을 제거하는 것이다. 이를 통해 지수 시간 복잡도를 다항 시간으로 개선할 수 있다.', true),
       (1182, 437, '모든 경우의 수를 탐색하는 알고리즘이다', '모든 경우의 수를 단순하게 탐색하는 것은 브루트 포스 접근법이다. 다이내믹 프로그래밍은 중복되는 부분 문제의 결과를 저장하여 재사용함으로써 브루트 포스보다 훨씬 효율적이다.', false),

       (1183, 439, '탐욕 선택과 지역 최적', '탐욕 선택 속성과 지역 최적해의 조합은 그리디 알고리즘의 핵심 개념이다. 다이내믹 프로그래밍은 중복 계산 제거와 최적 부분 구조를 활용한다는 점에서 그리디와 다르다.', false),
       (1184, 439, '중복 계산 제거와 최적해를 단계적으로 구성', '다이내믹 프로그래밍의 두 가지 핵심은 중복되는 부분 문제의 계산을 제거하는 것과 작은 문제의 최적해로부터 큰 문제의 최적해를 단계적으로 구성하는 것이다. 이 두 원리가 DP의 효율성과 정확성을 보장한다.', true),
       (1185, 439, '백트래킹과 가지치기', '백트래킹과 가지치기는 탐색 공간을 줄이는 기법으로, 주로 제약 조건을 만족하는 해를 찾는 문제에서 사용된다. 다이내믹 프로그래밍의 핵심 개념과는 거리가 있다.', false),
       (1186, 439, '순환 구조와 재귀 호출', '재귀 호출은 DP를 구현하는 방법 중 하나(Top-Down)일 뿐, DP의 핵심 개념은 아니다. DP의 본질은 중복 계산 제거와 최적 부분 구조의 활용에 있다.', false),

       (1187, 440, '매 순간 최선을 선택하는 것', '매 순간 최선의 선택을 하는 것은 그리디 알고리즘의 탐욕 선택 속성이다. 최적 부분 구조는 작은 문제들의 최적해로부터 큰 문제의 최적해를 구성할 수 있는 성질을 의미한다.', false),
       (1188, 440, '큰 문제의 최적해가 작은 부분 문제들의 최적해로부터 구성될 수 있는 구조', '최적 부분 구조는 큰 문제의 최적해를 작은 부분 문제들의 최적해를 결합하여 구할 수 있는 구조를 말한다. 이 성질이 있어야 부분 문제의 해를 재사용하여 전체 문제를 효율적으로 풀 수 있다.', true),
       (1189, 440, '백트래킹을 사용하는 것', '백트래킹은 탐색 과정에서 조건을 만족하지 않는 경로를 배제하는 기법이다. 최적 부분 구조는 문제의 구조적 특성을 나타내는 것으로 백트래킹과는 다른 개념이다.', false),
       (1190, 440, '모든 경우를 탐색하는 것', '모든 경우를 탐색하는 것은 브루트 포스의 특징이다. 최적 부분 구조는 작은 문제의 최적해로 큰 문제의 최적해를 구성할 수 있는 문제의 성질을 의미한다.', false),

       (1191, 442, '매 순간 최선만 선택한다', '매 순간 지역적으로 최선의 선택만 하는 것은 그리디 알고리즘의 특징이다. 다이내믹 프로그래밍은 모든 가능한 경우를 고려하여 전역 최적해를 구한다는 점에서 차이가 있다.', false),
       (1192, 442, 'dp 테이블에 결과를 저장하여 재사용하고 가능한 경우를 모두 고려하며 항상 최적해를 보장하지만 메모리와 시간이 더 소요된다', '다이내믹 프로그래밍은 부분 문제의 결과를 dp 테이블에 저장하여 재사용하고, 모든 가능한 경우를 체계적으로 고려함으로써 최적해를 보장한다. 단, 저장 공간과 계산 시간이 추가로 필요하다는 트레이드오프가 있다.', true),
       (1193, 442, '메모리 사용이 적다', '다이내믹 프로그래밍은 부분 문제의 해를 저장하기 위해 추가 메모리(dp 테이블)를 사용한다. 메모리 사용량이 적은 것이 아니라 오히려 시간을 메모리로 교환하는 접근법이다.', false),
       (1194, 442, '최적해를 보장하지 않는다', '다이내믹 프로그래밍은 최적 부분 구조를 만족하는 문제에 대해 항상 최적해를 보장한다. 모든 경우를 체계적으로 고려하므로 최적해를 놓치지 않는다.', false),

       (1195, 443, 'DP는 최적해를 보장하지 않는다', '다이내믹 프로그래밍은 최적 부분 구조를 만족하는 문제에 대해 항상 최적해를 보장한다. 모든 가능한 경우를 고려하고 부분 문제의 최적해를 결합하기 때문이다.', false),
       (1196, 443, 'DP는 가능한 경우를 모두 고려하고 그리디는 지금 최선만 고르며 DP는 항상 최적해를 보장하지만 그리디는 보장하지 않는다', '다이내믹 프로그래밍은 모든 가능한 경우를 체계적으로 고려하여 전역 최적해를 구하는 반면, 그리디는 매 단계에서 지역적으로 최선인 선택만 한다. 따라서 DP는 항상 최적해를 보장하지만 그리디는 특정 조건을 만족해야만 최적해를 보장한다.', true),
       (1197, 443, 'DP와 그리디는 동일한 방식이다', 'DP와 그리디는 근본적으로 다른 접근 방식이다. DP는 모든 경우를 고려하여 최적해를 구하고, 그리디는 지역 최적만 선택한다. 구현 방식과 최적해 보장 여부도 다르다.', false),
       (1198, 443, '그리디가 DP보다 메모리를 더 많이 사용한다', '그리디 알고리즘은 현재 상태에서의 선택만 고려하므로 일반적으로 메모리 사용량이 적다. 반대로 DP는 부분 문제의 결과를 저장하기 위해 더 많은 메모리를 사용한다.', false),

       (1199, 444, '구현이 항상 간단하다', '다이내믹 프로그래밍은 상태 정의, 점화식 수립, 초기값 설정, 계산 순서 결정 등 여러 단계를 거쳐야 하므로 구현이 복잡할 수 있다. 특히 다차원 DP는 더욱 어려울 수 있다.', false),
       (1200, 444, '항상 최적해를 보장한다', '다이내믹 프로그래밍은 최적 부분 구조와 부분 문제의 중복이라는 조건을 만족하는 문제에 대해 항상 최적해를 보장한다. 모든 가능한 경우를 체계적으로 고려하고 부분 문제의 최적해를 결합하기 때문이다.', true),
       (1201, 444, '메모리 사용이 매우 적다', '다이내믹 프로그래밍은 부분 문제의 해를 저장하는 dp 테이블을 사용하므로 추가 메모리가 필요하다. 시간 복잡도를 줄이는 대신 공간 복잡도가 증가하는 트레이드오프가 있다.', false),
       (1202, 444, '실행 시간이 항상 빠르다', 'DP는 브루트 포스보다는 빠르지만, 모든 부분 문제를 계산해야 하므로 경우에 따라 실행 시간이 길 수 있다. 특히 그리디로 풀 수 있는 문제라면 그리디가 더 빠를 수 있다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (141, 438, 'dp 테이블,배열,dp 배열,테이블,table,메모리,memory,dp테이블', '다이내믹 프로그래밍은 각 부분 문제의 해를 dp 테이블(배열)이라는 메모리 공간에 저장해두었다가 동일한 부분 문제가 다시 필요할 때 재사용한다. 이를 통해 중복 계산을 제거하고 효율성을 크게 향상시킬 수 있다.'),
       (142, 441, '부분 문제의 중복,Overlapping Subproblems,중복되는 부분 문제,overlapping subproblems,중복,부분문제의중복,부분 문제 중복,중복 부분 문제', '같은 부분 문제를 여러 번 반복해서 풀어야 하는 구조를 부분 문제의 중복(Overlapping Subproblems)이라고 한다. 피보나치 수열이 대표적인 예시로, fib(5)를 구하기 위해 fib(3)이 여러 번 계산된다. 이러한 중복 계산을 제거하는 것이 DP의 핵심이다.');

-- =====================================================
-- Lesson 72: 다이내믹 프로그래밍 예시 문제집
-- =====================================================

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (445, 72, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '피보나치 수열은 DP의 대표적인 예시이다.', 'OBJECTIVE'),
       (446, 72, '빈칸에 들어갈 알맞은 말을 작성하시오', '피보나치 수열에서 fib(5) = fib(4) + fib(3) = 3 + 2 = ___이다.', 'SUBJECTIVE'),
       (447, 72, '제시된 내용과 관련하여 옳은 것은?', '피보나치는 DP 적용의 좋은 예시이다.', 'OBJECTIVE'),
       (448, 72, '아래 제시한 개념에 대한 설명으로 옳은 것은?', 'C[j]는 j원을 거슬러 줄 때 사용되는 동전 개수의 최소값이다.', 'OBJECTIVE'),
       (449, 72, '빈칸에 들어갈 알맞은 말을 작성하시오', '동전이 16, 5, 1원이고 20원을 거슬러 줄 때 DP로 구한 최소 동전 개수는 ___개이다.', 'SUBJECTIVE'),
       (450, 72, '제시된 내용과 관련하여 옳은 것은?', '특정 경우에 DP가 그리디보다 정확하다.', 'OBJECTIVE'),
       (451, 72, '제시된 내용과 관련하여 옳은 것은?', 'DP는 체계적인 접근이 필요하다.', 'OBJECTIVE'),
       (452, 72, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '점화식은 DP의 핵심이다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (1203, 445, 'fib(n) = fib(n-1) × fib(n-2)', '피보나치 수열은 이전 두 항을 곱하는 것이 아니라 더하는 것이다. 곱셈을 사용하면 값이 기하급수적으로 증가하여 피보나치 수열의 성질을 만족하지 않는다.', false),
       (1204, 445, 'fib(n) = fib(n-1) + fib(n-2), fib(0) = 0, fib(1) = 1', '피보나치 수열의 점화식은 fib(n) = fib(n-1) + fib(n-2)이며, 초기값은 fib(0) = 0, fib(1) = 1이다. 이 간단한 재귀 관계가 부분 문제의 중복을 발생시키므로 DP를 적용하기에 적합한 문제이다.', true),
       (1205, 445, 'fib(n) = fib(n-1) - fib(n-2)', '피보나치 수열은 이전 두 항을 빼는 것이 아니라 더하는 것이다. 뺄셈을 사용하면 음수가 발생하고 수열의 증가 패턴을 만족하지 않는다.', false),
       (1206, 445, 'fib(n) = 2 × fib(n-1)', '이 식은 단순히 이전 항의 2배를 계산하는 것으로, 피보나치 수열의 특성인 "이전 두 항의 합"을 나타내지 못한다. 피보나치는 두 개의 이전 항을 모두 사용한다.', false),

       (1207, 447, '정렬을 하기 위해서', '피보나치 수열 문제는 정렬과 무관하다. 피보나치는 점화식을 통해 각 항을 계산하는 문제이지, 데이터를 비교하거나 순서를 재배치하는 문제가 아니다.', false),
       (1208, 447, 'fib(3), fib(2) 등이 여러 번 반복 계산되므로 한 번 계산한 값을 저장하여 재사용하는 것이 효율적이다', '피보나치를 재귀로 구현하면 fib(3), fib(2) 등의 같은 부분 문제가 여러 번 반복 계산된다. 이러한 중복 계산을 제거하기 위해 한 번 계산한 값을 메모리에 저장(메모이제이션)하여 재사용하는 것이 DP의 핵심이다.', true),
       (1209, 447, '백트래킹을 사용하기 위해서', '피보나치 수열 문제는 백트래킹이 필요하지 않다. 백트래킹은 제약 조건을 만족하는 해를 찾을 때 사용하는 기법으로, 피보나치와 같은 수열 계산 문제와는 거리가 있다.', false),
       (1210, 447, '매 순간 최선을 선택하기 위해서', '피보나치는 매 순간 선택을 하는 문제가 아니라 정해진 점화식에 따라 계산하는 문제이다. 매 순간 최선을 선택하는 것은 그리디 알고리즘의 특징이다.', false),

       (1211, 448, 'C[j] = max(C[j-1], C[j-5], C[j-16])', '동전 개수의 최소값을 구해야 하므로 max가 아닌 min을 사용해야 한다. 최대값을 구하면 가장 비효율적인 방법을 선택하게 되어 문제의 목적과 반대가 된다.', false),
       (1212, 448, 'C[j] = min(C[j-1] + 1, C[j-5] + 1, C[j-16] + 1)', 'j원을 만들기 위해 마지막에 1원, 5원, 또는 16원 동전을 사용할 수 있다. 각 경우에 대해 이전 상태에서 동전 1개를 추가(+1)한 값 중 최솟값을 선택하는 것이 최적 부분 구조를 만족하는 점화식이다.', true),
       (1213, 448, 'C[j] = C[j-1] × C[j-5]', '동전 개수는 곱셈이 아닌 덧셈과 최솟값 비교로 구한다. 곱셈을 사용하면 개수의 의미가 사라지고 올바른 결과를 얻을 수 없다.', false),
       (1214, 448, 'C[j] = C[j-1] + C[j-5] + C[j-16]', '세 경우를 모두 더하는 것이 아니라 그 중 최솟값을 선택해야 한다. 모두 더하면 동전 개수가 과도하게 계산되어 최소값을 구할 수 없다.', false),

       (1215, 450, 'DP가 메모리를 덜 사용한다', '다이내믹 프로그래밍은 부분 문제의 해를 저장하기 위해 dp 테이블을 사용하므로 그리디보다 메모리를 더 많이 사용한다. 시간을 메모리로 교환하는 것이 DP의 특징이다.', false),
       (1216, 450, 'DP는 모든 경우를 고려하여 진짜 최적해를 찾지만 그리디는 지역 최적만 선택하여 실패할 수 있다', '다이내믹 프로그래밍은 모든 가능한 경우를 체계적으로 고려하여 전역 최적해를 보장한다. 반면 그리디는 지역적으로 최선인 선택만 하므로 특정 조건을 만족하지 않으면 최적해를 보장하지 못한다.', true),
       (1217, 450, '그리디가 DP보다 더 정확하다', 'DP가 그리디보다 더 정확하다. DP는 모든 경우를 고려하여 최적해를 보장하지만, 그리디는 지역 최적만 선택하므로 항상 최적해를 보장하지 않는다.', false),
       (1218, 450, 'DP가 더 빠르다', 'DP가 항상 더 빠른 것은 아니다. 그리디로 최적해를 구할 수 있는 문제라면 그리디가 더 빠르고 효율적이다. DP의 장점은 속도가 아니라 정확성 보장에 있다.', false),

       (1219, 451, '초기값 설정', '초기값 설정은 상태 정의 이후에 이루어지는 단계이다. 먼저 dp[i]가 무엇을 의미하는지 명확히 정의해야 적절한 초기값을 설정할 수 있다.', false),
       (1220, 451, '상태 정의', 'DP 문제 해결의 첫 단계는 dp[i]가 무엇을 의미하는지 정의하는 상태 정의이다. 상태가 명확히 정의되어야 점화식을 세우고 초기값을 설정하며 계산 순서를 결정할 수 있다.', true),
       (1221, 451, '코드 작성', '코드 작성은 상태 정의, 점화식, 초기값, 계산 순서가 모두 결정된 후에 하는 마지막 단계이다. 설계 없이 바로 코드를 작성하면 오류가 발생하기 쉽다.', false),
       (1222, 451, '계산 순서 정하기', '계산 순서는 점화식과 상태 정의가 명확해진 후에 결정한다. 어떤 순서로 dp 테이블을 채워나갈지는 상태와 전이 관계를 먼저 이해해야 정할 수 있다.', false),

       (1223, 452, '초기값을 설정하는 것', '초기값 설정은 점화식과는 별개의 단계이다. 점화식은 상태 간의 전이 관계를 정의하는 것이고, 초기값은 가장 작은 부분 문제의 해를 직접 설정하는 것이다.', false),
       (1224, 452, '상태 전이 관계를 정의하는 것', '점화식은 작은 문제의 해로부터 큰 문제의 해를 구하는 상태 전이 관계를 정의하는 것이다. 예를 들어 fib(n) = fib(n-1) + fib(n-2)는 이전 상태들과 현재 상태의 관계를 나타낸다.', true),
       (1225, 452, '문제를 이해하는 것', '문제 이해는 DP를 적용하기 전에 해야 하는 선행 단계이다. 점화식은 문제를 이해한 후 상태 간의 수학적 관계를 정의하는 단계이다.', false),
       (1226, 452, '코드를 작성하는 것', '코드 작성은 점화식을 포함한 모든 설계가 완료된 후의 구현 단계이다. 점화식은 코드를 작성하기 위한 설계 단계에서 수립하는 것이다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (143, 446, '5,five,다섯', 'fib(5) = fib(4) + fib(3)이다. fib(4) = 3이고 fib(3) = 2이므로, fib(5) = 3 + 2 = 5가 된다. 이는 피보나치 수열의 점화식을 순차적으로 적용한 결과이다.'),
       (144, 449, '4,four,4개,네개,네 개,넷', '20원을 만들기 위해 DP를 적용하면 5원 동전 4개(5×4=20)를 사용하는 것이 최소이다. C[20] = min(C[19]+1, C[15]+1, C[4]+1)를 계산하면 C[15]+1 = 3+1 = 4가 최솟값이 된다. 그리디로는 16원 1개, 1원 4개로 5개가 필요하지만 DP는 진짜 최소인 4개를 찾는다.');

-- =====================================================
-- Lesson 73: 다이내믹 프로그래밍 접근법 문제집
-- =====================================================

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (453, 73, '아래 제시한 개념에 대한 설명으로 옳은 것은?', 'Bottom-Up은 DP의 구현 방식 중 하나이다.', 'OBJECTIVE'),
       (454, 73, '빈칸에 들어갈 알맞은 말을 작성하시오', 'Top-Down 방식은 ___를 사용하여 dp[n]의 값을 찾기 위해 위에서부터 호출을 시작한다.', 'SUBJECTIVE'),
       (455, 73, '제시된 내용과 관련하여 옳은 것은?', 'Top-Down은 재귀를 활용한다.', 'OBJECTIVE'),
       (456, 73, '제시된 내용과 관련하여 옳은 것은?', '두 방식은 계산 순서가 다르다.', 'OBJECTIVE'),
       (457, 73, '빈칸에 들어갈 알맞은 말을 작성하시오', 'Bottom-Up 방식은 ___라고도 하며 테이블에 저장된 값에 직접 접근하여 재활용한다.', 'SUBJECTIVE'),
       (458, 73, '제시된 내용과 관련하여 옳은 것은?', 'DP는 체계적인 접근이 필요하다.', 'OBJECTIVE'),
       (459, 73, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '초기값은 DP의 시작점이다.', 'OBJECTIVE'),
       (460, 73, '제시된 내용과 관련하여 옳은 것은?', 'DP는 특정 조건을 만족하는 문제에 적합하다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (1227, 453, '위에서부터 재귀 호출을 시작한다', '위에서부터 재귀 호출을 시작하는 것은 Top-Down 방식의 특징이다. Bottom-Up은 재귀를 사용하지 않고 반복문으로 아래에서부터 계산한다.', false),
       (1228, 453, '메모이제이션을 사용한다', '메모이제이션은 재귀 호출에서 중복 계산을 방지하기 위해 사용하는 기법으로, Top-Down 방식의 특징이다. Bottom-Up은 반복문으로 테이블을 채워나간다.', false),
       (1229, 453, '재귀 함수를 사용한다', '재귀 함수는 Top-Down 방식에서 사용하는 구현 기법이다. Bottom-Up은 반복문(for, while)을 사용하여 작은 문제부터 순차적으로 계산해나간다.', false),
       (1230, 453, '아래에서부터 계산을 수행하고 누적시켜 전체 문제를 해결하며 dp[0]에서 시작해 점화식을 통해 dp[n]까지 값을 전이시킨다', 'Bottom-Up 방식은 가장 작은 부분 문제(dp[0])부터 시작하여 반복문으로 점화식을 적용하면서 순차적으로 dp 테이블을 채워나간다. 재귀 호출 없이 반복문만 사용하므로 스택 오버플로우 위험이 없고 구현이 명확하다.', true),

       (1231, 455, '아래에서부터 계산한다', '아래에서부터 계산하는 것은 Bottom-Up 방식의 특징이다. Top-Down은 큰 문제(dp[n])에서 시작하여 재귀적으로 작은 문제로 내려간다.', false),
       (1232, 455, 'dp[n]의 값을 찾기 위해 위에서부터 호출을 시작하고 dp[0]까지 내려간 다음 결과값을 재귀를 통해 전이시켜 재활용하며 메모리에 저장된 내역을 꺼내서 사용한다', 'Top-Down 방식은 dp[n]을 구하기 위해 재귀적으로 호출하여 기저 사례(dp[0])까지 내려간다. 계산된 값은 메모리에 저장(메모이제이션)하여, 같은 값이 다시 필요할 때 재계산 없이 저장된 값을 재사용한다.', true),
       (1233, 455, '반복문만 사용한다', '반복문만 사용하는 것은 Bottom-Up 방식의 특징이다. Top-Down은 재귀 함수와 메모이제이션을 사용하여 구현한다.', false),
       (1234, 455, '테이블을 사용하지 않는다', 'Top-Down도 계산된 값을 저장하기 위해 메모리(테이블)를 사용한다. 다만 Bottom-Up은 테이블에 직접 접근(Tabulation)하고, Top-Down은 재귀 중에 메모이제이션한다는 차이가 있다.', false),

       (1235, 456, 'Bottom-Up이 항상 더 빠르다', '두 방식의 속도는 상황에 따라 다르다. Bottom-Up은 재귀 오버헤드가 없지만, Top-Down은 필요한 부분 문제만 계산하므로 경우에 따라 더 효율적일 수 있다.', false),
       (1236, 456, 'Bottom-Up은 아래에서부터 계산하고 Top-Down은 위에서부터 재귀 호출하며 Bottom-Up은 테이블에 직접 접근하고 Top-Down은 메모이제이션을 사용한다', 'Bottom-Up은 작은 문제부터 반복문으로 순차 계산하여 테이블을 채우고(Tabulation), Top-Down은 큰 문제에서 재귀 호출로 내려가며 메모이제이션으로 중복을 제거한다. 계산 방향과 구현 방법이 근본적으로 다르다.', true),
       (1237, 456, 'Top-Down은 반복문만 사용한다', 'Top-Down은 재귀 함수를 사용하는 방식이다. 반복문만 사용하는 것은 Bottom-Up의 특징이다.', false),
       (1238, 456, '두 방식은 완전히 동일하다', '두 방식은 최종 결과는 같지만 계산 순서(Bottom-Up: 아래→위, Top-Down: 위→아래)와 구현 방법(반복문 vs 재귀)이 다르다.', false),

       (1239, 458, '점화식 → 초기값 → 상태 정의', '순서가 잘못되었다. 상태를 먼저 정의해야 점화식을 세울 수 있고, 점화식이 있어야 초기값을 설정할 수 있다.', false),
       (1240, 458, '상태 정의 → 점화식 세우기 → 초기값 설정 → 계산 순서 정하기', 'DP 문제 해결은 (1) 상태 정의(dp[i]가 무엇인지), (2) 점화식 세우기(상태 전이 관계), (3) 초기값 설정(base case), (4) 계산 순서 정하기의 체계적인 단계로 진행된다.', true),
       (1241, 458, '계산 순서 정하기 → 상태 정의 → 점화식', '순서가 잘못되었다. 상태를 정의하지 않고는 어떤 순서로 계산할지 결정할 수 없다. 상태 정의가 가장 먼저 이루어져야 한다.', false),
       (1242, 458, '초기값 설정 → 상태 정의 → 계산 순서 정하기', '순서가 잘못되었다. 상태가 정의되지 않은 상태에서 초기값을 설정할 수 없다. 상태 정의가 첫 번째 단계이다.', false),

       (1243, 459, '계산 순서를 정하는 것', '계산 순서 결정은 초기값 설정 이후의 단계이다. 초기값은 가장 작은 부분 문제의 해를 직접 지정하는 것으로, 계산 순서와는 다른 개념이다.', false),
       (1244, 459, 'Base Case를 설정하는 것', '초기값 설정은 재귀나 점화식의 기저 사례(Base Case)를 설정하는 것이다. 예를 들어 피보나치의 fib(0) = 0, fib(1) = 1과 같이 직접 계산하지 않고 알 수 있는 가장 작은 문제의 해를 지정한다.', true),
       (1245, 459, '점화식을 세우는 것', '점화식은 상태 전이 관계를 정의하는 것으로, 초기값과는 별개의 단계이다. 점화식은 작은 문제의 해로 큰 문제를 푸는 방법이고, 초기값은 가장 작은 문제의 해이다.', false),
       (1246, 459, '상태를 정의하는 것', '상태 정의는 초기값 설정 이전 단계이다. dp[i]가 무엇을 의미하는지 먼저 정의해야 적절한 초기값을 설정할 수 있다.', false),

       (1247, 460, '탐욕 선택 속성을 만족하는 문제', '탐욕 선택 속성(greedy choice property)을 만족하는 문제는 그리디 알고리즘으로 해결할 수 있다. DP는 최적 부분 구조와 부분 문제의 중복이 필요하다.', false),
       (1248, 460, '최적 부분 구조와 부분 문제의 중복을 만족하는 문제', '다이내믹 프로그래밍은 (1) 최적 부분 구조: 큰 문제의 최적해가 작은 문제의 최적해로 구성될 수 있고, (2) 부분 문제의 중복: 같은 부분 문제가 여러 번 계산되는 두 조건을 만족하는 문제에 적합하다.', true),
       (1249, 460, '정렬만 필요한 문제', '정렬만으로 해결되는 문제는 정렬 알고리즘을 사용하면 되므로 DP가 필요하지 않다. DP는 최적 부분 구조와 중복 부분 문제가 있는 최적화 문제에 사용된다.', false),
       (1250, 460, '백트래킹이 필요한 문제', '백트래킹은 제약 조건을 만족하는 해를 찾는 탐색 기법이다. DP와는 다른 문제 유형에 적용되며, DP의 적용 조건과는 거리가 있다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (145, 454, '재귀,Recursion,메모이제이션,Memoization,recursion,memoization,재귀함수,재귀 함수', 'Top-Down 방식은 재귀(Recursion)와 메모이제이션(Memoization)을 사용하여 큰 문제(dp[n])에서 시작해 재귀적으로 작은 문제를 호출한다. 계산된 값은 메모리에 저장하여 같은 문제가 다시 호출될 때 재계산하지 않고 저장된 값을 반환한다.'),
       (146, 457, 'Tabulation,타뷸레이션,tabulation,테이블화,타불레이션', 'Bottom-Up 방식은 Tabulation이라고도 불린다. 작은 문제부터 시작하여 반복문으로 dp 테이블을 순차적으로 채워나가며, 이미 계산된 테이블의 값에 직접 접근하여 재활용한다. 재귀 없이 구현되므로 스택 오버플로우 위험이 없다.');
