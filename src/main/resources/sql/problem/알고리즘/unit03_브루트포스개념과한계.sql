-- Unit: 브루트 포스 개념과 한계 (Unit ID: 13)
-- Chapter: 알고리즘 (Chapter ID: 2)

-- Lesson 생성
INSERT INTO lesson (id, unit_id, title)
VALUES (36, 13, '브루트 포스 기초 문제집'),
       (37, 13, '브루트 포스 구현 문제집'),
       (38, 13, '브루트 포스 한계 문제집');

-- =====================================================
-- Lesson 36: 브루트 포스 기초 문제집
-- =====================================================

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (211, 36, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '브루트 포스는 문제 해결 방법 중 하나이다.', 'OBJECTIVE'),
       (212, 36, '빈칸에 들어갈 알맞은 말을 작성하시오', '브루트 포스는 가능한 ___를 탐색하면서 조건을 만족하는 해만 고르는 알고리즘이다.', 'SUBJECTIVE'),
       (213, 36, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '브루트 포스와 완전 탐색은 미세한 차이가 있다.', 'OBJECTIVE'),
       (214, 36, '제시된 내용과 관련하여 옳은 것은?', '브루트 포스는 특정한 장점을 가진다.', 'OBJECTIVE'),
       (215, 36, '빈칸에 들어갈 알맞은 말을 작성하시오', '브루트 포스는 모든 경우의 수를 탐색하기 때문에 ___를 보장한다.', 'SUBJECTIVE'),
       (216, 36, '제시된 내용과 관련하여 옳은 것은?', '브루트 포스는 단점도 가지고 있다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (561, 211, '가능한 모든 경우의 수를 탐색하면서 조건을 만족하는 해만 고르는 알고리즘이다',
        '브루트 포스는 가능한 모든 경우의 수를 탐색하면서 조건을 만족하는 해만 고르는 알고리즘이다. 완전 탐색이라고도 하며, 모든 가능성을 시도하여 문제를 해결한다.',
        true),
       (562, 211, '분할 정복 방식으로 문제를 해결한다',
        '이는 분할 정복 알고리즘의 특징이다. 브루트 포스는 모든 경우를 탐색한다.', false),
       (563, 211, '중복 계산을 제거하는 알고리즘이다',
        '이는 다이내믹 프로그래밍의 특징이다. 브루트 포스는 모든 경우를 탐색한다.', false),
       (564, 211, '최선의 선택만 고르는 알고리즘이다',
        '이는 그리디 알고리즘의 특징이다. 브루트 포스는 모든 경우의 수를 탐색한다.', false),

       (565, 213, '브루트 포스는 결과를 찾는 것에 중점을 두고 완전 탐색은 탐색에 중점을 둔다',
        '브루트 포스와 완전 탐색은 같은 의미로 쓰이기도 하지만 미세한 차이가 있다. 브루트 포스는 결과를 찾는 것에 중점을 두고, 완전 탐색은 탐색에 중점을 둔다.',
        true),
       (566, 213, '완전 탐색이 브루트 포스보다 항상 빠르다',
        '두 방법은 비슷한 개념이며 속도 차이가 있는 것이 아니다.', false),
       (567, 213, '브루트 포스와 완전 탐색은 완전히 다른 개념이다',
        '브루트 포스와 완전 탐색은 같은 의미로 쓰이기도 한다. 완전히 다른 개념은 아니다.', false),
       (568, 213, '브루트 포스는 백트래킹을 사용한다',
        '브루트 포스는 모든 경우를 탐색한다. 백트래킹은 가지치기를 통해 탐색을 줄인다.', false),

       (569, 214, '메모리 사용량이 매우 적다',
        '브루트 포스는 메모리 사용이 비효율적일 수 있다. 메모리 사용량이 적지 않다.', false),
       (570, 214, '알고리즘의 설계와 구현이 간단하다',
        '브루트 포스의 장점은 알고리즘의 설계와 구현이 간단하고, 모든 경우의 수를 탐색하기 때문에 해를 보장한다는 것이다. 직관적이고 이해하기 쉽다.',
        true),
       (571, 214, '시간이 매우 빠르다',
        '브루트 포스는 모든 경우를 탐색하므로 시간이 오래 걸린다. 빠르지 않다.', false),
       (572, 214, '항상 최적해를 빠르게 찾는다',
        '브루트 포스는 해를 보장하지만 빠르지 않다. 모든 경우를 탐색하므로 시간이 오래 걸린다.', false),

       (573, 216, '해를 보장하지 못한다',
        '브루트 포스는 모든 경우를 탐색하므로 해를 보장한다. 이는 장점이다.', false),
       (574, 216, '구현이 매우 복잡하다',
        '브루트 포스는 구현이 간단하다. 복잡하지 않다.', false),
       (575, 216, '메모리 사용량이 적다',
        '브루트 포스는 메모리 사용이 비효율적이다. 적지 않다.', false),
       (576, 216, '모든 경우의 수를 탐색하기 때문에 시간이 매우 오래 걸린다',
        '브루트 포스의 단점은 모든 경우의 수를 탐색하기 때문에 시간이 매우 오래 걸리고, 메모리 사용이 비효율적이라는 것이다. 입력 크기가 커지면 현실적으로 사용이 불가능해진다.',
        true);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (71, 212, '모든 경우의 수,모든 경우,경우의 수,전체 경우,all cases',
        '브루트 포스는 가능한 모든 경우의 수를 탐색하면서 조건을 만족하는 해만 고르는 알고리즘이다. 완전 탐색이라고도 불린다.'),
       (72, 215, '해,정답,답,solution,answer',
        '브루트 포스는 모든 경우의 수를 탐색하기 때문에 해를 보장한다. 가능한 모든 경우를 시도하므로 반드시 답을 찾을 수 있다.');

-- =====================================================
-- Lesson 37: 브루트 포스 구현 문제집
-- =====================================================

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (217, 37, '제시된 내용과 관련하여 옳은 것은?', '브루트 포스는 반복문으로 구현할 수 있다.', 'OBJECTIVE'),
       (218, 37, '빈칸에 들어갈 알맞은 말을 작성하시오', '경우의 수가 단계적으로 늘어나거나 깊이 있는 탐색에서는 ___ 기반으로 브루트 포스를 구현한다.', 'SUBJECTIVE'),
       (219, 37, '제시된 내용과 관련하여 옳은 것은?', '재귀 기반 브루트 포스는 특정한 특징을 가진다.', 'OBJECTIVE'),
       (220, 37, '제시된 내용과 관련하여 옳은 것은?', '브루트 포스 구현 방법은 상황에 따라 선택한다.', 'OBJECTIVE'),
       (221, 37, '빈칸에 들어갈 알맞은 말을 작성하시오', '반복문 기반 브루트 포스는 주로 ___를 사용하여 구현한다.', 'SUBJECTIVE'),
       (222, 37, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '브루트 포스는 특정한 시간 복잡도를 가진다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (577, 217, '백트래킹을 구현할 때 주로 사용한다',
        '백트래킹은 재귀로 구현하는 것이 일반적이다. 반복문 기반은 단순한 경우에 사용한다.', false),
       (578, 217, '메모리를 전혀 사용하지 않는다',
        '반복문도 변수 등을 통해 메모리를 사용한다.', false),
       (579, 217, '경우의 수가 무한정 늘어날 때 사용한다',
        '경우의 수가 단계적으로 늘어나면 재귀를 사용한다. 반복문은 경우의 수가 일정할 때 사용한다.', false),
       (580, 217, '경우의 수가 일정하거나 단순할 때 사용한다',
        '반복문 기반 브루트 포스는 경우의 수가 일정하거나 단순할 때 사용한다. for문 등을 사용하여 모든 경우를 순차적으로 탐색한다. 구현이 직관적이고 이해하기 쉽다.',
        true),

       (581, 219, '메모리를 전혀 사용하지 않는다',
        '재귀는 호출 스택에 메모리를 사용한다.', false),
       (582, 219, '경우의 수가 일정할 때만 사용한다',
        '경우의 수가 일정하면 반복문을 사용한다. 재귀는 경우의 수가 단계적으로 늘어날 때 사용한다.', false),
       (583, 219, '항상 반복문보다 빠르다',
        '재귀는 함수 호출 오버헤드가 있어 반복문보다 느릴 수 있다.', false),
       (584, 219, '경우의 수가 단계적으로 늘어나거나 깊이 있는 탐색에 적합하다',
        '재귀 기반 브루트 포스는 경우의 수가 단계적으로 늘어나거나 깊이 있는 탐색에서 사용한다. 함수 호출을 통해 상태를 저장하고 탐색하므로 복잡한 경우의 수를 다루기 좋다.',
        true),

       (585, 220, '항상 재귀를 사용한다',
        '상황에 따라 반복문을 사용하는 것이 더 적합할 수 있다.', false),
       (586, 220, '경우의 수가 일정하면 반복문을, 단계적으로 늘어나면 재귀를 사용한다',
        '브루트 포스 구현 방법은 경우의 수의 특성에 따라 선택한다. 경우의 수가 일정하거나 단순하면 반복문을, 단계적으로 늘어나거나 깊이 있는 탐색이면 재귀를 사용한다.',
        true),
       (587, 220, '항상 반복문을 사용한다',
        '상황에 따라 재귀를 사용하는 것이 더 적합할 수 있다.', false),
       (588, 220, '메모리가 적으면 재귀를, 많으면 반복문을 사용한다',
        '구현 방법은 경우의 수 특성에 따라 선택한다. 메모리만으로 결정하지 않는다.', false),

       (589, 222, '항상 O(n)이다',
        '브루트 포스의 시간 복잡도는 경우의 수에 따라 달라진다. 항상 O(n)은 아니다.', false),
       (590, 222, '항상 O(log n)이다',
        '브루트 포스는 모든 경우를 탐색하므로 O(log n)이 아니다.', false),
       (591, 222, '항상 O(1)이다',
        '브루트 포스는 모든 경우를 탐색하므로 O(1)이 아니다.', false),
       (592, 222, '모든 경우를 탐색하므로 O(경우의 수)이다',
        '브루트 포스는 모든 경우의 수를 탐색하므로 시간 복잡도는 O(경우의 수)이다. 경우의 수가 n개면 O(n), 2^n개면 O(2^n)이 된다. 입력 크기에 따라 지수적으로 증가할 수 있다.',
        true);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (73, 218, '재귀,recursion,재귀함수,recursive',
        '경우의 수가 단계적으로 늘어나거나 깊이 있는 탐색에서는 재귀 기반으로 브루트 포스를 구현한다. 재귀 함수를 사용하여 각 단계에서 가능한 모든 선택을 탐색한다.'),
       (74, 221, '반복문,for,while,loop,for문,while문',
        '반복문 기반 브루트 포스는 주로 for문이나 while문 등의 반복문을 사용하여 구현한다. 경우의 수가 일정하거나 단순할 때 사용한다.');

-- =====================================================
-- Lesson 38: 브루트 포스 한계 문제집
-- =====================================================

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (223, 38, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '브루트 포스는 명확한 한계를 가진다.', 'OBJECTIVE'),
       (224, 38, '빈칸에 들어갈 알맞은 말을 작성하시오', '브루트 포스의 한계를 극복하기 위해 필요한 부분만 선택적으로 확인하는 ___를 사용할 수 있다.', 'SUBJECTIVE'),
       (225, 38, '제시된 내용과 관련하여 옳은 것은?', '백트래킹은 브루트 포스를 개선한 기법이다.', 'OBJECTIVE'),
       (226, 38, '제시된 내용과 관련하여 옳은 것은?', '브루트 포스는 특정 상황에서 비효율적이다.', 'OBJECTIVE'),
       (227, 38, '빈칸에 들어갈 알맞은 말을 작성하시오', '백트래킹은 조건을 만족하지 않는 경로를 ___하여 탐색 효율을 높인다.', 'SUBJECTIVE'),
       (228, 38, '제시된 내용과 관련하여 옳은 것은?', '브루트 포스는 다양한 방법으로 개선할 수 있다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (593, 223, '메모리를 전혀 사용하지 않는다',
        '브루트 포스는 메모리를 사용한다. 공간적 비용이 크다.', false),
       (594, 223, '구현이 매우 복잡하다',
        '브루트 포스의 한계는 시간과 공간 비용이다. 구현이 복잡한 것은 아니다.', false),
       (595, 223, '모든 경우의 수를 탐색하기 때문에 시간적, 공간적 비용이 크다',
        '브루트 포스는 모든 경우의 수를 탐색하기 때문에 시간적, 공간적 비용이 크다. 경우의 수가 많아질수록 실행 시간이 기하급수적으로 증가하여 현실적으로 사용이 불가능해진다.',
        true),
       (596, 223, '항상 최적해를 빠르게 찾는다',
        '브루트 포스는 해를 보장하지만 빠르지 않다. 모든 경우를 탐색하므로 시간이 오래 걸린다.', false),

       (597, 225, '백트래킹과 브루트 포스는 완전히 동일하다',
        '백트래킹은 가지치기를 사용하지만 브루트 포스는 모든 경우를 탐색한다. 동일하지 않다.', false),
       (598, 225, '백트래킹은 해를 보장하지 못한다',
        '백트래킹도 모든 유효한 경로를 탐색하므로 해를 보장한다.', false),
       (599, 225, '백트래킹은 가지치기를 통해 해답이 아닌 경로를 제거하지만 브루트 포스는 모든 경로를 탐색한다',
        '백트래킹은 현재 상태가 조건을 만족하지 않으면 가지치기를 통해 해당 경로를 제거한다. 반면 브루트 포스는 가지치기 없이 모든 경우를 탐색한다. 백트래킹이 더 효율적이다.',
        true),
       (600, 225, '브루트 포스가 백트래킹보다 항상 빠르다',
        '백트래킹이 가지치기를 통해 탐색량을 줄이므로 더 빠르다.', false),

       (601, 226, '해가 하나만 존재하는 경우',
        '해의 개수는 브루트 포스의 효율성과 직접적인 관련이 없다. 경우의 수가 중요하다.', false),
       (602, 226, '입력 크기가 작은 경우',
        '입력 크기가 작으면 브루트 포스도 충분히 사용 가능하다.', false),
       (603, 226, '경우의 수가 매우 적은 경우',
        '경우의 수가 적으면 브루트 포스도 효율적으로 사용할 수 있다.', false),
       (604, 226, '경우의 수가 기하급수적으로 증가하는 경우',
        '브루트 포스는 경우의 수가 기하급수적으로 증가하는 경우(O(2^n), O(n!)) 비효율적이다. 입력 크기가 조금만 커져도 실행 시간이 급격히 증가하여 현실적으로 사용이 불가능해진다.',
        true),

       (605, 228, '무작위로 경우를 선택한다',
        '개선 방법은 체계적인 최적화 기법이다. 무작위 선택이 아니다.', false),
       (606, 228, '해를 찾지 않고 종료한다',
        '개선 방법도 해를 찾는 것을 목표로 한다. 해를 찾지 않는 것이 아니다.', false),
       (607, 228, '백트래킹, 그리디, 다이내믹 프로그래밍 등을 사용한다',
        '브루트 포스는 백트래킹(가지치기), 그리디(매 순간 최선 선택), 다이내믹 프로그래밍(중복 계산 제거) 등의 기법으로 개선할 수 있다. 상황에 맞는 최적화 기법을 선택하는 것이 중요하다.',
        true),
       (608, 228, '더 많은 경우의 수를 탐색한다',
        '개선 방법은 탐색량을 줄이는 것이다. 더 많이 탐색하는 것이 아니다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (75, 224, '백트래킹,backtracking,가지치기,pruning',
        '브루트 포스의 한계를 극복하기 위해 필요한 부분만 선택적으로 확인하는 백트래킹(backtracking)을 사용할 수 있다. 백트래킹은 조건을 만족하지 않는 경로를 가지치기하여 탐색 효율을 높인다.'),
       (76, 227, '가지치기,제거,pruning,삭제,cut',
        '백트래킹은 조건을 만족하지 않는 경로를 가지치기(pruning)하여 탐색 효율을 높인다. 유망하지 않은 노드를 제거함으로써 탐색량을 줄인다.');
