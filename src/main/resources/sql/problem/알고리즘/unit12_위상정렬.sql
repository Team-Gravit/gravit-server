-- Unit: 위상 정렬 (Unit ID: 22)
-- Chapter: 알고리즘 (Chapter ID: 2)

-- Lesson 생성
INSERT INTO lesson (id, unit_id, title)
VALUES (63, 22, '위상 정렬 기초 문제집'),
       (64, 22, '위상 정렬 응용 문제집');

-- =====================================================
-- Lesson 63: 위상 정렬 기초 문제집
-- =====================================================

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (373, 63, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '위상 정렬은 방향 그래프에서 사용되는 정렬 알고리즘이다.', 'OBJECTIVE'),
       (374, 63, '제시된 내용과 관련하여 옳은 것은?', '위상 정렬을 수행하기 위해서는 그래프가 특정 조건을 만족해야 한다.', 'OBJECTIVE'),
       (375, 63, '빈칸에 들어갈 알맞은 말을 작성하시오', '위상 정렬은 ___에서만 수행 가능하다. (사이클이 없는 방향 그래프)', 'SUBJECTIVE'),
       (376, 63, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '위상 정렬에서 진입 차수는 중요한 개념이다.', 'OBJECTIVE'),
       (377, 63, '빈칸에 들어갈 알맞은 말을 작성하시오', '큐를 이용한 위상 정렬 알고리즘을 ___라고 한다.', 'SUBJECTIVE'),
       (378, 63, '제시된 내용과 관련하여 옳은 것은?', 'V는 정점의 개수, E는 간선의 개수를 의미한다.', 'OBJECTIVE'),
       (379, 63, '제시된 내용과 관련하여 옳은 것은?', '위상 정렬은 여러 가지 특징을 가지고 있다.', 'OBJECTIVE'),
       (380, 63, '빈칸에 들어갈 알맞은 말을 작성하시오', '위상 정렬을 수행할 때 처음에 큐에 삽입하는 노드는 진입 차수가 ___인 노드이다.', 'SUBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (993, 373, '최단 경로를 찾는 알고리즘이다', '최단 경로 탐색은 다익스트라 등의 알고리즘이므로 오답이다.', false),
       (994, 373, '순서가 정해진 작업을 정렬하는 알고리즘이다', '위상 정렬은 순서가 정해져 있는 일련의 작업을 차례대로 수행해야 할 때 사용하므로 정답이다.', true),
       (995, 373, '배열을 오름차순으로 정렬하는 알고리즘이다', '위상 정렬은 작업 순서를 결정하는 알고리즘이므로 오답이다.', false),
       (996, 373, '가중치의 합을 최소화하는 알고리즘이다', '가중치 합 최소화는 최소 신장 트리의 목적이므로 오답이다.', false),

       (997, 374, '무방향 그래프', '무방향 그래프는 위상 정렬을 수행할 수 없으므로 오답이다.', false),
       (998, 374, '완전 그래프', '완전 그래프는 위상 정렬의 조건이 아니므로 오답이다.', false),
       (999, 374, '사이클이 없는 방향 그래프(DAG)', '위상 정렬은 DAG에서만 수행 가능하므로 정답이다.', true),
       (1000, 374, '사이클이 있는 방향 그래프', '사이클이 있으면 위상 정렬이 불가능하므로 오답이다.', false),

       (1001, 376, '노드가 가진 자식의 개수', '진입 차수는 간선의 개수를 의미하므로 오답이다.', false),
       (1002, 376, '특정 노드에서 나가는 간선의 개수', '이는 진출 차수에 대한 설명이므로 오답이다.', false),
       (1003, 376, '특정 노드로 들어오는 간선의 개수', '진입 차수는 특정 노드로 들어오는 간선의 개수를 의미하므로 정답이다.', true),
       (1004, 376, '노드의 총 간선 개수', '진입 차수는 들어오는 간선만 계산하므로 오답이다.', false),

       (1005, 378, 'O(V log V)', '위상 정렬의 시간 복잡도는 O(V + E)이므로 오답이다.', false),
       (1006, 378, 'O(E log V)', '이는 다익스트라 알고리즘의 시간 복잡도이므로 오답이다.', false),
       (1007, 378, 'O(V + E)', '위상 정렬의 시간 복잡도는 O(V + E)이므로 정답이다.', true),
       (1008, 378, 'O(V²)', '위상 정렬은 O(V²)보다 효율적이므로 오답이다.', false),

       (1009, 379, 'DFS 방식과 BFS 방식 두 가지로 구현 가능하다', '두 가지 구현 방법이 모두 가능하다.', true),
       (1010, 379, '여러 개의 해답이 존재할 수 있다', '진입 차수가 0인 노드가 여러 개면 여러 가지 답이 존재하므로 오답이다.', false),
       (1011, 379, '무방향 그래프에서도 사용 가능하다', '위상 정렬은 DAG에서만 사용 가능하므로 오답이다.', false),
       (1012, 379, '사이클 탐지가 가능하다', '위상 정렬을 통해 사이클 존재 여부를 확인할 수 있으므로 오답이다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (125, 375, 'dag,사이클이 없는 방향 그래프,directed acyclic graph,비순환 방향 그래프',
        '위상 정렬은 DAG(Directed Acyclic Graph, 사이클이 없는 방향 그래프)에서만 수행 가능하다. 사이클이 존재하면 작업의 순서를 명확하게 결정할 수 없기 때문이다.'),
       (126, 377, 'kahn''s algorithm,칸 알고리즘,kahn algorithm,kahn,칸',
        '큐를 이용한 위상 정렬 알고리즘을 Kahn''s Algorithm(칸 알고리즘)이라고 한다. 진입 차수가 0인 노드를 큐에 넣고, 해당 노드와 연결된 간선을 제거하며 위상 정렬을 수행한다.'),
       (127, 380, '0,zero,제로',
        '위상 정렬을 수행할 때 처음에 큐에 삽입하는 노드는 진입 차수가 0인 노드이다. 진입 차수가 0이라는 것은 해당 노드가 다른 노드에 의존하지 않음을 의미하므로, 가장 먼저 수행할 수 있는 작업이다.');

-- =====================================================
-- Lesson 64: 위상 정렬 응용 문제집
-- =====================================================

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (381, 64, '제시된 내용과 관련하여 옳은 것은?', '위상 정렬은 다양한 분야에서 활용된다.', 'OBJECTIVE'),
       (382, 64, '제시된 내용과 관련하여 옳은 것은?', '위상 정렬을 이용하면 사이클 존재 여부를 확인할 수 있다.', 'OBJECTIVE'),
       (383, 64, '아래 제시한 개념에 대한 설명으로 옳은 것은?', 'Kahn''s Algorithm은 특정 자료구조를 사용한다.', 'OBJECTIVE'),
       (384, 64, '제시된 내용과 관련하여 옳은 것은?', '위상 정렬 결과가 여러 개 나올 수 있는 이유는 진입 차수가 0인 노드가 동시에 여러 개 존재할 수 있기 때문이다.', 'OBJECTIVE'),
       (385, 64, '빈칸에 들어갈 알맞은 말을 작성하시오', '위상 정렬을 수행한 후 모든 노드를 방문하지 못했다면 그래프에 ___이 존재한다는 의미이다.', 'SUBJECTIVE'),
       (386, 64, '아래 제시한 개념에 대한 설명으로 옳은 것은?', 'DFS 방식의 위상 정렬은 스택을 활용한다.', 'OBJECTIVE'),
       (387, 64, '제시된 내용과 관련하여 옳은 것은?', '위상 정렬은 여러 가지 장점을 가지고 있다.', 'OBJECTIVE'),
       (388, 64, '제시된 내용과 관련하여 옳은 것은?', '위상 정렬은 단점도 가지고 있다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (1013, 381, '빌드 시스템 의존성 해결', '빌드 시스템 의존성은 위상 정렬의 활용 사례이므로 오답이다.', false),
       (1014, 381, '최단 경로 탐색', '최단 경로 탐색은 위상 정렬의 활용 사례가 아니므로 정답이다.', true),
       (1015, 381, '작업 스케줄링', '작업 스케줄링은 위상 정렬의 활용 사례이므로 오답이다.', false),
       (1016, 381, '선수과목 순서 결정', '선수과목 순서는 위상 정렬의 대표적인 활용 사례이므로 오답이다.', false),

       (1017, 382, '진입 차수가 0인 노드가 없는 경우', '진입 차수가 0인 노드가 없으면 사이클이 존재할 가능성이 있으나 충분조건은 아니므로 오답이다.', false),
       (1018, 382, '진출 차수가 0인 노드가 여러 개인 경우', '진출 차수는 사이클 탐지와 직접적인 관련이 없으므로 오답이다.', false),
       (1019, 382, '간선의 개수가 정점보다 많은 경우', '간선 개수만으로는 사이클을 판단할 수 없으므로 오답이다.', false),
       (1020, 382, '모든 노드를 방문하지 못한 경우', '위상 정렬 후 모든 노드를 방문하지 못했다면 사이클이 존재하므로 정답이다.', true),

       (1021, 383, '덱(Deque)', '덱은 위상 정렬의 기본 자료구조가 아니므로 오답이다.', false),
       (1022, 383, '스택(Stack)', '스택은 DFS 방식 위상 정렬에서 사용되므로 오답이다.', false),
       (1023, 383, '큐(Queue)', 'Kahn''s Algorithm은 큐를 사용하여 진입 차수가 0인 노드를 관리하므로 정답이다.', true),
       (1024, 383, '우선순위 큐(Priority Queue)', '위상 정렬에서 우선순위 큐는 필수가 아니므로 오답이다.', false),

       (1025, 384, '올바르지 않다', '해당 설명은 올바르므로 오답이다.', false),
       (1026, 384, '올바르다', '진입 차수가 0인 노드가 여러 개면 선택 순서에 따라 여러 답이 나오므로 정답이다.', true),

       (1027, 386, '진입 차수를 계산하여 사용한다', '진입 차수 계산은 BFS 방식의 특징이므로 오답이다.', false),
       (1028, 386, '큐를 사용하여 구현한다', '큐 사용은 BFS 방식의 특징이므로 오답이다.', false),
       (1029, 386, '스택을 역순으로 pop하여 결과를 생성한다', 'DFS 방식은 스택에 노드를 추가한 후 역순으로 pop하여 위상 정렬 결과를 얻으므로 정답이다.', true),
       (1030, 386, '진입 차수가 0인 노드부터 처리한다', '이는 BFS 방식의 특징이므로 오답이다.', false),

       (1031, 387, '모든 그래프에 적용 가능하다', '위상 정렬은 DAG에만 적용 가능하므로 오답이다.', false),
       (1032, 387, '그래프 변경 시 부분 수정이 가능하다', '그래프 변경 시 처음부터 다시 계산해야 하므로 오답이다.', false),
       (1033, 387, '선형 시간 복잡도로 효율적이다', '위상 정렬은 O(V + E)의 선형 시간 복잡도로 효율적이므로 정답이다.', true),
       (1034, 387, '항상 유일한 답을 보장한다', '위상 정렬은 여러 개의 답이 나올 수 있으므로 오답이다.', false),

       (1035, 388, '그래프 변경 시 부분 수정이 가능하다', '그래프 변경 시 처음부터 다시 계산해야 하므로 오답이다.', false),
       (1036, 388, 'DAG에만 적용 가능하다', '위상 정렬은 DAG에만 적용 가능하므로 정답이다.', true),
       (1037, 388, '추가 메모리가 필요 없다', '위상 정렬은 큐나 스택 등 추가 메모리가 필요하므로 오답이다.', false),
       (1038, 388, '항상 유일한 답을 제공한다', '위상 정렬은 여러 개의 답이 나올 수 있으므로 오답이다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (128, 385, '사이클,cycle,순환',
        '위상 정렬을 수행한 후 모든 노드를 방문하지 못했다면 그래프에 사이클이 존재한다는 의미이다. 사이클이 있으면 작업 간에 순환 의존성이 발생하여 올바른 순서를 결정할 수 없다.');
