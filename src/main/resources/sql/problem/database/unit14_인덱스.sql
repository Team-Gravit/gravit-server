-- Chapter: 데이터베이스 (id: 4), Unit: 인덱스 (id: 55)

-- Lesson 1: 인덱스 기초 (ID: 161)
INSERT INTO lesson (id, title, unit_id)
VALUES (161, '인덱스 기초', 55);

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (1118, 161, '다음 중 인덱스(Index)에 대한 설명으로 올바른 것은?', '인덱스는 데이터 검색 속도를 향상시키는 데이터베이스 객체이다.', 'OBJECTIVE'),
       (1119, 161, '빈칸에 들어갈 키워드를 작성하시오.', '___ INDEX idx_name ON students(name); -- 인덱스 생성', 'SUBJECTIVE'),
       (1120, 161, '다음 중 인덱스의 장점으로 올바르지 않은 것은?', '인덱스는 조회 성능을 향상시키지만 단점도 있다.', 'OBJECTIVE'),
       (1121, 161, '다음 SQL 명령어의 역할은?', 'CREATE INDEX idx_student_name ON students(name);', 'OBJECTIVE'),
       (1122, 161, '빈칸에 들어갈 용어를 작성하시오.', '인덱스는 책의 ___와 같은 역할을 한다.', 'SUBJECTIVE'),
       (1123, 161, '다음 중 인덱스가 필요한 경우로 올바른 것은?', '인덱스는 적절한 상황에서 사용해야 효과적이다.', 'OBJECTIVE'),
       (1124, 161, '다음 중 인덱스의 단점으로 올바른 것은?', '인덱스는 장점과 함께 단점도 고려해야 한다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES
-- 문제 1118
(3183, 1118, '인덱스는 데이터를 물리적으로 저장한다', '인덱스는 데이터의 위치 정보를 저장한다.', false),
(3184, 1118, '인덱스는 검색 속도를 향상시키기 위한 별도의 자료구조이다', '인덱스는 테이블의 검색 속도를 높이기 위해 컬럼 값과 해당 레코드의 주소를 키-값 쌍으로 저장하는 자료구조이다.', true),
(3185, 1118, '인덱스는 모든 쿼리의 성능을 향상시킨다', '인덱스는 조회 성능은 향상시키지만 삽입, 수정, 삭제 성능은 저하시킬 수 있다.', false),
(3186, 1118, '인덱스는 테이블과 동일한 개념이다', '인덱스와 테이블은 서로 다른 객체이다.', false),

-- 문제 1120
(3187, 1120, '검색 속도가 향상된다', '인덱스의 주요 장점이다.', false),
(3188, 1120, 'WHERE 절의 조회 성능이 개선된다', '인덱스는 조건 검색 성능을 향상시킨다.', false),
(3189, 1120, 'ORDER BY 성능이 향상된다', '인덱스는 정렬된 상태로 저장되어 ORDER BY 성능이 향상된다.', false),
(3190, 1120, '데이터 삽입 속도가 향상된다', '인덱스는 삽입 시 인덱스도 업데이트해야 하므로 삽입 속도가 저하된다. 이것은 단점이다.', true),

-- 문제 1121
(3191, 1121, 'students 테이블의 name 컬럼에 인덱스를 생성한다', 'CREATE INDEX로 name 컬럼에 idx_student_name이라는 인덱스를 생성한다. 이름으로 검색하는 쿼리의 성능이 향상된다.', true),
(3192, 1121, 'students 테이블을 삭제한다', 'DROP TABLE이 테이블을 삭제한다.', false),
(3193, 1121, 'name 컬럼을 삭제한다', 'ALTER TABLE ... DROP COLUMN이 컬럼을 삭제한다.', false),
(3194, 1121, 'students 테이블의 데이터를 조회한다', 'SELECT가 데이터를 조회한다.', false),

-- 문제 1123
(3195, 1123, '테이블의 데이터가 매우 적을 때', '데이터가 적으면 인덱스 효과가 미미하다.', false),
(3196, 1123, 'WHERE 절에서 자주 사용되는 컬럼일 때', 'WHERE 절에서 자주 조회되는 컬럼에 인덱스를 생성하면 검색 성능이 크게 향상된다.', true),
(3197, 1123, '데이터 수정이 매우 빈번한 컬럼일 때', '수정이 빈번하면 인덱스 유지 비용이 크다.', false),
(3198, 1123, '모든 컬럼에 인덱스를 생성할 때', '불필요한 인덱스는 성능을 저하시킨다.', false),

-- 문제 1124
(3199, 1124, '조회 성능이 향상된다', '이것은 장점이다.', false),
(3200, 1124, '추가 저장 공간이 필요하다', '인덱스는 별도의 저장 공간을 차지한다. 테이블 크기의 약 10% 정도의 추가 공간이 필요하다.', true),
(3201, 1124, '정렬 성능이 향상된다', '이것은 장점이다.', false),
(3202, 1124, '검색 속도가 빨라진다', '이것은 장점이다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (321, 1119, 'create', 'CREATE INDEX 문으로 인덱스를 생성한다. CREATE INDEX 인덱스명 ON 테이블명(컬럼명) 형식으로 작성한다.'),
       (322, 1122, '목차,색인,책갈피,목록', '인덱스는 책의 목차나 색인과 같은 역할을 한다. 원하는 내용을 빠르게 찾을 수 있도록 돕는다.');


-- Lesson 2: 인덱스 종류 (ID: 162)
INSERT INTO lesson (id, title, unit_id)
VALUES (162, '인덱스 종류', 55);

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (1125, 162, '다음 중 클러스터형 인덱스(Clustered Index)의 특징으로 올바른 것은?', '클러스터형 인덱스는 데이터의 물리적 정렬과 관련이 있다.', 'OBJECTIVE'),
       (1126, 162, '빈칸에 들어갈 용어를 작성하시오.', '테이블당 ___개의 클러스터형 인덱스만 생성할 수 있다.', 'SUBJECTIVE'),
       (1127, 162, '다음 중 비클러스터형 인덱스(Non-Clustered Index)의 특징으로 올바른 것은?', '비클러스터형 인덱스는 별도의 인덱스 공간을 사용한다.', 'OBJECTIVE'),
       (1128, 162, '다음 SQL 명령어의 역할은?', 'CREATE UNIQUE INDEX idx_email ON users(email);', 'OBJECTIVE'),
       (1129, 162, '빈칸에 들어갈 키워드를 작성하시오.', 'CREATE ___ INDEX idx_unique_id ON students(student_id); -- 중복 불가 인덱스', 'SUBJECTIVE'),
       (1130, 162, '다음 중 복합 인덱스(Composite Index)에 대한 설명으로 올바른 것은?', '복합 인덱스는 여러 컬럼을 조합한 인덱스이다.', 'OBJECTIVE'),
       (1131, 162, '다음 SQL 명령어의 역할은?', 'CREATE INDEX idx_name_grade ON students(name, grade);', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES
-- 문제 1125
(3203, 1125, '테이블당 여러 개 생성할 수 있다', '클러스터형 인덱스는 테이블당 하나만 생성 가능하다.', false),
(3204, 1125, '데이터가 인덱스 키 순서대로 물리적으로 정렬된다', '클러스터형 인덱스는 테이블 데이터를 인덱스 키 순서대로 물리적으로 정렬하여 저장한다. 일반적으로 기본키에 자동 생성된다.', true),
(3205, 1125, '별도의 인덱스 공간이 필요하다', '비클러스터형 인덱스의 특징이다.', false),
(3206, 1125, '검색 속도가 비클러스터형보다 느리다', '클러스터형 인덱스가 일반적으로 더 빠르다.', false),

-- 문제 1127
(3207, 1127, '데이터를 물리적으로 정렬한다', '클러스터형 인덱스의 특징이다.', false),
(3208, 1127, '별도의 인덱스 페이지에 인덱스 정보를 저장한다', '비클러스터형 인덱스는 데이터와 별도로 인덱스 정보를 저장한다. 테이블당 여러 개 생성 가능하다.', true),
(3209, 1127, '테이블당 하나만 생성할 수 있다', '비클러스터형 인덱스는 여러 개 생성 가능하다.', false),
(3210, 1127, '자동으로 생성된다', '명시적으로 생성해야 한다.', false),

-- 문제 1128
(3211, 1128, 'users 테이블의 email 컬럼에 중복을 허용하지 않는 인덱스를 생성한다', 'UNIQUE INDEX는 중복 값을 허용하지 않는 인덱스이다. email 컬럼에 동일한 값이 들어갈 수 없다.', true),
(3212, 1128, 'email 컬럼을 삭제한다', 'ALTER TABLE ... DROP COLUMN이 컬럼을 삭제한다.', false),
(3213, 1128, 'users 테이블을 생성한다', 'CREATE TABLE이 테이블을 생성한다.', false),
(3214, 1128, '중복된 email을 조회한다', 'SELECT가 데이터를 조회한다.', false),

-- 문제 1130
(3215, 1130, '하나의 컬럼만 사용하는 인덱스이다', '복합 인덱스는 여러 컬럼을 사용한다.', false),
(3216, 1130, '두 개 이상의 컬럼을 조합하여 생성하는 인덱스이다', '복합 인덱스는 여러 컬럼을 조합하여 만든다. 컬럼 순서가 중요하며, 첫 번째 컬럼부터 순서대로 사용해야 인덱스가 효과적이다.', true),
(3217, 1130, '자동으로 생성된다', '명시적으로 생성해야 한다.', false),
(3218, 1130, '성능에 도움이 되지 않는다', '적절히 사용하면 성능이 향상된다.', false),

-- 문제 1131
(3219, 1131, 'name 컬럼에만 인덱스를 생성한다', 'name과 grade 두 컬럼에 복합 인덱스를 생성한다.', false),
(3220, 1131, 'name과 grade 컬럼을 조합한 복합 인덱스를 생성한다', 'name과 grade를 조합한 복합 인덱스를 생성한다. name으로 검색하거나 name과 grade로 함께 검색할 때 효과적이다.', true),
(3221, 1131, '두 개의 별도 인덱스를 생성한다', '하나의 복합 인덱스를 생성한다.', false),
(3222, 1131, '테이블을 생성한다', 'CREATE INDEX는 인덱스를 생성한다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (323, 1126, '1,하나,한', '클러스터형 인덱스는 데이터를 물리적으로 정렬하므로 테이블당 하나만 생성할 수 있다. 일반적으로 기본키에 자동 생성된다.'),
       (324, 1129, 'unique', 'UNIQUE INDEX는 중복 값을 허용하지 않는 인덱스이다. 해당 컬럼에 동일한 값이 들어갈 수 없다.');


-- Lesson 3: 인덱스 최적화 (ID: 163)
INSERT INTO lesson (id, title, unit_id)
VALUES (163, '인덱스 최적화', 55);

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (1132, 163, '다음 중 인덱스가 사용되지 않는 경우는?', '특정 상황에서는 인덱스가 무시될 수 있다.', 'OBJECTIVE'),
       (1133, 163, '빈칸에 들어갈 키워드를 작성하시오.', '___ INDEX idx_name; -- 인덱스 삭제', 'SUBJECTIVE'),
       (1134, 163, '다음 중 복합 인덱스 사용 시 주의사항으로 올바른 것은?', '복합 인덱스는 컬럼 순서가 중요하다.', 'OBJECTIVE'),
       (1135, 163, '다음 SQL 쿼리에서 인덱스가 사용되지 않는 이유는?', 'CREATE INDEX idx_name ON students(name);\nSELECT * FROM students WHERE UPPER(name) = ''홍길동'';', 'OBJECTIVE'),
       (1136, 163, '빈칸에 들어갈 용어를 작성하시오.', '인덱스를 사용하지 않고 테이블 전체를 읽는 것을 ___라고 한다.', 'SUBJECTIVE'),
       (1137, 163, '다음 중 인덱스 성능을 저하시키는 요인으로 올바른 것은?', '인덱스도 관리가 필요하다.', 'OBJECTIVE'),
       (1138, 163, '다음 중 인덱스 설계 시 고려사항으로 올바르지 않은 것은?', '인덱스는 신중하게 설계해야 한다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES
-- 문제 1132
(3223, 1132, 'WHERE name = ''홍길동''', '인덱스가 있으면 사용된다.', false),
(3224, 1132, 'WHERE id = 100', '기본키 인덱스가 사용된다.', false),
(3225, 1132, 'WHERE YEAR(birth_date) = 2000', '컬럼에 함수를 적용하면 인덱스를 사용할 수 없다. birth_date 컬럼에 인덱스가 있어도 YEAR 함수로 인해 무시된다.', true),
(3226, 1132, 'WHERE age > 20', '인덱스가 있으면 사용될 수 있다.', false),

-- 문제 1134
(3227, 1134, '컬럼 순서는 중요하지 않다', '복합 인덱스는 컬럼 순서가 매우 중요하다.', false),
(3228, 1134, '마지막 컬럼만 사용해도 된다', '첫 번째 컬럼부터 순서대로 사용해야 한다.', false),
(3229, 1134, '복합 인덱스는 성능에 도움이 되지 않는다', '적절히 사용하면 성능이 크게 향상된다.', false),
(3230, 1134, '첫 번째 컬럼부터 순서대로 사용해야 인덱스가 효과적이다', '복합 인덱스 (A, B, C)는 A, A+B, A+B+C 조건에서 사용되지만 B, C만 사용하면 인덱스가 효과적이지 않다. 첫 번째 컬럼이 포함되어야 한다.', true),

-- 문제 1135
(3231, 1135, '컬럼에 함수를 적용하여 인덱스를 사용할 수 없어서', 'UPPER 함수를 name 컬럼에 적용하면 인덱스를 사용할 수 없다. WHERE name = ''홍길동'' 형태로 작성해야 인덱스가 사용된다.', true),
(3232, 1135, 'name 컬럼에 인덱스가 없어서', '인덱스는 생성되어 있다.', false),
(3233, 1135, 'SELECT *를 사용해서', 'SELECT *는 인덱스 사용 여부와 무관하다.', false),
(3234, 1135, '데이터가 너무 많아서', '데이터 양은 이 경우와 무관하다.', false),

-- 문제 1137
(3235, 1137, '인덱스를 자주 생성한다', '적절한 인덱스 생성은 성능을 향상시킨다.', false),
(3236, 1137, '데이터 수정이 빈번하여 인덱스 재구성이 자주 발생한다', '데이터 삽입, 수정, 삭제가 빈번하면 인덱스도 함께 업데이트되어야 하므로 성능이 저하된다. 단편화도 발생할 수 있다.', true),
(3237, 1137, 'WHERE 절을 사용한다', 'WHERE 절은 인덱스 사용을 유도한다.', false),
(3238, 1137, '적은 양의 데이터를 저장한다', '데이터가 적으면 인덱스 효과가 미미할 뿐이다.', false),

-- 문제 1138
(3239, 1138, 'WHERE 절에 자주 사용되는 컬럼에 인덱스를 생성한다', '올바른 설계 원칙이다.', false),
(3240, 1138, '카디널리티가 높은 컬럼에 인덱스를 생성한다', '중복도가 낮은 컬럼이 인덱스 효과가 좋다.', false),
(3241, 1138, '모든 컬럼에 인덱스를 생성한다', '불필요한 인덱스는 저장 공간을 낭비하고 DML 성능을 저하시킨다. 필요한 컬럼에만 선택적으로 생성해야 한다.', true),
(3242, 1138, '데이터 수정이 적은 컬럼에 인덱스를 생성한다', '올바른 설계 원칙이다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (325, 1133, 'drop', 'DROP INDEX 문으로 인덱스를 삭제한다. DROP INDEX 인덱스명 형식으로 작성한다.'),
       (326, 1136, '풀 테이블 스캔,full table scan,전체 테이블 스캔,full scan,풀스캔', '인덱스를 사용하지 않고 테이블의 모든 행을 처음부터 끝까지 읽는 것을 풀 테이블 스캔이라고 한다. 데이터가 많으면 성능이 크게 저하된다.');
