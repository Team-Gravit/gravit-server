-- Unit: 연결리스트 (Unit ID: 2)
-- Chapter: 자료구조 (Chapter ID: 1)

-- Lesson 생성
INSERT INTO lesson (id, unit_id, title)
VALUES (4, 2, '연결리스트 기초 문제집'),
       (5, 2, '연결리스트 심화 문제집'),
       (6, 2, '연결리스트 응용 문제집');

-- =====================================================
-- Lesson 4: 연결리스트 기초 문제집
-- =====================================================

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (19, 4, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '연결리스트(Linked List)는 노드들이 연결된 자료구조이다.', 'OBJECTIVE'),
       (20, 4, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '연결리스트는 포인터를 통해 노드에 접근하는 자료구조이다.', 'OBJECTIVE'),
       (21, 4, '빈칸에 들어갈 알맞은 말을 작성하시오', '연결리스트의 각 노드는 데이터 영역과 ___로 구성된다.', 'SUBJECTIVE'),
       (22, 4, '제시된 내용과 관련하여 옳은 것은?', '연결리스트는 다양한 장단점을 가진 자료구조이다.', 'OBJECTIVE'),
       (23, 4, '빈칸에 들어갈 알맞은 말을 작성하시오', '연결리스트에서 삽입 위치를 알고 있을 때 삽입 연산의 시간 복잡도는 ___이다.', 'SUBJECTIVE'),
       (24, 4, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '연결리스트는 메모리 상에서 특정한 방식으로 데이터를 저장하는 자료구조이다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (49, 19, '연속된 메모리 공간에 저장된다', '연속된 메모리 공간에 저장되는 것은 배열의 특징이다. 연결리스트는 노드들이 메모리 상에서 비연속적으로 배치되며 포인터로 연결된다.',
        false),
       (50, 19, '노드가 데이터와 포인터로 구성된다',
        '연결리스트의 각 노드는 데이터 영역과 다음 노드를 가리키는 포인터로 구성된다. 이러한 구조로 인해 물리적 저장 순서와 논리적 저장 순서가 일치하지 않으며, 동적 확장이 가능하다.', true),
       (51, 19, '인덱스를 통해 직접 접근할 수 있다', '인덱스를 통한 직접 접근은 배열의 특징이다. 연결리스트는 인덱스가 없으며 순차 접근만 가능하다.', false),
       (52, 19, '크기가 고정되어 있다', '크기가 고정되어 있는 것은 기본 배열의 특징이다. 연결리스트는 동적으로 노드를 추가하거나 삭제할 수 있어 크기 제약이 없다.', false),

       (53, 20, '접근: O(1), 삽입/삭제: O(n)', '이는 배열의 시간 복잡도이다. 연결리스트는 접근에 O(n), 삽입/삭제에 O(1)(위치를 아는 경우)이 소요된다.', false),
       (54, 20, '접근: O(1), 삽입/삭제: O(1)', '연결리스트는 인덱스가 없어 특정 위치에 O(1) 시간에 접근할 수 없다. 처음부터 순차적으로 탐색해야 하므로 접근은 O(n)이다.',
        false),
       (55, 20, '접근: O(n), 삽입/삭제: O(1)',
        '연결리스트는 특정 위치에 접근하려면 처음부터 순차적으로 탐색해야 하므로 O(n)이 소요된다. 하지만 삽입/삭제 위치를 알고 있다면 포인터만 변경하면 되므로 O(1)에 가능하다.', true),
       (56, 20, '접근: O(n), 삽입/삭제: O(n)', '삽입/삭제 위치를 알고 있다면 포인터만 조정하면 되므로 O(1)에 가능하다. O(n)이 소요되는 것은 삽입/삭제 위치를 찾는 탐색 과정이다.',
        false),

       (57, 22, '인덱스를 통한 빠른 접근이 가능하다', '인덱스를 통한 빠른 접근은 배열의 장점이다. 연결리스트는 인덱스가 없어 순차 접근만 가능하므로 접근 속도가 느리다.', false),
       (58, 22, '캐시 지역성이 높다',
        '연결리스트는 노드들이 메모리 상에서 비연속적으로 배치되므로 캐시 지역성이 낮다. 캐시 지역성이 높은 것은 연속된 메모리를 사용하는 배열의 장점이다.', false),
       (59, 22, '추가 메모리가 필요하지 않다', '연결리스트는 각 노드마다 포인터를 저장해야 하므로 데이터 외에 추가 메모리가 필요하다. 이는 연결리스트의 단점 중 하나이다.', false),
       (60, 22, '동적으로 크기를 확장할 수 있다',
        '연결리스트는 노드를 동적으로 추가하거나 삭제할 수 있어 크기 제약이 없다. 배열처럼 미리 크기를 지정할 필요가 없으며, 필요에 따라 메모리를 할당받아 확장할 수 있다.', true),

       (61, 24, '모든 노드가 연속된 메모리에 저장된다', '연속된 메모리에 저장되는 것은 배열의 특징이다. 연결리스트는 노드들이 메모리 상에서 흩어져 있고 포인터로 연결된다.', false),
       (62, 24, '노드들이 메모리 상에서 비연속적으로 배치된다',
        '연결리스트의 노드들은 메모리 상에서 비연속적으로 배치되며, 포인터를 통해 논리적으로 연결된다. 이러한 특성으로 인해 동적 확장이 가능하지만 캐시 지역성은 낮아진다.', true),
       (63, 24, '고정된 크기의 메모리를 미리 할당한다', '고정된 크기의 메모리를 미리 할당하는 것은 배열의 특징이다. 연결리스트는 필요할 때마다 동적으로 노드를 생성한다.', false),
       (64, 24, '인덱스를 통해 메모리 주소를 계산한다', '인덱스를 통한 메모리 주소 계산은 배열의 특징이다. 연결리스트는 인덱스가 없으며 포인터를 따라 순차적으로 접근한다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (7, 21, '포인터,pointer,다음 노드의 주소,next pointer,링크',
        '연결리스트의 각 노드는 데이터 영역과 다음 노드를 가리키는 포인터(또는 다음 노드의 주소)로 구성된다. 이 포인터를 통해 노드들이 논리적으로 연결되며, 이러한 구조로 인해 동적 확장과 효율적인 삽입/삭제가 가능하다.'),
       (8, 23, 'o(1),상수 시간,constant time',
        '연결리스트에서 삽입 위치를 이미 알고 있다면, 해당 위치의 포인터만 변경하면 되므로 O(1)의 시간 복잡도를 가진다. 새 노드의 포인터를 다음 노드로 설정하고, 이전 노드의 포인터를 새 노드로 변경하는 두 단계만 필요하다. 다만 삽입 위치를 찾는 탐색 과정까지 포함하면 O(n)이 된다.');

-- =====================================================
-- Lesson 5: 연결리스트 심화 문제집
-- =====================================================

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (25, 5, '제시된 내용과 관련하여 옳은 것은?', '연결리스트에 새로운 노드를 삽입하는 과정을 고려한다.', 'OBJECTIVE'),
       (26, 5, '빈칸에 들어갈 알맞은 말을 작성하시오', '연결리스트에서 특정 값을 탐색할 때의 시간 복잡도는 ___이다.', 'SUBJECTIVE'),
       (27, 5, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '연결리스트와 배열은 서로 다른 특성을 가진 자료구조이다.', 'OBJECTIVE'),
       (28, 5, '제시된 내용과 관련하여 옳은 것은?', '연결리스트에서 노드를 삭제하는 과정을 고려한다.', 'OBJECTIVE'),
       (29, 5, '빈칸에 들어갈 알맞은 말을 작성하시오', '연결리스트는 논리적 저장 순서와 물리적 저장 순서가 ___하지 않는다.', 'SUBJECTIVE'),
       (30, 5, '제시된 내용과 관련하여 옳은 것은?', '연결리스트는 여러 단점을 가지고 있다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (65, 25, '모든 노드를 한 칸씩 이동시킨다', '모든 노드를 이동시키는 것은 배열의 삽입 방식이다. 연결리스트는 포인터만 변경하면 되므로 노드를 이동시킬 필요가 없다.', false),
       (66, 25, '새로운 배열을 생성하고 복사한다', '새로운 배열을 생성하고 복사하는 것은 배열의 크기를 확장할 때 필요한 과정이다. 연결리스트는 동적으로 노드를 추가할 수 있어 이러한 과정이 불필요하다.',
        false),
       (67, 25, '새 노드의 포인터를 설정하고 이전 노드의 포인터를 변경한다',
        '연결리스트의 삽입은 1) 새 노드의 포인터를 다음 노드로 설정하고, 2) 이전 노드의 포인터를 새 노드로 변경하는 두 단계로 이루어진다. 포인터 영역만 변경하면 되므로 O(1)의 시간 복잡도를 가진다.',
        true),
       (68, 25, '인덱스를 재계산한다', '인덱스를 사용하는 것은 배열의 특징이다. 연결리스트는 인덱스가 없으며 포인터를 통해 노드를 연결한다.', false),

       (69, 27, '연결리스트가 배열보다 항상 빠르다', '연결리스트가 항상 빠른 것은 아니다. 접근/탐색은 배열이 빠르고, 삽입/삭제는 연결리스트가 빠르다. 사용 패턴에 따라 적합한 자료구조가 다르다.',
        false),
       (70, 27, '탐색/조회가 빈번하면 배열, 삽입/삭제가 빈번하면 연결리스트가 적합하다',
        '배열은 인덱스를 통한 O(1) 접근이 가능하므로 탐색/조회가 빈번한 경우에 적합하다. 연결리스트는 포인터 조정만으로 O(1) 삽입/삭제가 가능하므로(위치를 아는 경우) 삽입/삭제가 빈번한 경우에 적합하다.',
        true),
       (71, 27, '배열은 메모리를 낭비하지만 연결리스트는 메모리 효율이 높다',
        '배열은 사용하지 않는 공간도 미리 할당되어 메모리 낭비가 있을 수 있다. 하지만 연결리스트도 포인터 저장을 위한 추가 메모리가 필요하므로 항상 메모리 효율이 높다고 할 수 없다.', false),
       (72, 27, '연결리스트는 캐시 지역성이 배열보다 높다',
        '연결리스트는 노드들이 메모리 상에서 비연속적으로 배치되므로 캐시 지역성이 낮다. 배열은 연속적으로 저장되어 캐시 지역성이 높아 성능상 이점이 있다.', false),

       (73, 28, '모든 노드를 한 칸씩 이동시킨다', '모든 노드를 이동시키는 것은 배열의 삭제 방식이다. 연결리스트는 포인터만 변경하면 되므로 노드를 이동시킬 필요가 없다.', false),
       (74, 28, '삭제된 위치에 null을 넣는다', '단순히 null을 넣는 것은 삭제가 아니라 값을 비우는 것이다. 연결리스트의 삭제는 포인터를 조정하여 노드를 연결에서 제외시키는 과정이다.',
        false),
       (75, 28, '인덱스를 재조정한다', '인덱스를 사용하는 것은 배열의 특징이다. 연결리스트는 인덱스가 없으며 포인터를 통해 노드를 연결한다.', false),
       (76, 28, '이전 노드의 포인터를 다음 노드로 변경한다',
        '연결리스트의 삭제는 삭제할 노드의 이전 노드의 포인터를 다음 노드로 변경하는 방식으로 이루어진다. 포인터만 조정하면 되므로 O(1)의 시간 복잡도를 가진다. 삭제된 노드는 가비지 컬렉션에 의해 메모리에서 제거된다.',
        true),

       (77, 30, '크기를 동적으로 변경할 수 없다', '크기를 동적으로 변경할 수 없는 것은 기본 배열의 단점이다. 연결리스트는 오히려 동적 확장이 가능한 것이 장점이다.', false),
       (78, 30, '메모리를 전혀 사용하지 않는다', '연결리스트는 각 노드마다 데이터와 포인터를 저장하므로 당연히 메모리를 사용한다. 오히려 포인터 때문에 추가 메모리가 필요하다.',
        false),
       (79, 30, '인덱스가 없어 순차 접근만 가능하다',
        '연결리스트는 인덱스가 없어 특정 위치에 접근하려면 처음부터 순차적으로 탐색해야 한다. 이로 인해 n번째 요소에 접근하는 데 O(n)의 시간이 소요되며, 이는 배열의 O(1) 접근에 비해 비효율적이다.',
        true),
       (80, 30, '삽입과 삭제가 불가능하다', '삽입과 삭제가 불가능한 것이 아니라, 오히려 포인터 조정만으로 효율적인 삽입/삭제가 가능한 것이 연결리스트의 주요 장점이다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (9, 26, 'o(n),선형 시간,선형시간,linear time',
        '연결리스트에서 특정 값을 탐색하려면 처음 노드부터 시작하여 순차적으로 각 노드를 확인해야 한다. 최악의 경우 마지막 노드까지 모두 확인해야 하므로 시간 복잡도는 O(n)이다. 이는 인덱스를 통한 O(1) 접근이 가능한 배열에 비해 비효율적이다.'),
       (10, 29, '일치하지,않음,다름,불일치,different,not equal,같지 않음',
        '연결리스트는 논리적 저장 순서와 물리적 저장 순서가 일치하지 않는 자료구조이다. 논리적으로는 첫 번째 노드 다음에 두 번째 노드가 오지만, 물리적 메모리 상에서는 두 노드가 떨어져 있을 수 있다. 이러한 특성으로 인해 동적 확장이 가능하지만 캐시 지역성은 낮아진다.');

-- =====================================================
-- Lesson 6: 연결리스트 응용 문제집
-- =====================================================

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (31, 6, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '단일 연결리스트는 가장 기본적인 형태의 연결리스트이다.', 'OBJECTIVE'),
       (32, 6, '빈칸에 들어갈 알맞은 말을 작성하시오', '이중 연결리스트는 각 노드가 이전 노드와 다음 노드 모두를 가리키는 ___를 가진다.', 'SUBJECTIVE'),
       (33, 6, '제시된 내용과 관련하여 옳은 것은?', '이중 연결리스트는 단일 연결리스트를 개선한 자료구조이다.', 'OBJECTIVE'),
       (34, 6, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '원형 연결리스트는 특수한 형태의 연결리스트이다.', 'OBJECTIVE'),
       (35, 6, '빈칸에 들어갈 알맞은 말을 작성하시오', '___은 각 노드가 다음 노드만 가리키며 단방향 순회만 가능하다.', 'SUBJECTIVE'),
       (36, 6, '제시된 내용과 관련하여 옳은 것은?', '연결리스트는 다양한 상황에서 활용될 수 있는 자료구조이다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (81, 31, '양방향 순회가 가능하다', '양방향 순회가 가능한 것은 이중 연결리스트의 특징이다. 단일 연결리스트는 다음 노드 포인터만 있어 단방향 순회만 가능하다.', false),
       (82, 31, '마지막 노드가 첫 노드를 가리킨다', '마지막 노드가 첫 노드를 가리키는 것은 원형 연결리스트의 특징이다. 단일 연결리스트의 마지막 노드는 null을 가리킨다.', false),
       (83, 31, '각 노드가 이전 노드와 다음 노드 모두를 가리킨다', '이전 노드와 다음 노드 모두를 가리키는 것은 이중 연결리스트의 특징이다. 단일 연결리스트는 다음 노드만 가리킨다.',
        false),
       (84, 31, '각 노드가 다음 노드만 가리킨다',
        '단일 연결리스트는 각 노드가 데이터와 다음 노드를 가리키는 포인터 하나만 가진다. 이로 인해 단방향 순회만 가능하며, 이전 노드로 돌아가려면 처음부터 다시 탐색해야 한다.', true),

       (85, 33, '메모리 사용량이 단일 연결리스트보다 적다',
        '이중 연결리스트는 각 노드가 포인터를 2개 가지므로 단일 연결리스트보다 메모리 사용량이 많다. 이는 이중 연결리스트의 단점이다.', false),
       (86, 33, '양방향 순회가 가능하다',
        '이중 연결리스트는 각 노드가 이전 노드와 다음 노드 포인터를 모두 가지므로 양방향 순회가 가능하다. 앞으로도 뒤로도 자유롭게 이동할 수 있어 특정 위치에서의 삭제나 역방향 탐색이 효율적이다.', true),
       (87, 33, '단방향 순회만 가능하다', '단방향 순회만 가능한 것은 단일 연결리스트의 특징이다. 이중 연결리스트는 양방향 순회가 가능한 것이 장점이다.', false),
       (88, 33, '포인터를 하나만 사용한다', '포인터를 하나만 사용하는 것은 단일 연결리스트이다. 이중 연결리스트는 이전 노드와 다음 노드를 가리키는 두 개의 포인터를 사용한다.',
        false),

       (89, 34, '마지막 노드가 null을 가리킨다', '마지막 노드가 null을 가리키는 것은 일반적인 단일/이중 연결리스트의 특징이다. 원형 연결리스트는 마지막 노드가 첫 노드를 가리킨다.',
        false),
       (90, 34, '양방향 순회만 가능하다', '양방향 순회는 이중 연결리스트의 특징이다. 원형 연결리스트는 순환 구조를 가지는 것이 특징이며, 단일 원형과 이중 원형 모두 가능하다.', false),
       (91, 34, '마지막 노드가 첫 노드를 가리킨다',
        '원형 연결리스트는 마지막 노드의 포인터가 null이 아닌 첫 노드를 가리켜 순환 구조를 형성한다. 이로 인해 리스트의 끝에서 다시 처음으로 돌아갈 수 있으며, 라운드 로빈 스케줄링 등에 활용된다.', true),
       (92, 34, '포인터를 사용하지 않는다', '원형 연결리스트도 노드들을 포인터로 연결한다. 다만 마지막 노드의 포인터가 null이 아닌 첫 노드를 가리킨다는 점이 다르다.',
        false),

       (93, 36, '인덱스 기반 접근이 빈번한 데이터', '인덱스 기반 접근이 빈번한 경우에는 O(1) 접근이 가능한 배열이 더 적합하다. 연결리스트는 순차 접근만 가능하여 O(n)이 소요된다.',
        false),
       (94, 36, '삽입과 삭제가 빈번한 데이터',
        '연결리스트는 포인터 조정만으로 O(1) 시간에 삽입/삭제가 가능하므로(위치를 아는 경우), 삽입과 삭제가 빈번한 경우에 적합하다. 스택, 큐, 텍스트 에디터의 실행 취소 기능 등에 활용된다.', true),
       (95, 36, '고정된 크기의 데이터', '고정된 크기의 데이터는 배열이 더 적합하다. 연결리스트의 장점은 동적 크기 조정이 가능하다는 점이므로, 고정 크기에서는 배열이 더 효율적이다.', false),
       (96, 36, '연속된 메모리가 필요한 데이터', '연속된 메모리가 필요한 경우에는 배열이 적합하다. 연결리스트는 노드들이 메모리 상에서 비연속적으로 배치되는 것이 특징이다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (11, 32, '포인터,pointer,두 개의 포인터,2개의 포인터,prev와 next,이전 포인터와 다음 포인터',
        '이중 연결리스트는 각 노드가 이전 노드와 다음 노드를 가리키는 두 개의 포인터를 가진다. 이로 인해 양방향 순회가 가능하며, 특정 노드에서 앞뒤로 자유롭게 이동할 수 있다. 하지만 포인터가 2개이므로 단일 연결리스트보다 메모리를 더 사용한다.'),
       (12, 35, '단일 연결리스트,singly linked list,싱글리 링크드 리스트,단방향 연결리스트',
        '단일 연결리스트는 각 노드가 다음 노드만 가리키는 포인터 하나만 가지며, 단방향 순회만 가능한 가장 기본적인 형태의 연결리스트이다. 구현이 간단하고 메모리 사용량이 적지만, 이전 노드로 돌아갈 수 없다는 단점이 있다.');
