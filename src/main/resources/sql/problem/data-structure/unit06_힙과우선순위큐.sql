-- Unit: 힙과우선순위큐 (Unit ID: 6)
-- Chapter: 자료구조 (Chapter ID: 1)

-- Lesson 생성
INSERT INTO lesson (id, unit_id, title)
VALUES (16, 6, '힙 기초 문제집'),
       (17, 6, '힙 연산 문제집'),
       (18, 6, '우선순위 큐 응용 문제집');

-- =====================================================
-- Lesson 1: 힙 기초 문제집
-- =====================================================

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (91, 16, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '힙(Heap)은 트리 기반의 자료구조이다.', 'OBJECTIVE'),
       (92, 16, '빈칸에 들어갈 알맞은 말을 작성하시오', '힙은 ___기반의 자료구조로, 최대값 또는 최소값을 빠르게 찾기 위해 설계되었다.', 'SUBJECTIVE'),
       (93, 16, '제시된 내용과 관련하여 옳은 것은?', '힙은 여러 종류가 있으며 각각 다른 특징을 가진다.', 'OBJECTIVE'),
       (94, 16, '제시된 내용과 관련하여 옳은 것은?', '힙은 여러 종류가 있으며 각각 다른 특징을 가진다.', 'OBJECTIVE'),
       (95, 16, '빈칸에 들어갈 알맞은 말을 작성하시오', '힙에서 최대값 또는 최소값에 접근하는 시간 복잡도는 ___이다.', 'SUBJECTIVE'),
       (96, 16, '제시된 내용과 관련하여 옳은 것은?', '힙은 특정 방식으로 구현할 수 있다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (241, 91, 'FIFO 구조의 자료구조이다',
        'FIFO 구조는 큐의 특징이다. 힙은 부모-자식 간 대소 관계를 유지하는 완전 이진 트리 구조이다.', false),
       (242, 91, '완전 이진 트리 기반의 자료구조이다',
        '힙은 완전 이진 트리 기반의 자료구조로, 최대값 또는 최소값을 빠르게 찾기 위해 설계되었다. 부모와 자식 간의 대소 관계만 유지하는 반정렬 상태이다.', true),
       (243, 91, '연결리스트 기반의 자료구조이다',
        '힙은 완전 이진 트리 구조이며, 일반적으로 배열로 구현된다. 연결리스트 기반이 아니다.', false),
       (244, 91, '정렬된 배열이다',
        '힙은 완전히 정렬된 상태가 아니라 부모-자식 간 대소 관계만 유지하는 반정렬 상태이다. 완전히 정렬된 배열과는 다르다.', false),

       (245, 93, '형제 노드 간에도 대소 관계가 정의된다',
        '힙은 부모-자식 간의 대소 관계만 유지한다. 형제 노드 간의 대소 관계는 정의되지 않는다.', false),
       (246, 93, '부모 노드의 값이 자식 노드의 값보다 작거나 같다',
        '부모가 자식보다 작거나 같은 것은 최소 힙의 특징이다. 최대 힙은 부모가 자식보다 크거나 같다.', false),
       (247, 93, '완전히 정렬된 상태이다',
        '힙은 부모-자식 간 대소 관계만 유지하는 반정렬 상태이다. 완전히 정렬된 상태가 아니다.', false),
       (248, 93, '부모 노드의 값이 자식 노드의 값보다 크거나 같다',
        '최대 힙은 부모 노드의 값이 자식 노드의 값보다 크거나 같은 완전 이진 트리이다. 루트 노드에 최대값이 위치하므로 O(1) 시간에 최대값 접근이 가능하다.', true),

       (249, 94, '이진 탐색 트리의 규칙을 따른다',
        '힙은 이진 탐색 트리와 다른 규칙을 가진다. BST는 왼쪽이 작고 오른쪽이 크지만, 힙은 부모-자식 간 대소 관계만 유지한다.', false),
       (250, 94, '부모 노드의 값이 자식 노드의 값보다 작거나 같다',
        '최소 힙은 부모 노드의 값이 자식 노드의 값보다 작거나 같은 완전 이진 트리이다. 루트 노드에 최소값이 위치하므로 O(1) 시간에 최소값 접근이 가능하다.', true),
       (251, 94, '부모 노드의 값이 자식 노드의 값보다 크거나 같다',
        '부모가 자식보다 크거나 같은 것은 최대 힙의 특징이다. 최소 힙은 부모가 자식보다 작거나 같다.', false),
       (252, 94, '루트에 최대값이 위치한다',
        '최소 힙은 루트에 최소값이 위치한다. 최대값이 루트에 있는 것은 최대 힙이다.', false),

       (253, 96, '연결리스트로만 구현 가능하다',
        '힙은 완전 이진 트리이므로 배열로 구현하는 것이 가장 효율적이다. 연결리스트로도 가능하지만 일반적이지 않다.', false),
       (254, 96, '스택으로 구현한다',
        '스택은 LIFO 구조의 선형 자료구조이다. 힙은 완전 이진 트리 구조로 배열을 사용하여 구현한다.', false),
       (255, 96, '배열을 사용하여 구현한다',
        '힙은 완전 이진 트리이므로 배열을 사용하여 효율적으로 구현할 수 있다. 인덱스 i의 왼쪽 자식은 2i, 오른쪽 자식은 2i+1, 부모는 i/2이다.', true),
       (256, 96, '해시 테이블을 사용한다',
        '해시 테이블은 키-값 쌍을 저장하는 자료구조이다. 힙은 배열 기반 완전 이진 트리로 구현한다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (31, 92, '완전 이진 트리,complete binary tree,완전이진트리,완전 이진트리',
        '힙은 완전 이진 트리 기반의 자료구조이다. 완전 이진 트리는 마지막 레벨을 제외한 모든 레벨이 꽉 차있고, 마지막 레벨은 왼쪽부터 채워진 트리이다. 이러한 구조 덕분에 배열로 효율적으로 구현할 수 있다.'),
       (32, 95, 'O(1),상수 시간,constant time',
        '힙에서 최대값(최대 힙) 또는 최소값(최소 힙)은 항상 루트 노드에 위치하므로 O(1) 시간에 접근할 수 있다. 이는 힙의 가장 큰 장점 중 하나이다.');

-- =====================================================
-- Lesson 2: 힙 연산 문제집
-- =====================================================

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (97, 17, '제시된 내용과 관련하여 옳은 것은?', '힙에서 원소를 추가하는 연산이 있다.', 'OBJECTIVE'),
       (98, 17, '빈칸에 들어갈 알맞은 말을 작성하시오', '힙의 삽입 연산의 시간 복잡도는 ___이다.', 'SUBJECTIVE'),
       (99, 17, '제시된 내용과 관련하여 옳은 것은?', '힙에서 원소를 제거하는 연산이 있다.', 'OBJECTIVE'),
       (100, 17, '제시된 내용과 관련하여 옳은 것은?', '힙을 배열로 구현할 때 특정한 인덱스 규칙이 있다.', 'OBJECTIVE'),
       (101, 17, '빈칸에 들어갈 알맞은 말을 작성하시오', '힙의 삭제 연산의 시간 복잡도는 ___이다.', 'SUBJECTIVE'),
       (102, 17, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '힙은 특정한 성질을 만족하는 자료구조이다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (257, 97, '루트 위치에 바로 삽입한다',
        '루트 위치에 바로 삽입하면 힙의 완전 이진 트리 구조가 깨진다. 마지막 위치에 삽입한 후 조정한다.', false),
       (258, 97, '마지막 위치에 삽입한 후 부모와 비교하며 위로 이동시킨다',
        '힙의 삽입은 완전 이진 트리 구조를 유지하기 위해 마지막 위치에 원소를 추가한 후, 부모 노드와 비교하며 힙 속성을 만족할 때까지 위로 이동시킨다.', true),
       (259, 97, '정렬된 위치를 찾아 삽입한다',
        '힙은 완전히 정렬된 구조가 아니다. 완전 이진 트리의 마지막 위치에 삽입한 후 부모와 비교하며 조정한다.', false),
       (260, 97, '중간 위치에 삽입한다',
        '중간 위치에 삽입하면 완전 이진 트리 구조가 깨진다. 항상 마지막 위치에 삽입한 후 위로 이동시킨다.', false),

       (261, 99, '마지막 노드를 삭제한다',
        '마지막 노드를 삭제하는 것이 아니라, 루트를 삭제하고 마지막 노드를 루트로 이동시킨 후 조정한다.', false),
       (262, 99, '루트를 삭제하고 마지막 노드를 루트로 이동한 후 아래로 조정한다',
        '힙의 삭제는 루트 노드(최대값 또는 최소값)를 삭제한 후, 마지막 노드를 루트 위치로 이동시키고, 자식과 비교하며 아래로 이동시켜 힙 속성을 복구한다.', true),
       (263, 99, '삭제 없이 표시만 한다',
        '힙에서는 실제로 루트 노드를 삭제하고 힙 구조를 재조정한다. 표시만 하는 것이 아니다.', false),
       (264, 99, '중간 노드를 삭제한다',
        '힙의 삭제 연산은 루트 노드(최대값 또는 최소값)를 삭제하는 것이다. 중간 노드를 삭제하는 것은 일반적인 힙 연산이 아니다.', false),

       (265, 100, '인덱스 i의 부모는 i+1이다',
        '인덱스 i의 부모는 i/2이다. i+1은 잘못된 관계이다.', false),
       (266, 100, '인덱스 i의 왼쪽 자식은 2i, 오른쪽 자식은 2i+1이다',
        '배열의 인덱스 1부터 시작할 때, 인덱스 i의 왼쪽 자식은 2i, 오른쪽 자식은 2i+1, 부모는 i/2이다. 이러한 규칙으로 배열만으로 트리 구조를 표현할 수 있다.',
        true),
       (267, 100, '인덱스 관계가 정의되지 않는다',
        '완전 이진 트리는 명확한 인덱스 관계가 정의된다. 이를 이용해 배열로 효율적으로 구현할 수 있다.', false),
       (268, 100, '인덱스 i의 왼쪽 자식은 i+1, 오른쪽 자식은 i+2이다',
        '이는 잘못된 인덱스 관계이다. 완전 이진 트리의 배열 표현은 왼쪽 자식 2i, 오른쪽 자식 2i+1의 관계를 가진다.', false),

       (269, 102, '이진 탐색 트리의 규칙을 따른다',
        '힙과 이진 탐색 트리는 다른 규칙을 가진다. BST는 왼쪽이 작고 오른쪽이 크지만, 힙은 부모가 자식보다 크거나(최대 힙) 작다(최소 힙).', false),
       (270, 102, '부모-자식 간 대소 관계만 유지하는 반정렬 상태이다',
        '힙은 부모-자식 간의 대소 관계만 유지하는 반정렬 상태이다. 형제 노드 간의 순서는 정의되지 않으며, 완전히 정렬된 상태가 아니다.', true),
       (271, 102, '중복된 값을 허용하지 않는다',
        '힙은 중복된 값을 허용한다. 이진 탐색 트리와 달리 중복 값 저장에 제약이 없다.', false),
       (272, 102, '완전히 정렬된 상태를 유지한다',
        '힙은 완전히 정렬된 상태가 아니라 부모-자식 간 대소 관계만 유지한다. 형제 노드 간에는 순서가 없다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (33, 98, 'o(log n),로그 시간,logarithmic time',
        '힙의 삽입 연산은 마지막 위치에 원소를 추가한 후 부모와 비교하며 위로 이동시킨다. 트리의 높이만큼 비교가 필요하므로 시간 복잡도는 O(log n)이다.'),
       (34, 101, 'o(log n),로그 시간,logarithmic time',
        '힙의 삭제 연산은 루트를 삭제하고 마지막 노드를 루트로 이동한 후 자식과 비교하며 아래로 조정한다. 트리의 높이만큼 비교가 필요하므로 시간 복잡도는 O(log n)이다.');

-- =====================================================
-- Lesson 3: 우선순위 큐 응용 문제집
-- =====================================================

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (103, 18, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '우선순위 큐(Priority Queue)는 특별한 규칙을 가진 자료구조이다.', 'OBJECTIVE'),
       (104, 18, '빈칸에 들어갈 알맞은 말을 작성하시오', '우선순위 큐는 ___를 사용하여 구현하는 것이 가장 효율적이다.', 'SUBJECTIVE'),
       (105, 18, '제시된 내용과 관련하여 옳은 것은?', '우선순위 큐는 다양한 방법으로 구현할 수 있다.', 'OBJECTIVE'),
       (106, 18, '제시된 내용과 관련하여 옳은 것은?', '우선순위 큐는 다양한 분야에서 활용된다.', 'OBJECTIVE'),
       (107, 18, '빈칸에 들어갈 알맞은 말을 작성하시오', '힙으로 구현한 우선순위 큐에서 삽입과 삭제의 시간 복잡도는 ___이다.', 'SUBJECTIVE'),
       (108, 18, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '힙 정렬은 힙 자료구조를 활용하는 알고리즘이다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (273, 103, 'LIFO 구조로 동작한다',
        'LIFO는 스택의 특징이다. 우선순위 큐는 우선순위에 따라 처리 순서가 결정된다.', false),
       (274, 103, 'FIFO 구조로 동작한다',
        'FIFO는 일반 큐의 특징이다. 우선순위 큐는 우선순위에 따라 처리 순서가 결정된다.', false),
       (275, 103, '우선순위가 높은 데이터가 먼저 나가는 자료구조이다',
        '우선순위 큐는 우선순위가 높은 데이터가 먼저 나가는 자료구조이다. 일반 큐의 FIFO와 달리, 우선순위에 따라 처리 순서가 결정된다.', true),
       (276, 103, '삽입 순서대로 처리된다',
        '우선순위 큐는 삽입 순서가 아니라 우선순위에 따라 처리된다. 높은 우선순위가 먼저 처리된다.', false),

       (277, 105, '배열로 구현하면 모든 연산이 O(1)이다',
        '배열로 구현하면 삽입은 O(1)이지만 최대/최소값 찾기는 O(n)이 소요된다. 힙이 더 효율적이다.', false),
       (278, 105, '스택으로 구현하는 것이 가장 효율적이다',
        '스택은 LIFO 구조로 우선순위 큐 구현에 적합하지 않다. 힙을 사용하는 것이 가장 효율적이다.', false),
       (279, 105, '힙으로 구현하면 삽입과 삭제가 O(log n)이다',
        '힙으로 우선순위 큐를 구현하면 삽입과 삭제 모두 O(log n)의 시간 복잡도를 가진다. 이는 배열이나 연결리스트보다 효율적이다.', true),
       (280, 105, '연결리스트로 구현하면 삽입이 O(1)이고 삭제도 O(1)이다',
        '연결리스트로 구현하면 삽입은 O(1)이지만 최대/최소값을 찾아 삭제하려면 O(n)이 필요하다.', false),

       (281, 106, '이진 탐색',
        '이진 탐색은 정렬된 배열에서 중간값을 비교하며 탐색하는 알고리즘으로, 우선순위 큐를 사용하지 않는다.', false),
       (282, 106, '깊이 우선 탐색(DFS)',
        'DFS는 스택을 사용하는 알고리즘이다. 우선순위 큐를 사용하지 않는다.', false),
       (283, 106, '다익스트라 최단 경로 알고리즘',
        '다익스트라 알고리즘은 우선순위 큐를 사용하여 현재까지의 최단 거리가 가장 짧은 노드를 선택한다. 힙 기반 우선순위 큐로 O((V+E)log V)에 구현할 수 있다.',
        true),
       (284, 106, '해시 테이블 충돌 처리',
        '해시 테이블의 충돌 처리는 체이닝이나 개방 주소법을 사용한다. 우선순위 큐와는 관련이 없다.', false),

       (285, 108, '시간 복잡도가 O(n^2)이다',
        '힙 정렬의 시간 복잡도는 최선, 평균, 최악 모두 O(n log n)이다. O(n^2)가 아니다.', false),
       (286, 108, '힙을 구성한 후 루트를 반복적으로 추출하여 정렬한다',
        '힙 정렬은 배열을 힙으로 구성한 후, 루트(최대값 또는 최소값)를 반복적으로 추출하며 정렬하는 알고리즘이다. 시간 복잡도는 O(n log n)이다.', true),
       (287, 108, '추가 메모리가 O(n) 필요하다',
        '힙 정렬은 제자리 정렬(in-place)로 추가 메모리가 O(1)만 필요하다. 병합 정렬과 달리 O(n)의 추가 메모리가 필요하지 않다.', false),
       (288, 108, '퀵 정렬과 동일한 알고리즘이다',
        '힙 정렬과 퀵 정렬은 다른 알고리즘이다. 힙 정렬은 힙을 사용하고, 퀵 정렬은 피벗을 사용한다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (35, 104, '힙,heap,히프',
        '우선순위 큐는 힙을 사용하여 구현하는 것이 가장 효율적이다. 최대 힙을 사용하면 최대 우선순위 큐를, 최소 힙을 사용하면 최소 우선순위 큐를 구현할 수 있으며, 삽입과 삭제가 모두 O(log n)에 가능하다.'),
       (36, 107, 'o(log n),로그 시간,로그시간,logarithmic time',
        '힙으로 구현한 우선순위 큐에서 삽입과 삭제의 시간 복잡도는 O(log n)이다. 힙의 높이만큼 비교와 조정이 필요하기 때문이다. 이는 배열(O(n))이나 연결리스트(O(n))보다 효율적이다.');
