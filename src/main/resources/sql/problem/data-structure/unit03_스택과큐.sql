-- Unit: 스택 & 큐 (Unit ID: 3)
-- Chapter: 자료구조 (Chapter ID: 1)

-- Lesson 생성
INSERT INTO lesson (id, unit_id, title)
VALUES (7, 3, '스택 기초 문제집'),
       (8, 3, '큐 기초 문제집'),
       (9, 3, '스택 & 큐 응용 문제집');

-- =====================================================
-- Lesson 7: 스택 기초 문제집
-- =====================================================

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (37, 7, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '스택(Stack)은 한쪽 끝에서만 데이터를 처리하는 자료구조이다.', 'OBJECTIVE'),
       (38, 7, '빈칸에 들어갈 알맞은 말을 작성하시오', '스택은 ___구조로, 가장 나중에 들어온 데이터가 가장 먼저 나온다.', 'SUBJECTIVE'),
       (39, 7, '제시된 내용과 관련하여 옳은 것은?', '스택은 특정한 연산들을 통해 데이터를 관리한다.', 'OBJECTIVE'),
       (40, 7, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '스택 포인터는 스택의 상태를 관리하는 변수이다.', 'OBJECTIVE'),
       (41, 7, '빈칸에 들어갈 알맞은 말을 작성하시오', '스택의 push와 pop 연산의 시간 복잡도는 ___이다.', 'SUBJECTIVE'),
       (42, 7, '제시된 내용과 관련하여 옳은 것은?', '스택은 다양한 분야에서 활용되는 자료구조이다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (97, 37, 'FIFO 구조이다',
        'FIFO(First In First Out) 구조는 큐의 특징이다. 스택은 LIFO 구조로 가장 나중에 들어간 데이터가 먼저 나온다.', false),
       (98, 37, '양쪽 끝에서 삽입과 삭제가 가능하다',
        '양쪽 끝에서 삽입과 삭제가 가능한 것은 덱(Deque)의 특징이다. 스택은 한쪽 끝(Top)에서만 삽입과 삭제가 발생한다.', false),
       (99, 37, 'LIFO 구조이다',
        '스택은 LIFO(Last In First Out) 구조로, 가장 나중에 들어간 데이터가 가장 먼저 나온다. 이는 접시를 쌓고 빼는 것과 유사한 구조이다.', true),
       (100, 37, '중간 삽입이 자유롭다',
        '스택은 Top에서만 삽입과 삭제가 가능하며, 중간에 데이터를 삽입하거나 삭제할 수 없다. 이는 스택의 기본 제약 사항이다.', false),

       (101, 39, 'enqueue, dequeue',
        'enqueue와 dequeue는 큐의 연산이다. enqueue는 Rear에 데이터를 삽입하고, dequeue는 Front에서 데이터를 제거한다.', false),
       (102, 39, 'insert, delete, search',
        'insert, delete, search는 일반적인 자료구조 연산이지만, 스택의 표준 연산 명칭은 push, pop, peek이다.', false),
       (103, 39, 'add, remove, get',
        'add, remove, get은 일반적인 컬렉션 연산이지만, 스택의 표준 연산 명칭은 push, pop, peek이다.', false),
       (104, 39, 'push, pop, peek',
        '스택의 주요 연산은 push(삽입), pop(삭제 및 반환), peek(조회)이다. push는 Top에 데이터를 삽입하고, pop은 Top에서 데이터를 제거하며 반환하고, peek는 Top 데이터를 제거하지 않고 조회만 한다.',
        true),

       (105, 40, '항상 0을 가리킨다',
        '스택 포인터는 고정된 값이 아니라 push와 pop 연산에 따라 변경되는 동적인 값이다. 초기값은 -1이며, 데이터가 추가되면 증가하고 제거되면 감소한다.',
        false),
       (106, 40, '스택의 중간 위치를 가리킨다',
        '스택 포인터는 중간 위치가 아니라 Top 위치, 즉 다음 값이 들어갈 위치를 가리킨다. 스택은 Top에서만 연산이 발생하므로 Top 위치 관리가 중요하다.',
        false),
       (107, 40, '스택의 크기를 나타낸다',
        '스택 포인터는 크기가 아니라 Top 위치를 가리킨다. 다만 스택 포인터 값 + 1이 현재 스택에 들어있는 원소의 개수와 같다.', false),
       (108, 40, '다음 값이 들어갈 위치를 가리킨다',
        '스택 포인터는 다음 값이 들어갈 위치를 가리키며, 초기값은 -1이다. push 연산 시 포인터를 먼저 증가시킨 후 데이터를 삽입하고, pop 연산 시 데이터를 꺼낸 후 포인터를 감소시킨다.',
        true),

       (109, 42, '프린터 작업 대기열',
        '프린터 작업 대기열은 먼저 요청한 작업이 먼저 처리되어야 하므로 FIFO 구조인 큐를 사용한다. LIFO 구조인 스택은 적합하지 않다.', false),
       (110, 42, '함수 호출 및 재귀',
        '스택은 함수 호출 시 복귀 주소와 지역 변수를 저장하는 데 사용된다. 재귀 함수의 경우 각 호출마다 스택 프레임이 쌓이며, 종료 시 역순으로 복귀한다.', true),
       (111, 42, '너비 우선 탐색(BFS)',
        '너비 우선 탐색(BFS)은 같은 레벨의 노드를 먼저 탐색해야 하므로 FIFO 구조인 큐를 사용한다. 깊이 우선 탐색(DFS)에서 스택을 사용한다.', false),
       (112, 42, '데이터베이스 인덱싱',
        '데이터베이스 인덱싱은 주로 B-Tree나 해시 테이블과 같은 자료구조를 사용한다. 스택은 인덱싱 용도로 적합하지 않다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (13, 38, 'lifo,last in first out,후입선출,리포',
        '스택은 LIFO(Last In First Out) 또는 후입선출 구조의 자료구조이다. 가장 나중에 들어온 데이터가 가장 먼저 나가는 구조로, 접시를 쌓고 빼는 것과 유사하다.'),
       (14, 41, 'o(1),상수 시간,constant time',
        '스택의 push와 pop 연산은 모두 Top에서만 발생하므로 O(1)의 시간 복잡도를 가진다. 스택 포인터만 조작하면 되기 때문에 매우 빠르게 수행된다.');

-- =====================================================
-- Lesson 8: 큐 기초 문제집
-- =====================================================

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (43, 8, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '큐(Queue)는 한쪽에서 삽입하고 반대쪽에서 삭제하는 자료구조이다.', 'OBJECTIVE'),
       (44, 8, '빈칸에 들어갈 알맞은 말을 작성하시오', '큐는 ___구조로, 가장 먼저 들어온 데이터가 가장 먼저 나온다.', 'SUBJECTIVE'),
       (45, 8, '제시된 내용과 관련하여 옳은 것은?', '큐는 특정한 연산들을 통해 데이터를 관리한다.', 'OBJECTIVE'),
       (46, 8, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '선형 큐는 포인터로 삽입/삭제 위치를 관리한다.', 'OBJECTIVE'),
       (47, 8, '빈칸에 들어갈 알맞은 말을 작성하시오', '큐의 enqueue와 dequeue 연산의 시간 복잡도는 ___이다.', 'SUBJECTIVE'),
       (48, 8, '제시된 내용과 관련하여 옳은 것은?', '원형 큐는 선형 큐의 문제점을 해결한 자료구조이다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (113, 43, 'LIFO 구조이다',
        'LIFO(Last In First Out) 구조는 스택의 특징이다. 큐는 FIFO 구조로 먼저 들어온 데이터가 먼저 나온다.', false),
       (114, 43, '한쪽 끝에서만 삽입과 삭제가 발생한다',
        '한쪽 끝에서만 삽입과 삭제가 발생하는 것은 스택의 특징이다. 큐는 Rear에서 삽입, Front에서 삭제가 발생한다.', false),
       (115, 43, 'FIFO 구조이다',
        '큐는 FIFO(First In First Out) 구조로, 가장 먼저 들어온 데이터가 가장 먼저 나온다. 이는 줄을 서는 것과 유사한 구조이다.', true),
       (116, 43, '중간 접근이 자유롭다',
        '큐는 Front와 Rear에서만 연산이 가능하며, 중간 접근이나 삽입/삭제는 허용되지 않는다.', false),

       (117, 45, 'push, pop',
        'push와 pop은 스택의 연산이다. 큐의 연산은 enqueue(Rear에 삽입)와 dequeue(Front에서 삭제)이다.', false),
       (118, 45, 'insert, delete',
        'insert와 delete는 일반적인 자료구조 연산이지만, 큐의 표준 연산 명칭은 enqueue와 dequeue이다.', false),
       (119, 45, 'enqueue, dequeue',
        '큐의 주요 연산은 enqueue(삽입)와 dequeue(삭제 및 반환)이다. enqueue는 Rear에 데이터를 추가하고, dequeue는 Front에서 데이터를 제거하며 반환한다.',
        true),
       (120, 45, 'add, remove',
        'add와 remove는 일반적인 컬렉션 연산이지만, 큐의 표준 연산 명칭은 enqueue와 dequeue이다.', false),

       (121, 46, '삽입과 삭제가 O(n) 시간이 소요된다',
        '선형 큐의 삽입과 삭제는 포인터만 조작하므로 O(1) 시간에 가능하다. 메모리 낭비가 문제이지 시간 복잡도는 효율적이다.', false),
       (122, 46, 'Rear가 배열 끝에 도달하면 앞쪽 빈 공간을 활용할 수 없다',
        '선형 큐는 Rear가 배열 끝에 도달하면 앞쪽에 빈 공간이 있어도 삽입이 불가능하다. 이는 선형 큐의 주요 단점으로, 원형 큐를 통해 해결할 수 있다.', true),
       (123, 46, '크기를 동적으로 조정할 수 없다',
        '크기 조정의 제약은 배열 기반 자료구조 전반의 문제이며, 선형 큐만의 고유한 단점은 아니다. 선형 큐의 고유한 단점은 메모리 낭비이다.', false),
       (124, 46, 'Front와 Rear를 구분할 수 없다',
        '선형 큐는 Front와 Rear 포인터로 명확히 위치를 구분한다. 이는 선형 큐의 단점이 아니다.', false),

       (125, 48, '무한한 크기를 가진다',
        '원형 큐도 배열 기반이므로 크기가 고정되어 있다. 다만 순환 구조를 통해 공간을 효율적으로 활용할 수 있다.', false),
       (126, 48, '삽입과 삭제가 O(n) 시간이 소요된다',
        '원형 큐의 삽입과 삭제도 포인터 조작만으로 이루어지므로 O(1) 시간에 가능하다. 순환 구조가 시간 복잡도에 영향을 주지 않는다.', false),
       (127, 48, 'LIFO 구조로 동작한다',
        '원형 큐도 큐의 한 종류이므로 FIFO 구조로 동작한다. 순환 구조는 공간 활용 방식의 개선이지 동작 방식의 변경이 아니다.', false),
       (128, 48, '배열의 처음과 끝을 논리적으로 연결한다',
        '원형 큐는 배열의 처음과 끝을 논리적으로 연결하여 선형 큐의 메모리 낭비 문제를 해결한다. (index + 1) % size로 순환 구조를 구현한다.', true);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (15, 44, 'fifo,first in first out,선입선출,피포',
        '큐는 FIFO(First In First Out) 또는 선입선출 구조의 자료구조이다. 가장 먼저 들어온 데이터가 가장 먼저 나가는 구조로, 줄을 서는 것과 유사하다.'),
       (16, 47, 'o(1),상수 시간,constant time',
        '큐의 enqueue와 dequeue 연산은 모두 포인터 조작만으로 이루어지므로 O(1)의 시간 복잡도를 가진다. Rear에서 삽입, Front에서 삭제가 발생하며 매우 빠르게 수행된다.');

-- =====================================================
-- Lesson 9: 스택 & 큐 응용 문제집
-- =====================================================

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (49, 9, '제시된 내용과 관련하여 옳은 것은?', '동적 스택은 배열 기반 스택의 크기 제한 문제를 해결한 것이다.', 'OBJECTIVE'),
       (50, 9, '빈칸에 들어갈 알맞은 말을 작성하시오', '스택을 ___로 구현하면 크기 제한 없이 사용할 수 있다.', 'SUBJECTIVE'),
       (51, 9, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '연결리스트 큐는 노드를 연결하는 방식으로 구현한 큐이다.', 'OBJECTIVE'),
       (52, 9, '제시된 내용과 관련하여 옳은 것은?', 'Deque는 Double-Ended Queue의 약자이다.', 'OBJECTIVE'),
       (53, 9, '빈칸에 들어갈 알맞은 말을 작성하시오', '스택에서 Top 데이터를 제거하지 않고 조회만 하는 연산은 ___이다.', 'SUBJECTIVE'),
       (54, 9, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '큐는 순서가 중요한 다양한 상황에서 활용된다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (129, 49, '무한한 크기를 가진다',
        '동적 스택도 메모리 한계 내에서 동작하므로 무한한 크기를 가질 수 없다. 다만 필요에 따라 동적으로 크기를 조정할 수 있다.', false),
       (130, 49, '가득 차면 배열 크기를 확장한다',
        '동적 스택은 배열이 가득 차면 더 큰 배열을 생성하고 기존 데이터를 복사하여 크기를 확장한다. 일반적으로 기존 크기의 2배로 확장한다.', true),
       (131, 49, '크기를 줄일 수 없다',
        '동적 스택은 크기를 늘릴 수도 있고 줄일 수도 있다. 원소가 줄어들면 메모리 효율을 위해 크기를 축소할 수 있다.', false),
       (132, 49, 'FIFO 구조로 동작한다',
        '동적 스택도 스택이므로 LIFO 구조로 동작한다. 크기 조정 방식은 구현의 세부사항이지 기본 동작 방식은 동일하다.', false),

       (133, 51, '삽입과 삭제가 O(n) 시간이 소요된다',
        '연결리스트 큐도 Front와 Rear에서 포인터 조작만으로 삽입/삭제가 가능하므로 O(1) 시간에 수행된다.', false),
       (134, 51, 'crsize 제한이 없다',
        '연결리스트 큐는 노드를 동적으로 할당하므로 메모리가 허용하는 한 크기 제한이 없다. 배열 기반 큐의 고정 크기 문제를 해결한다.', true),
       (135, 51, '인덱스로 직접 접근할 수 있다',
        '연결리스트는 순차 접근만 가능하므로 인덱스로 직접 접근할 수 없다. 이는 연결리스트 기반 자료구조의 일반적인 특징이다.', false),
       (136, 51, '원형 구조로 구현된다',
        '원형 구조는 배열 기반 큐에서 공간을 효율적으로 활용하기 위한 방법이다. 연결리스트 큐는 원형 구조가 필요 없다.', false),

       (137, 52, '한쪽 끝에서만 연산이 가능하다',
        '한쪽 끝에서만 연산이 가능한 것은 스택의 특징이다. Deque는 양쪽 끝에서 모두 연산이 가능하다.', false),
       (138, 52, 'LIFO 구조로만 동작한다',
        'Deque는 양쪽 끝에서 연산이 가능하므로 LIFO와 FIFO 모두 구현할 수 있다. 사용 방식에 따라 스택이나 큐로 동작할 수 있다.', false),
       (139, 52, '양쪽 끝에서 삽입과 삭제가 모두 가능하다',
        'Deque(덱)는 양쪽 끝에서 삽입과 삭제가 모두 가능한 자료구조이다. 스택과 큐의 기능을 모두 제공하며, 배열 또는 연결리스트로 구현 가능하다.', true),
       (140, 52, '크기를 변경할 수 없다',
        'Deque도 배열 또는 연결리스트로 구현되므로, 연결리스트 기반인 경우 크기 제한이 없고, 동적 배열 기반인 경우 크기 조정이 가능하다.', false),

       (141, 54, '함수 호출 스택',
        '함수 호출 스택은 가장 최근에 호출된 함수가 먼저 종료되어야 하므로 LIFO 구조인 스택을 사용한다. 큐는 적합하지 않다.', false),
       (142, 54, '프로세스 스케줄링',
        '운영체제의 프로세스 스케줄링은 먼저 도착한 프로세스를 먼저 처리해야 하므로 FIFO 구조인 큐를 사용한다. 준비 큐(Ready Queue)가 대표적인 예시이다.',
        true),
       (143, 54, '깊이 우선 탐색(DFS)',
        '깊이 우선 탐색(DFS)은 한 경로를 끝까지 탐색한 후 돌아오므로 LIFO 구조인 스택을 사용한다. 너비 우선 탐색(BFS)에서 큐를 사용한다.', false),
       (144, 54, '후위 표기법 계산',
        '후위 표기법 계산은 연산자를 만났을 때 최근 두 피연산자를 사용하므로 LIFO 구조인 스택을 사용한다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (17, 50, '연결리스트,linked list,링크드 리스트,연결 리스트',
        '스택을 연결리스트로 구현하면 노드를 동적으로 할당하므로 크기 제한 없이 사용할 수 있다. 각 노드가 데이터와 다음 노드의 주소를 저장하며, Top에서만 삽입/삭제가 발생한다.'),
       (18, 53, 'peek,top,피크,탑',
        'peek 또는 top 연산은 스택의 최상단 데이터를 제거하지 않고 조회만 하는 연산이다. 스택의 상태를 확인하거나 다음 처리할 데이터를 미리 확인할 때 사용한다.');
