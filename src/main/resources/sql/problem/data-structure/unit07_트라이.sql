-- Unit: 트라이(Trie) (Unit ID: 7)
-- Chapter: 자료구조 (Chapter ID: 1)

-- Lesson 생성
INSERT INTO lesson (id, unit_id, title)
VALUES (19, 7, '트라이 기초 문제집'),
       (20, 7, '트라이 응용 문제집');

-- =====================================================
-- Lesson 1: 트라이 기초 문제집
-- =====================================================

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (109, 19, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '트라이(Trie)는 데이터를 효율적으로 처리하는 자료구조이다.', 'OBJECTIVE'),
       (110, 19, '빈칸에 들어갈 알맞은 말을 작성하시오', '트라이는 ___트리 또는 검색 트리라고도 불린다.', 'SUBJECTIVE'),
       (111, 19, '제시된 내용과 관련하여 옳은 것은?', '트라이는 특정 데이터 유형에 특화된 자료구조이다.', 'OBJECTIVE'),
       (112, 19, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '트라이의 각 노드는 특정 정보를 저장하는 구조를 가진다.', 'OBJECTIVE'),
       (113, 19, '빈칸에 들어갈 알맞은 말을 작성하시오', '길이가 M인 문자열을 트라이에서 탐색하는 시간 복잡도는 ___이다.', 'SUBJECTIVE'),
       (114, 19, '제시된 내용과 관련하여 옳은 것은?', '트라이는 다양한 장단점을 가진 자료구조이다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (289, 109, 'FIFO 구조의 자료구조이다',
        'FIFO는 큐의 특징이다. 트라이는 트리 구조로 문자열을 저장하고 탐색하는 자료구조이다.', false),
       (290, 109, '문자열을 트리 형태로 저장하여 효율적으로 탐색하는 자료구조이다',
        '트라이는 문자열을 트리 형태로 저장하는 자료구조로, 접두사 트리(Prefix Tree) 또는 검색 트리(Retrieval Tree)라고도 한다. 문자열 탐색에 특화되어 있다.', true),
       (291, 109, '연결리스트의 한 종류이다',
        '트라이는 트리 구조이다. 연결리스트가 아니라 계층적 트리 구조로 문자열을 저장한다.', false),
       (292, 109, '정수를 효율적으로 탐색하는 자료구조이다',
        '트라이는 문자열 탐색에 특화된 자료구조이다. 정수 탐색이 주목적이 아니다.', false),

       (293, 111, '이진 트리 구조로만 구현 가능하다',
        '트라이는 이진 트리가 아니다. 각 노드는 여러 개의 자식(일반적으로 알파벳 개수만큼)을 가질 수 있다.', false),
       (294, 111, '각 노드는 완전한 문자열을 저장한다',
        '트라이의 각 노드는 문자 하나만 저장한다. 완전한 문자열은 루트부터 해당 노드까지의 경로로 표현된다.', false),
       (295, 111, '각 노드는 문자 하나와 문자열 종료 여부를 저장한다',
        '트라이의 각 노드는 문자 하나와 문자열 종료 여부(flag)를 저장한다. 루트에서 특정 노드까지의 경로가 하나의 문자열을 형성한다.', true),
       (296, 111, '사이클이 존재한다',
        '트라이는 트리 구조이므로 사이클이 존재하지 않는다.', false),

       (297, 112, '숫자 값만 저장한다',
        '트라이는 문자를 저장한다. 각 노드는 문자 하나와 종료 플래그를 저장한다.', false),
       (298, 112, '완전한 문자열만 저장한다',
        '각 노드는 문자 하나만 저장한다. 완전한 문자열은 경로로 표현된다.', false),
       (299, 112, '문자 하나와 문자열 종료 여부를 저장한다',
        '트라이의 각 노드는 문자 하나와 문자열 종료 여부(flag)를 저장한다. 또한 자식 노드를 가리키는 포인터 배열을 가진다.', true),
       (300, 112, '부모 노드의 포인터만 저장한다',
        '트라이의 노드는 자식 노드를 가리키는 포인터를 저장한다. 부모 포인터만 저장하는 것이 아니다.', false),

       (301, 114, '메모리 사용량이 매우 적다',
        '트라이는 각 노드가 자식 노드 포인터 배열을 저장하므로 메모리 사용량이 크다. 이는 트라이의 단점이다.', false),
       (302, 114, '삽입과 삭제가 O(1)이다',
        '트라이의 삽입과 삭제는 문자열 길이 M에 비례하므로 O(M)이다. O(1)이 아니다.', false),
       (303, 114, '접두사 기반 검색에 효율적이다',
        '트라이는 공통 접두사를 공유하므로 자동완성이나 접두사 기반 검색에 매우 효율적이다. 문자열의 길이가 M일 때 O(M) 시간에 탐색이 가능하다.', true),
       (304, 114, '정렬된 순서로 저장된다',
        '트라이는 문자열을 트리 형태로 저장하며, 정렬된 순서로 저장하는 것이 주목적이 아니다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (37, 110, '접두사,prefix,프리픽스,접두사 트리,prefix tree',
        '트라이는 접두사 트리(Prefix Tree) 또는 검색 트리(Retrieval Tree)라고도 불린다. 공통 접두사를 공유하여 저장하므로 접두사 기반 검색에 효율적이다.'),
       (38, 113, 'o(m),선형 시간,선형시간,linear time',
        '길이가 M인 문자열을 트라이에서 탐색하는 시간 복잡도는 O(M)이다. 문자열의 각 문자를 순서대로 따라가며 탐색하므로 문자열 길이에 비례한다. 저장된 문자열의 개수와는 무관하다.');

-- =====================================================
-- Lesson 2: 트라이 응용 문제집
-- =====================================================

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (115, 20, '제시된 내용과 관련하여 옳은 것은?', '트라이에 데이터를 삽입하는 과정을 고려한다.', 'OBJECTIVE'),
       (116, 20, '빈칸에 들어갈 알맞은 말을 작성하시오', '길이가 M인 문자열을 트라이에 삽입하는 시간 복잡도는 ___이다.', 'SUBJECTIVE'),
       (117, 20, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '트라이는 메모리 사용에 있어 특정한 특성을 가진다.', 'OBJECTIVE'),
       (118, 20, '제시된 내용과 관련하여 옳은 것은?', '트라이는 여러 단점을 가지고 있다.', 'OBJECTIVE'),
       (119, 20, '빈칸에 들어갈 알맞은 말을 작성하시오', '트라이에서 문자열의 ___를 공유하여 저장 공간을 절약한다.', 'SUBJECTIVE'),
       (120, 20, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '트라이는 실제 응용 분야에서 활용되는 자료구조이다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (305, 115, '항상 새로운 경로를 생성한다',
        '공통 접두사가 있으면 기존 경로를 공유한다. 항상 새로운 경로를 생성하는 것이 아니다.', false),
       (306, 115, '정렬된 위치를 찾아 삽입한다',
        '트라이는 문자 단위로 경로를 따라가며 삽입한다. 정렬된 위치를 찾는 것이 아니다.', false),
       (307, 115, '기존 경로를 따라가다가 없는 문자를 만나면 새 노드를 생성한다',
        '트라이의 삽입은 루트부터 시작하여 문자열의 각 문자에 해당하는 경로를 따라간다. 기존 경로가 있으면 그대로 이동하고, 없으면 새 노드를 생성한다. 마지막 노드에 종료 플래그를 설정한다.',
        true),
       (308, 115, '문자열 전체를 하나의 노드에 저장한다',
        '트라이는 문자열을 문자 단위로 분해하여 각 문자를 노드에 저장한다. 전체 문자열을 하나의 노드에 저장하지 않는다.', false),

       (309, 117, '메모리 사용량이 매우 적다',
        '트라이는 각 노드가 포인터 배열을 저장하므로 메모리 사용량이 크다. 이는 트라이의 단점이다.', false),
       (310, 117, '배열과 동일한 메모리를 사용한다',
        '트라이는 트리 구조로 포인터 배열을 추가로 저장하므로 단순 배열보다 메모리를 많이 사용한다.', false),
       (311, 117, '각 노드가 자식 노드 포인터 배열을 저장하여 메모리 사용량이 크다',
        '트라이의 각 노드는 자식 노드를 가리키는 포인터 배열을 저장한다. 저장할 문자 종류가 많을수록(예: 알파벳 26개) 메모리 오버헤드가 증가한다. 이는 트라이의 주요 단점이다.',
        true),
       (312, 117, '문자열 개수에만 비례한다',
        '메모리 사용량은 문자열 개수뿐만 아니라 문자 종류의 개수, 문자열의 길이 등에도 영향을 받는다.', false),

       (313, 118, '탐색 시간이 O(n^2)으로 비효율적이다',
        '트라이의 탐색 시간은 O(M)으로 효율적이다. M은 문자열 길이이며, O(n^2)가 아니다.', false),
       (314, 118, '문자열을 저장할 수 없다',
        '트라이는 문자열을 저장하는 자료구조이다. 문자열 저장이 가능하다.', false),
       (315, 118, '각 노드가 포인터 배열을 저장하여 메모리 사용량이 크다',
        '트라이의 주요 단점은 메모리 사용량이 크다는 것이다. 각 노드가 자식 노드 포인터 배열을 저장하므로, 저장할 문자 종류가 많을수록 메모리 오버헤드가 증가한다.', true),
       (316, 118, '삽입이 불가능하다',
        '트라이는 삽입이 가능하다. 삽입 시간 복잡도는 O(M)이다.', false),

       (317, 120, '정수 정렬',
        '정수 정렬은 일반적으로 정렬 알고리즘을 사용한다. 트라이는 문자열 탐색에 특화되어 있다.', false),
       (318, 120, '네트워크 패킷 라우팅',
        '네트워크 패킷 라우팅은 라우팅 테이블을 사용한다. 트라이가 일부 사용될 수 있지만 주요 활용 사례는 아니다.', false),
       (319, 120, '검색 엔진의 자동완성 기능',
        '트라이는 접두사 기반 검색에 효율적이므로 검색 엔진의 자동완성, 사전 검색, IDE의 자동완성 등에 활용된다. 사용자가 입력한 접두사로 시작하는 모든 단어를 빠르게 찾을 수 있다.',
        true),
       (320, 120, '스택 메모리 관리',
        '스택 메모리는 LIFO 구조의 스택 자료구조로 관리된다. 트라이와는 관련이 없다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (39, 116, 'o(m),선형 시간,선형시간,linear time',
        '길이가 M인 문자열을 트라이에 삽입하는 시간 복잡도는 O(M)이다. 문자열의 각 문자를 순서대로 처리하며 노드를 생성하거나 이동하므로 문자열 길이에 비례한다.'),
       (40, 119, '공통 접두사, 접두사, prefix, 프리픽스, Prefix, 공통 접두어',
        '트라이는 문자열의 공통 접두사를 공유하여 저장 공간을 절약한다. 예를 들어 "cat"과 "car"는 "ca"라는 공통 접두사를 공유하므로 "ca"까지의 경로를 함께 사용한다.');