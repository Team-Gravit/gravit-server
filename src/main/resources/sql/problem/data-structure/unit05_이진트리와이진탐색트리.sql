-- Unit: 이진 트리 & 이진 탐색 트리 (Unit ID: 5)
-- Chapter: 자료구조 (Chapter ID: 1)

-- Lesson 생성
INSERT INTO lesson (id, unit_id, title)
VALUES (13, 5, '이진 트리 기초 문제집'),
       (14, 5, '이진 탐색 트리 기초 문제집'),
       (15, 5, '이진 탐색 트리 응용 문제집');

-- =====================================================
-- Lesson 1: 이진 트리 기초 문제집
-- =====================================================

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (73, 13, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '이진 트리(Binary Tree)는 트리의 한 형태이다.', 'OBJECTIVE'),
       (74, 13, '빈칸에 들어갈 알맞은 말을 작성하시오', '이진 트리의 각 노드는 최대 ___개의 자식 노드를 가질 수 있다.', 'SUBJECTIVE'),
       (75, 13, '제시된 내용과 관련하여 옳은 것은?', '이진 트리는 특정한 성질을 만족한다.', 'OBJECTIVE'),
       (76, 13, '제시된 내용과 관련하여 옳은 것은?', '포화 이진 트리는 이진 트리의 한 형태이다.', 'OBJECTIVE'),
       (77, 13, '빈칸에 들어갈 알맞은 말을 작성하시오', '높이가 h인 포화 이진 트리는 ___개의 노드를 가진다.', 'SUBJECTIVE'),
       (78, 13, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '완전 이진 트리는 이진 트리의 한 형태이다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (193, 73, '각 노드가 정확히 3개의 자식을 가진다',
        '각 노드가 정확히 3개의 자식을 가지는 것은 3진 트리이다. 이진 트리는 최대 2개의 자식을 가진다.', false),
       (194, 73, '모든 노드가 반드시 2개의 자식을 가진다',
        '이진 트리의 노드는 0개, 1개, 또는 2개의 자식을 가질 수 있다. 반드시 2개를 가져야 하는 것은 아니다.', false),
       (195, 73, '최대 2개의 서브 트리로 나뉘는 트리이다',
        '이진 트리는 루트 노드를 중심으로 최대 2개의 서브 트리(왼쪽, 오른쪽)로 나뉘는 트리 구조이다. 각 노드는 최대 2개의 자식 노드를 가질 수 있다.', true),
       (196, 73, '사이클이 존재하는 트리이다',
        '이진 트리도 트리의 일종이므로 사이클이 존재하지 않는다. 사이클이 있으면 그래프이지 트리가 아니다.', false),

       (197, 75, '높이가 h일 때 항상 2^h개의 노드를 가진다',
        '높이가 h일 때 2^h개의 노드를 가지는 것은 포화 이진 트리의 특성이다. 일반 이진 트리는 최소 h개에서 최대 2^h - 1개의 노드를 가진다.', false),
       (198, 75, 'n개의 노드가 있으면 n-1개의 간선이 존재한다',
        '이진 트리도 트리의 일종이므로 n개의 노드가 있으면 n-1개의 간선이 존재한다. 루트를 제외한 모든 노드가 정확히 하나의 부모와 연결되기 때문이다.', true),
       (199, 75, '모든 레벨이 노드로 꽉 차있다',
        '모든 레벨이 노드로 꽉 차있는 것은 포화 이진 트리의 특성이다. 일반 이진 트리는 이러한 제약이 없다.', false),
       (200, 75, '중위 순회가 불가능하다',
        '이진 트리에서도 전위, 중위, 후위, 레벨 순회가 모두 가능하다. 중위 순회는 왼쪽 자식 → 부모 → 오른쪽 자식 순으로 방문한다.', false),

       (201, 76, '마지막 레벨만 꽉 차있다',
        '마지막 레벨만 꽉 차있는 것이 아니라 모든 레벨이 꽉 차있어야 포화 이진 트리이다.', false),
       (202, 76, '각 노드가 0개 또는 2개의 자식을 가진다',
        '각 노드가 0개 또는 2개의 자식을 가지는 것은 정 이진 트리이다. 포화 이진 트리는 리프 노드를 제외한 모든 노드가 2개의 자식을 가진다.', false),
       (203, 76, '모든 레벨이 노드로 꽉 차있다',
        '포화 이진 트리는 모든 레벨이 노드로 꽉 찬 트리이다. 높이가 h일 때 2^h - 1개의 노드를 가지며, 가장 완벽하게 균형잡힌 형태이다.', true),
       (204, 76, '왼쪽부터 순서대로 채워진다',
        '왼쪽부터 순서대로 채워지는 것은 완전 이진 트리의 특징이다. 포화 이진 트리는 모든 레벨이 완전히 채워진 상태이다.', false),

       (205, 78, '모든 레벨이 완전히 채워져 있다',
        '모든 레벨이 완전히 채워진 것은 포화 이진 트리이다. 완전 이진 트리는 마지막 레벨이 부분적으로 채워질 수 있다.', false),
       (206, 78, '마지막 레벨을 제외한 모든 레벨이 꽉 차있고, 마지막 레벨은 왼쪽부터 채워진다',
        '완전 이진 트리는 마지막 레벨을 제외한 모든 레벨이 노드로 꽉 차있고, 마지막 레벨의 노드는 왼쪽부터 순서대로 채워진 트리이다. 힙이 완전 이진 트리 구조를 사용한다.',
        true),
       (207, 78, '오른쪽부터 순서대로 채워진다',
        '완전 이진 트리는 마지막 레벨을 왼쪽부터 순서대로 채운다. 오른쪽부터 채우면 완전 이진 트리가 아니다.', false),
       (208, 78, '각 노드가 0개 또는 2개의 자식을 가진다',
        '각 노드가 0개 또는 2개의 자식을 가지는 것은 정 이진 트리이다. 완전 이진 트리는 마지막 레벨의 채워진 형태에 대한 제약이다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (25, 74, '2,두,two',
        '이진 트리의 각 노드는 최대 2개의 자식 노드를 가질 수 있다. 0개, 1개, 또는 2개의 자식을 가질 수 있으며, 이것이 "이진"이라는 이름의 유래이다.'),
       (26, 77, '2^h - 1,2^h-1',
        '높이가 h인 포화 이진 트리는 2^h - 1개의 노드를 가진다. 예를 들어 높이가 3이면 2^3 - 1 = 7개의 노드를 가진다. 각 레벨 i는 2^(i-1)개의 노드를 가지며, 이를 모두 합하면 2^h - 1이 된다.');

-- =====================================================
-- Lesson 2: 이진 탐색 트리 기초 문제집
-- =====================================================

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (79, 14, '제시된 내용과 관련하여 옳은 것은?', '이진 탐색 트리(BST)는 효율적인 탐색을 위한 구조를 유지한다.', 'OBJECTIVE'),
       (80, 14, '빈칸에 들어갈 알맞은 말을 작성하시오', '이진 탐색 트리에서 탐색, 삽입, 삭제의 평균 시간 복잡도는 ___이다.', 'SUBJECTIVE'),
       (81, 14, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '이진 탐색 트리에서 특정 값을 찾는 과정이다.', 'OBJECTIVE'),
       (82, 14, '제시된 내용과 관련하여 옳은 것은?', '이진 탐색 트리에 새로운 노드를 삽입하는 과정이다.', 'OBJECTIVE'),
       (83, 14, '빈칸에 들어갈 알맞은 말을 작성하시오', '이진 탐색 트리를 ___하면 오름차순으로 정렬된 값을 얻을 수 있다.', 'SUBJECTIVE'),
       (84, 14, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '이진 탐색 트리는 이진 트리와 이진 탐색의 장점을 결합한 자료구조이다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (209, 79, '왼쪽 서브 트리는 부모보다 크고, 오른쪽 서브 트리는 부모보다 작다',
        '반대이다. 왼쪽 서브 트리는 부모보다 작고, 오른쪽 서브 트리는 부모보다 크다.', false),
       (210, 79, '모든 노드가 동일한 값을 가진다',
        '이진 탐색 트리는 중복되는 값을 허용하지 않으며, 각 노드는 고유한 값을 가진다.', false),
       (211, 79, '왼쪽 서브 트리는 부모보다 작고, 오른쪽 서브 트리는 부모보다 크다',
        '이진 탐색 트리는 왼쪽 서브 트리의 모든 값이 부모보다 작고, 오른쪽 서브 트리의 모든 값이 부모보다 크다는 규칙을 만족한다. 이를 통해 효율적인 탐색이 가능하다.', true),
       (212, 79, '부모와 자식 간에 대소 관계가 없다',
        '이진 탐색 트리는 부모와 자식 간의 명확한 대소 관계를 유지하는 것이 핵심이다.', false),

       (213, 81, '모든 노드를 순차적으로 방문한다',
        '모든 노드를 순차적으로 방문하는 것은 비효율적이다. 이진 탐색 트리는 대소 관계를 이용해 불필요한 노드를 건너뛰며 탐색한다.', false),
       (214, 81, '루트부터 시작하여 찾는 값이 작으면 왼쪽, 크면 오른쪽으로 이동한다',
        '이진 탐색 트리의 탐색은 루트부터 시작하여, 찾는 값이 현재 노드보다 작으면 왼쪽 서브 트리로, 크면 오른쪽 서브 트리로 이동하며 탐색한다.', true),
       (215, 81, '항상 왼쪽 자식부터 탐색한다',
        '탐색 방향은 찾는 값과 현재 노드 값의 대소 관계에 따라 결정된다. 항상 왼쪽부터 탐색하는 것이 아니다.', false),
       (216, 81, '레벨 순회로 탐색한다',
        '레벨 순회는 같은 깊이의 모든 노드를 방문하는 방식으로, 이진 탐색 트리의 효율적인 탐색 방법이 아니다.', false),

       (217, 82, '항상 루트 노드에 삽입한다',
        '루트에 삽입하면 BST의 규칙이 깨진다. 적절한 위치를 찾아 삽입해야 한다.', false),
       (218, 82, '무작위 위치에 삽입한다',
        '무작위 위치에 삽입하면 BST의 대소 관계 규칙이 깨진다. 규칙을 만족하는 위치를 찾아 삽입해야 한다.', false),
       (219, 82, '탐색과 동일한 방식으로 삽입 위치를 찾아 새 노드를 추가한다',
        '이진 탐색 트리의 삽입은 탐색과 동일한 방식으로 삽입 위치를 찾은 후, 리프 노드 위치에 새 노드를 추가한다. 삽입 후에도 BST의 규칙이 유지된다.', true),
       (220, 82, '중간 노드에만 삽입할 수 있다',
        '삽입은 일반적으로 리프 노드 위치에 이루어진다. 중간 노드에만 삽입할 수 있다는 제약은 없다.', false),

       (221, 84, 'FIFO 구조로 동작한다',
        'FIFO는 큐의 특징이다. 이진 탐색 트리는 대소 관계에 기반한 계층적 구조이다.', false),
       (222, 84, '이진 탐색의 빠른 탐색과 연결리스트의 유연한 삽입/삭제를 결합했다',
        '이진 탐색 트리는 이진 탐색의 O(log n) 탐색 성능과 연결리스트의 유연한 삽입/삭제를 결합한 자료구조이다. 배열의 고정 크기 문제를 해결한다.', true),
       (223, 84, '모든 연산이 O(1)이다',
        '이진 탐색 트리의 평균 시간 복잡도는 O(log n)이다. O(1)이 아니다.', false),
       (224, 84, '중복 값을 허용한다',
        '일반적으로 이진 탐색 트리는 중복 값을 허용하지 않는다. 각 노드는 고유한 값을 가진다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (27, 80, 'o(log n),로그시간,logarithmic time',
        '이진 탐색 트리에서 탐색, 삽입, 삭제의 평균 시간 복잡도는 O(log n)이다. 균형잡힌 트리에서 각 단계마다 탐색 범위가 절반으로 줄어들기 때문이다. 단, 편향 트리의 경우 O(n)으로 저하될 수 있다.'),
       (28, 83, '중위 순회,중위순회,inorder,in-order traversal,in-order',
        '이진 탐색 트리를 중위 순회(왼쪽 자식 → 부모 → 오른쪽 자식)하면 자동으로 오름차순 정렬된 순서로 값을 얻을 수 있다. 이는 BST의 대소 관계 규칙 덕분이다.');

-- =====================================================
-- Lesson 3: 이진 탐색 트리 응용 문제집
-- =====================================================

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (85, 15, '제시된 내용과 관련하여 옳은 것은?', '이진 탐색 트리에서 노드를 삭제할 때는 경우를 나누어 처리한다.', 'OBJECTIVE'),
       (86, 15, '빈칸에 들어갈 알맞은 말을 작성하시오', '자식이 2개인 노드를 삭제할 때는 왼쪽 서브 트리의 ___또는 오른쪽 서브 트리의 최소값으로 대체한다.', 'SUBJECTIVE'),
       (87, 15, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '편향 트리(Skewed Tree)는 이진 탐색 트리의 한 형태이다.', 'OBJECTIVE'),
       (88, 15, '제시된 내용과 관련하여 옳은 것은?', '이진 탐색 트리의 편향 문제를 해결한 자료구조들이 있다.', 'OBJECTIVE'),
       (89, 15, '빈칸에 들어갈 알맞은 말을 작성하시오', '편향 트리에서 탐색, 삽입, 삭제의 시간 복잡도는 ___이다.', 'SUBJECTIVE'),
       (90, 15, '아래 제시한 개념에 대한 설명으로 옳은 것은?', '이진 탐색 트리는 다양한 상황에서 활용된다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (225, 85, '항상 루트 노드만 삭제할 수 있다',
        '이진 탐색 트리에서는 어떤 노드든 삭제할 수 있다. 루트 노드만 삭제할 수 있다는 제약은 없다.', false),
       (226, 85, '삭제 후 트리를 재구성해야 한다',
        '적절한 후계자 노드를 선택하면 트리 전체를 재구성할 필요 없이 국지적으로 조정만 하면 된다.', false),
       (227, 85, '자식이 없으면 삭제, 1개면 자식을 올리고, 2개면 후계자로 대체한다',
        '이진 탐색 트리의 삭제는 3가지 경우로 나뉜다. 자식이 없으면 단순 삭제, 1개면 자식을 부모 위치로 올리고, 2개면 왼쪽 서브 트리의 최대값 또는 오른쪽 서브 트리의 최소값으로 대체한다.',
        true),
       (228, 85, '삭제는 불가능하고 표시만 한다',
        '이진 탐색 트리에서는 실제 노드 삭제가 가능하다. 표시만 하는 것은 특정 구현 방식일 뿐이다.', false),

       (229, 87, '편향 트리는 균형잡힌 최적의 상태이다',
        '편향 트리는 균형이 깨진 최악의 상태이다. 연결리스트와 유사한 형태가 되어 BST의 이점을 상실한다.', false),
       (230, 87, '편향 트리에서도 탐색이 O(log n)이다',
        '편향 트리에서는 탐색이 O(n)으로 저하된다. 한쪽 방향으로만 탐색이 진행되기 때문이다.', false),
       (231, 87, '정렬된 데이터를 순차적으로 삽입하면 한쪽으로 편향된다',
        '정렬된 데이터(1, 2, 3, ...)를 순차적으로 삽입하면 한쪽으로 편향되는 구조가 된다. 이 경우 트리의 높이가 n이 되어 탐색/삽입/삭제가 O(n)으로 저하된다.', true),
       (232, 87, '랜덤 데이터 삽입 시 항상 편향 트리가 된다',
        '랜덤 데이터를 삽입하면 일반적으로 어느 정도 균형잡힌 트리가 형성된다. 정렬된 데이터를 순차 삽입할 때 편향된다.', false),

       (233, 88, '스택, 큐',
        '스택과 큐는 특정 순서로 데이터를 처리하는 선형 자료구조로, BST의 편향 문제와는 관련이 없다.', false),
       (234, 88, 'AVL 트리, Red-Black 트리',
        'AVL 트리와 Red-Black 트리는 자가 균형(Self-Balancing) 이진 탐색 트리로, 삽입/삭제 시 자동으로 균형을 맞추어 항상 O(log n)의 성능을 보장한다.', true),
       (235, 88, '배열, 연결리스트',
        '배열과 연결리스트는 기본 선형 자료구조로, BST의 균형 문제를 해결하는 자료구조가 아니다.', false),
       (236, 88, '해시 테이블',
        '해시 테이블은 O(1) 탐색을 제공하는 자료구조이지만, BST의 편향 문제를 해결하기 위한 것이 아니며 정렬된 순회가 불가능하다.', false),

       (237, 90, '프로세스 스케줄링',
        '프로세스 스케줄링은 우선순위 큐나 일반 큐를 주로 사용한다. BST를 직접 사용하지는 않는다.', false),
       (238, 90, '네트워크 패킷 전송',
        '네트워크 패킷 전송은 큐나 버퍼를 사용한다. 계층적 탐색 구조가 필요하지 않으므로 BST를 사용하지 않는다.', false),
       (239, 90, '데이터베이스 인덱싱',
        '데이터베이스는 B-Tree나 B+Tree 등 균형잡힌 트리 구조를 인덱싱에 활용한다. 이는 BST의 확장된 형태로 효율적인 탐색과 범위 검색을 제공한다.', true),
       (240, 90, '스택 메모리 관리',
        '스택 메모리는 LIFO 구조의 스택 자료구조로 관리된다. BST와는 관련이 없다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (29, 86, '최대값,최댓값,maximum,max,가장 큰 값',
        '자식이 2개인 노드를 삭제할 때는 왼쪽 서브 트리의 최대값(가장 오른쪽 노드) 또는 오른쪽 서브 트리의 최소값(가장 왼쪽 노드)으로 대체한다. 이렇게 하면 BST의 대소 관계 규칙이 유지된다.'),
       (30, 89, 'o(n),선형시간,linear time',
        '편향 트리에서는 트리의 높이가 n이 되므로 탐색, 삽입, 삭제의 시간 복잡도가 O(n)으로 저하된다. 이는 연결리스트와 동일한 성능으로, BST의 이점을 완전히 상실한 상태이다.');
