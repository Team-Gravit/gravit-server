-- Chapter: 자료구조 (id: 1), Unit: 배열 (id: 1)

-- Lesson 생성
INSERT INTO lesson (id, unit_id, title)
VALUES (1, 1, '배열 기초 문제집'),
       (2, 1, '배열 심화 문제집'),
       (3, 1, '배열 응용 문제집');

-- Chapter: 자료구조 (id: 1), Unit: 배열 (id: 1), Lesson: 배열 기초 문제집 (id: 1)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (1, 1, '다음 중 배열의 특징으로 올바른 것은?', '배열(Array)은 메모리 상에서 데이터를 저장하는 자료구조이다.', 'OBJECTIVE'),
       (2, 1, '다음 중 배열의 시간 복잡도로 올바른 것은?', '배열은 인덱스를 통해 요소에 접근할 수 있는 자료구조이다.', 'OBJECTIVE'),
       (3, 1, '빈칸에 들어갈 용어를 작성하시오', '배열은 논리적 저장 순서와 물리적 저장 순서가 ___하는 자료구조이다.', 'SUBJECTIVE'),
       (4, 1, '다음 중 배열의 단점으로 올바른 것은?', '배열은 다양한 장단점을 가진 자료구조이다.', 'OBJECTIVE'),
       (5, 1, '빈칸에 들어갈 시간 복잡도를 작성하시오', '배열에서 특정 인덱스의 원소에 접근하는 시간 복잡도는 ___이다.', 'SUBJECTIVE'),
       (6, 1, '다음 중 배열의 메모리 특성으로 올바른 것은?', '배열은 메모리 상에서 특정한 방식으로 데이터를 저장한다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (1, 1, '연속된 메모리 공간에 데이터를 저장한다', '배열은 메모리 상에서 연속된 공간에 데이터를 순차적으로 저장한다. 이로 인해 인덱스를 통한 빠른 접근이 가능하며, 캐시 지역성도 높다.',
        true),
       (2, 1, '비연속적인 메모리 공간에 데이터를 저장한다',
        '비연속적인 메모리 공간에 데이터를 저장하는 것은 연결리스트의 특징이다. 배열은 연속된 메모리 공간에 데이터를 저장하여 인덱스 기반의 빠른 접근을 가능하게 한다.', false),
       (3, 1, '포인터를 통해 다음 요소를 참조한다', '포인터를 통해 다음 요소를 참조하는 것은 연결리스트의 특징이다. 배열은 인덱스를 통해 직접 접근하며, 포인터를 사용하지 않는다.', false),
       (4, 1, '삽입과 삭제가 O(1) 시간에 가능하다',
        '배열은 중간에 원소를 삽입하거나 삭제할 때 이후의 모든 원소를 이동시켜야 하므로 O(n)의 시간 복잡도를 가진다. O(1) 시간의 삽입과 삭제는 배열의 장점이 아니다.', false),

       (5, 2, '접근: O(1), 탐색: O(n)',
        '배열은 인덱스를 통한 직접 접근이 가능하므로 접근 시간 복잡도는 O(1)이다. 하지만 특정 값을 찾기 위해서는 배열을 순차적으로 탐색해야 하므로 탐색 시간 복잡도는 O(n)이다.', true),
       (6, 2, '접근: O(n), 탐색: O(1)',
        '배열은 인덱스를 통해 O(1) 시간에 접근이 가능하다. 반대로 특정 값을 찾는 탐색은 순차적으로 확인해야 하므로 O(n)이 소요된다. 따라서 접근과 탐색의 시간 복잡도가 반대이다.', false),
       (7, 2, '접근: O(1), 탐색: O(1)',
        '탐색이 O(1)이 되려면 해시테이블과 같은 자료구조가 필요하다. 배열은 인덱스를 통한 접근은 O(1)이지만, 특정 값을 찾는 탐색은 O(n)의 시간이 소요된다.', false),
       (8, 2, '접근: O(n), 탐색: O(n)',
        '배열의 접근 시간 복잡도는 O(1)이다. 인덱스를 통해 메모리 주소를 계산하여 바로 접근할 수 있기 때문이다. 탐색은 O(n)이 맞지만 접근은 O(n)이 아니다.', false),

       (9, 4, '크기가 고정되어 있다',
        '배열은 생성 시 크기를 지정해야 하며, 이후 크기를 변경할 수 없다. 크기를 늘리려면 더 큰 배열을 새로 생성하고 기존 데이터를 복사해야 하므로 O(n)의 비용이 발생한다.', true),
       (10, 4, '인덱스로 접근할 수 없다', '배열의 가장 큰 장점은 인덱스를 통한 O(1) 시간의 직접 접근이다. 인덱스로 접근할 수 없다는 것은 배열의 단점이 아니라 잘못된 설명이다.',
        false),
       (11, 4, '메모리를 전혀 사용하지 않는다',
        '배열은 연속된 메모리 공간을 사용하여 데이터를 저장한다. 오히려 사용하지 않는 공간도 미리 할당되므로 메모리 낭비가 발생할 수 있다는 것이 단점이다.', false),
       (12, 4, '삽입과 삭제가 매우 빠르다', '배열은 중간에 원소를 삽입하거나 삭제할 때 이후의 모든 원소를 이동시켜야 하므로 O(n)의 시간이 소요된다. 이는 배열의 장점이 아니라 단점이다.',
        false),

       (13, 6, '캐시 지역성이 높다',
        '배열은 메모리 상에서 연속적으로 저장되므로 CPU가 특정 요소에 접근할 때 인접한 메모리 영역도 함께 캐시에 로드된다. 이로 인해 캐시 히트율이 높아지고 성능이 향상된다.', true),
       (14, 6, '포인터를 사용하여 연결된다', '포인터를 사용하여 노드를 연결하는 것은 연결리스트의 특징이다. 배열은 연속된 메모리 공간에 데이터를 저장하며 포인터를 사용하지 않는다.', false),
       (15, 6, '동적으로 크기가 변경된다',
        '배열은 생성 시 크기가 고정되며 동적으로 크기를 변경할 수 없다. Python의 list나 Java의 ArrayList는 내부적으로 크기를 조정하지만, 기본 배열 자체는 고정 크기이다.',
        false),
       (16, 6, '각 요소가 독립적인 메모리 블록을 사용한다', '배열의 모든 요소는 연속된 하나의 메모리 블록 내에 저장된다. 각 요소가 독립적인 메모리 블록을 사용하는 것은 연결리스트의 특징이다.',
        false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (1, 3, '일치, 같음, 동일',
        '배열은 논리적 저장 순서와 물리적 저장 순서가 일치하는 자료구조이다. 이는 배열의 첫 번째 요소가 메모리 상에서도 첫 번째에 위치하고, 두 번째 요소가 그 다음에 연속적으로 위치함을 의미한다. 이러한 특성 덕분에 인덱스를 통한 O(1) 시간의 직접 접근이 가능하다.'),
       (2, 5, 'O(1)',
        '배열에서 특정 인덱스의 원소에 접근하는 시간 복잡도는 O(1)이다. 배열의 시작 주소와 인덱스, 요소의 크기를 알면 "시작 주소 + (인덱스 × 요소 크기)"라는 간단한 산술 연산으로 메모리 주소를 계산할 수 있기 때문이다. 이는 배열의 가장 큰 장점 중 하나이다.');

-- Chapter: 자료구조 (id: 1), Unit: 배열 (id: 1), Lesson: 배열 심화 문제집 (id: 2)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (7, 2, '다음 중 배열의 삽입 과정에 대한 설명으로 올바른 것은?', '배열의 중간에 새로운 원소를 삽입하는 과정을 설명한 것이다.', 'OBJECTIVE'),
       (8, 2, '빈칸에 들어갈 시간 복잡도를 작성하시오', '배열의 맨 앞에 원소를 삽입하는 최악의 경우 시간 복잡도는 ___이다.', 'SUBJECTIVE'),
       (9, 2, '다음 중 배열과 연결리스트의 비교로 올바른 것은?', '배열과 연결리스트는 각각 다른 특성을 가진 자료구조이다.', 'OBJECTIVE'),
       (10, 2, '다음 중 배열의 삭제 과정에 대한 설명으로 올바른 것은?', '배열의 중간에 있는 원소를 삭제하는 과정을 설명한 것이다.', 'OBJECTIVE'),
       (11, 2, '빈칸에 들어갈 용어를 작성하시오', '배열은 메모리 상에서 연속적으로 저장되어 ___이 좋다.', 'SUBJECTIVE'),
       (12, 2, '다음 중 배열의 활용 사례로 적절한 것은?', '배열은 다양한 상황에서 활용될 수 있는 자료구조이다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (17, 7, '삽입 위치 이후의 모든 원소를 오른쪽으로 이동시킨다',
        '배열 중간에 원소를 삽입하려면 삽입 위치 이후의 모든 원소를 한 칸씩 오른쪽으로 이동시켜 공간을 만들어야 한다. 이로 인해 최악의 경우 O(n)의 시간 복잡도가 발생한다.', true),
       (18, 7, '포인터만 변경하면 바로 삽입할 수 있다', '포인터만 변경하여 삽입하는 것은 연결리스트의 특징이다. 배열은 연속된 메모리 구조를 유지해야 하므로 원소들을 이동시켜야 한다.',
        false),
       (19, 7, '삽입 위치의 원소만 교체하면 된다', '단순히 원소를 교체하는 것은 삽입이 아니라 수정이다. 삽입은 새로운 원소를 추가하는 것이므로 기존 원소들을 이동시켜 공간을 확보해야 한다.',
        false),
       (20, 7, '배열의 크기가 자동으로 증가한다',
        '기본 배열은 크기가 고정되어 있으며 자동으로 증가하지 않는다. Python의 list나 Java의 ArrayList는 내부적으로 크기를 조정하지만, 이는 새로운 배열을 생성하고 복사하는 과정을 거친다.',
        false),

       (21, 9, '배열은 접근이 빠르고, 연결리스트는 삽입/삭제가 빠르다',
        '배열은 인덱스를 통한 O(1) 접근이 가능하지만 삽입/삭제는 O(n)이 소요된다. 연결리스트는 접근에 O(n)이 필요하지만 위치를 알고 있다면 삽입/삭제는 O(1)에 가능하다. 따라서 접근이 빈번하면 배열, 삽입/삭제가 빈번하면 연결리스트가 적합하다.',
        true),
       (22, 9, '배열은 메모리를 낭비하지만, 연결리스트는 메모리 효율이 높다',
        '배열은 사용하지 않는 공간도 미리 할당되어 메모리 낭비가 있을 수 있다. 하지만 연결리스트도 포인터 저장을 위한 추가 메모리가 필요하므로 메모리 효율이 항상 높다고 할 수 없다.', false),
       (23, 9, '배열과 연결리스트는 동일한 시간 복잡도를 가진다',
        '배열과 연결리스트는 각 연산에서 다른 시간 복잡도를 가진다. 배열은 접근 O(1), 삽입/삭제 O(n)이며, 연결리스트는 접근 O(n), 삽입/삭제 O(1)이다.', false),
       (24, 9, '연결리스트는 캐시 지역성이 배열보다 높다',
        '연결리스트는 노드들이 메모리 상에서 비연속적으로 배치되므로 캐시 지역성이 낮다. 배열은 연속적으로 저장되어 캐시 지역성이 높아 성능상 이점이 있다.', false),

       (25, 10, '삭제 후 뒤의 모든 원소를 왼쪽으로 이동시킨다',
        '배열에서 중간 원소를 삭제하면 연속성을 유지하기 위해 삭제 위치 이후의 모든 원소를 한 칸씩 왼쪽으로 이동시켜야 한다. 이로 인해 최악의 경우 O(n)의 시간 복잡도가 발생한다.', true),
       (26, 10, '포인터만 변경하면 바로 삭제할 수 있다',
        '포인터만 변경하여 삭제하는 것은 연결리스트의 특징이다. 배열은 연속된 메모리 구조를 유지해야 하므로 원소들을 이동시켜 빈 공간을 채워야 한다.', false),
       (27, 10, '삭제된 위치에 null을 넣으면 된다',
        '단순히 null을 넣는 것은 삭제가 아니라 값을 비우는 것이다. 배열의 삭제는 원소를 제거하고 뒤의 원소들을 이동시켜 연속성을 유지하는 과정을 포함한다.', false),
       (28, 10, '배열의 크기가 자동으로 감소한다', '기본 배열은 크기가 고정되어 있으며 원소를 삭제해도 크기가 자동으로 감소하지 않는다. 단지 유효한 원소의 개수만 줄어들 뿐이다.', false),

       (29, 12, '조회가 빈번하고 크기가 일정한 데이터',
        '배열은 인덱스를 통한 O(1) 접근이 가능하므로 조회가 빈번한 경우에 적합하다. 또한 크기가 일정하면 고정 크기라는 배열의 단점이 문제가 되지 않는다.', true),
       (30, 12, '삽입과 삭제가 빈번한 데이터', '삽입과 삭제가 빈번한 경우에는 연결리스트가 더 적합하다. 배열은 삽입/삭제 시 원소 이동이 필요하여 O(n)의 비용이 발생하기 때문이다.',
        false),
       (31, 12, '크기를 자주 변경해야 하는 데이터',
        '크기를 자주 변경해야 하는 경우에는 동적 배열(ArrayList 등)이나 연결리스트가 더 적합하다. 기본 배열은 크기가 고정되어 있어 크기 변경이 비효율적이다.', false),
       (32, 12, '메모리가 비연속적으로 할당되어야 하는 데이터', '배열은 연속된 메모리 공간을 사용하는 자료구조이다. 메모리가 비연속적으로 할당되어야 하는 경우에는 연결리스트가 적합하다.',
        false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (3, 8, 'O(n)',
        '배열의 맨 앞에 원소를 삽입하는 경우, 기존의 모든 원소를 한 칸씩 오른쪽으로 이동시켜야 한다. 배열에 n개의 원소가 있다면 n번의 이동 연산이 필요하므로 시간 복잡도는 O(n)이다. 이는 배열 삽입의 최악의 경우에 해당한다.'),
       (4, 11, '캐시 지역성, cache locality',
        '배열은 메모리 상에서 연속적으로 저장되므로 캐시 지역성이 좋다. CPU가 특정 요소에 접근할 때 인접한 메모리 영역도 함께 캐시에 로드되므로, 순차적인 접근 시 캐시 히트율이 높아져 성능이 향상된다. 이는 배열의 중요한 성능상 이점이다.');

-- Chapter: 자료구조 (id: 1), Unit: 배열 (id: 1), Lesson: 배열 응용 문제집 (id: 3)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (13, 3, '다음 중 배열의 메모리 주소 계산 방식으로 올바른 것은?', '배열에서 특정 인덱스의 메모리 주소를 계산하는 방식을 설명한 것이다.', 'OBJECTIVE'),
       (14, 3, '빈칸에 들어갈 개념을 작성하시오', '배열은 크기를 확장하려면 더 큰 배열을 생성하고 기존 데이터를 ___해야 한다.', 'SUBJECTIVE'),
       (15, 3, '다음 중 다차원 배열에 대한 설명으로 올바른 것은?', '다차원 배열은 배열 안에 배열을 포함하는 구조이다.', 'OBJECTIVE'),
       (16, 3, '다음 중 Python의 list와 기본 배열의 차이점으로 올바른 것은?', 'Python의 list는 내부적으로 배열을 사용하지만 추가 기능을 제공한다.', 'OBJECTIVE'),
       (17, 3, '빈칸에 들어갈 용어를 작성하시오', '배열에서 원소들이 메모리 상에서 연속적으로 배치되는 특성을 ___라고 한다.', 'SUBJECTIVE'),
       (18, 3, '다음 중 배열의 한계를 극복한 자료구조로 올바른 것은?', '배열의 고정 크기와 삽입/삭제의 비효율성을 개선한 자료구조가 있다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (33, 13, '시작 주소 + (인덱스 × 원소 크기)',
        '배열의 메모리 주소는 "시작 주소 + (인덱스 × 원소 크기)"로 계산된다. 예를 들어 시작 주소가 1000이고 각 원소가 4바이트라면, arr[2]의 주소는 1000 + (2 × 4) = 1008이다. 이러한 간단한 산술 연산으로 O(1) 시간에 접근할 수 있다.',
        true),
       (34, 13, '시작 주소 + 인덱스',
        '원소의 크기를 고려하지 않은 잘못된 계산 방식이다. 각 원소가 차지하는 메모리 크기를 곱해주어야 정확한 주소를 얻을 수 있다. 정확한 계산식은 "시작 주소 + (인덱스 × 원소 크기)"이다.',
        false),
       (35, 13, '포인터를 따라가며 탐색', '포인터를 따라가며 탐색하는 것은 연결리스트의 방식이다. 배열은 인덱스와 원소 크기를 이용한 산술 연산으로 메모리 주소를 직접 계산한다.', false),
       (36, 13, '이진 탐색을 통해 주소 계산', '이진 탐색은 정렬된 배열에서 값을 찾는 알고리즘이지, 메모리 주소를 계산하는 방식이 아니다. 배열은 간단한 산술 연산으로 주소를 계산한다.',
        false),

       (37, 15, '2차원 배열은 행과 열로 구성된다',
        '2차원 배열은 행(row)과 열(column)로 구성된 표 형태의 자료구조이다. 실제 메모리 상에서는 1차원으로 연속 저장되지만, 논리적으로는 2차원 구조로 접근할 수 있다. arr[i][j] 형태로 접근하며, 행렬 연산 등에 활용된다.',
        true),
       (38, 15, '다차원 배열은 포인터로 연결된다', '다차원 배열도 메모리 상에서는 연속적으로 저장되며, 포인터로 연결되지 않는다. 포인터를 사용하는 것은 연결리스트의 특징이다.', false),
       (39, 15, '3차원 이상의 배열은 생성할 수 없다',
        '대부분의 프로그래밍 언어는 3차원 이상의 다차원 배열도 생성할 수 있다. 다만 차원이 높아질수록 메모리 사용량이 기하급수적으로 증가하고 관리가 복잡해진다.', false),
       (40, 15, '다차원 배열은 크기를 동적으로 변경할 수 있다', '다차원 배열도 기본 배열과 마찬가지로 생성 시 크기가 고정된다. 크기를 변경하려면 새로운 배열을 생성하고 데이터를 복사해야 한다.',
        false),

       (41, 16, 'list는 크기를 동적으로 조정할 수 있다',
        'Python의 list는 내부적으로 동적 배열로 구현되어 있어, 원소 추가 시 자동으로 크기를 조정한다. 기본 배열은 고정 크기이지만, list는 필요에 따라 내부 배열을 재할당하여 크기를 늘린다.',
        true),
       (42, 16, 'list는 인덱스로 접근할 수 없다',
        'Python의 list도 배열처럼 인덱스를 통한 O(1) 시간의 접근이 가능하다. list[i] 형태로 접근하며, 이는 list의 주요 장점 중 하나이다.', false),
       (43, 16, 'list는 메모리를 전혀 사용하지 않는다',
        'Python의 list는 내부적으로 배열을 사용하므로 당연히 메모리를 사용한다. 오히려 동적 크기 조정을 위한 추가 메모리가 필요할 수 있다.', false),
       (44, 16, 'list는 연속된 메모리를 사용하지 않는다',
        'Python의 list는 내부적으로 연속된 메모리 공간을 사용하는 배열로 구현되어 있다. 다만 원소 추가 시 공간이 부족하면 더 큰 연속 공간으로 이동한다.', false),

       (45, 18, '연결리스트',
        '연결리스트는 각 노드가 포인터로 연결되어 있어 크기 제약이 없고, 삽입/삭제 시 포인터만 변경하면 되므로 O(1)에 가능하다. 이는 배열의 고정 크기와 O(n) 삽입/삭제 문제를 해결한 자료구조이다.',
        true),
       (46, 18, '스택', '스택은 LIFO 구조의 자료구조로, 배열이나 연결리스트로 구현될 수 있다. 배열의 한계를 극복한 자료구조라기보다는 특정 동작 방식을 정의한 추상 자료형이다.', false),
       (47, 18, '큐', '큐는 FIFO 구조의 자료구조로, 배열이나 연결리스트로 구현될 수 있다. 배열의 한계를 극복한 자료구조라기보다는 특정 동작 방식을 정의한 추상 자료형이다.', false),
       (48, 18, '트리', '트리는 계층적 구조를 표현하는 비선형 자료구조이다. 배열의 한계를 극복하기 위한 목적보다는 계층 관계를 표현하기 위해 설계된 자료구조이다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (5, 14, '복사, copy, 이동',
        '배열의 크기를 확장하려면 더 큰 새로운 배열을 생성하고, 기존 배열의 모든 데이터를 새 배열로 복사해야 한다. 이 과정은 O(n)의 시간이 소요되며, 이는 배열의 크기 변경이 비효율적인 이유이다. Python의 list나 Java의 ArrayList는 내부적으로 이러한 복사 과정을 자동으로 수행한다.'),
       (6, 17, '연속성, contiguity, 순차성',
        '배열의 원소들이 메모리 상에서 연속적으로 배치되는 특성을 연속성 또는 순차성이라고 한다. 이러한 연속성 덕분에 인덱스를 통한 빠른 접근이 가능하고, 캐시 지역성이 높아져 성능상 이점을 얻을 수 있다. 이는 배열의 핵심 특성이자 장점이다.');

-- Chapter: 자료구조 (id: 1), Unit: 연결리스트 (id: 2)

-- Lesson 생성
INSERT INTO lesson (id, unit_id, title)
VALUES (4, 2, '연결리스트 기초 문제집'),
       (5, 2, '연결리스트 심화 문제집'),
       (6, 2, '연결리스트 응용 문제집');

-- Chapter: 자료구조 (id: 1), Unit: 연결리스트 (id: 2), Lesson: 연결리스트 기초 문제집 (id: 4)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (19, 4, '다음 중 연결리스트의 특징으로 올바른 것은?', '연결리스트(Linked List)는 노드들이 연결된 자료구조이다.', 'OBJECTIVE'),
       (20, 4, '다음 중 연결리스트의 시간 복잡도로 올바른 것은?', '연결리스트는 포인터를 통해 노드에 접근하는 자료구조이다.', 'OBJECTIVE'),
       (21, 4, '빈칸에 들어갈 용어를 작성하시오', '연결리스트의 각 노드는 데이터 영역과 ___로 구성된다.', 'SUBJECTIVE'),
       (22, 4, '다음 중 연결리스트의 장점으로 올바른 것은?', '연결리스트는 다양한 장단점을 가진 자료구조이다.', 'OBJECTIVE'),
       (23, 4, '빈칸에 들어갈 시간 복잡도를 작성하시오', '연결리스트에서 삽입 위치를 알고 있을 때 삽입 연산의 시간 복잡도는 ___이다.', 'SUBJECTIVE'),
       (24, 4, '다음 중 연결리스트의 메모리 특성으로 올바른 것은?', '연결리스트는 메모리 상에서 특정한 방식으로 데이터를 저장한다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (49, 19, '노드가 데이터와 포인터로 구성된다',
        '연결리스트의 각 노드는 데이터 영역과 다음 노드를 가리키는 포인터로 구성된다. 이러한 구조로 인해 물리적 저장 순서와 논리적 저장 순서가 일치하지 않으며, 동적 확장이 가능하다.', true),
       (50, 19, '연속된 메모리 공간에 저장된다', '연속된 메모리 공간에 저장되는 것은 배열의 특징이다. 연결리스트는 노드들이 메모리 상에서 비연속적으로 배치되며 포인터로 연결된다.',
        false),
       (51, 19, '인덱스를 통해 직접 접근할 수 있다', '인덱스를 통한 직접 접근은 배열의 특징이다. 연결리스트는 인덱스가 없으며 순차 접근만 가능하다.', false),
       (52, 19, '크기가 고정되어 있다', '크기가 고정되어 있는 것은 기본 배열의 특징이다. 연결리스트는 동적으로 노드를 추가하거나 삭제할 수 있어 크기 제약이 없다.', false),

       (53, 20, '접근: O(n), 삽입/삭제: O(1)',
        '연결리스트는 특정 위치에 접근하려면 처음부터 순차적으로 탐색해야 하므로 O(n)이 소요된다. 하지만 삽입/삭제 위치를 알고 있다면 포인터만 변경하면 되므로 O(1)에 가능하다.', true),
       (54, 20, '접근: O(1), 삽입/삭제: O(n)', '이는 배열의 시간 복잡도이다. 연결리스트는 접근에 O(n), 삽입/삭제에 O(1)(위치를 아는 경우)이 소요된다.', false),
       (55, 20, '접근: O(1), 삽입/삭제: O(1)', '연결리스트는 인덱스가 없어 특정 위치에 O(1) 시간에 접근할 수 없다. 처음부터 순차적으로 탐색해야 하므로 접근은 O(n)이다.',
        false),
       (56, 20, '접근: O(n), 삽입/삭제: O(n)', '삽입/삭제 위치를 알고 있다면 포인터만 조정하면 되므로 O(1)에 가능하다. O(n)이 소요되는 것은 삽입/삭제 위치를 찾는 탐색 과정이다.',
        false),

       (57, 22, '동적으로 크기를 확장할 수 있다',
        '연결리스트는 노드를 동적으로 추가하거나 삭제할 수 있어 크기 제약이 없다. 배열처럼 미리 크기를 지정할 필요가 없으며, 필요에 따라 메모리를 할당받아 확장할 수 있다.', true),
       (58, 22, '인덱스를 통한 빠른 접근이 가능하다', '인덱스를 통한 빠른 접근은 배열의 장점이다. 연결리스트는 인덱스가 없어 순차 접근만 가능하므로 접근 속도가 느리다.', false),
       (59, 22, '캐시 지역성이 높다',
        '연결리스트는 노드들이 메모리 상에서 비연속적으로 배치되므로 캐시 지역성이 낮다. 캐시 지역성이 높은 것은 연속된 메모리를 사용하는 배열의 장점이다.', false),
       (60, 22, '추가 메모리가 필요하지 않다', '연결리스트는 각 노드마다 포인터를 저장해야 하므로 데이터 외에 추가 메모리가 필요하다. 이는 연결리스트의 단점 중 하나이다.', false),

       (61, 24, '노드들이 메모리 상에서 비연속적으로 배치된다',
        '연결리스트의 노드들은 메모리 상에서 비연속적으로 배치되며, 포인터를 통해 논리적으로 연결된다. 이러한 특성으로 인해 동적 확장이 가능하지만 캐시 지역성은 낮아진다.', true),
       (62, 24, '모든 노드가 연속된 메모리에 저장된다', '연속된 메모리에 저장되는 것은 배열의 특징이다. 연결리스트는 노드들이 메모리 상에서 흩어져 있고 포인터로 연결된다.', false),
       (63, 24, '고정된 크기의 메모리를 미리 할당한다', '고정된 크기의 메모리를 미리 할당하는 것은 배열의 특징이다. 연결리스트는 필요할 때마다 동적으로 노드를 생성한다.', false),
       (64, 24, '인덱스를 통해 메모리 주소를 계산한다', '인덱스를 통한 메모리 주소 계산은 배열의 특징이다. 연결리스트는 인덱스가 없으며 포인터를 따라 순차적으로 접근한다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (7, 21, '포인터, pointer, 다음 노드의 주소',
        '연결리스트의 각 노드는 데이터 영역과 다음 노드를 가리키는 포인터(또는 다음 노드의 주소)로 구성된다. 이 포인터를 통해 노드들이 논리적으로 연결되며, 이러한 구조로 인해 동적 확장과 효율적인 삽입/삭제가 가능하다.'),
       (8, 23, 'O(1)',
        '연결리스트에서 삽입 위치를 이미 알고 있다면, 해당 위치의 포인터만 변경하면 되므로 O(1)의 시간 복잡도를 가진다. 새 노드의 포인터를 다음 노드로 설정하고, 이전 노드의 포인터를 새 노드로 변경하는 두 단계만 필요하다. 다만 삽입 위치를 찾는 탐색 과정까지 포함하면 O(n)이 된다.');

-- Chapter: 자료구조 (id: 1), Unit: 연결리스트 (id: 2), Lesson: 연결리스트 심화 문제집 (id: 5)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (25, 5, '다음 중 연결리스트의 삽입 과정에 대한 설명으로 올바른 것은?', '연결리스트에 새로운 노드를 삽입하는 과정을 설명한 것이다.', 'OBJECTIVE'),
       (26, 5, '빈칸에 들어갈 시간 복잡도를 작성하시오', '연결리스트에서 특정 값을 탐색할 때의 시간 복잡도는 ___이다.', 'SUBJECTIVE'),
       (27, 5, '다음 중 연결리스트와 배열의 비교로 올바른 것은?', '연결리스트와 배열은 서로 다른 특성을 가진 자료구조이다.', 'OBJECTIVE'),
       (28, 5, '다음 중 연결리스트의 삭제 과정에 대한 설명으로 올바른 것은?', '연결리스트에서 노드를 삭제하는 과정을 설명한 것이다.', 'OBJECTIVE'),
       (29, 5, '빈칸에 들어갈 용어를 작성하시오', '연결리스트는 논리적 저장 순서와 물리적 저장 순서가 ___하지 않는다.', 'SUBJECTIVE'),
       (30, 5, '다음 중 연결리스트의 단점으로 올바른 것은?', '연결리스트는 여러 단점을 가지고 있다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (65, 25, '새 노드의 포인터를 설정하고 이전 노드의 포인터를 변경한다',
        '연결리스트의 삽입은 1) 새 노드의 포인터를 다음 노드로 설정하고, 2) 이전 노드의 포인터를 새 노드로 변경하는 두 단계로 이루어진다. 포인터 영역만 변경하면 되므로 O(1)의 시간 복잡도를 가진다.',
        true),
       (66, 25, '모든 노드를 한 칸씩 이동시킨다', '모든 노드를 이동시키는 것은 배열의 삽입 방식이다. 연결리스트는 포인터만 변경하면 되므로 노드를 이동시킬 필요가 없다.', false),
       (67, 25, '새로운 배열을 생성하고 복사한다', '새로운 배열을 생성하고 복사하는 것은 배열의 크기를 확장할 때 필요한 과정이다. 연결리스트는 동적으로 노드를 추가할 수 있어 이러한 과정이 불필요하다.',
        false),
       (68, 25, '인덱스를 재계산한다', '인덱스를 사용하는 것은 배열의 특징이다. 연결리스트는 인덱스가 없으며 포인터를 통해 노드를 연결한다.', false),

       (69, 27, '탐색/조회가 빈번하면 배열, 삽입/삭제가 빈번하면 연결리스트가 적합하다',
        '배열은 인덱스를 통한 O(1) 접근이 가능하므로 탐색/조회가 빈번한 경우에 적합하다. 연결리스트는 포인터 조정만으로 O(1) 삽입/삭제가 가능하므로(위치를 아는 경우) 삽입/삭제가 빈번한 경우에 적합하다.',
        true),
       (70, 27, '연결리스트가 배열보다 항상 빠르다', '연결리스트가 항상 빠른 것은 아니다. 접근/탐색은 배열이 빠르고, 삽입/삭제는 연결리스트가 빠르다. 사용 패턴에 따라 적합한 자료구조가 다르다.',
        false),
       (71, 27, '배열은 메모리를 낭비하지만 연결리스트는 메모리 효율이 높다',
        '배열은 사용하지 않는 공간도 미리 할당되어 메모리 낭비가 있을 수 있다. 하지만 연결리스트도 포인터 저장을 위한 추가 메모리가 필요하므로 항상 메모리 효율이 높다고 할 수 없다.', false),
       (72, 27, '연결리스트는 캐시 지역성이 배열보다 높다',
        '연결리스트는 노드들이 메모리 상에서 비연속적으로 배치되므로 캐시 지역성이 낮다. 배열은 연속적으로 저장되어 캐시 지역성이 높아 성능상 이점이 있다.', false),

       (73, 28, '이전 노드의 포인터를 다음 노드로 변경한다',
        '연결리스트의 삭제는 삭제할 노드의 이전 노드의 포인터를 다음 노드로 변경하는 방식으로 이루어진다. 포인터만 조정하면 되므로 O(1)의 시간 복잡도를 가진다. 삭제된 노드는 가비지 컬렉션에 의해 메모리에서 제거된다.',
        true),
       (74, 28, '모든 노드를 한 칸씩 이동시킨다', '모든 노드를 이동시키는 것은 배열의 삭제 방식이다. 연결리스트는 포인터만 변경하면 되므로 노드를 이동시킬 필요가 없다.', false),
       (75, 28, '삭제된 위치에 null을 넣는다', '단순히 null을 넣는 것은 삭제가 아니라 값을 비우는 것이다. 연결리스트의 삭제는 포인터를 조정하여 노드를 연결에서 제외시키는 과정이다.',
        false),
       (76, 28, '인덱스를 재조정한다', '인덱스를 사용하는 것은 배열의 특징이다. 연결리스트는 인덱스가 없으며 포인터를 통해 노드를 연결한다.', false),

       (77, 30, '인덱스가 없어 순차 접근만 가능하다',
        '연결리스트는 인덱스가 없어 특정 위치에 접근하려면 처음부터 순차적으로 탐색해야 한다. 이로 인해 n번째 요소에 접근하는 데 O(n)의 시간이 소요되며, 이는 배열의 O(1) 접근에 비해 비효율적이다.',
        true),
       (78, 30, '크기를 동적으로 변경할 수 없다', '크기를 동적으로 변경할 수 없는 것은 기본 배열의 단점이다. 연결리스트는 오히려 동적 확장이 가능한 것이 장점이다.', false),
       (79, 30, '메모리를 전혀 사용하지 않는다', '연결리스트는 각 노드마다 데이터와 포인터를 저장하므로 당연히 메모리를 사용한다. 오히려 포인터 때문에 추가 메모리가 필요하다.',
        false),
       (80, 30, '삽입과 삭제가 불가능하다', '삽입과 삭제가 불가능한 것이 아니라, 오히려 포인터 조정만으로 효율적인 삽입/삭제가 가능한 것이 연결리스트의 주요 장점이다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (9, 26, 'O(n)',
        '연결리스트에서 특정 값을 탐색하려면 처음 노드부터 시작하여 순차적으로 각 노드를 확인해야 한다. 최악의 경우 마지막 노드까지 모두 확인해야 하므로 시간 복잡도는 O(n)이다. 이는 인덱스를 통한 O(1) 접근이 가능한 배열에 비해 비효율적이다.'),
       (10, 29, '일치, 같음, 동일',
        '연결리스트는 논리적 저장 순서와 물리적 저장 순서가 일치하지 않는 자료구조이다. 논리적으로는 첫 번째 노드 다음에 두 번째 노드가 오지만, 물리적 메모리 상에서는 두 노드가 떨어져 있을 수 있다. 이러한 특성으로 인해 동적 확장이 가능하지만 캐시 지역성은 낮아진다.');

-- Chapter: 자료구조 (id: 1), Unit: 연결리스트 (id: 2), Lesson: 연결리스트 응용 문제집 (id: 6)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (31, 6, '다음 중 단일 연결리스트에 대한 설명으로 올바른 것은?', '단일 연결리스트는 가장 기본적인 형태의 연결리스트이다.', 'OBJECTIVE'),
       (32, 6, '빈칸에 들어갈 용어를 작성하시오', '이중 연결리스트는 각 노드가 이전 노드와 다음 노드 모두를 가리키는 ___를 가진다.', 'SUBJECTIVE'),
       (33, 6, '다음 중 이중 연결리스트의 장점으로 올바른 것은?', '이중 연결리스트는 단일 연결리스트를 개선한 자료구조이다.', 'OBJECTIVE'),
       (34, 6, '다음 중 원형 연결리스트에 대한 설명으로 올바른 것은?', '원형 연결리스트는 특수한 형태의 연결리스트이다.', 'OBJECTIVE'),
       (35, 6, '빈칸에 들어갈 연결리스트 종류를 작성하시오', '___은 각 노드가 다음 노드만 가리키며 단방향 순회만 가능하다.', 'SUBJECTIVE'),
       (36, 6, '다음 중 연결리스트의 활용 사례로 적절한 것은?', '연결리스트는 다양한 상황에서 활용될 수 있는 자료구조이다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (81, 31, '각 노드가 다음 노드만 가리킨다',
        '단일 연결리스트는 각 노드가 데이터와 다음 노드를 가리키는 포인터 하나만 가진다. 이로 인해 단방향 순회만 가능하며, 이전 노드로 돌아가려면 처음부터 다시 탐색해야 한다.', true),
       (82, 31, '양방향 순회가 가능하다', '양방향 순회가 가능한 것은 이중 연결리스트의 특징이다. 단일 연결리스트는 다음 노드 포인터만 있어 단방향 순회만 가능하다.', false),
       (83, 31, '마지막 노드가 첫 노드를 가리킨다', '마지막 노드가 첫 노드를 가리키는 것은 원형 연결리스트의 특징이다. 단일 연결리스트의 마지막 노드는 null을 가리킨다.', false),
       (84, 31, '각 노드가 이전 노드와 다음 노드 모두를 가리킨다', '이전 노드와 다음 노드 모두를 가리키는 것은 이중 연결리스트의 특징이다. 단일 연결리스트는 다음 노드만 가리킨다.',
        false),

       (85, 33, '양방향 순회가 가능하다',
        '이중 연결리스트는 각 노드가 이전 노드와 다음 노드 포인터를 모두 가지므로 양방향 순회가 가능하다. 앞으로도 뒤로도 자유롭게 이동할 수 있어 특정 위치에서의 삭제나 역방향 탐색이 효율적이다.', true),
       (86, 33, '메모리 사용량이 단일 연결리스트보다 적다',
        '이중 연결리스트는 각 노드가 포인터를 2개 가지므로 단일 연결리스트보다 메모리 사용량이 많다. 이는 이중 연결리스트의 단점이다.', false),
       (87, 33, '단방향 순회만 가능하다', '단방향 순회만 가능한 것은 단일 연결리스트의 특징이다. 이중 연결리스트는 양방향 순회가 가능한 것이 장점이다.', false),
       (88, 33, '포인터를 하나만 사용한다', '포인터를 하나만 사용하는 것은 단일 연결리스트이다. 이중 연결리스트는 이전 노드와 다음 노드를 가리키는 두 개의 포인터를 사용한다.',
        false),

       (89, 34, '마지막 노드가 첫 노드를 가리킨다',
        '원형 연결리스트는 마지막 노드의 포인터가 null이 아닌 첫 노드를 가리켜 순환 구조를 형성한다. 이로 인해 리스트의 끝에서 다시 처음으로 돌아갈 수 있으며, 라운드 로빈 스케줄링 등에 활용된다.', true),
       (90, 34, '마지막 노드가 null을 가리킨다', '마지막 노드가 null을 가리키는 것은 일반적인 단일/이중 연결리스트의 특징이다. 원형 연결리스트는 마지막 노드가 첫 노드를 가리킨다.',
        false),
       (91, 34, '양방향 순회만 가능하다', '양방향 순회는 이중 연결리스트의 특징이다. 원형 연결리스트는 순환 구조를 가지는 것이 특징이며, 단일 원형과 이중 원형 모두 가능하다.', false),
       (92, 34, '포인터를 사용하지 않는다', '원형 연결리스트도 노드들을 포인터로 연결한다. 다만 마지막 노드의 포인터가 null이 아닌 첫 노드를 가리킨다는 점이 다르다.',
        false),

       (93, 36, '삽입과 삭제가 빈번한 데이터',
        '연결리스트는 포인터 조정만으로 O(1) 시간에 삽입/삭제가 가능하므로(위치를 아는 경우), 삽입과 삭제가 빈번한 경우에 적합하다. 스택, 큐, 텍스트 에디터의 실행 취소 기능 등에 활용된다.', true),
       (94, 36, '인덱스 기반 접근이 빈번한 데이터', '인덱스 기반 접근이 빈번한 경우에는 O(1) 접근이 가능한 배열이 더 적합하다. 연결리스트는 순차 접근만 가능하여 O(n)이 소요된다.',
        false),
       (95, 36, '고정된 크기의 데이터', '고정된 크기의 데이터는 배열이 더 적합하다. 연결리스트의 장점은 동적 크기 조정이 가능하다는 점이므로, 고정 크기에서는 배열이 더 효율적이다.', false),
       (96, 36, '연속된 메모리가 필요한 데이터', '연속된 메모리가 필요한 경우에는 배열이 적합하다. 연결리스트는 노드들이 메모리 상에서 비연속적으로 배치되는 것이 특징이다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (11, 32, '포인터, pointer, 두 개의 포인터',
        '이중 연결리스트는 각 노드가 이전 노드와 다음 노드를 가리키는 두 개의 포인터를 가진다. 이로 인해 양방향 순회가 가능하며, 특정 노드에서 앞뒤로 자유롭게 이동할 수 있다. 하지만 포인터가 2개이므로 단일 연결리스트보다 메모리를 더 사용한다.'),
       (12, 35, '단일 연결리스트, Singly Linked List',
        '단일 연결리스트는 각 노드가 다음 노드만 가리키는 포인터 하나만 가지며, 단방향 순회만 가능한 가장 기본적인 형태의 연결리스트이다. 구현이 간단하고 메모리 사용량이 적지만, 이전 노드로 돌아갈 수 없다는 단점이 있다.');

-- Chapter: 자료구조 (id: 1), Unit: 스택 & 큐 (id: 3)

-- Lesson 생성
INSERT INTO lesson (id, unit_id, title)
VALUES (7, 3, '스택 기초 문제집'),
       (8, 3, '큐 기초 문제집'),
       (9, 3, '스택 & 큐 응용 문제집');

-- Chapter: 자료구조 (id: 1), Unit: 스택 & 큐 (id: 3), Lesson: 스택 기초 문제집 (id: 7)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (37, 7, '다음 중 스택의 특징으로 올바른 것은?', '스택(Stack)은 한쪽 끝에서만 데이터를 넣고 빼는 자료구조이다.', 'OBJECTIVE'),
       (38, 7, '빈칸에 들어갈 용어를 작성하시오', '스택은 ___구조로, 가장 나중에 들어온 데이터가 가장 먼저 나온다.', 'SUBJECTIVE'),
       (39, 7, '다음 중 스택의 주요 연산으로 올바른 것은?', '스택은 특정한 연산들을 통해 데이터를 관리한다.', 'OBJECTIVE'),
       (40, 7, '다음 중 스택 포인터에 대한 설명으로 올바른 것은?', '스택 포인터는 스택의 상태를 관리하는 변수이다.', 'OBJECTIVE'),
       (41, 7, '빈칸에 들어갈 시간 복잡도를 작성하시오', '스택의 push와 pop 연산의 시간 복잡도는 ___이다.', 'SUBJECTIVE'),
       (42, 7, '다음 중 스택의 활용 사례로 올바른 것은?', '스택은 다양한 분야에서 활용되는 자료구조이다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (97, 37, 'LIFO 구조이다',
        '스택은 LIFO(Last In First Out) 구조로, 가장 나중에 들어간 데이터가 가장 먼저 나온다. 이는 접시를 쌓고 빼는 것과 유사한 구조이다.', true),
       (98, 37, 'FIFO 구조이다',
        'FIFO(First In First Out) 구조는 큐의 특징이다. 스택은 LIFO 구조로 가장 나중에 들어간 데이터가 먼저 나온다.', false),
       (99, 37, '양쪽 끝에서 삽입과 삭제가 가능하다',
        '양쪽 끝에서 삽입과 삭제가 가능한 것은 덱(Deque)의 특징이다. 스택은 한쪽 끝(Top)에서만 삽입과 삭제가 발생한다.', false),
       (100, 37, '중간 삽입이 자유롭다',
        '스택은 Top에서만 삽입과 삭제가 가능하며, 중간에 데이터를 삽입하거나 삭제할 수 없다. 이는 스택의 기본 제약 사항이다.', false),

       (101, 39, 'push, pop, peek',
        '스택의 주요 연산은 push(삽입), pop(삭제 및 반환), peek(조회)이다. push는 Top에 데이터를 삽입하고, pop은 Top에서 데이터를 제거하며 반환하고, peek는 Top 데이터를 제거하지 않고 조회만 한다.',
        true),
       (102, 39, 'enqueue, dequeue',
        'enqueue와 dequeue는 큐의 연산이다. enqueue는 Rear에 데이터를 삽입하고, dequeue는 Front에서 데이터를 제거한다.', false),
       (103, 39, 'insert, delete, search',
        'insert, delete, search는 일반적인 자료구조 연산이지만, 스택의 표준 연산 명칭은 push, pop, peek이다.', false),
       (104, 39, 'add, remove, get',
        'add, remove, get은 일반적인 컬렉션 연산이지만, 스택의 표준 연산 명칭은 push, pop, peek이다.', false),

       (105, 40, '다음 값이 들어갈 위치를 가리킨다',
        '스택 포인터는 다음 값이 들어갈 위치를 가리키며, 초기값은 -1이다. push 연산 시 포인터를 먼저 증가시킨 후 데이터를 삽입하고, pop 연산 시 데이터를 꺼낸 후 포인터를 감소시킨다.',
        true),
       (106, 40, '항상 0을 가리킨다',
        '스택 포인터는 고정된 값이 아니라 push와 pop 연산에 따라 변경되는 동적인 값이다. 초기값은 -1이며, 데이터가 추가되면 증가하고 제거되면 감소한다.',
        false),
       (107, 40, '스택의 중간 위치를 가리킨다',
        '스택 포인터는 중간 위치가 아니라 Top 위치, 즉 다음 값이 들어갈 위치를 가리킨다. 스택은 Top에서만 연산이 발생하므로 Top 위치 관리가 중요하다.',
        false),
       (108, 40, '스택의 크기를 나타낸다',
        '스택 포인터는 크기가 아니라 Top 위치를 가리킨다. 다만 스택 포인터 값 + 1이 현재 스택에 들어있는 원소의 개수와 같다.', false),

       (109, 42, '함수 호출 및 재귀',
        '스택은 함수 호출 시 복귀 주소와 지역 변수를 저장하는 데 사용된다. 재귀 함수의 경우 각 호출마다 스택 프레임이 쌓이며, 종료 시 역순으로 복귀한다.', true),
       (110, 42, '프린터 작업 대기열',
        '프린터 작업 대기열은 먼저 요청한 작업이 먼저 처리되어야 하므로 FIFO 구조인 큐를 사용한다. LIFO 구조인 스택은 적합하지 않다.', false),
       (111, 42, '너비 우선 탐색(BFS)',
        '너비 우선 탐색(BFS)은 같은 레벨의 노드를 먼저 탐색해야 하므로 FIFO 구조인 큐를 사용한다. 깊이 우선 탐색(DFS)에서 스택을 사용한다.', false),
       (112, 42, '데이터베이스 인덱싱',
        '데이터베이스 인덱싱은 주로 B-Tree나 해시 테이블과 같은 자료구조를 사용한다. 스택은 인덱싱 용도로 적합하지 않다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (13, 38, 'LIFO, Last In First Out, 후입선출',
        '스택은 LIFO(Last In First Out) 또는 후입선출 구조의 자료구조이다. 가장 나중에 들어온 데이터가 가장 먼저 나가는 구조로, 접시를 쌓고 빼는 것과 유사하다.'),
       (14, 41, 'O(1)',
        '스택의 push와 pop 연산은 모두 Top에서만 발생하므로 O(1)의 시간 복잡도를 가진다. 스택 포인터만 조작하면 되기 때문에 매우 빠르게 수행된다.');

-- Chapter: 자료구조 (id: 1), Unit: 스택 & 큐 (id: 3), Lesson: 큐 기초 문제집 (id: 8)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (43, 8, '다음 중 큐의 특징으로 올바른 것은?', '큐(Queue)는 한쪽에서 삽입하고 반대쪽에서 삭제하는 자료구조이다.', 'OBJECTIVE'),
       (44, 8, '빈칸에 들어갈 용어를 작성하시오', '큐는 ___구조로, 가장 먼저 들어온 데이터가 가장 먼저 나온다.', 'SUBJECTIVE'),
       (45, 8, '다음 중 큐의 주요 연산으로 올바른 것은?', '큐는 특정한 연산들을 통해 데이터를 관리한다.', 'OBJECTIVE'),
       (46, 8, '다음 중 선형 큐의 단점으로 올바른 것은?', '선형 큐는 Front와 Rear 포인터로 삽입/삭제 위치를 관리한다.', 'OBJECTIVE'),
       (47, 8, '빈칸에 들어갈 시간 복잡도를 작성하시오', '큐의 enqueue와 dequeue 연산의 시간 복잡도는 ___이다.', 'SUBJECTIVE'),
       (48, 8, '다음 중 원형 큐에 대한 설명으로 올바른 것은?', '원형 큐는 선형 큐의 문제점을 해결한 자료구조이다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (113, 43, 'FIFO 구조이다',
        '큐는 FIFO(First In First Out) 구조로, 가장 먼저 들어온 데이터가 가장 먼저 나온다. 이는 줄을 서는 것과 유사한 구조이다.', true),
       (114, 43, 'LIFO 구조이다',
        'LIFO(Last In First Out) 구조는 스택의 특징이다. 큐는 FIFO 구조로 먼저 들어온 데이터가 먼저 나온다.', false),
       (115, 43, '한쪽 끝에서만 삽입과 삭제가 발생한다',
        '한쪽 끝에서만 삽입과 삭제가 발생하는 것은 스택의 특징이다. 큐는 Rear에서 삽입, Front에서 삭제가 발생한다.', false),
       (116, 43, '중간 접근이 자유롭다',
        '큐는 Front와 Rear에서만 연산이 가능하며, 중간 접근이나 삽입/삭제는 허용되지 않는다.', false),

       (117, 45, 'enqueue, dequeue',
        '큐의 주요 연산은 enqueue(삽입)와 dequeue(삭제 및 반환)이다. enqueue는 Rear에 데이터를 추가하고, dequeue는 Front에서 데이터를 제거하며 반환한다.',
        true),
       (118, 45, 'push, pop',
        'push와 pop은 스택의 연산이다. 큐의 연산은 enqueue(Rear에 삽입)와 dequeue(Front에서 삭제)이다.', false),
       (119, 45, 'insert, delete',
        'insert와 delete는 일반적인 자료구조 연산이지만, 큐의 표준 연산 명칭은 enqueue와 dequeue이다.', false),
       (120, 45, 'add, remove',
        'add와 remove는 일반적인 컬렉션 연산이지만, 큐의 표준 연산 명칭은 enqueue와 dequeue이다.', false),

       (121, 46, 'Rear가 배열 끝에 도달하면 앞쪽 빈 공간을 활용할 수 없다',
        '선형 큐는 Rear가 배열 끝에 도달하면 앞쪽에 빈 공간이 있어도 삽입이 불가능하다. 이는 선형 큐의 주요 단점으로, 원형 큐를 통해 해결할 수 있다.', true),
       (122, 46, '삽입과 삭제가 O(n) 시간이 소요된다',
        '선형 큐의 삽입과 삭제는 포인터만 조작하므로 O(1) 시간에 가능하다. 메모리 낭비가 문제이지 시간 복잡도는 효율적이다.', false),
       (123, 46, '크기를 동적으로 조정할 수 없다',
        '크기 조정의 제약은 배열 기반 자료구조 전반의 문제이며, 선형 큐만의 고유한 단점은 아니다. 선형 큐의 고유한 단점은 메모리 낭비이다.', false),
       (124, 46, 'Front와 Rear를 구분할 수 없다',
        '선형 큐는 Front와 Rear 포인터로 명확히 위치를 구분한다. 이는 선형 큐의 단점이 아니다.', false),

       (125, 48, '배열의 처음과 끝을 논리적으로 연결한다',
        '원형 큐는 배열의 처음과 끝을 논리적으로 연결하여 선형 큐의 메모리 낭비 문제를 해결한다. (index + 1) % size로 순환 구조를 구현한다.', true),
       (126, 48, '무한한 크기를 가진다',
        '원형 큐도 배열 기반이므로 크기가 고정되어 있다. 다만 순환 구조를 통해 공간을 효율적으로 활용할 수 있다.', false),
       (127, 48, '삽입과 삭제가 O(n) 시간이 소요된다',
        '원형 큐의 삽입과 삭제도 포인터 조작만으로 이루어지므로 O(1) 시간에 가능하다. 순환 구조가 시간 복잡도에 영향을 주지 않는다.', false),
       (128, 48, 'LIFO 구조로 동작한다',
        '원형 큐도 큐의 한 종류이므로 FIFO 구조로 동작한다. 순환 구조는 공간 활용 방식의 개선이지 동작 방식의 변경이 아니다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (15, 44, 'FIFO, First In First Out, 선입선출',
        '큐는 FIFO(First In First Out) 또는 선입선출 구조의 자료구조이다. 가장 먼저 들어온 데이터가 가장 먼저 나가는 구조로, 줄을 서는 것과 유사하다.'),
       (16, 47, 'O(1)',
        '큐의 enqueue와 dequeue 연산은 모두 포인터 조작만으로 이루어지므로 O(1)의 시간 복잡도를 가진다. Rear에서 삽입, Front에서 삭제가 발생하며 매우 빠르게 수행된다.');

-- Chapter: 자료구조 (id: 1), Unit: 스택 & 큐 (id: 3), Lesson: 스택 & 큐 응용 문제집 (id: 9)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (49, 9, '다음 중 동적 스택에 대한 설명으로 올바른 것은?', '동적 스택은 배열 기반 스택의 크기 제한 문제를 해결한 것이다.', 'OBJECTIVE'),
       (50, 9, '빈칸에 들어갈 자료구조를 작성하시오', '스택을 ___로 구현하면 크기 제한 없이 사용할 수 있다.', 'SUBJECTIVE'),
       (51, 9, '다음 중 연결리스트 큐의 장점으로 올바른 것은?', '연결리스트 큐는 노드를 연결하는 방식으로 구현한 큐이다.', 'OBJECTIVE'),
       (52, 9, '다음 중 Deque에 대한 설명으로 올바른 것은?', 'Deque는 Double-Ended Queue의 약자이다.', 'OBJECTIVE'),
       (53, 9, '빈칸에 들어갈 연산을 작성하시오', '스택에서 Top 데이터를 제거하지 않고 조회만 하는 연산은 ___이다.', 'SUBJECTIVE'),
       (54, 9, '다음 중 큐의 활용 사례로 올바른 것은?', '큐는 순서가 중요한 다양한 상황에서 활용된다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (129, 49, '가득 차면 배열 크기를 확장한다',
        '동적 스택은 배열이 가득 차면 더 큰 배열을 생성하고 기존 데이터를 복사하여 크기를 확장한다. 일반적으로 기존 크기의 2배로 확장한다.', true),
       (130, 49, '무한한 크기를 가진다',
        '동적 스택도 메모리 한계 내에서 동작하므로 무한한 크기를 가질 수 없다. 다만 필요에 따라 동적으로 크기를 조정할 수 있다.', false),
       (131, 49, '크기를 줄일 수 없다',
        '동적 스택은 크기를 늘릴 수도 있고 줄일 수도 있다. 원소가 줄어들면 메모리 효율을 위해 크기를 축소할 수 있다.', false),
       (132, 49, 'FIFO 구조로 동작한다',
        '동적 스택도 스택이므로 LIFO 구조로 동작한다. 크기 조정 방식은 구현의 세부사항이지 기본 동작 방식은 동일하다.', false),

       (133, 51, '크기 제한이 없다',
        '연결리스트 큐는 노드를 동적으로 할당하므로 메모리가 허용하는 한 크기 제한이 없다. 배열 기반 큐의 고정 크기 문제를 해결한다.', true),
       (134, 51, '삽입과 삭제가 O(n) 시간이 소요된다',
        '연결리스트 큐도 Front와 Rear에서 포인터 조작만으로 삽입/삭제가 가능하므로 O(1) 시간에 수행된다.', false),
       (135, 51, '인덱스로 직접 접근할 수 있다',
        '연결리스트는 순차 접근만 가능하므로 인덱스로 직접 접근할 수 없다. 이는 연결리스트 기반 자료구조의 일반적인 특징이다.', false),
       (136, 51, '원형 구조로 구현된다',
        '원형 구조는 배열 기반 큐에서 공간을 효율적으로 활용하기 위한 방법이다. 연결리스트 큐는 원형 구조가 필요 없다.', false),

       (137, 52, '양쪽 끝에서 삽입과 삭제가 모두 가능하다',
        'Deque(덱)는 양쪽 끝에서 삽입과 삭제가 모두 가능한 자료구조이다. 스택과 큐의 기능을 모두 제공하며, 배열 또는 연결리스트로 구현 가능하다.', true),
       (138, 52, '한쪽 끝에서만 연산이 가능하다',
        '한쪽 끝에서만 연산이 가능한 것은 스택의 특징이다. Deque는 양쪽 끝에서 모두 연산이 가능하다.', false),
       (139, 52, 'LIFO 구조로만 동작한다',
        'Deque는 양쪽 끝에서 연산이 가능하므로 LIFO와 FIFO 모두 구현할 수 있다. 사용 방식에 따라 스택이나 큐로 동작할 수 있다.', false),
       (140, 52, '크기를 변경할 수 없다',
        'Deque도 배열 또는 연결리스트로 구현되므로, 연결리스트 기반인 경우 크기 제한이 없고, 동적 배열 기반인 경우 크기 조정이 가능하다.', false),

       (141, 54, '프로세스 스케줄링',
        '운영체제의 프로세스 스케줄링은 먼저 도착한 프로세스를 먼저 처리해야 하므로 FIFO 구조인 큐를 사용한다. 준비 큐(Ready Queue)가 대표적인 예시이다.',
        true),
       (142, 54, '함수 호출 스택',
        '함수 호출 스택은 가장 최근에 호출된 함수가 먼저 종료되어야 하므로 LIFO 구조인 스택을 사용한다. 큐는 적합하지 않다.', false),
       (143, 54, '깊이 우선 탐색(DFS)',
        '깊이 우선 탐색(DFS)은 한 경로를 끝까지 탐색한 후 돌아오므로 LIFO 구조인 스택을 사용한다. 너비 우선 탐색(BFS)에서 큐를 사용한다.', false),
       (144, 54, '후위 표기법 계산',
        '후위 표기법 계산은 연산자를 만났을 때 최근 두 피연산자를 사용하므로 LIFO 구조인 스택을 사용한다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (17, 50, '연결리스트, Linked List',
        '스택을 연결리스트로 구현하면 노드를 동적으로 할당하므로 크기 제한 없이 사용할 수 있다. 각 노드가 데이터와 다음 노드의 주소를 저장하며, Top에서만 삽입/삭제가 발생한다.'),
       (18, 53, 'peek, top',
        'peek 또는 top 연산은 스택의 최상단 데이터를 제거하지 않고 조회만 하는 연산이다. 스택의 상태를 확인하거나 다음 처리할 데이터를 미리 확인할 때 사용한다.');

-- Chapter: 자료구조 (id: 1), Unit: 트리 기본 (id: 4)

-- Lesson 생성
INSERT INTO lesson (id, unit_id, title)
VALUES (10, 4, '트리 기초 문제집'),
       (11, 4, '트리 순회 문제집'),
       (12, 4, '트리 응용 문제집');

-- Chapter: 자료구조 (id: 1), Unit: 트리 기본 (id: 4), Lesson: 트리 기초 문제집 (id: 10)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (55, 10, '다음 중 트리의 특징으로 올바른 것은?', '트리(Tree)는 노드와 간선으로 구성된 계층적 자료구조이다.', 'OBJECTIVE'),
       (56, 10, '빈칸에 들어갈 용어를 작성하시오', '트리는 ___이 존재하지 않는 자료구조이다.', 'SUBJECTIVE'),
       (57, 10, '다음 중 트리의 구성 요소에 대한 설명으로 올바른 것은?', '트리는 여러 구성 요소로 이루어져 있다.', 'OBJECTIVE'),
       (58, 10, '다음 중 트리와 그래프의 차이점으로 올바른 것은?', '트리와 그래프는 모두 노드와 간선으로 구성된 자료구조이다.', 'OBJECTIVE'),
       (59, 10, '빈칸에 들어갈 개수를 작성하시오', 'N개의 노드가 있는 트리는 ___개의 간선을 가진다.', 'SUBJECTIVE'),
       (60, 10, '다음 중 트리의 성질로 올바른 것은?', '트리는 특정한 성질을 만족하는 자료구조이다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (145, 55, '계층적 비선형 자료구조이다',
        '트리는 노드와 간선으로 구성된 계층적 비선형 자료구조이다. 하나의 루트 노드에서 시작해 여러 자식 노드로 분기되는 구조를 가진다.', true),
       (146, 55, '선형 자료구조이다',
        '선형 자료구조는 배열, 연결리스트, 스택, 큐와 같이 데이터가 일렬로 나열된 구조이다. 트리는 계층적 구조를 가진 비선형 자료구조이다.', false),
       (147, 55, '사이클이 반드시 존재한다',
        '트리는 사이클이 존재하지 않는 자료구조이다. 사이클이 있으면 그래프이지 트리가 아니다.', false),
       (148, 55, 'FIFO 구조로 동작한다',
        'FIFO 구조는 큐의 특징이다. 트리는 계층적 구조를 표현하는 자료구조로 FIFO나 LIFO와는 관계가 없다.', false),

       (149, 57, '루트 노드는 부모가 없는 최상위 노드이다',
        '루트 노드는 트리의 최상위에 위치한 노드로 부모가 없다. 모든 다른 노드는 루트 노드로부터 도달할 수 있다.', true),
       (150, 57, '리프 노드는 자식이 있는 노드이다',
        '리프 노드는 자식이 없는 노드를 의미한다. 자식이 있는 노드는 내부 노드(Internal Node)라고 한다.', false),
       (151, 57, '간선은 노드 간의 연결을 나타내지 않는다',
        '간선(Edge)은 노드와 노드를 연결하는 선으로, 부모-자식 관계를 나타낸다. 간선이 노드 간의 연결을 나타내는 것이 맞다.', false),
       (152, 57, '내부 노드는 자식이 없는 노드이다',
        '내부 노드(Internal Node)는 자식이 있는 노드를 의미한다. 자식이 없는 노드는 리프 노드이다.', false),

       (153, 58, '트리는 사이클이 없고 그래프는 사이클이 있을 수 있다',
        '트리는 사이클이 존재하지 않는 연결된 그래프이다. 그래프는 사이클이 존재할 수 있으며, 방향성과 가중치 등 다양한 형태를 가질 수 있다.', true),
       (154, 58, '트리와 그래프는 완전히 동일한 자료구조이다',
        '트리는 그래프의 특수한 형태이다. 트리는 사이클이 없고, 루트가 존재하며, 계층적 구조를 가진다는 점에서 일반 그래프와 다르다.', false),
       (155, 58, '트리는 루트가 없고 그래프는 루트가 있다',
        '반대이다. 트리는 하나의 루트 노드가 존재하지만, 일반 그래프는 루트 개념이 없다.', false),
       (156, 58, '그래프는 방향성이 없고 트리는 방향성이 있다',
        '그래프는 방향성이 있을 수도 있고 없을 수도 있다. 트리는 부모에서 자식으로의 방향성을 가진 특수한 그래프이다.', false),

       (157, 60, '임의 두 노드 간의 경로는 하나만 존재한다',
        '트리는 사이클이 없는 연결 그래프이므로 임의의 두 노드 간에는 유일한 경로만 존재한다. 이는 트리의 중요한 성질이다.', true),
       (158, 60, '모든 노드가 동일한 개수의 자식을 가진다',
        '트리에서 각 노드가 가지는 자식의 개수는 다를 수 있다. 노드의 자식 수를 차수(Degree)라고 하며, 노드마다 다른 차수를 가질 수 있다.', false),
       (159, 60, '항상 완전 이진 트리 형태를 가진다',
        '트리는 다양한 형태를 가질 수 있다. 완전 이진 트리는 트리의 특수한 형태 중 하나일 뿐이다.', false),
       (160, 60, '모든 노드가 부모를 가진다',
        '루트 노드는 부모가 없다. 루트 노드를 제외한 모든 노드가 정확히 하나의 부모를 가진다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (19, 56, '사이클, cycle',
        '트리는 사이클이 존재하지 않는 자료구조이다. 사이클이 있으면 순환 구조가 형성되어 트리의 계층적 특성이 깨지므로 그래프로 분류된다.'),
       (20, 59, 'N-1',
        'N개의 노드가 있는 트리는 N-1개의 간선을 가진다. 루트 노드를 제외한 모든 노드가 정확히 하나의 부모와 연결되므로 간선의 개수는 항상 노드 개수보다 1 적다.');

-- Chapter: 자료구조 (id: 1), Unit: 트리 기본 (id: 4), Lesson: 트리 순회 문제집 (id: 11)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (61, 11, '다음 중 전위 순회의 방문 순서로 올바른 것은?', '전위 순회(Pre-order)는 트리를 순회하는 방법 중 하나이다.', 'OBJECTIVE'),
       (62, 11, '빈칸에 들어갈 순회 방법을 작성하시오', '이진 탐색 트리에서 정렬된 순서로 값을 출력하려면 ___를 사용한다.', 'SUBJECTIVE'),
       (63, 11, '다음 중 중위 순회의 방문 순서로 올바른 것은?', '중위 순회(In-order)는 트리를 순회하는 방법 중 하나이다.', 'OBJECTIVE'),
       (64, 11, '다음 중 후위 순회의 특징으로 올바른 것은?', '후위 순회(Post-order)는 트리를 순회하는 방법 중 하나이다.', 'OBJECTIVE'),
       (65, 11, '빈칸에 들어갈 순회 방법을 작성하시오', '트리를 삭제할 때는 ___를 사용하여 자식 노드를 먼저 삭제한 후 부모 노드를 삭제한다.', 'SUBJECTIVE'),
       (66, 11, '다음 중 레벨 순회에 대한 설명으로 올바른 것은?', '레벨 순회(Level-order)는 트리를 순회하는 방법 중 하나이다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (161, 61, '부모 → 왼쪽 자식 → 오른쪽 자식',
        '전위 순회는 부모 노드를 먼저 방문한 후 왼쪽 자식, 오른쪽 자식 순으로 방문한다. 트리 복사나 전위 표기법 변환에 활용된다.', true),
       (162, 61, '왼쪽 자식 → 부모 → 오른쪽 자식',
        '왼쪽 자식 → 부모 → 오른쪽 자식 순서는 중위 순회의 방문 순서이다. 전위 순회는 부모를 가장 먼저 방문한다.', false),
       (163, 61, '왼쪽 자식 → 오른쪽 자식 → 부모',
        '왼쪽 자식 → 오른쪽 자식 → 부모 순서는 후위 순회의 방문 순서이다. 전위 순회는 부모를 가장 먼저 방문한다.', false),
       (164, 61, '같은 레벨의 노드를 좌→우로 방문',
        '같은 레벨의 노드를 좌→우로 방문하는 것은 레벨 순회이다. 전위 순회는 깊이 우선으로 부모를 먼저 방문한다.', false),

       (165, 63, '왼쪽 자식 → 부모 → 오른쪽 자식',
        '중위 순회는 왼쪽 자식을 먼저 방문한 후 부모, 오른쪽 자식 순으로 방문한다. 이진 탐색 트리에서 정렬된 순서로 값을 출력하는 데 활용된다.', true),
       (166, 63, '부모 → 왼쪽 자식 → 오른쪽 자식',
        '부모 → 왼쪽 자식 → 오른쪽 자식 순서는 전위 순회의 방문 순서이다. 중위 순회는 왼쪽 자식을 가장 먼저 방문한다.', false),
       (167, 63, '왼쪽 자식 → 오른쪽 자식 → 부모',
        '왼쪽 자식 → 오른쪽 자식 → 부모 순서는 후위 순회의 방문 순서이다. 중위 순회는 왼쪽 자식 다음에 부모를 방문한다.', false),
       (168, 63, '오른쪽 자식 → 부모 → 왼쪽 자식',
        '중위 순회는 왼쪽 자식 → 부모 → 오른쪽 자식 순서로 방문한다. 방문 순서가 반대이다.', false),

       (169, 64, '자식 노드를 먼저 방문한 후 부모 노드를 방문한다',
        '후위 순회는 왼쪽 자식, 오른쪽 자식을 모두 방문한 후 마지막으로 부모 노드를 방문한다. 트리 삭제나 후위 표기법 계산에 활용된다.', true),
       (170, 64, '부모 노드를 가장 먼저 방문한다',
        '부모 노드를 가장 먼저 방문하는 것은 전위 순회이다. 후위 순회는 부모를 가장 마지막에 방문한다.', false),
       (171, 64, '이진 탐색 트리의 정렬된 출력에 사용된다',
        '이진 탐색 트리의 정렬된 출력에는 중위 순회를 사용한다. 후위 순회는 트리 삭제나 후위 표기법에 활용된다.', false),
       (172, 64, '같은 레벨의 노드를 먼저 방문한다',
        '같은 레벨의 노드를 먼저 방문하는 것은 레벨 순회이다. 후위 순회는 깊이 우선으로 자식을 먼저 방문한다.', false),

       (173, 66, '같은 레벨의 노드를 좌→우로 방문한다',
        '레벨 순회는 같은 레벨(깊이)의 노드들을 왼쪽에서 오른쪽으로 방문한다. BFS(너비 우선 탐색)와 유사하며 큐를 사용하여 구현한다.', true),
       (174, 66, '부모 노드를 가장 먼저 방문한다',
        '부모를 가장 먼저 방문하는 것은 전위 순회이다. 레벨 순회는 깊이가 얕은 노드부터 레벨별로 방문한다.', false),
       (175, 66, '자식 노드를 가장 먼저 방문한다',
        '자식을 먼저 방문하는 것은 후위 순회이다. 레벨 순회는 같은 레벨의 노드를 좌에서 우로 방문한다.', false),
       (176, 66, '스택을 사용하여 구현한다',
        '레벨 순회는 큐를 사용하여 구현한다. 스택은 DFS(깊이 우선 탐색) 기반의 전위/중위/후위 순회에서 사용한다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (21, 62, '중위 순회, In-order, 중위순회',
        '이진 탐색 트리에서 중위 순회를 수행하면 왼쪽 자식 → 부모 → 오른쪽 자식 순으로 방문하므로 자동으로 오름차순 정렬된 순서로 값을 출력할 수 있다.'),
       (22, 65, '후위 순회, Post-order, 후위순회',
        '트리를 삭제할 때는 후위 순회를 사용한다. 자식 노드를 먼저 삭제한 후 부모 노드를 삭제해야 메모리 누수 없이 안전하게 트리를 제거할 수 있다.');

-- Chapter: 자료구조 (id: 1), Unit: 트리 기본 (id: 4), Lesson: 트리 응용 문제집 (id: 12)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (67, 12, '다음 중 트리의 용어에 대한 설명으로 올바른 것은?', '트리에는 다양한 용어가 사용된다.', 'OBJECTIVE'),
       (68, 12, '빈칸에 들어갈 용어를 작성하시오', '노드의 자식 수를 ___이라고 한다.', 'SUBJECTIVE'),
       (69, 12, '다음 중 트리의 높이에 대한 설명으로 올바른 것은?', '트리의 높이는 트리의 구조를 나타내는 중요한 지표이다.', 'OBJECTIVE'),
       (70, 12, '다음 중 트리와 그래프의 관계로 올바른 것은?', '트리와 그래프는 모두 노드와 간선으로 구성된다.', 'OBJECTIVE'),
       (71, 12, '빈칸에 들어갈 관계를 작성하시오', '트리는 ___관계로 표현된 계층적 구조이다.', 'SUBJECTIVE'),
       (72, 12, '다음 중 트리의 활용 사례로 올바른 것은?', '트리는 다양한 분야에서 활용되는 자료구조이다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (177, 67, '레벨은 루트부터의 깊이를 나타낸다',
        '레벨(Level)은 루트 노드로부터의 깊이를 나타낸다. 루트 노드의 레벨을 0 또는 1로 시작하며, 아래로 내려갈수록 레벨이 증가한다.', true),
       (178, 67, '리프 노드는 자식이 있는 노드이다',
        '리프 노드(Leaf Node)는 자식이 없는 노드를 의미한다. 트리의 말단에 위치한 노드들이다.', false),
       (179, 67, '형제 노드는 다른 부모를 가진 노드이다',
        '형제 노드(Sibling)는 같은 부모를 가진 노드들을 의미한다. 다른 부모를 가진 노드는 형제 관계가 아니다.', false),
       (180, 67, '차수는 트리의 최대 레벨을 의미한다',
        '트리의 최대 레벨을 의미하는 것은 높이(Height)이다. 차수(Degree)는 노드의 자식 수를 의미한다.', false),

       (181, 69, '트리의 최대 레벨을 의미한다',
        '트리의 높이(Height)는 루트 노드에서 가장 깊은 리프 노드까지의 경로 길이, 즉 트리의 최대 레벨을 의미한다.', true),
       (182, 69, '트리의 노드 개수를 의미한다',
        '노드 개수는 트리의 크기(Size)를 나타낸다. 높이는 트리의 깊이, 즉 최대 레벨을 의미한다.', false),
       (183, 69, '트리의 간선 개수를 의미한다',
        '간선 개수는 항상 노드 개수 - 1이다. 높이는 루트에서 가장 깊은 노드까지의 레벨을 의미한다.', false),
       (184, 69, '루트 노드의 자식 수를 의미한다',
        '루트 노드의 자식 수는 루트 노드의 차수를 나타낸다. 높이는 트리 전체의 최대 깊이를 의미한다.', false),

       (185, 70, '트리는 사이클이 없는 연결 그래프이다',
        '트리는 그래프의 특수한 형태로, 사이클이 없고 모든 노드가 연결된 그래프이다. 즉, 트리는 연결되고 비순환적인 그래프이다.', true),
       (186, 70, '그래프는 트리의 특수한 형태이다',
        '반대이다. 트리가 그래프의 특수한 형태이다. 트리는 사이클이 없고 연결된 그래프라는 추가 제약을 가진다.', false),
       (187, 70, '트리는 항상 방향성이 없고 그래프는 방향성이 있다',
        '트리도 방향성을 가질 수 있으며(부모→자식), 그래프도 방향성이 있을 수도 있고 없을 수도 있다.', false),
       (188, 70, '트리와 그래프는 완전히 독립적인 자료구조이다',
        '트리는 그래프의 부분집합이다. 모든 트리는 그래프이지만, 모든 그래프가 트리인 것은 아니다.', false),

       (189, 72, '파일 시스템의 디렉토리 구조',
        '파일 시스템은 디렉토리와 파일이 계층적으로 구성되어 있어 트리 구조로 표현된다. 루트 디렉토리에서 시작해 하위 디렉토리와 파일로 분기된다.', true),
       (190, 72, '프로세스 스케줄링의 준비 큐',
        '프로세스 스케줄링의 준비 큐는 먼저 도착한 프로세스를 먼저 처리하는 FIFO 구조의 큐를 사용한다. 트리 구조가 아니다.', false),
       (191, 72, '네트워크 패킷의 순차 전송',
        '네트워크 패킷의 순차 전송은 큐나 버퍼를 사용한다. 계층적 구조가 아니므로 트리를 사용하지 않는다.', false),
       (192, 72, '해시 테이블의 충돌 처리',
        '해시 테이블의 충돌 처리는 체이닝(연결리스트) 또는 개방 주소법을 사용한다. 일반적으로 트리를 사용하지 않는다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (23, 68, '차수, degree',
        '노드의 자식 수를 차수(Degree)라고 한다. 예를 들어 자식이 2개인 노드의 차수는 2이며, 리프 노드의 차수는 0이다.'),
       (24, 71, '부모-자식, 부모 자식, parent-child',
        '트리는 부모-자식(Parent-Child) 관계로 표현된 계층적 구조이다. 각 노드는 0개 이상의 자식 노드를 가지며, 루트를 제외한 모든 노드는 정확히 하나의 부모를 가진다.');

-- Chapter: 자료구조 (id: 1), Unit: 이진 트리 & 이진 탐색 트리 (id: 5)

-- Lesson 생성
INSERT INTO lesson (id, unit_id, title)
VALUES (13, 5, '이진 트리 기초 문제집'),
       (14, 5, '이진 탐색 트리 기초 문제집'),
       (15, 5, '이진 탐색 트리 응용 문제집');

-- Chapter: 자료구조 (id: 1), Unit: 이진 트리 & 이진 탐색 트리 (id: 5), Lesson: 이진 트리 기초 문제집 (id: 13)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (73, 13, '다음 중 이진 트리의 정의로 올바른 것은?', '이진 트리(Binary Tree)는 트리의 특수한 형태이다.', 'OBJECTIVE'),
       (74, 13, '빈칸에 들어갈 개수를 작성하시오', '이진 트리의 각 노드는 최대 ___개의 자식 노드를 가질 수 있다.', 'SUBJECTIVE'),
       (75, 13, '다음 중 이진 트리의 성질로 올바른 것은?', '이진 트리는 특정한 수학적 성질을 만족한다.', 'OBJECTIVE'),
       (76, 13, '다음 중 포화 이진 트리에 대한 설명으로 올바른 것은?', '포화 이진 트리는 이진 트리의 특수한 형태이다.', 'OBJECTIVE'),
       (77, 13, '빈칸에 들어갈 개수를 작성하시오', '높이가 h인 포화 이진 트리는 ___개의 노드를 가진다.', 'SUBJECTIVE'),
       (78, 13, '다음 중 완전 이진 트리에 대한 설명으로 올바른 것은?', '완전 이진 트리는 이진 트리의 특수한 형태이다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (193, 73, '최대 2개의 서브 트리로 나뉘는 트리이다',
        '이진 트리는 루트 노드를 중심으로 최대 2개의 서브 트리(왼쪽, 오른쪽)로 나뉘는 트리 구조이다. 각 노드는 최대 2개의 자식 노드를 가질 수 있다.', true),
       (194, 73, '각 노드가 정확히 3개의 자식을 가진다',
        '각 노드가 정확히 3개의 자식을 가지는 것은 3진 트리이다. 이진 트리는 최대 2개의 자식을 가진다.', false),
       (195, 73, '모든 노드가 반드시 2개의 자식을 가진다',
        '이진 트리의 노드는 0개, 1개, 또는 2개의 자식을 가질 수 있다. 반드시 2개를 가져야 하는 것은 아니다.', false),
       (196, 73, '사이클이 존재하는 트리이다',
        '이진 트리도 트리의 일종이므로 사이클이 존재하지 않는다. 사이클이 있으면 그래프이지 트리가 아니다.', false),

       (197, 75, 'n개의 노드가 있으면 n-1개의 간선이 존재한다',
        '이진 트리도 트리의 일종이므로 n개의 노드가 있으면 n-1개의 간선이 존재한다. 루트를 제외한 모든 노드가 정확히 하나의 부모와 연결되기 때문이다.', true),
       (198, 75, '높이가 h일 때 항상 2^h개의 노드를 가진다',
        '높이가 h일 때 2^h개의 노드를 가지는 것은 포화 이진 트리의 특성이다. 일반 이진 트리는 최소 h개에서 최대 2^h - 1개의 노드를 가진다.', false),
       (199, 75, '모든 레벨이 노드로 꽉 차있다',
        '모든 레벨이 노드로 꽉 차있는 것은 포화 이진 트리의 특성이다. 일반 이진 트리는 이러한 제약이 없다.', false),
       (200, 75, '중위 순회가 불가능하다',
        '이진 트리에서도 전위, 중위, 후위, 레벨 순회가 모두 가능하다. 중위 순회는 왼쪽 자식 → 부모 → 오른쪽 자식 순으로 방문한다.', false),

       (201, 76, '모든 레벨이 노드로 꽉 차있다',
        '포화 이진 트리는 모든 레벨이 노드로 꽉 찬 트리이다. 높이가 h일 때 2^h - 1개의 노드를 가지며, 가장 완벽하게 균형잡힌 형태이다.', true),
       (202, 76, '마지막 레벨만 꽉 차있다',
        '마지막 레벨만 꽉 차있는 것이 아니라 모든 레벨이 꽉 차있어야 포화 이진 트리이다.', false),
       (203, 76, '왼쪽부터 순서대로 채워진다',
        '왼쪽부터 순서대로 채워지는 것은 완전 이진 트리의 특징이다. 포화 이진 트리는 모든 레벨이 완전히 채워진 상태이다.', false),
       (204, 76, '각 노드가 0개 또는 2개의 자식을 가진다',
        '각 노드가 0개 또는 2개의 자식을 가지는 것은 정 이진 트리이다. 포화 이진 트리는 리프 노드를 제외한 모든 노드가 2개의 자식을 가진다.', false),

       (205, 78, '마지막 레벨을 제외한 모든 레벨이 꽉 차있고, 마지막 레벨은 왼쪽부터 채워진다',
        '완전 이진 트리는 마지막 레벨을 제외한 모든 레벨이 노드로 꽉 차있고, 마지막 레벨의 노드는 왼쪽부터 순서대로 채워진 트리이다. 힙이 완전 이진 트리 구조를 사용한다.',
        true),
       (206, 78, '모든 레벨이 완전히 채워져 있다',
        '모든 레벨이 완전히 채워진 것은 포화 이진 트리이다. 완전 이진 트리는 마지막 레벨이 부분적으로 채워질 수 있다.', false),
       (207, 78, '오른쪽부터 순서대로 채워진다',
        '완전 이진 트리는 마지막 레벨을 왼쪽부터 순서대로 채운다. 오른쪽부터 채우면 완전 이진 트리가 아니다.', false),
       (208, 78, '각 노드가 0개 또는 2개의 자식을 가진다',
        '각 노드가 0개 또는 2개의 자식을 가지는 것은 정 이진 트리이다. 완전 이진 트리는 마지막 레벨의 채워진 형태에 대한 제약이다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (25, 74, '2, 두',
        '이진 트리의 각 노드는 최대 2개의 자식 노드를 가질 수 있다. 0개, 1개, 또는 2개의 자식을 가질 수 있으며, 이것이 "이진"이라는 이름의 유래이다.'),
       (26, 77, '2^h - 1',
        '높이가 h인 포화 이진 트리는 2^h - 1개의 노드를 가진다. 예를 들어 높이가 3이면 2^3 - 1 = 7개의 노드를 가진다. 각 레벨 i는 2^(i-1)개의 노드를 가지며, 이를 모두 합하면 2^h - 1이 된다.');

-- Chapter: 자료구조 (id: 1), Unit: 이진 트리 & 이진 탐색 트리 (id: 5), Lesson: 이진 탐색 트리 기초 문제집 (id: 14)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (79, 14, '다음 중 이진 탐색 트리의 규칙으로 올바른 것은?', '이진 탐색 트리(BST)는 효율적인 탐색을 위해 정렬된 구조를 유지한다.', 'OBJECTIVE'),
       (80, 14, '빈칸에 들어갈 시간 복잡도를 작성하시오', '이진 탐색 트리에서 탐색, 삽입, 삭제의 평균 시간 복잡도는 ___이다.', 'SUBJECTIVE'),
       (81, 14, '다음 중 이진 탐색 트리의 탐색 과정으로 올바른 것은?', '이진 탐색 트리에서 특정 값을 찾는 과정이다.', 'OBJECTIVE'),
       (82, 14, '다음 중 이진 탐색 트리의 삽입 과정으로 올바른 것은?', '이진 탐색 트리에 새로운 노드를 삽입하는 과정이다.', 'OBJECTIVE'),
       (83, 14, '빈칸에 들어갈 순회 방법을 작성하시오', '이진 탐색 트리를 ___하면 오름차순으로 정렬된 값을 얻을 수 있다.', 'SUBJECTIVE'),
       (84, 14, '다음 중 이진 탐색 트리의 특징으로 올바른 것은?', '이진 탐색 트리는 이진 트리와 이진 탐색의 장점을 결합한 자료구조이다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (209, 79, '왼쪽 서브 트리는 부모보다 작고, 오른쪽 서브 트리는 부모보다 크다',
        '이진 탐색 트리는 왼쪽 서브 트리의 모든 값이 부모보다 작고, 오른쪽 서브 트리의 모든 값이 부모보다 크다는 규칙을 만족한다. 이를 통해 효율적인 탐색이 가능하다.', true),
       (210, 79, '왼쪽 서브 트리는 부모보다 크고, 오른쪽 서브 트리는 부모보다 작다',
        '반대이다. 왼쪽 서브 트리는 부모보다 작고, 오른쪽 서브 트리는 부모보다 크다.', false),
       (211, 79, '모든 노드가 동일한 값을 가진다',
        '이진 탐색 트리는 중복되는 값을 허용하지 않으며, 각 노드는 고유한 값을 가진다.', false),
       (212, 79, '부모와 자식 간에 대소 관계가 없다',
        '이진 탐색 트리는 부모와 자식 간의 명확한 대소 관계를 유지하는 것이 핵심이다.', false),

       (213, 81, '루트부터 시작하여 찾는 값이 작으면 왼쪽, 크면 오른쪽으로 이동한다',
        '이진 탐색 트리의 탐색은 루트부터 시작하여, 찾는 값이 현재 노드보다 작으면 왼쪽 서브 트리로, 크면 오른쪽 서브 트리로 이동하며 탐색한다.', true),
       (214, 81, '모든 노드를 순차적으로 방문한다',
        '모든 노드를 순차적으로 방문하는 것은 비효율적이다. 이진 탐색 트리는 대소 관계를 이용해 불필요한 노드를 건너뛰며 탐색한다.', false),
       (215, 81, '항상 왼쪽 자식부터 탐색한다',
        '탐색 방향은 찾는 값과 현재 노드 값의 대소 관계에 따라 결정된다. 항상 왼쪽부터 탐색하는 것이 아니다.', false),
       (216, 81, '레벨 순회로 탐색한다',
        '레벨 순회는 같은 깊이의 모든 노드를 방문하는 방식으로, 이진 탐색 트리의 효율적인 탐색 방법이 아니다.', false),

       (217, 82, '탐색과 동일한 방식으로 삽입 위치를 찾아 새 노드를 추가한다',
        '이진 탐색 트리의 삽입은 탐색과 동일한 방식으로 삽입 위치를 찾은 후, 리프 노드 위치에 새 노드를 추가한다. 삽입 후에도 BST의 규칙이 유지된다.', true),
       (218, 82, '항상 루트 노드에 삽입한다',
        '루트에 삽입하면 BST의 규칙이 깨진다. 적절한 위치를 찾아 삽입해야 한다.', false),
       (219, 82, '무작위 위치에 삽입한다',
        '무작위 위치에 삽입하면 BST의 대소 관계 규칙이 깨진다. 규칙을 만족하는 위치를 찾아 삽입해야 한다.', false),
       (220, 82, '중간 노드에만 삽입할 수 있다',
        '삽입은 일반적으로 리프 노드 위치에 이루어진다. 중간 노드에만 삽입할 수 있다는 제약은 없다.', false),

       (221, 84, '이진 탐색의 빠른 탐색과 연결리스트의 유연한 삽입/삭제를 결합했다',
        '이진 탐색 트리는 이진 탐색의 O(log n) 탐색 성능과 연결리스트의 유연한 삽입/삭제를 결합한 자료구조이다. 배열의 고정 크기 문제를 해결한다.', true),
       (222, 84, 'FIFO 구조로 동작한다',
        'FIFO는 큐의 특징이다. 이진 탐색 트리는 대소 관계에 기반한 계층적 구조이다.', false),
       (223, 84, '모든 연산이 O(1)이다',
        '이진 탐색 트리의 평균 시간 복잡도는 O(log n)이다. O(1)이 아니다.', false),
       (224, 84, '중복 값을 허용한다',
        '일반적으로 이진 탐색 트리는 중복 값을 허용하지 않는다. 각 노드는 고유한 값을 가진다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (27, 80, 'O(log n)',
        '이진 탐색 트리에서 탐색, 삽입, 삭제의 평균 시간 복잡도는 O(log n)이다. 균형잡힌 트리에서 각 단계마다 탐색 범위가 절반으로 줄어들기 때문이다. 단, 편향 트리의 경우 O(n)으로 저하될 수 있다.'),
       (28, 83, '중위 순회, In-order, 중위순회',
        '이진 탐색 트리를 중위 순회(왼쪽 자식 → 부모 → 오른쪽 자식)하면 자동으로 오름차순 정렬된 순서로 값을 얻을 수 있다. 이는 BST의 대소 관계 규칙 덕분이다.');

-- Chapter: 자료구조 (id: 1), Unit: 이진 트리 & 이진 탐색 트리 (id: 5), Lesson: 이진 탐색 트리 응용 문제집 (id: 15)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (85, 15, '다음 중 이진 탐색 트리의 삭제 과정으로 올바른 것은?', '이진 탐색 트리에서 노드를 삭제할 때는 경우를 나누어 처리한다.', 'OBJECTIVE'),
       (86, 15, '빈칸에 들어갈 용어를 작성하시오', '자식이 2개인 노드를 삭제할 때는 왼쪽 서브 트리의 ___또는 오른쪽 서브 트리의 최소값으로 대체한다.', 'SUBJECTIVE'),
       (87, 15, '다음 중 편향 트리에 대한 설명으로 올바른 것은?', '편향 트리(Skewed Tree)는 이진 탐색 트리의 최악의 형태이다.', 'OBJECTIVE'),
       (88, 15, '다음 중 이진 탐색 트리의 한계를 극복한 자료구조로 올바른 것은?', '이진 탐색 트리의 편향 문제를 해결한 자료구조들이 있다.', 'OBJECTIVE'),
       (89, 15, '빈칸에 들어갈 시간 복잡도를 작성하시오', '편향 트리에서 탐색, 삽입, 삭제의 시간 복잡도는 ___이다.', 'SUBJECTIVE'),
       (90, 15, '다음 중 이진 탐색 트리의 활용 사례로 올바른 것은?', '이진 탐색 트리는 다양한 상황에서 활용된다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (225, 85, '자식이 없으면 삭제, 1개면 자식을 올리고, 2개면 후계자로 대체한다',
        '이진 탐색 트리의 삭제는 3가지 경우로 나뉜다. 자식이 없으면 단순 삭제, 1개면 자식을 부모 위치로 올리고, 2개면 왼쪽 서브 트리의 최대값 또는 오른쪽 서브 트리의 최소값으로 대체한다.',
        true),
       (226, 85, '항상 루트 노드만 삭제할 수 있다',
        '이진 탐색 트리에서는 어떤 노드든 삭제할 수 있다. 루트 노드만 삭제할 수 있다는 제약은 없다.', false),
       (227, 85, '삭제 후 트리를 재구성해야 한다',
        '적절한 후계자 노드를 선택하면 트리 전체를 재구성할 필요 없이 국지적으로 조정만 하면 된다.', false),
       (228, 85, '삭제는 불가능하고 표시만 한다',
        '이진 탐색 트리에서는 실제 노드 삭제가 가능하다. 표시만 하는 것은 특정 구현 방식일 뿐이다.', false),

       (229, 87, '정렬된 데이터를 순차적으로 삽입하면 한쪽으로 편향된다',
        '정렬된 데이터(1, 2, 3, ...)를 순차적으로 삽입하면 한쪽으로 편향되는 구조가 된다. 이 경우 트리의 높이가 n이 되어 탐색/삽입/삭제가 O(n)으로 저하된다.', true),
       (230, 87, '편향 트리는 균형잡힌 최적의 상태이다',
        '편향 트리는 균형이 깨진 최악의 상태이다. 연결리스트와 유사한 형태가 되어 BST의 이점을 상실한다.', false),
       (231, 87, '편향 트리에서도 탐색이 O(log n)이다',
        '편향 트리에서는 탐색이 O(n)으로 저하된다. 한쪽 방향으로만 탐색이 진행되기 때문이다.', false),
       (232, 87, '랜덤 데이터 삽입 시 항상 편향 트리가 된다',
        '랜덤 데이터를 삽입하면 일반적으로 어느 정도 균형잡힌 트리가 형성된다. 정렬된 데이터를 순차 삽입할 때 편향된다.', false),

       (233, 88, 'AVL 트리, Red-Black 트리',
        'AVL 트리와 Red-Black 트리는 자가 균형(Self-Balancing) 이진 탐색 트리로, 삽입/삭제 시 자동으로 균형을 맞추어 항상 O(log n)의 성능을 보장한다.', true),
       (234, 88, '스택, 큐',
        '스택과 큐는 특정 순서로 데이터를 처리하는 선형 자료구조로, BST의 편향 문제와는 관련이 없다.', false),
       (235, 88, '배열, 연결리스트',
        '배열과 연결리스트는 기본 선형 자료구조로, BST의 균형 문제를 해결하는 자료구조가 아니다.', false),
       (236, 88, '해시 테이블',
        '해시 테이블은 O(1) 탐색을 제공하는 자료구조이지만, BST의 편향 문제를 해결하기 위한 것이 아니며 정렬된 순회가 불가능하다.', false),

       (237, 90, '데이터베이스 인덱싱',
        '데이터베이스는 B-Tree나 B+Tree 등 균형잡힌 트리 구조를 인덱싱에 활용한다. 이는 BST의 확장된 형태로 효율적인 탐색과 범위 검색을 제공한다.', true),
       (238, 90, '프로세스 스케줄링',
        '프로세스 스케줄링은 우선순위 큐나 일반 큐를 주로 사용한다. BST를 직접 사용하지는 않는다.', false),
       (239, 90, '네트워크 패킷 전송',
        '네트워크 패킷 전송은 큐나 버퍼를 사용한다. 계층적 탐색 구조가 필요하지 않으므로 BST를 사용하지 않는다.', false),
       (240, 90, '스택 메모리 관리',
        '스택 메모리는 LIFO 구조의 스택 자료구조로 관리된다. BST와는 관련이 없다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (29, 86, '최대값, 최댓값, maximum',
        '자식이 2개인 노드를 삭제할 때는 왼쪽 서브 트리의 최대값(가장 오른쪽 노드) 또는 오른쪽 서브 트리의 최소값(가장 왼쪽 노드)으로 대체한다. 이렇게 하면 BST의 대소 관계 규칙이 유지된다.'),
       (30, 89, 'O(n)',
        '편향 트리에서는 트리의 높이가 n이 되므로 탐색, 삽입, 삭제의 시간 복잡도가 O(n)으로 저하된다. 이는 연결리스트와 동일한 성능으로, BST의 이점을 완전히 상실한 상태이다.');

-- Chapter: 자료구조 (id: 1), Unit: 힙 & 우선순위 큐 (id: 6)

-- Lesson 생성
INSERT INTO lesson (id, unit_id, title)
VALUES (16, 6, '힙 기초 문제집'),
       (17, 6, '힙 연산 문제집'),
       (18, 6, '우선순위 큐 응용 문제집');

-- Chapter: 자료구조 (id: 1), Unit: 힙 & 우선순위 큐 (id: 6), Lesson: 힙 기초 문제집 (id: 16)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (91, 16, '다음 중 힙의 정의로 올바른 것은?', '힙(Heap)은 완전 이진 트리 기반의 자료구조이다.', 'OBJECTIVE'),
       (92, 16, '빈칸에 들어갈 용어를 작성하시오', '힙은 ___기반의 자료구조로, 최대값 또는 최소값을 빠르게 찾기 위해 설계되었다.', 'SUBJECTIVE'),
       (93, 16, '다음 중 최대 힙의 특징으로 올바른 것은?', '최대 힙(Max Heap)은 힙의 한 종류이다.', 'OBJECTIVE'),
       (94, 16, '다음 중 최소 힙의 특징으로 올바른 것은?', '최소 힙(Min Heap)은 힙의 한 종류이다.', 'OBJECTIVE'),
       (95, 16, '빈칸에 들어갈 시간 복잡도를 작성하시오', '힙에서 최대값 또는 최소값에 접근하는 시간 복잡도는 ___이다.', 'SUBJECTIVE'),
       (96, 16, '다음 중 힙의 구현 방법으로 올바른 것은?', '힙은 효율적인 구현을 위해 특정 방식을 사용한다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (241, 91, '완전 이진 트리 기반의 자료구조이다',
        '힙은 완전 이진 트리 기반의 자료구조로, 최대값 또는 최소값을 빠르게 찾기 위해 설계되었다. 부모와 자식 간의 대소 관계만 유지하는 반정렬 상태이다.', true),
       (242, 91, 'FIFO 구조의 자료구조이다',
        'FIFO 구조는 큐의 특징이다. 힙은 부모-자식 간 대소 관계를 유지하는 완전 이진 트리 구조이다.', false),
       (243, 91, '정렬된 배열이다',
        '힙은 완전히 정렬된 상태가 아니라 부모-자식 간 대소 관계만 유지하는 반정렬 상태이다. 완전히 정렬된 배열과는 다르다.', false),
       (244, 91, '연결리스트 기반의 자료구조이다',
        '힙은 완전 이진 트리 구조이며, 일반적으로 배열로 구현된다. 연결리스트 기반이 아니다.', false),

       (245, 93, '부모 노드의 값이 자식 노드의 값보다 크거나 같다',
        '최대 힙은 부모 노드의 값이 자식 노드의 값보다 크거나 같은 완전 이진 트리이다. 루트 노드에 최대값이 위치하므로 O(1) 시간에 최대값 접근이 가능하다.', true),
       (246, 93, '부모 노드의 값이 자식 노드의 값보다 작거나 같다',
        '부모가 자식보다 작거나 같은 것은 최소 힙의 특징이다. 최대 힙은 부모가 자식보다 크거나 같다.', false),
       (247, 93, '형제 노드 간에도 대소 관계가 정의된다',
        '힙은 부모-자식 간의 대소 관계만 유지한다. 형제 노드 간의 대소 관계는 정의되지 않는다.', false),
       (248, 93, '완전히 정렬된 상태이다',
        '힙은 부모-자식 간 대소 관계만 유지하는 반정렬 상태이다. 완전히 정렬된 상태가 아니다.', false),

       (249, 94, '부모 노드의 값이 자식 노드의 값보다 작거나 같다',
        '최소 힙은 부모 노드의 값이 자식 노드의 값보다 작거나 같은 완전 이진 트리이다. 루트 노드에 최소값이 위치하므로 O(1) 시간에 최소값 접근이 가능하다.', true),
       (250, 94, '부모 노드의 값이 자식 노드의 값보다 크거나 같다',
        '부모가 자식보다 크거나 같은 것은 최대 힙의 특징이다. 최소 힙은 부모가 자식보다 작거나 같다.', false),
       (251, 94, '루트에 최대값이 위치한다',
        '최소 힙은 루트에 최소값이 위치한다. 최대값이 루트에 있는 것은 최대 힙이다.', false),
       (252, 94, '이진 탐색 트리의 규칙을 따른다',
        '힙은 이진 탐색 트리와 다른 규칙을 가진다. BST는 왼쪽이 작고 오른쪽이 크지만, 힙은 부모-자식 간 대소 관계만 유지한다.', false),

       (253, 96, '배열을 사용하여 구현한다',
        '힙은 완전 이진 트리이므로 배열을 사용하여 효율적으로 구현할 수 있다. 인덱스 i의 왼쪽 자식은 2i, 오른쪽 자식은 2i+1, 부모는 i/2이다.', true),
       (254, 96, '연결리스트로만 구현 가능하다',
        '힙은 완전 이진 트리이므로 배열로 구현하는 것이 가장 효율적이다. 연결리스트로도 가능하지만 일반적이지 않다.', false),
       (255, 96, '해시 테이블을 사용한다',
        '해시 테이블은 키-값 쌍을 저장하는 자료구조이다. 힙은 배열 기반 완전 이진 트리로 구현한다.', false),
       (256, 96, '스택으로 구현한다',
        '스택은 LIFO 구조의 선형 자료구조이다. 힙은 완전 이진 트리 구조로 배열을 사용하여 구현한다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (31, 92, '완전 이진 트리, Complete Binary Tree',
        '힙은 완전 이진 트리 기반의 자료구조이다. 완전 이진 트리는 마지막 레벨을 제외한 모든 레벨이 꽉 차있고, 마지막 레벨은 왼쪽부터 채워진 트리이다. 이러한 구조 덕분에 배열로 효율적으로 구현할 수 있다.'),
       (32, 95, 'O(1)',
        '힙에서 최대값(최대 힙) 또는 최소값(최소 힙)은 항상 루트 노드에 위치하므로 O(1) 시간에 접근할 수 있다. 이는 힙의 가장 큰 장점 중 하나이다.');

-- Chapter: 자료구조 (id: 1), Unit: 힙 & 우선순위 큐 (id: 6), Lesson: 힙 연산 문제집 (id: 17)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (97, 17, '다음 중 힙의 삽입 과정으로 올바른 것은?', '힙에 새로운 원소를 삽입하는 과정이다.', 'OBJECTIVE'),
       (98, 17, '빈칸에 들어갈 시간 복잡도를 작성하시오', '힙의 삽입 연산의 시간 복잡도는 ___이다.', 'SUBJECTIVE'),
       (99, 17, '다음 중 힙의 삭제 과정으로 올바른 것은?', '힙에서 루트 노드를 삭제하는 과정이다.', 'OBJECTIVE'),
       (100, 17, '다음 중 힙의 배열 표현에서 인덱스 관계로 올바른 것은?', '힙을 배열로 구현할 때 부모와 자식의 인덱스 관계이다.', 'OBJECTIVE'),
       (101, 17, '빈칸에 들어갈 시간 복잡도를 작성하시오', '힙의 삭제 연산의 시간 복잡도는 ___이다.', 'SUBJECTIVE'),
       (102, 17, '다음 중 힙의 특징으로 올바른 것은?', '힙은 특정한 성질을 만족하는 자료구조이다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (257, 97, '마지막 위치에 삽입한 후 부모와 비교하며 위로 이동시킨다',
        '힙의 삽입은 완전 이진 트리 구조를 유지하기 위해 마지막 위치에 원소를 추가한 후, 부모 노드와 비교하며 힙 속성을 만족할 때까지 위로 이동시킨다.', true),
       (258, 97, '루트 위치에 바로 삽입한다',
        '루트 위치에 바로 삽입하면 힙의 완전 이진 트리 구조가 깨진다. 마지막 위치에 삽입한 후 조정한다.', false),
       (259, 97, '중간 위치에 삽입한다',
        '중간 위치에 삽입하면 완전 이진 트리 구조가 깨진다. 항상 마지막 위치에 삽입한 후 위로 이동시킨다.', false),
       (260, 97, '정렬된 위치를 찾아 삽입한다',
        '힙은 완전히 정렬된 구조가 아니다. 완전 이진 트리의 마지막 위치에 삽입한 후 부모와 비교하며 조정한다.', false),

       (261, 99, '루트를 삭제하고 마지막 노드를 루트로 이동한 후 아래로 조정한다',
        '힙의 삭제는 루트 노드(최대값 또는 최소값)를 삭제한 후, 마지막 노드를 루트 위치로 이동시키고, 자식과 비교하며 아래로 이동시켜 힙 속성을 복구한다.', true),
       (262, 99, '중간 노드를 삭제한다',
        '힙의 삭제 연산은 루트 노드(최대값 또는 최소값)를 삭제하는 것이다. 중간 노드를 삭제하는 것은 일반적인 힙 연산이 아니다.', false),
       (263, 99, '마지막 노드를 삭제한다',
        '마지막 노드를 삭제하는 것이 아니라, 루트를 삭제하고 마지막 노드를 루트로 이동시킨 후 조정한다.', false),
       (264, 99, '삭제 없이 표시만 한다',
        '힙에서는 실제로 루트 노드를 삭제하고 힙 구조를 재조정한다. 표시만 하는 것이 아니다.', false),

       (265, 100, '인덱스 i의 왼쪽 자식은 2i, 오른쪽 자식은 2i+1이다',
        '배열의 인덱스 1부터 시작할 때, 인덱스 i의 왼쪽 자식은 2i, 오른쪽 자식은 2i+1, 부모는 i/2이다. 이러한 규칙으로 배열만으로 트리 구조를 표현할 수 있다.',
        true),
       (266, 100, '인덱스 i의 왼쪽 자식은 i+1, 오른쪽 자식은 i+2이다',
        '이는 잘못된 인덱스 관계이다. 완전 이진 트리의 배열 표현은 왼쪽 자식 2i, 오른쪽 자식 2i+1의 관계를 가진다.', false),
       (267, 100, '인덱스 i의 부모는 i+1이다',
        '인덱스 i의 부모는 i/2이다. i+1은 잘못된 관계이다.', false),
       (268, 100, '인덱스 관계가 정의되지 않는다',
        '완전 이진 트리는 명확한 인덱스 관계가 정의된다. 이를 이용해 배열로 효율적으로 구현할 수 있다.', false),

       (269, 102, '부모-자식 간 대소 관계만 유지하는 반정렬 상태이다',
        '힙은 부모-자식 간의 대소 관계만 유지하는 반정렬 상태이다. 형제 노드 간의 순서는 정의되지 않으며, 완전히 정렬된 상태가 아니다.', true),
       (270, 102, '완전히 정렬된 상태를 유지한다',
        '힙은 완전히 정렬된 상태가 아니라 부모-자식 간 대소 관계만 유지한다. 형제 노드 간에는 순서가 없다.', false),
       (271, 102, '중복된 값을 허용하지 않는다',
        '힙은 중복된 값을 허용한다. 이진 탐색 트리와 달리 중복 값 저장에 제약이 없다.', false),
       (272, 102, '이진 탐색 트리의 규칙을 따른다',
        '힙과 이진 탐색 트리는 다른 규칙을 가진다. BST는 왼쪽이 작고 오른쪽이 크지만, 힙은 부모가 자식보다 크거나(최대 힙) 작다(최소 힙).', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (33, 98, 'O(log n)',
        '힙의 삽입 연산은 마지막 위치에 원소를 추가한 후 부모와 비교하며 위로 이동시킨다. 트리의 높이만큼 비교가 필요하므로 시간 복잡도는 O(log n)이다.'),
       (34, 101, 'O(log n)',
        '힙의 삭제 연산은 루트를 삭제하고 마지막 노드를 루트로 이동한 후 자식과 비교하며 아래로 조정한다. 트리의 높이만큼 비교가 필요하므로 시간 복잡도는 O(log n)이다.');

-- Chapter: 자료구조 (id: 1), Unit: 힙 & 우선순위 큐 (id: 6), Lesson: 우선순위 큐 응용 문제집 (id: 18)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (103, 18, '다음 중 우선순위 큐의 정의로 올바른 것은?', '우선순위 큐(Priority Queue)는 특별한 규칙을 가진 자료구조이다.', 'OBJECTIVE'),
       (104, 18, '빈칸에 들어갈 자료구조를 작성하시오', '우선순위 큐는 ___를 사용하여 구현하는 것이 가장 효율적이다.', 'SUBJECTIVE'),
       (105, 18, '다음 중 우선순위 큐의 구현 방법 비교로 올바른 것은?', '우선순위 큐는 다양한 방법으로 구현할 수 있다.', 'OBJECTIVE'),
       (106, 18, '다음 중 우선순위 큐의 활용 사례로 올바른 것은?', '우선순위 큐는 다양한 알고리즘과 시스템에서 활용된다.', 'OBJECTIVE'),
       (107, 18, '빈칸에 들어갈 시간 복잡도를 작성하시오', '힙으로 구현한 우선순위 큐에서 삽입과 삭제의 시간 복잡도는 ___이다.', 'SUBJECTIVE'),
       (108, 18, '다음 중 힙 정렬에 대한 설명으로 올바른 것은?', '힙 정렬은 힙 자료구조를 활용하는 정렬 알고리즘이다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (273, 103, '우선순위가 높은 데이터가 먼저 나가는 자료구조이다',
        '우선순위 큐는 우선순위가 높은 데이터가 먼저 나가는 자료구조이다. 일반 큐의 FIFO와 달리, 우선순위에 따라 처리 순서가 결정된다.', true),
       (274, 103, 'FIFO 구조로 동작한다',
        'FIFO는 일반 큐의 특징이다. 우선순위 큐는 우선순위에 따라 처리 순서가 결정된다.', false),
       (275, 103, 'LIFO 구조로 동작한다',
        'LIFO는 스택의 특징이다. 우선순위 큐는 우선순위에 따라 처리 순서가 결정된다.', false),
       (276, 103, '삽입 순서대로 처리된다',
        '우선순위 큐는 삽입 순서가 아니라 우선순위에 따라 처리된다. 높은 우선순위가 먼저 처리된다.', false),

       (277, 105, '힙으로 구현하면 삽입과 삭제가 O(log n)이다',
        '힙으로 우선순위 큐를 구현하면 삽입과 삭제 모두 O(log n)의 시간 복잡도를 가진다. 이는 배열이나 연결리스트보다 효율적이다.', true),
       (278, 105, '배열로 구현하면 모든 연산이 O(1)이다',
        '배열로 구현하면 삽입은 O(1)이지만 최대/최소값 찾기는 O(n)이 소요된다. 힙이 더 효율적이다.', false),
       (279, 105, '연결리스트로 구현하면 삽입이 O(1)이고 삭제도 O(1)이다',
        '연결리스트로 구현하면 삽입은 O(1)이지만 최대/최소값을 찾아 삭제하려면 O(n)이 필요하다.', false),
       (280, 105, '스택으로 구현하는 것이 가장 효율적이다',
        '스택은 LIFO 구조로 우선순위 큐 구현에 적합하지 않다. 힙을 사용하는 것이 가장 효율적이다.', false),

       (281, 106, '다익스트라 최단 경로 알고리즘',
        '다익스트라 알고리즘은 우선순위 큐를 사용하여 현재까지의 최단 거리가 가장 짧은 노드를 선택한다. 힙 기반 우선순위 큐로 O((V+E)log V)에 구현할 수 있다.',
        true),
       (282, 106, '깊이 우선 탐색(DFS)',
        'DFS는 스택을 사용하는 알고리즘이다. 우선순위 큐를 사용하지 않는다.', false),
       (283, 106, '이진 탐색',
        '이진 탐색은 정렬된 배열에서 중간값을 비교하며 탐색하는 알고리즘으로, 우선순위 큐를 사용하지 않는다.', false),
       (284, 106, '해시 테이블 충돌 처리',
        '해시 테이블의 충돌 처리는 체이닝이나 개방 주소법을 사용한다. 우선순위 큐와는 관련이 없다.', false),

       (285, 108, '힙을 구성한 후 루트를 반복적으로 추출하여 정렬한다',
        '힙 정렬은 배열을 힙으로 구성한 후, 루트(최대값 또는 최소값)를 반복적으로 추출하며 정렬하는 알고리즘이다. 시간 복잡도는 O(n log n)이다.', true),
       (286, 108, '퀵 정렬과 동일한 알고리즘이다',
        '힙 정렬과 퀵 정렬은 다른 알고리즘이다. 힙 정렬은 힙을 사용하고, 퀵 정렬은 피벗을 사용한다.', false),
       (287, 108, '시간 복잡도가 O(n^2)이다',
        '힙 정렬의 시간 복잡도는 최선, 평균, 최악 모두 O(n log n)이다. O(n^2)가 아니다.', false),
       (288, 108, '추가 메모리가 O(n) 필요하다',
        '힙 정렬은 제자리 정렬(in-place)로 추가 메모리가 O(1)만 필요하다. 병합 정렬과 달리 O(n)의 추가 메모리가 필요하지 않다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (35, 104, '힙, Heap',
        '우선순위 큐는 힙을 사용하여 구현하는 것이 가장 효율적이다. 최대 힙을 사용하면 최대 우선순위 큐를, 최소 힙을 사용하면 최소 우선순위 큐를 구현할 수 있으며, 삽입과 삭제가 모두 O(log n)에 가능하다.'),
       (36, 107, 'O(log n)',
        '힙으로 구현한 우선순위 큐에서 삽입과 삭제의 시간 복잡도는 O(log n)이다. 힙의 높이만큼 비교와 조정이 필요하기 때문이다. 이는 배열(O(n))이나 연결리스트(O(n))보다 효율적이다.');

-- Chapter: 자료구조 (id: 1), Unit: 트라이(Trie) (id: 7)

-- Lesson 생성
INSERT INTO lesson (id, unit_id, title)
VALUES (19, 7, '트라이 기초 문제집'),
       (20, 7, '트라이 응용 문제집');

-- Chapter: 자료구조 (id: 1), Unit: 트라이(Trie) (id: 7), Lesson: 트라이 기초 문제집 (id: 19)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (109, 19, '다음 중 트라이의 정의로 올바른 것은?', '트라이(Trie)는 문자열을 효율적으로 저장하고 탐색하는 자료구조이다.', 'OBJECTIVE'),
       (110, 19, '빈칸에 들어갈 용어를 작성하시오', '트라이는 ___트리 또는 검색 트리라고도 불린다.', 'SUBJECTIVE'),
       (111, 19, '다음 중 트라이의 특징으로 올바른 것은?', '트라이는 문자열 탐색에 특화된 트리 구조이다.', 'OBJECTIVE'),
       (112, 19, '다음 중 트라이의 노드 구조로 올바른 것은?', '트라이의 각 노드는 특정한 정보를 저장한다.', 'OBJECTIVE'),
       (113, 19, '빈칸에 들어갈 시간 복잡도를 작성하시오', '길이가 M인 문자열을 트라이에서 탐색하는 시간 복잡도는 ___이다.', 'SUBJECTIVE'),
       (114, 19, '다음 중 트라이의 장점으로 올바른 것은?', '트라이는 다른 문자열 탐색 방법과 비교하여 장점을 가진다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (289, 109, '문자열을 트리 형태로 저장하여 효율적으로 탐색하는 자료구조이다',
        '트라이는 문자열을 트리 형태로 저장하는 자료구조로, 접두사 트리(Prefix Tree) 또는 검색 트리(Retrieval Tree)라고도 한다. 문자열 탐색에 특화되어 있다.', true),
       (290, 109, 'FIFO 구조의 자료구조이다',
        'FIFO는 큐의 특징이다. 트라이는 트리 구조로 문자열을 저장하고 탐색하는 자료구조이다.', false),
       (291, 109, '정수를 효율적으로 탐색하는 자료구조이다',
        '트라이는 문자열 탐색에 특화된 자료구조이다. 정수 탐색이 주목적이 아니다.', false),
       (292, 109, '연결리스트의 한 종류이다',
        '트라이는 트리 구조이다. 연결리스트가 아니라 계층적 트리 구조로 문자열을 저장한다.', false),

       (293, 111, '각 노드는 문자 하나와 문자열 종료 여부를 저장한다',
        '트라이의 각 노드는 문자 하나와 문자열 종료 여부(flag)를 저장한다. 루트에서 특정 노드까지의 경로가 하나의 문자열을 형성한다.', true),
       (294, 111, '각 노드는 완전한 문자열을 저장한다',
        '트라이의 각 노드는 문자 하나만 저장한다. 완전한 문자열은 루트부터 해당 노드까지의 경로로 표현된다.', false),
       (295, 111, '이진 트리 구조로만 구현 가능하다',
        '트라이는 이진 트리가 아니다. 각 노드는 여러 개의 자식(일반적으로 알파벳 개수만큼)을 가질 수 있다.', false),
       (296, 111, '사이클이 존재한다',
        '트라이는 트리 구조이므로 사이클이 존재하지 않는다.', false),

       (297, 112, '문자 하나와 문자열 종료 여부를 저장한다',
        '트라이의 각 노드는 문자 하나와 문자열 종료 여부(flag)를 저장한다. 또한 자식 노드를 가리키는 포인터 배열을 가진다.', true),
       (298, 112, '완전한 문자열만 저장한다',
        '각 노드는 문자 하나만 저장한다. 완전한 문자열은 경로로 표현된다.', false),
       (299, 112, '숫자 값만 저장한다',
        '트라이는 문자를 저장한다. 각 노드는 문자 하나와 종료 플래그를 저장한다.', false),
       (300, 112, '부모 노드의 포인터만 저장한다',
        '트라이의 노드는 자식 노드를 가리키는 포인터를 저장한다. 부모 포인터만 저장하는 것이 아니다.', false),

       (301, 114, '접두사 기반 검색에 효율적이다',
        '트라이는 공통 접두사를 공유하므로 자동완성이나 접두사 기반 검색에 매우 효율적이다. 문자열의 길이가 M일 때 O(M) 시간에 탐색이 가능하다.', true),
       (302, 114, '메모리 사용량이 매우 적다',
        '트라이는 각 노드가 자식 노드 포인터 배열을 저장하므로 메모리 사용량이 크다. 이는 트라이의 단점이다.', false),
       (303, 114, '정렬된 순서로 저장된다',
        '트라이는 문자열을 트리 형태로 저장하며, 정렬된 순서로 저장하는 것이 주목적이 아니다.', false),
       (304, 114, '삽입과 삭제가 O(1)이다',
        '트라이의 삽입과 삭제는 문자열 길이 M에 비례하므로 O(M)이다. O(1)이 아니다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (37, 110, '접두사, Prefix',
        '트라이는 접두사 트리(Prefix Tree) 또는 검색 트리(Retrieval Tree)라고도 불린다. 공통 접두사를 공유하여 저장하므로 접두사 기반 검색에 효율적이다.'),
       (38, 113, 'O(M)',
        '길이가 M인 문자열을 트라이에서 탐색하는 시간 복잡도는 O(M)이다. 문자열의 각 문자를 순서대로 따라가며 탐색하므로 문자열 길이에 비례한다. 저장된 문자열의 개수와는 무관하다.');

-- Chapter: 자료구조 (id: 1), Unit: 트라이(Trie) (id: 7), Lesson: 트라이 응용 문제집 (id: 20)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (115, 20, '다음 중 트라이의 삽입 과정으로 올바른 것은?', '트라이에 새로운 문자열을 삽입하는 과정이다.', 'OBJECTIVE'),
       (116, 20, '빈칸에 들어갈 시간 복잡도를 작성하시오', '길이가 M인 문자열을 트라이에 삽입하는 시간 복잡도는 ___이다.', 'SUBJECTIVE'),
       (117, 20, '다음 중 트라이의 공간 복잡도에 대한 설명으로 올바른 것은?', '트라이의 메모리 사용량에 대한 설명이다.', 'OBJECTIVE'),
       (118, 20, '다음 중 트라이의 단점으로 올바른 것은?', '트라이는 장점과 함께 단점도 가지고 있다.', 'OBJECTIVE'),
       (119, 20, '빈칸에 들어갈 용어를 작성하시오', '트라이에서 문자열의 ___를 공유하여 저장 공간을 절약한다.', 'SUBJECTIVE'),
       (120, 20, '다음 중 트라이의 활용 사례로 올바른 것은?', '트라이는 다양한 분야에서 활용되는 자료구조이다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (305, 115, '기존 경로를 따라가다가 없는 문자를 만나면 새 노드를 생성한다',
        '트라이의 삽입은 루트부터 시작하여 문자열의 각 문자에 해당하는 경로를 따라간다. 기존 경로가 있으면 그대로 이동하고, 없으면 새 노드를 생성한다. 마지막 노드에 종료 플래그를 설정한다.',
        true),
       (306, 115, '항상 새로운 경로를 생성한다',
        '공통 접두사가 있으면 기존 경로를 공유한다. 항상 새로운 경로를 생성하는 것이 아니다.', false),
       (307, 115, '문자열 전체를 하나의 노드에 저장한다',
        '트라이는 문자열을 문자 단위로 분해하여 각 문자를 노드에 저장한다. 전체 문자열을 하나의 노드에 저장하지 않는다.', false),
       (308, 115, '정렬된 위치를 찾아 삽입한다',
        '트라이는 문자 단위로 경로를 따라가며 삽입한다. 정렬된 위치를 찾는 것이 아니다.', false),

       (309, 117, '각 노드가 자식 노드 포인터 배열을 저장하여 메모리 사용량이 크다',
        '트라이의 각 노드는 자식 노드를 가리키는 포인터 배열을 저장한다. 저장할 문자 종류가 많을수록(예: 알파벳 26개) 메모리 오버헤드가 증가한다. 이는 트라이의 주요 단점이다.',
        true),
       (310, 117, '메모리 사용량이 매우 적다',
        '트라이는 각 노드가 포인터 배열을 저장하므로 메모리 사용량이 크다. 이는 트라이의 단점이다.', false),
       (311, 117, '문자열 개수에만 비례한다',
        '메모리 사용량은 문자열 개수뿐만 아니라 문자 종류의 개수, 문자열의 길이 등에도 영향을 받는다.', false),
       (312, 117, '배열과 동일한 메모리를 사용한다',
        '트라이는 트리 구조로 포인터 배열을 추가로 저장하므로 단순 배열보다 메모리를 많이 사용한다.', false),

       (313, 118, '각 노드가 포인터 배열을 저장하여 메모리 사용량이 크다',
        '트라이의 주요 단점은 메모리 사용량이 크다는 것이다. 각 노드가 자식 노드 포인터 배열을 저장하므로, 저장할 문자 종류가 많을수록 메모리 오버헤드가 증가한다.', true),
       (314, 118, '탐색 시간이 O(n^2)으로 비효율적이다',
        '트라이의 탐색 시간은 O(M)으로 효율적이다. M은 문자열 길이이며, O(n^2)가 아니다.', false),
       (315, 118, '삽입이 불가능하다',
        '트라이는 삽입이 가능하다. 삽입 시간 복잡도는 O(M)이다.', false),
       (316, 118, '문자열을 저장할 수 없다',
        '트라이는 문자열을 저장하는 자료구조이다. 문자열 저장이 가능하다.', false),

       (317, 120, '검색 엔진의 자동완성 기능',
        '트라이는 접두사 기반 검색에 효율적이므로 검색 엔진의 자동완성, 사전 검색, IDE의 자동완성 등에 활용된다. 사용자가 입력한 접두사로 시작하는 모든 단어를 빠르게 찾을 수 있다.',
        true),
       (318, 120, '정수 정렬',
        '정수 정렬은 일반적으로 정렬 알고리즘을 사용한다. 트라이는 문자열 탐색에 특화되어 있다.', false),
       (319, 120, '스택 메모리 관리',
        '스택 메모리는 LIFO 구조의 스택 자료구조로 관리된다. 트라이와는 관련이 없다.', false),
       (320, 120, '네트워크 패킷 라우팅',
        '네트워크 패킷 라우팅은 라우팅 테이블을 사용한다. 트라이가 일부 사용될 수 있지만 주요 활용 사례는 아니다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (39, 116, 'O(M)',
        '길이가 M인 문자열을 트라이에 삽입하는 시간 복잡도는 O(M)이다. 문자열의 각 문자를 순서대로 처리하며 노드를 생성하거나 이동하므로 문자열 길이에 비례한다.'),
       (40, 119, '공통 접두사, 접두사, prefix',
        '트라이는 문자열의 공통 접두사를 공유하여 저장 공간을 절약한다. 예를 들어 "cat"과 "car"는 "ca"라는 공통 접두사를 공유하므로 "ca"까지의 경로를 함께 사용한다.');

-- Chapter: 자료구조 (id: 1), Unit: 균형 이진 탐색 트리 (id: 8)

-- Lesson 생성
INSERT INTO lesson (id, unit_id, title)
VALUES (21, 8, 'AVL 트리 기초 문제집'),
       (22, 8, 'Red-Black 트리 기초 문제집'),
       (23, 8, '균형 트리 비교 문제집');

-- Chapter: 자료구조 (id: 1), Unit: 균형 이진 탐색 트리 (id: 8), Lesson: AVL 트리 기초 문제집 (id: 21)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (121, 21, '다음 중 AVL 트리의 정의로 올바른 것은?', 'AVL 트리는 이진 탐색 트리의 한계를 개선한 자료구조이다.', 'OBJECTIVE'),
       (122, 21, '빈칸에 들어갈 숫자를 작성하시오', 'AVL 트리는 모든 노드의 왼쪽과 오른쪽 서브트리의 높이 차이를 최대 ___로 유지한다.', 'SUBJECTIVE'),
       (123, 21, '다음 중 AVL 트리의 균형 지표(BF)에 대한 설명으로 올바른 것은?', 'AVL 트리는 균형 지표를 사용하여 균형을 판단한다.', 'OBJECTIVE'),
       (124, 21, '다음 중 AVL 트리의 회전에 대한 설명으로 올바른 것은?', 'AVL 트리는 균형이 깨지면 회전을 수행한다.', 'OBJECTIVE'),
       (125, 21, '빈칸에 들어갈 시간 복잡도를 작성하시오', 'AVL 트리에서 탐색, 삽입, 삭제 연산의 시간 복잡도는 모두 ___이다.', 'SUBJECTIVE'),
       (126, 21, '다음 중 AVL 트리의 장점으로 올바른 것은?', 'AVL 트리는 이진 탐색 트리보다 개선된 특성을 가진다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (321, 121, '왼쪽과 오른쪽 서브트리의 높이 차이를 최대 1로 유지하는 균형 이진 탐색 트리이다',
        'AVL 트리는 모든 노드의 왼쪽 서브트리와 오른쪽 서브트리의 높이 차이를 최대 1로 유지하는 균형 이진 탐색 트리이다. 삽입이나 삭제 시 균형이 깨지면 회전을 통해 균형을 복구한다.',
        true),
       (322, 121, '모든 노드가 2개의 자식을 가지는 트리이다',
        '이는 포화 이진 트리의 특징이다. AVL 트리는 높이 차이를 1 이하로 유지하는 균형 이진 탐색 트리이다.', false),
       (323, 121, '사이클이 존재하는 그래프이다',
        'AVL 트리는 트리 구조이므로 사이클이 존재하지 않는다.', false),
       (324, 121, 'LIFO 구조의 자료구조이다',
        'LIFO는 스택의 특징이다. AVL 트리는 균형 이진 탐색 트리이다.', false),

       (325, 123, 'BF = 왼쪽 서브트리 높이 - 오른쪽 서브트리 높이이며, -1, 0, 1 중 하나여야 한다',
        'AVL 트리의 균형 지표(Balance Factor)는 왼쪽 서브트리 높이에서 오른쪽 서브트리 높이를 뺀 값이다. 균형을 유지하려면 BF가 -1, 0, 1 중 하나여야 한다.',
        true),
       (326, 123, 'BF는 항상 0이어야 한다',
        'BF는 -1, 0, 1 중 하나면 된다. 항상 0일 필요는 없다.', false),
       (327, 123, 'BF = 오른쪽 서브트리 높이 - 왼쪽 서브트리 높이이다',
        'BF는 왼쪽 서브트리 높이 - 오른쪽 서브트리 높이이다. 순서가 반대이다.', false),
       (328, 123, 'BF는 노드의 개수로 계산한다',
        'BF는 높이로 계산한다. 노드의 개수가 아니다.', false),

       (329, 124, '균형이 깨지면 LL, RR, LR, RL 케이스에 맞춰 회전을 수행한다',
        'AVL 트리는 삽입이나 삭제 시 BF가 -1, 0, 1을 벗어나면 LL(Left Left), RR(Right Right), LR(Left Right), RL(Right Left) 케이스에 맞춰 회전을 수행하여 균형을 복구한다.',
        true),
       (330, 124, '회전 없이 노드를 재배치한다',
        'AVL 트리는 회전을 통해 균형을 복구한다. 회전 없이는 균형을 유지할 수 없다.', false),
       (331, 124, '균형이 깨져도 회전하지 않는다',
        'AVL 트리는 균형이 깨지면 반드시 회전을 수행하여 균형을 복구한다.', false),
       (332, 124, '삽입만 회전하고 삭제는 회전하지 않는다',
        'AVL 트리는 삽입과 삭제 모두에서 균형이 깨지면 회전을 수행한다.', false),

       (333, 126, '편향 트리 문제를 해결하여 모든 연산이 O(log n)을 보장한다',
        'AVL 트리는 높이 균형을 유지하므로 편향 트리가 발생하지 않는다. 따라서 탐색, 삽입, 삭제 모든 연산이 O(log n) 시간 복잡도를 보장한다.',
        true),
       (334, 126, '메모리 사용량이 매우 적다',
        'AVL 트리는 균형 정보를 저장해야 하므로 추가 메모리가 필요하다. 메모리 사용량이 적은 것은 아니다.', false),
       (335, 126, '삽입과 삭제가 O(1)이다',
        'AVL 트리의 삽입과 삭제는 O(log n)이다. O(1)이 아니다.', false),
       (336, 126, '중복 값을 허용한다',
        '일반적으로 이진 탐색 트리와 AVL 트리는 중복 값을 허용하지 않는다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (41, 122, '1',
        'AVL 트리는 모든 노드의 왼쪽과 오른쪽 서브트리의 높이 차이를 최대 1로 유지한다. 이를 통해 트리의 높이를 O(log n)으로 유지하여 모든 연산이 효율적으로 수행된다.'),
       (42, 125, 'O(log n)',
        'AVL 트리는 균형을 유지하므로 트리의 높이가 O(log n)이다. 따라서 탐색, 삽입, 삭제 모든 연산의 시간 복잡도가 O(log n)이다.');

-- Chapter: 자료구조 (id: 1), Unit: 균형 이진 탐색 트리 (id: 8), Lesson: Red-Black 트리 기초 문제집 (id: 22)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (127, 22, '다음 중 Red-Black 트리의 정의로 올바른 것은?', 'Red-Black 트리는 균형 이진 탐색 트리의 한 종류이다.', 'OBJECTIVE'),
       (128, 22, '빈칸에 들어갈 색상을 작성하시오', 'Red-Black 트리의 루트 노드와 리프 노드는 항상 ___색이다.', 'SUBJECTIVE'),
       (129, 22, '다음 중 Red-Black 트리의 속성으로 올바른 것은?', 'Red-Black 트리는 특정한 색상 규칙을 따른다.', 'OBJECTIVE'),
       (130, 22, '다음 중 Red-Black 트리의 균형 유지 방법으로 올바른 것은?', 'Red-Black 트리는 삽입이나 삭제 시 균형을 유지한다.', 'OBJECTIVE'),
       (131, 22, '빈칸에 들어갈 용어를 작성하시오', 'Red-Black 트리에서 Red 노드의 자식 노드는 모두 ___색이어야 한다.', 'SUBJECTIVE'),
       (132, 22, '다음 중 Red-Black 트리의 시간 복잡도로 올바른 것은?', 'Red-Black 트리의 연산 시간 복잡도는 특정 값으로 보장된다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (337, 127, '각 노드가 Red 또는 Black 색상을 가지며 색상 규칙을 통해 균형을 유지하는 이진 탐색 트리이다',
        'Red-Black 트리는 각 노드가 Red 또는 Black 색상을 가지며, 특정한 색상 규칙을 따라 균형을 유지하는 균형 이진 탐색 트리이다. AVL 트리보다 느슨한 균형 조건을 적용한다.',
        true),
       (338, 127, '모든 노드가 같은 색상을 가지는 트리이다',
        'Red-Black 트리는 Red와 Black 두 가지 색상을 사용한다. 모든 노드가 같은 색상을 가지지 않는다.', false),
       (339, 127, '높이 차이를 1로 유지하는 트리이다',
        '이는 AVL 트리의 특징이다. Red-Black 트리는 색상 규칙으로 균형을 유지한다.', false),
       (340, 127, '완전 이진 트리 구조만 허용한다',
        'Red-Black 트리는 완전 이진 트리일 필요는 없다. 색상 규칙을 만족하면 된다.', false),

       (341, 129, 'Red 노드의 자식 노드는 모두 Black이어야 한다',
        'Red-Black 트리의 중요한 속성 중 하나는 Red 노드의 자식 노드가 모두 Black이어야 한다는 것이다. 이를 통해 연속된 Red 노드가 존재하지 않도록 한다.',
        true),
       (342, 129, '모든 노드는 Red여야 한다',
        'Red-Black 트리는 Red와 Black 노드가 혼재한다. 모든 노드가 Red인 것은 아니다.', false),
       (343, 129, '리프 노드는 Red여야 한다',
        'Red-Black 트리의 리프 노드(NIL)는 Black이다. Red가 아니다.', false),
       (344, 129, '자식 노드의 색상은 제한이 없다',
        'Red-Black 트리는 명확한 색상 규칙이 있다. 자식 노드의 색상에 제한이 있다.', false),

       (345, 130, '삽입이나 삭제 시 회전과 색상 변경을 통해 균형을 복구한다',
        'Red-Black 트리는 Red-Black 속성을 위반하면 회전과 색상 변경을 통해 균형을 복구한다. AVL 트리보다 느슨한 균형 조건을 적용하므로 회전 횟수가 적다.',
        true),
       (346, 130, '균형을 유지하지 않는다',
        'Red-Black 트리는 균형 이진 탐색 트리이므로 균형을 유지한다.', false),
       (347, 130, '노드를 삭제하지 않는다',
        'Red-Black 트리는 삽입과 삭제 모두 가능하다.', false),
       (348, 130, '높이 차이만으로 균형을 판단한다',
        'Red-Black 트리는 색상 규칙으로 균형을 판단한다. 높이 차이만으로 판단하지 않는다.', false),

       (349, 132, '탐색, 삽입, 삭제 모두 O(log n)이다',
        'Red-Black 트리는 균형을 유지하므로 트리의 높이가 O(log n)이다. 따라서 탐색, 삽입, 삭제 모든 연산의 시간 복잡도가 O(log n)으로 보장된다.',
        true),
       (350, 132, '탐색만 O(log n)이고 삽입과 삭제는 O(n)이다',
        'Red-Black 트리는 균형을 유지하므로 삽입과 삭제도 O(log n)이다.', false),
       (351, 132, '모든 연산이 O(1)이다',
        '트리 구조에서 모든 연산이 O(1)일 수는 없다. Red-Black 트리는 O(log n)이다.', false),
       (352, 132, '최악의 경우 O(n^2)이다',
        'Red-Black 트리는 균형을 유지하므로 최악의 경우에도 O(log n)이다. O(n^2)가 아니다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (43, 128, 'Black, 블랙',
        'Red-Black 트리의 루트 노드와 리프 노드(NIL)는 항상 Black 색이다. 이는 Red-Black 트리의 기본 속성 중 하나이다.'),
       (44, 131, 'Black, 블랙',
        'Red-Black 트리에서 Red 노드의 자식 노드는 모두 Black색이어야 한다. 이를 통해 연속된 Red 노드가 존재하지 않도록 하여 균형을 유지한다.');

-- Chapter: 자료구조 (id: 1), Unit: 균형 이진 탐색 트리 (id: 8), Lesson: 균형 트리 비교 문제집 (id: 23)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (133, 23, '다음 중 AVL 트리와 Red-Black 트리의 공통점으로 올바른 것은?', 'AVL 트리와 Red-Black 트리는 공통점과 차이점을 가진다.', 'OBJECTIVE'),
       (134, 23, '빈칸에 들어갈 트리 이름을 작성하시오', '___트리는 AVL 트리보다 균형 조건이 느슨하여 회전 횟수가 적다.', 'SUBJECTIVE'),
       (135, 23, '다음 중 AVL 트리와 Red-Black 트리의 차이점으로 올바른 것은?', 'AVL 트리와 Red-Black 트리는 균형 유지 방법이 다르다.', 'OBJECTIVE'),
       (136, 23, '다음 중 균형 이진 탐색 트리의 장점으로 올바른 것은?', '균형 이진 탐색 트리는 일반 이진 탐색 트리보다 개선된 특성을 가진다.', 'OBJECTIVE'),
       (137, 23, '빈칸에 들어갈 시간 복잡도를 작성하시오', '편향 트리에서 탐색의 시간 복잡도는 ___이지만, 균형 트리에서는 O(log n)이다.', 'SUBJECTIVE'),
       (138, 23, '다음 중 Red-Black 트리의 장점으로 올바른 것은?', 'Red-Black 트리는 AVL 트리와 비교하여 장점을 가진다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (353, 133, '모두 균형 이진 탐색 트리이며 모든 연산이 O(log n)을 보장한다',
        'AVL 트리와 Red-Black 트리는 모두 균형 이진 탐색 트리이다. 트리의 높이를 O(log n)으로 유지하여 탐색, 삽입, 삭제 모든 연산이 O(log n) 시간 복잡도를 보장한다.',
        true),
       (354, 133, '모두 완전 이진 트리 구조이다',
        '균형 이진 탐색 트리가 완전 이진 트리일 필요는 없다. 균형 조건을 만족하면 된다.', false),
       (355, 133, '모두 중복 값을 허용한다',
        '일반적으로 이진 탐색 트리는 중복 값을 허용하지 않는다.', false),
       (356, 133, '모두 색상 정보를 저장한다',
        'AVL 트리는 높이 정보를 저장하고, Red-Black 트리만 색상 정보를 저장한다.', false),

       (357, 135, 'AVL 트리는 높이 차이로, Red-Black 트리는 색상 규칙으로 균형을 유지한다',
        'AVL 트리는 왼쪽과 오른쪽 서브트리의 높이 차이를 최대 1로 유지하고, Red-Black 트리는 색상 규칙을 통해 균형을 유지한다. AVL 트리가 더 엄격한 균형 조건을 가진다.',
        true),
       (358, 135, 'AVL 트리는 색상을, Red-Black 트리는 높이를 사용한다',
        '반대이다. AVL 트리는 높이를 사용하고, Red-Black 트리는 색상을 사용한다.', false),
       (359, 135, '둘 다 동일한 방법으로 균형을 유지한다',
        'AVL 트리와 Red-Black 트리는 서로 다른 방법으로 균형을 유지한다.', false),
       (360, 135, 'AVL 트리는 균형을 유지하지 않는다',
        'AVL 트리는 균형 이진 탐색 트리이므로 균형을 유지한다.', false),

       (361, 136, '편향 트리 문제를 해결하여 최악의 경우에도 O(log n)을 보장한다',
        '균형 이진 탐색 트리는 트리의 높이를 O(log n)으로 유지하여 편향 트리 문제를 해결한다. 따라서 최악의 경우에도 O(log n) 시간 복잡도를 보장한다.',
        true),
       (362, 136, '메모리 사용량이 배열보다 적다',
        '트리 구조는 포인터를 저장해야 하므로 배열보다 메모리 사용량이 많다.', false),
       (363, 136, '모든 연산이 O(1)이다',
        '균형 트리의 연산은 O(log n)이다. O(1)이 아니다.', false),
       (364, 136, '정렬 없이 데이터를 저장한다',
        '이진 탐색 트리는 왼쪽 < 부모 < 오른쪽 규칙으로 정렬된 구조를 유지한다.', false),

       (365, 138, 'AVL 트리보다 회전 횟수가 적어 삽입과 삭제가 더 빠르다',
        'Red-Black 트리는 AVL 트리보다 느슨한 균형 조건을 적용하여 회전 횟수가 적다. 따라서 삽입과 삭제 연산이 AVL 트리보다 빠르다. 대신 탐색은 AVL 트리가 더 빠르다.',
        true),
       (366, 138, '탐색이 AVL 트리보다 빠르다',
        'AVL 트리가 더 엄격한 균형을 유지하므로 탐색은 AVL 트리가 더 빠르다.', false),
       (367, 138, '메모리 사용량이 매우 적다',
        'Red-Black 트리는 색상 정보를 저장해야 하므로 추가 메모리가 필요하다.', false),
       (368, 138, '구현이 AVL 트리보다 간단하다',
        'Red-Black 트리는 색상 규칙이 복잡하여 AVL 트리보다 구현이 어렵다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (45, 134, 'Red-Black, 레드블랙',
        'Red-Black 트리는 AVL 트리보다 느슨한 균형 조건을 적용한다. 따라서 삽입이나 삭제 시 회전 횟수가 적어 이러한 연산이 더 빠르다.'),
       (46, 137, 'O(n)',
        '편향 트리는 한쪽으로 치우친 구조로 높이가 n이 된다. 따라서 탐색의 시간 복잡도가 O(n)이다. 반면 균형 트리는 높이를 O(log n)으로 유지하여 탐색이 O(log n)이다.');

-- Chapter: 자료구조 (id: 1), Unit: 해시테이블 (id: 9)

-- Lesson 생성
INSERT INTO lesson (id, unit_id, title)
VALUES (24, 9, '해시테이블 기초 문제집'),
       (25, 9, '충돌 처리 문제집'),
       (26, 9, '해시테이블 응용 문제집');

-- Chapter: 자료구조 (id: 1), Unit: 해시테이블 (id: 9), Lesson: 해시테이블 기초 문제집 (id: 24)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (139, 24, '다음 중 해시테이블의 정의로 올바른 것은?', '해시테이블은 키와 값을 저장하는 자료구조이다.', 'OBJECTIVE'),
       (140, 24, '빈칸에 들어갈 용어를 작성하시오', '해시테이블은 ___를 이용해 키를 인덱스로 변환한다.', 'SUBJECTIVE'),
       (141, 24, '다음 중 해시테이블의 시간 복잡도로 올바른 것은?', '해시테이블의 연산 시간 복잡도는 특정 값으로 보장된다.', 'OBJECTIVE'),
       (142, 24, '다음 중 해시테이블의 특징으로 올바른 것은?', '해시테이블은 특정한 구조적 특징을 가진다.', 'OBJECTIVE'),
       (143, 24, '빈칸에 들어갈 용어를 작성하시오', '해시테이블에서 데이터가 저장되는 위치를 ___ 또는 슬롯이라 한다.', 'SUBJECTIVE'),
       (144, 24, '다음 중 해시테이블의 장점으로 올바른 것은?', '해시테이블은 다른 자료구조와 비교하여 장점을 가진다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (369, 139, '해시 함수를 이용해 키를 인덱스로 변환하여 데이터를 빠르게 저장하고 검색하는 자료구조이다',
        '해시테이블은 키(Key)와 값(Value)을 저장하는 자료구조로, 해시 함수를 이용해 키를 인덱스로 변환하고 그 위치에 값을 저장함으로써 데이터를 빠르게 검색, 삽입, 삭제할 수 있다.',
        true),
       (370, 139, '트리 구조로 데이터를 정렬하여 저장하는 자료구조이다',
        '이는 이진 탐색 트리의 특징이다. 해시테이블은 해시 함수를 사용하는 자료구조이다.', false),
       (371, 139, 'LIFO 구조의 자료구조이다',
        'LIFO는 스택의 특징이다. 해시테이블은 키-값 쌍을 저장하는 자료구조이다.', false),
       (372, 139, '연결리스트 기반의 자료구조이다',
        '해시테이블은 내부적으로 배열 기반이다. 충돌 처리 시 연결리스트를 사용할 수 있지만, 기본 구조는 배열이다.', false),

       (373, 141, '평균적으로 삽입, 삭제, 검색 모두 O(1)이다',
        '해시 함수를 통해 저장 위치를 직접 계산하므로 평균적으로 삽입, 삭제, 검색 연산이 O(1)의 시간 복잡도를 가진다. 단, 충돌이 많이 발생하면 최악의 경우 O(n)까지 증가할 수 있다.',
        true),
       (374, 141, '모든 연산이 O(log n)이다',
        '해시테이블은 평균적으로 O(1)이다. O(log n)은 트리 구조의 시간 복잡도이다.', false),
       (375, 141, '모든 경우에 O(1)을 보장한다',
        '충돌이 발생하면 최악의 경우 O(n)까지 증가할 수 있다. 모든 경우에 O(1)을 보장하지는 않는다.', false),
       (376, 141, '탐색만 O(1)이고 삽입과 삭제는 O(n)이다',
        '평균적으로 삽입, 삭제, 검색 모두 O(1)이다.', false),

       (377, 142, '내부적으로 배열 기반이며 인덱스 범위는 0부터 테이블 크기 - 1까지이다',
        '해시테이블은 내부적으로 배열을 사용한다. 해시 함수를 통해 계산된 인덱스는 0부터 테이블 크기 - 1까지의 범위를 가진다.', true),
       (378, 142, '데이터가 정렬된 순서로 저장된다',
        '해시테이블은 해시 함수에 의해 위치가 결정되므로 데이터의 저장 순서가 유지되지 않는다.', false),
       (379, 142, '트리 구조로 구현된다',
        '해시테이블은 배열 기반이다. 트리 구조가 아니다.', false),
       (380, 142, '연결리스트로만 구현 가능하다',
        '해시테이블은 배열 기반이다. 충돌 처리 시 연결리스트를 사용할 수 있지만, 기본 구조는 배열이다.', false),

       (381, 144, '데이터에 빠르게 접근할 수 있고 대용량 데이터 관리에 효과적이다',
        '해시테이블은 평균 O(1)의 시간 복잡도로 데이터에 빠르게 접근할 수 있다. 또한 다양한 형태의 키로 데이터에 접근 가능하여 대용량 데이터 관리에 효과적이다.',
        true),
       (382, 144, '메모리 사용량이 매우 적다',
        '해시테이블은 배열을 사용하므로 충분한 공간을 미리 할당해야 하며, 메모리 사용량이 적지 않다.', false),
       (383, 144, '데이터가 정렬된 순서로 유지된다',
        '해시테이블은 데이터의 저장 순서가 유지되지 않는다. 이는 해시테이블의 단점이다.', false),
       (384, 144, '충돌이 절대 발생하지 않는다',
        '서로 다른 키가 같은 해시 값을 가지면 충돌이 발생한다. 이는 해시테이블의 단점이다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (47, 140, '해시 함수, 해시함수, hash function',
        '해시테이블은 해시 함수를 이용해 키를 인덱스로 변환한다. 예를 들어 index = hash(key) % table_size와 같이 계산하여 데이터의 저장 위치를 결정한다.'),
       (48, 143, '버킷, bucket',
        '해시테이블에서 데이터가 저장되는 위치를 버킷(Bucket) 또는 슬롯(Slot)이라 한다. 해시 함수를 통해 계산된 인덱스 위치의 공간을 의미한다.');

-- Chapter: 자료구조 (id: 1), Unit: 해시테이블 (id: 9), Lesson: 충돌 처리 문제집 (id: 25)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (145, 25, '다음 중 충돌에 대한 설명으로 올바른 것은?', '해시테이블에서 충돌은 불가피하게 발생할 수 있다.', 'OBJECTIVE'),
       (146, 25, '빈칸에 들어갈 충돌 처리 방법을 작성하시오', '충돌 시 같은 인덱스에 연결리스트나 트리 형태로 여러 데이터를 저장하는 전략을 ___이라 한다.', 'SUBJECTIVE'),
       (147, 25, '다음 중 개별 체이닝의 특징으로 올바른 것은?', '개별 체이닝은 충돌 처리 전략 중 하나이다.', 'OBJECTIVE'),
       (148, 25, '다음 중 개방 주소법의 설명으로 올바른 것은?', '개방 주소법은 충돌 처리 전략 중 하나이다.', 'OBJECTIVE'),
       (149, 25, '빈칸에 들어갈 탐사 방법을 작성하시오', '개방 주소법에서 한 칸씩 순서대로 다음 칸을 검사하는 방법을 ___이라 한다.', 'SUBJECTIVE'),
       (150, 25, '다음 중 이중 해싱의 특징으로 올바른 것은?', '이중 해싱은 개방 주소법의 탐사 방식 중 하나이다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (385, 145, '서로 다른 키가 같은 해시 값을 가질 때 발생한다',
        '충돌은 서로 다른 키가 같은 해시 값을 가져 같은 인덱스에 저장되려고 할 때 발생한다. 이를 해결하기 위해 개별 체이닝이나 개방 주소법 등의 충돌 처리 전략을 사용한다.',
        true),
       (386, 145, '모든 해시테이블에서 절대 발생하지 않는다',
        '충돌은 해시테이블의 불가피한 문제이다. 완벽한 해시 함수를 만들기 어렵기 때문에 충돌이 발생할 수 있다.', false),
       (387, 145, '해시 함수가 잘못되었을 때만 발생한다',
        '해시 함수가 좋더라도 충돌은 발생할 수 있다. 키의 개수가 테이블 크기보다 많으면 필연적으로 충돌이 발생한다.', false),
       (388, 145, '데이터가 정렬되지 않았을 때 발생한다',
        '충돌은 데이터의 정렬 여부와 무관하게 같은 해시 값이 계산될 때 발생한다.', false),

       (389, 147, '구현이 간단하고 충돌이 많아도 데이터 저장이 가능하다',
        '개별 체이닝은 충돌 시 같은 인덱스에 연결리스트나 트리 형태로 여러 데이터를 저장한다. 구현이 간단하고 충돌이 많아도 계속 데이터를 저장할 수 있으며, 테이블 확장이 자유롭다.',
        true),
       (390, 147, '추가 메모리가 전혀 필요하지 않다',
        '개별 체이닝은 연결리스트나 트리를 위한 추가 메모리가 필요하다. 이는 개별 체이닝의 단점이다.', false),
       (391, 147, '연결리스트 길이와 무관하게 항상 O(1)이다',
        '연결리스트 길이가 길어지면 성능이 O(n)까지 떨어진다. 이는 개별 체이닝의 단점이다.', false),
       (392, 147, '테이블 내에서만 데이터를 저장한다',
        '개별 체이닝은 테이블 외부에 연결리스트나 트리를 생성하여 데이터를 저장한다.', false),

       (393, 148, '충돌 시 테이블 내 다른 빈 공간을 탐사해 저장한다',
        '개방 주소법은 충돌 시 테이블 내에서 다른 빈 공간을 탐사하여 저장하는 전략이다. 선형 탐사, 이차 탐사, 이중 해싱 등 3가지 탐사 방식이 존재한다.',
        true),
       (394, 148, '연결리스트를 사용하여 충돌을 처리한다',
        '이는 개별 체이닝의 특징이다. 개방 주소법은 테이블 내에서 빈 공간을 찾아 저장한다.', false),
       (395, 148, '충돌이 발생하면 데이터를 저장하지 않는다',
        '개방 주소법은 충돌 시 다른 빈 공간을 찾아 저장한다. 데이터를 저장하지 않는 것이 아니다.', false),
       (396, 148, '테이블 외부에 별도 공간을 사용한다',
        '개방 주소법은 테이블 내부에서만 공간을 사용한다. 테이블 외부 공간은 사용하지 않는다.', false),

       (397, 150, '두 번째 해시 함수를 사용하여 이동 폭을 다르게 지정한다',
        '이중 해싱은 두 번째 해시 함수를 사용하여 이동 폭을 다르게 지정하는 방법이다. 충돌이 매우 적고 분포가 균등하다는 장점이 있지만, 구현이 복잡하고 두 개의 좋은 해시 함수가 필요하다.',
        true),
       (398, 150, '한 칸씩 순서대로 탐사한다',
        '이는 선형 탐사의 특징이다. 이중 해싱은 두 번째 해시 함수로 이동 폭을 결정한다.', false),
       (399, 150, '제곱수 단위로 건너뛰며 탐사한다',
        '이는 이차 탐사의 특징이다. 이중 해싱은 두 번째 해시 함수를 사용한다.', false),
       (400, 150, '연결리스트를 사용한다',
        '이는 개별 체이닝의 특징이다. 이중 해싱은 개방 주소법의 한 방식이다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (49, 146, '개별 체이닝, Separate Chaining, 체이닝',
        '개별 체이닝(Separate Chaining)은 충돌 시 같은 인덱스에 여러 데이터를 연결리스트나 트리 형태로 저장하는 충돌 처리 전략이다. 구현이 간단하고 충돌이 많아도 데이터 저장이 가능하다.'),
       (50, 149, '선형 탐사, Linear Probing',
        '선형 탐사(Linear Probing)는 개방 주소법에서 한 칸씩 순서대로 다음 칸을 검사하여 비어 있으면 저장하는 방법이다. 구현이 간단하지만 연속된 칸이 채워지는 클러스터링 현상이 발생한다는 단점이 있다.');

-- Chapter: 자료구조 (id: 1), Unit: 해시테이블 (id: 9), Lesson: 해시테이블 응용 문제집 (id: 26)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (151, 26, '다음 중 해시테이블의 동작 순서로 올바른 것은?', '해시테이블은 특정한 순서로 동작한다.', 'OBJECTIVE'),
       (152, 26, '빈칸에 들어갈 시간 복잡도를 작성하시오', '충돌이 발생하여 버킷 안의 모든 값을 조사해야 하는 최악의 경우 시간 복잡도는 ___이다.', 'SUBJECTIVE'),
       (153, 26, '다음 중 해시테이블의 단점으로 올바른 것은?', '해시테이블은 장점과 함께 단점도 가진다.', 'OBJECTIVE'),
       (154, 26, '다음 중 해시 함수의 역할로 올바른 것은?', '해시 함수는 해시테이블에서 중요한 역할을 한다.', 'OBJECTIVE'),
       (155, 26, '빈칸에 들어갈 용어를 작성하시오', '해시테이블에서 충돌이 발생하면 ___를 조사하여 다른 위치를 찾는다.', 'SUBJECTIVE'),
       (156, 26, '다음 중 해시테이블의 활용 사례로 올바른 것은?', '해시테이블은 다양한 분야에서 활용된다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (401, 151, '키를 해시 함수에 전달하여 해시 값을 계산하고 인덱스를 결정한다',
        '해시테이블의 동작 순서는 다음과 같다. 1) 키를 해시 함수에 전달해 해시 값을 계산한다. 2) 해시 값을 이용해 테이블 내의 인덱스를 결정한다(예: index = hash(key) % table_size). 3) 계산된 인덱스 위치에 값을 저장하거나 충돌 시 다른 슬롯에 저장한다.',
        true),
       (402, 151, '키를 정렬한 후 이진 탐색으로 위치를 찾는다',
        '이는 이진 탐색 트리의 동작 방식이다. 해시테이블은 해시 함수로 위치를 직접 계산한다.', false),
       (403, 151, '연결리스트를 순회하여 데이터를 찾는다',
        '해시테이블은 해시 함수로 직접 인덱스를 계산한다. 연결리스트 순회는 충돌 처리 시에만 사용된다.', false),
       (404, 151, '트리 구조로 데이터를 탐색한다',
        '해시테이블은 배열 기반이며 해시 함수로 인덱스를 계산한다. 트리 구조를 사용하지 않는다.', false),

       (405, 153, '서로 다른 키가 같은 해시 값을 가지면 충돌이 발생한다',
        '해시테이블의 주요 단점은 충돌 발생이다. 서로 다른 키가 같은 해시 값을 가지면 충돌이 일어나고, 이를 처리해야 한다. 또한 데이터의 저장 순서가 유지되지 않으며, 해시 함수 품질에 따라 성능이 달라진다.',
        true),
       (406, 153, '모든 연산이 항상 O(1)을 보장한다',
        '충돌이 발생하면 최악의 경우 O(n)까지 증가할 수 있다. 항상 O(1)을 보장하는 것은 아니다.', false),
       (407, 153, '메모리 사용량이 매우 적다',
        '해시테이블은 배열을 사용하므로 충분한 공간을 미리 할당해야 하며, 메모리 사용량이 적지 않다.', false),
       (408, 153, '정렬된 순서로 데이터를 유지한다',
        '해시테이블은 데이터의 저장 순서가 유지되지 않는다. 이는 해시테이블의 단점이다.', false),

       (409, 154, '키를 인덱스로 변환하여 데이터의 저장 위치를 결정한다',
        '해시 함수는 키를 입력받아 해시 값을 계산하고, 이를 인덱스로 변환하여 데이터의 저장 위치를 결정한다. 좋은 해시 함수는 충돌을 최소화하고 데이터를 균등하게 분산시킨다.',
        true),
       (410, 154, '데이터를 정렬하여 저장한다',
        '해시 함수는 데이터의 저장 위치를 결정한다. 정렬은 해시 함수의 역할이 아니다.', false),
       (411, 154, '트리 구조를 생성한다',
        '해시 함수는 인덱스를 계산한다. 트리 구조 생성은 해시 함수의 역할이 아니다.', false),
       (412, 154, '데이터를 암호화한다',
        '해시 함수는 인덱스 계산을 위한 것이다. 암호화는 별도의 목적이다.', false),

       (413, 156, '데이터베이스 인덱싱과 캐시 구현',
        '해시테이블은 빠른 검색이 필요한 다양한 분야에서 활용된다. 데이터베이스 인덱싱, 캐시 구현, 중복 검사, 프로그래밍 언어의 딕셔너리/맵 자료구조 등에 사용된다.',
        true),
       (414, 156, '정렬된 데이터 출력',
        '해시테이블은 데이터의 저장 순서가 유지되지 않으므로 정렬된 출력에는 적합하지 않다.', false),
       (415, 156, '스택 메모리 관리',
        '스택 메모리는 LIFO 구조의 스택 자료구조로 관리된다. 해시테이블과는 관련이 없다.', false),
       (416, 156, '트리 순회',
        '트리 순회는 트리 자료구조에서 수행하는 작업이다. 해시테이블의 활용 사례가 아니다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (51, 152, 'O(n)',
        '충돌이 발생하면 버킷 안의 모든 값을 조사해야 한다. 최악의 경우 모든 데이터가 하나의 버킷에 저장되어 있다면 시간 복잡도는 O(n)이 된다. 평균적으로는 O(1)이지만 최악의 경우 O(n)이다.'),
       (52, 155, '버킷, bucket, 슬롯, slot',
        '해시테이블에서 충돌이 발생하면 다른 버킷(또는 슬롯)을 조사하여 빈 공간을 찾는다. 개방 주소법에서는 선형 탐사, 이차 탐사, 이중 해싱 등의 방법으로 다른 버킷을 탐사한다.');

-- Chapter: 자료구조 (id: 1), Unit: 그래프 (id: 10)

-- Lesson 생성
INSERT INTO lesson (id, unit_id, title)
VALUES (27, 10, '그래프 기초 문제집'),
       (28, 10, '그래프 종류 문제집'),
       (29, 10, '그래프 구현 및 탐색 문제집');

-- Chapter: 자료구조 (id: 1), Unit: 그래프 (id: 10), Lesson: 그래프 기초 문제집 (id: 27)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (157, 27, '다음 중 그래프의 정의로 올바른 것은?', '그래프는 관계를 표현하는 자료구조이다.', 'OBJECTIVE'),
       (158, 27, '빈칸에 들어갈 용어를 작성하시오', '그래프는 여러 ___와 이들을 잇는 간선으로 이루어진 자료구조이다.', 'SUBJECTIVE'),
       (159, 27, '다음 중 그래프의 특징으로 올바른 것은?', '그래프는 특정한 구조적 특징을 가진다.', 'OBJECTIVE'),
       (160, 27, '다음 중 그래프와 트리의 차이점으로 올바른 것은?', '그래프와 트리는 서로 다른 자료구조이다.', 'OBJECTIVE'),
       (161, 27, '빈칸에 들어갈 탐색 알고리즘을 작성하시오', '그래프 탐색은 주로 ___와 BFS로 수행된다.', 'SUBJECTIVE'),
       (162, 27, '다음 중 그래프의 표현 방법으로 올바른 것은?', '그래프를 표현하는 방법에는 여러 가지가 있다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (417, 157, '여러 정점과 이들을 잇는 간선으로 이루어진 관계를 표현하는 자료구조이다',
        '그래프는 여러 개의 정점(Vertex)과 이들을 잇는 간선(Edge)으로 이루어진 자료구조이다. 방향성과 가중치를 통해 다양한 형태의 관계를 표현할 수 있으며, 여러 개의 고립된 부분 그래프로 구성될 수 있다.',
        true),
       (418, 157, 'LIFO 구조의 자료구조이다',
        'LIFO는 스택의 특징이다. 그래프는 정점과 간선으로 관계를 표현하는 자료구조이다.', false),
       (419, 157, '사이클이 절대 존재하지 않는 자료구조이다',
        '그래프는 사이클이 존재할 수 있다. 사이클이 없는 것은 트리의 특징이다.', false),
       (420, 157, '하나의 루트에서 시작하는 계층 구조이다',
        '이는 트리의 특징이다. 그래프는 루트가 없으며 계층 구조가 아니다.', false),

       (421, 159, '방향성과 가중치를 통해 다양한 형태를 표현할 수 있다',
        '그래프는 방향성(유향/무향)과 가중치(가중치/비가중치)를 통해 유향 그래프, 무향 그래프, 가중치 그래프 등 다양한 형태를 표현할 수 있다. 또한 사이클 존재 여부에 따라 순환 그래프와 비순환 그래프로 구분된다.',
        true),
       (422, 159, '항상 사이클이 존재한다',
        '그래프는 사이클이 존재할 수도 있고 존재하지 않을 수도 있다. 항상 사이클이 존재하는 것은 아니다.', false),
       (423, 159, '하나의 루트 노드만 가진다',
        '그래프는 루트 노드 개념이 없다. 이는 트리의 특징이다.', false),
       (424, 159, '모든 정점이 연결되어 있어야 한다',
        '그래프는 비연결 그래프일 수 있다. 모든 정점이 연결되어 있을 필요는 없다.', false),

       (425, 160, '그래프는 사이클이 존재할 수 있지만 트리는 사이클이 없다',
        '그래프와 트리의 주요 차이점은 사이클 존재 여부이다. 그래프는 사이클이 존재할 수 있지만, 트리는 사이클이 존재하지 않는다. 또한 트리는 루트가 1개 존재하지만 그래프는 루트가 없다.',
        true),
       (426, 160, '트리는 사이클이 존재하지만 그래프는 사이클이 없다',
        '반대이다. 그래프는 사이클이 존재할 수 있지만 트리는 사이클이 없다.', false),
       (427, 160, '둘 다 사이클이 반드시 존재한다',
        '트리는 사이클이 존재하지 않는다.', false),
       (428, 160, '그래프와 트리는 완전히 동일하다',
        '그래프와 트리는 다른 자료구조이다. 트리는 사이클이 없는 특수한 그래프이다.', false),

       (429, 162, '인접 리스트와 인접 행렬로 표현할 수 있다',
        '그래프는 인접 리스트(Adjacency List)와 인접 행렬(Adjacency Matrix)로 표현할 수 있다. 인접 리스트는 각 정점에 인접한 정점들을 리스트로 저장하고, 인접 행렬은 2차원 배열로 정점 간 연결 관계를 저장한다.',
        true),
       (430, 162, '스택으로만 표현할 수 있다',
        '그래프는 인접 리스트나 인접 행렬로 표현한다. 스택으로만 표현하는 것이 아니다.', false),
       (431, 162, '큐로만 표현할 수 있다',
        '그래프는 인접 리스트나 인접 행렬로 표현한다. 큐로만 표현하는 것이 아니다.', false),
       (432, 162, '연결리스트로만 표현할 수 있다',
        '그래프는 인접 리스트나 인접 행렬로 표현한다. 연결리스트만 사용하는 것이 아니다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (53, 158, '정점, vertex, 노드, node',
        '그래프는 여러 개의 정점(Vertex)과 이들을 잇는 간선(Edge)으로 이루어진 자료구조이다. 정점은 노드(Node)라고도 불리며, 간선은 정점들 사이의 연결 관계를 나타낸다.'),
       (54, 161, 'DFS, 깊이 우선 탐색, Depth First Search',
        '그래프 탐색은 주로 DFS(깊이 우선 탐색)와 BFS(너비 우선 탐색)로 수행된다. DFS는 한 방향으로 끝까지 탐색 후 다른 경로를 탐색하는 방식이고, BFS는 가까운 정점부터 차례로 탐색하는 방식이다.');

-- Chapter: 자료구조 (id: 1), Unit: 그래프 (id: 10), Lesson: 그래프 종류 문제집 (id: 28)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (163, 28, '다음 중 무방향 그래프의 특징으로 올바른 것은?', '무방향 그래프는 특정한 특징을 가진다.', 'OBJECTIVE'),
       (164, 28, '빈칸에 들어갈 그래프 종류를 작성하시오', '간선에 방향이 존재하는 그래프를 ___라 한다.', 'SUBJECTIVE'),
       (165, 28, '다음 중 가중치 그래프의 설명으로 올바른 것은?', '가중치 그래프는 특정한 정보를 포함한다.', 'OBJECTIVE'),
       (166, 28, '다음 중 완전 그래프의 특징으로 올바른 것은?', '완전 그래프는 특별한 형태의 그래프이다.', 'OBJECTIVE'),
       (167, 28, '빈칸에 들어갈 약어를 작성하시오', '사이클이 없는 유향 그래프를 ___라 한다.', 'SUBJECTIVE'),
       (168, 28, '다음 중 연결 그래프와 비연결 그래프의 차이로 올바른 것은?', '연결 그래프와 비연결 그래프는 구조가 다르다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (433, 163, '간선에 방향이 없으며 (A,B)와 (B,A)는 동일하다',
        '무방향 그래프(Undirected Graph)는 간선에 방향이 없는 그래프이다. (A,B)와 (B,A)는 동일한 간선으로 취급되며, 양방향으로 이동이 가능하다.',
        true),
       (434, 163, '간선에 방향이 존재한다',
        '이는 방향 그래프(유향 그래프)의 특징이다. 무방향 그래프는 간선에 방향이 없다.', false),
       (435, 163, '가중치가 반드시 존재한다',
        '무방향 그래프는 가중치가 있을 수도 있고 없을 수도 있다. 가중치는 별도의 속성이다.', false),
       (436, 163, '사이클이 절대 존재하지 않는다',
        '무방향 그래프도 사이클이 존재할 수 있다. 사이클 여부는 별도의 특성이다.', false),

       (437, 165, '간선에 비용, 거리, 시간 등의 값이 부여된 그래프이다',
        '가중치 그래프(Weighted Graph)는 간선에 비용, 거리, 시간 등의 값(가중치)이 부여된 그래프이다. 최단 경로 알고리즘 등에서 활용되며, 실제 세계의 다양한 관계를 표현할 수 있다.',
        true),
       (438, 165, '모든 간선의 가중치가 동일하다',
        '가중치 그래프는 간선마다 서로 다른 가중치를 가질 수 있다. 모든 간선의 가중치가 동일한 것은 아니다.', false),
       (439, 165, '가중치가 없는 그래프이다',
        '가중치 그래프는 간선에 가중치가 부여된 그래프이다. 가중치가 없는 것이 아니다.', false),
       (440, 165, '방향이 반드시 존재해야 한다',
        '가중치 그래프는 방향이 있을 수도 있고 없을 수도 있다. 방향과 가중치는 독립적인 속성이다.', false),

       (441, 166, '모든 정점 쌍이 간선으로 연결되어 있다',
        '완전 그래프(Complete Graph)는 모든 정점 쌍이 간선으로 연결되어 있는 그래프이다. n개의 정점을 가진 무방향 완전 그래프는 n(n-1)/2개의 간선을 가진다.',
        true),
       (442, 166, '일부 정점만 연결되어 있다',
        '완전 그래프는 모든 정점 쌍이 연결되어 있다. 일부만 연결된 것이 아니다.', false),
       (443, 166, '사이클이 존재하지 않는다',
        '완전 그래프는 모든 정점이 연결되어 있으므로 사이클이 존재한다.', false),
       (444, 166, '간선이 하나도 없다',
        '완전 그래프는 모든 정점 쌍이 간선으로 연결되어 있다. 간선이 많다.', false),

       (445, 168, '연결 그래프는 모든 정점 쌍에 경로가 존재하지만 비연결 그래프는 일부 정점이 고립되어 있다',
        '연결 그래프(Connected Graph)는 모든 정점 쌍 사이에 경로가 존재하는 그래프이다. 반면 비연결 그래프(Disconnected Graph)는 일부 정점이 고립되어 있어 모든 정점에 도달할 수 없다.',
        true),
       (446, 168, '비연결 그래프는 모든 정점이 연결되어 있다',
        '비연결 그래프는 일부 정점이 고립되어 있다. 모든 정점이 연결된 것은 연결 그래프이다.', false),
       (447, 168, '둘 다 모든 정점이 연결되어 있다',
        '비연결 그래프는 일부 정점이 고립되어 있다.', false),
       (448, 168, '연결 그래프는 간선이 없다',
        '연결 그래프는 모든 정점이 경로로 연결되어 있으므로 간선이 존재한다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (55, 164, '방향 그래프, 유향 그래프, directed graph',
        '간선에 방향이 존재하는 그래프를 방향 그래프(Directed Graph) 또는 유향 그래프라 한다. 방향 그래프에서 ⟨A,B⟩와 ⟨B,A⟩는 서로 다른 간선이다.'),
       (56, 167, 'DAG, Directed Acyclic Graph',
        '사이클이 없는 유향 그래프를 DAG(Directed Acyclic Graph)라 한다. DAG는 위상 정렬 등의 알고리즘에서 중요하게 사용되며, 선후 관계가 명확한 작업 순서를 표현할 수 있다.');

-- Chapter: 자료구조 (id: 1), Unit: 그래프 (id: 10), Lesson: 그래프 구현 및 탐색 문제집 (id: 29)

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (169, 29, '다음 중 인접 리스트의 특징으로 올바른 것은?', '인접 리스트는 그래프 구현 방법 중 하나이다.', 'OBJECTIVE'),
       (170, 29, '빈칸에 들어갈 공간 복잡도를 작성하시오', '인접 리스트의 공간 복잡도는 ___이다.', 'SUBJECTIVE'),
       (171, 29, '다음 중 인접 행렬의 특징으로 올바른 것은?', '인접 행렬은 그래프 구현 방법 중 하나이다.', 'OBJECTIVE'),
       (172, 29, '다음 중 인접 리스트와 인접 행렬의 비교로 올바른 것은?', '인접 리스트와 인접 행렬은 각각 장단점이 있다.', 'OBJECTIVE'),
       (173, 29, '빈칸에 들어갈 탐색 알고리즘을 작성하시오', '그래프에서 한 방향으로 끝까지 탐색한 후 다른 경로를 탐색하는 방식을 ___라 한다.', 'SUBJECTIVE'),
       (174, 29, '다음 중 BFS의 특징으로 올바른 것은?', 'BFS는 그래프 탐색 알고리즘 중 하나이다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES (449, 169, '각 정점에 인접한 정점들을 연결 리스트로 저장한다',
        '인접 리스트(Adjacency List)는 각 정점을 배열로 저장하고 인접한 정점은 연결 리스트로 관리한다. 어떤 정점에 인접한 정점들을 쉽게 찾을 수 있으며, 공간 복잡도는 O(V+E)이다.',
        true),
       (450, 169, '2차원 배열로 모든 정점 쌍의 관계를 저장한다',
        '이는 인접 행렬의 특징이다. 인접 리스트는 연결 리스트로 인접 정점을 저장한다.', false),
       (451, 169, '공간 복잡도가 O(V²)이다',
        '인접 리스트의 공간 복잡도는 O(V+E)이다. O(V²)는 인접 행렬의 공간 복잡도이다.', false),
       (452, 169, '두 정점의 연결 여부를 O(1)에 확인할 수 있다',
        '인접 리스트는 연결 여부 확인 시 리스트를 순회해야 하므로 O(degree)가 소요된다. O(1)은 인접 행렬의 특징이다.', false),

       (453, 171, '2차원 배열로 정점 간 연결 관계를 저장하며 연결되면 1, 아니면 0을 저장한다',
        '인접 행렬(Adjacency Matrix)은 2차원 배열로 정점 간 연결 관계를 저장한다. 인접하면 1(또는 가중치), 그렇지 않으면 0을 저장한다. 두 정점의 연결 여부를 O(1)에 확인할 수 있지만, 공간 복잡도는 O(V²)이다.',
        true),
       (454, 171, '연결 리스트로 인접 정점을 저장한다',
        '이는 인접 리스트의 특징이다. 인접 행렬은 2차원 배열을 사용한다.', false),
       (455, 171, '공간 복잡도가 O(V+E)이다',
        '인접 행렬의 공간 복잡도는 O(V²)이다. O(V+E)는 인접 리스트의 공간 복잡도이다.', false),
       (456, 171, '인접한 정점을 찾기 위해 리스트를 순회해야 한다',
        '인접 행렬은 배열 인덱스로 직접 접근하여 O(1)에 확인할 수 있다. 리스트 순회는 인접 리스트의 특징이다.', false),

       (457, 172, '인접 리스트는 공간 효율적이고 인접 행렬은 연결 여부 확인이 빠르다',
        '인접 리스트는 공간 복잡도가 O(V+E)로 효율적이며, 인접 행렬은 두 정점의 연결 여부를 O(1)에 확인할 수 있다. 그래프가 희소하면 인접 리스트가, 밀집하면 인접 행렬이 유리하다.',
        true),
       (458, 172, '인접 행렬이 공간 효율적이다',
        '인접 행렬은 O(V²)의 공간을 사용하므로 공간 효율적이지 않다. 인접 리스트가 공간 효율적이다.', false),
       (459, 172, '인접 리스트가 연결 여부 확인이 더 빠르다',
        '인접 행렬이 O(1)에 연결 여부를 확인할 수 있다. 인접 리스트는 리스트를 순회해야 한다.', false),
       (460, 172, '둘 다 공간 복잡도가 동일하다',
        '인접 리스트는 O(V+E), 인접 행렬은 O(V²)로 공간 복잡도가 다르다.', false),

       (461, 174, '가까운 정점부터 차례로 탐색하며 큐를 사용한다',
        'BFS(너비 우선 탐색)는 시작 정점에서 가까운 정점부터 차례로 탐색하는 방식이다. 큐(Queue)를 사용하여 구현하며, 가중치가 없는 그래프에서 최단 경로를 보장한다. 시간 복잡도는 O(V+E)이다.',
        true),
       (462, 174, '한 방향으로 끝까지 탐색한 후 다른 경로를 탐색한다',
        '이는 DFS의 특징이다. BFS는 가까운 정점부터 차례로 탐색한다.', false),
       (463, 174, '스택을 사용하여 구현한다',
        'BFS는 큐를 사용한다. 스택은 DFS에서 사용한다.', false),
       (464, 174, '최단 경로를 보장하지 않는다',
        'BFS는 가중치가 없는 그래프에서 최단 경로를 보장한다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (57, 170, 'O(V+E)',
        '인접 리스트의 공간 복잡도는 O(V+E)이다. V는 정점의 개수, E는 간선의 개수이다. 정점을 저장하는 배열과 간선을 저장하는 리스트를 합한 공간이 필요하다.'),
       (58, 173, 'DFS, 깊이 우선 탐색, Depth First Search',
        '그래프에서 한 방향으로 끝까지 탐색한 후 다른 경로를 탐색하는 방식을 DFS(깊이 우선 탐색)라 한다. 스택 또는 재귀 함수로 구현하며, 백트래킹 방식으로 동작한다.');
