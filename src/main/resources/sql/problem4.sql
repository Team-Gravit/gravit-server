-- Unit 42: 데이터 모델링 기본
-- =====================================================

-- Lesson 1: 데이터 모델링 기초 1 (ID: 122)
INSERT INTO lesson (id, title, unit_id)
VALUES (122, '데이터 모델링 기초 1', 42);

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES
(845, 122, '다음 중 데이터 모델링의 3단계 순서로 올바른 것은?', '데이터 모델링은 현실 세계의 데이터를 데이터베이스로 옮기기 위해 구조화하는 과정이다.', 'OBJECTIVE'),
(846, 122, '다음 설명에 해당하는 데이터 모델링 단계는?', '요구사항 분석을 기반으로 엔터티를 추출하고 엔터티 간의 관계를 정의하여 E-R 다이어그램을 작성하는 단계이다.', 'OBJECTIVE'),
(847, 122, '빈칸에 들어갈 용어를 작성하시오.', '___은(는) 업무에서 필요하고 유용한 정보를 저장하고 관리하기 위한 집합적인 것으로, 물리적 데이터베이스에서는 테이블(Table)에 해당한다.', 'SUBJECTIVE'),
(848, 122, '다음 중 속성(Attribute)에 대한 설명으로 올바르지 않은 것은?', '속성은 업무에서 필요한 인스턴스의 구성요소이다.', 'OBJECTIVE'),
(849, 122, '다음 설명에 해당하는 속성 유형은?', '다른 속성을 통해 계산된 속성으로, 예를 들어 총합계나 평균값이 이에 해당한다.', 'OBJECTIVE'),
(850, 122, '빈칸에 들어갈 용어를 작성하시오.', '___은(는) 엔터티에 저장된 개별 데이터를 의미하며, 물리적 데이터베이스에서는 행(Row) 또는 튜플(Tuple)에 해당한다.', 'SUBJECTIVE'),
(851, 122, '다음 중 관계(Relationship)의 종류에 대한 설명으로 올바른 것은?', '관계는 엔터티 간의 연관성을 나타낸다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES
-- 문제 845
(2403, 845, '물리적 → 논리적 → 개념적', '물리적 모델링은 마지막 단계이다. 데이터 모델링은 개념적 → 논리적 → 물리적 순서로 진행된다.', false),
(2404, 845, '개념적 → 물리적 → 논리적', '논리적 모델링이 물리적 모델링보다 먼저 수행된다. 올바른 순서는 개념적 → 논리적 → 물리적이다.', false),
(2405, 845, '논리적 → 개념적 → 물리적', '개념적 모델링이 가장 먼저 수행된다. E-R 다이어그램을 먼저 작성한 후 논리적 모델링을 진행한다.', false),
(2406, 845, '개념적 → 논리적 → 물리적', '데이터 모델링의 3단계는 개념적 모델링(E-R 다이어그램 작성) → 논리적 모델링(DBMS에 맞게 매핑, 정규화) → 물리적 모델링(저장 구조 정의) 순서로 진행된다.', true),

-- 문제 846
(2407, 846, '물리적 모델링', '물리적 모델링은 논리적 모델을 실제 저장하기 위해 물리적 구조를 정의하는 단계이다. E-R 다이어그램 작성은 개념적 모델링 단계에서 수행한다.', false),
(2408, 846, '논리적 모델링', '논리적 모델링은 개념적 모델링에서 만든 E-R 다이어그램을 DBMS에 맞게 매핑하고 정규화를 수행하는 단계이다.', false),
(2409, 846, '개념적 모델링', '개념적 모델링은 정보 모델링이라고도 하며, 요구사항 분석을 기반으로 엔터티를 추출하고 엔터티 간의 관계를 정의하여 E-R 다이어그램을 작성하는 단계이다.', true),
(2410, 846, '정규화 모델링', '정규화 모델링이라는 단계는 존재하지 않는다. 정규화는 논리적 모델링 단계에서 수행되는 작업 중 하나이다.', false),

-- 문제 848
(2411, 848, '물리적 데이터베이스에서 컬럼(Column)에 해당한다', '속성은 물리적 데이터베이스에서 컬럼(Column)에 해당한다. 이는 올바른 설명이다.', false),
(2412, 848, '하나의 엔터티는 반드시 하나의 속성만 가져야 한다', '하나의 엔터티는 반드시 속성을 가져야 하지만, 하나만 가져야 하는 것은 아니다. 일반적으로 엔터티는 여러 개의 속성을 가진다.',
 true),
(2413, 848, '의미상 더 이상 분리되지 않는 최소 데이터 단위이다', '속성은 의미상 더 이상 분리되지 않는 최소 데이터 단위이다. 이는 올바른 설명이다.', false),
(2414, 848, 'PK 속성, FK 속성, 일반 속성으로 분류할 수 있다', '속성은 엔터티 구성에 따라 PK 속성, FK 속성, 일반 속성으로 분류할 수 있다. 이는 올바른 설명이다.', false),

-- 문제 849
(2415, 849, '기본 속성', '기본 속성은 업무에서 추출한 원래 속성이다. 계산을 통해 도출된 속성은 파생 속성이다.', false),
(2416, 849, '설계 속성', '설계 속성은 모델링 과정에서 새로 만든 속성이다. 다른 속성을 통해 계산된 속성은 파생 속성이다.', false),
(2417, 849, 'FK 속성', 'FK 속성은 다른 엔터티와의 관계를 나타내는 속성이다. 계산된 속성은 파생 속성이다.', false),
(2418, 849, '파생 속성', '파생 속성은 다른 속성을 통해 계산된 속성이다. 총합계, 평균값, 나이(생년월일로부터 계산) 등이 파생 속성에 해당한다.', true),

-- 문제 851
(2419, 851, '일대일(1:1) 관계는 양쪽 엔터티가 여러 개와 대응된다', '일대일(1:1) 관계는 양쪽 엔터티가 각각 하나씩 대응되는 관계이다. 여러 개와 대응되는 것은 다대다(M:N) 관계이다.',
 false),
(2420, 851, '다대다(M:N) 관계는 물리적 데이터베이스에서 직접 구현할 수 있다', '다대다(M:N) 관계는 물리적 데이터베이스에서 직접 구현할 수 없다. 연결 엔터티(중간 테이블)를 추가하여 일대다(1:N) 관계로 해소해야 한다.', false),
(2421, 851, '일대다(1:N) 관계에서 한쪽 엔터티는 여러 개와 대응된다', '일대다(1:N) 관계는 한쪽 엔터티가 여러 개의 다른 엔터티와 대응되는 관계이다. 예를 들어 부서-사원 관계에서 하나의 부서에 여러 사원이 속할 수 있다.', true),
(2422, 851, '관계는 엔터티 내부의 속성 간 연관성을 나타낸다', '관계는 엔터티 간의 연관성을 나타내는 것이지, 엔터티 내부 속성 간의 연관성이 아니다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (243, 847, '엔터티, Entity, 개체', '엔터티(Entity)는 업무에서 필요하고 유용한 정보를 저장하고 관리하기 위한 집합적인 것이다. 물리적 데이터베이스에서는 테이블(Table)에 해당하며, 유일한 식별자로 구분할 수 있어야 하고 반드시 속성을 가져야 한다.'),
       (244, 850, '인스턴스, Instance', '인스턴스(Instance)는 엔터티에 저장된 개별 데이터를 의미한다. 물리적 데이터베이스에서는 행(Row) 또는 튜플(Tuple)에 해당하며, 각 인스턴스는 엔터티가 정의한 속성들의 실제 값을 가진다.');

-- Lesson 2: 데이터 모델링 기초 2 (ID: 123)
INSERT INTO lesson (id, title, unit_id)
VALUES (123, '데이터 모델링 기초 2', 42);

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (852, 123, '다음 중 논리적 모델링 단계에서 수행하는 작업으로 올바른 것은?', '논리적 모델링은 개념적 모델링 이후에 수행되는 단계이다.', 'OBJECTIVE'),
       (853, 123, '빈칸에 들어갈 용어를 작성하시오.', '두 테이블 간의 관계에서 각각의 레코드가 서로 어떻게 연결되는지를 나타내거나, 특정 컬럼에 존재하는 고유한 값의 개수를 의미하는 용어는 ___이다.', 'SUBJECTIVE'),
       (854, 123, '다음 중 엔터티의 특징으로 올바르지 않은 것은?', '엔터티는 업무에서 필요하고 유용한 정보를 저장하고 관리하기 위한 집합적인 것이다.', 'OBJECTIVE'),
       (855, 123, '다음 설명에 해당하는 모델링 단계는?', 'DBMS 특성에 맞는 저장 구조를 정의하여 최적의 성능을 얻기 위한 단계이다.', 'OBJECTIVE'),
       (856, 123, '다음 중 속성의 특성에 따른 분류가 아닌 것은?', '속성은 특성에 따라 분류할 수 있다.', 'OBJECTIVE'),
       (857, 123, '빈칸에 들어갈 관계 유형을 작성하시오.', '학생과 강좌의 관계처럼 양쪽 모두 여러 개와 대응되는 관계를 ___관계라고 한다.', 'SUBJECTIVE'),
       (858, 123, '다음 중 컬럼에서의 카디널리티에 대한 설명으로 올바른 것은?', '카디널리티는 두 가지 의미로 사용된다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES
-- 문제 852
(2423, 852, 'E-R 다이어그램 작성', 'E-R 다이어그램 작성은 개념적 모델링 단계에서 수행한다. 논리적 모델링은 E-R 다이어그램을 DBMS에 맞게 매핑하는 단계이다.', false),
(2424, 852, 'DBMS에 맞게 매핑 및 정규화 수행', '논리적 모델링은 개념적 모델링에서 만든 E-R 다이어그램을 DBMS에 맞게 매핑하고, 상세 속성을 추출하며, 정규화를 수행하는 단계이다.',
 true),
(2425, 852, '저장 구조 정의', '저장 구조 정의는 물리적 모델링 단계에서 수행한다.', false),
(2426, 852, '요구사항 분석', '요구사항 분석은 개념적 모델링의 기반이 되는 작업이다.', false),

-- 문제 854
(2427, 854, '유일한 식별자로 구분할 수 있어야 한다', '엔터티는 유일한 식별자로 구분할 수 있어야 한다. 이는 올바른 설명이다.', false),
(2428, 854, '반드시 속성을 가져야 한다', '엔터티는 반드시 속성을 가져야 한다. 이는 올바른 설명이다.', false),
(2429, 854, '다른 엔터티와 관계를 가지지 않아도 된다', '엔터티는 다른 엔터티와 최소 1개 이상의 관계를 가져야 한다. 관계가 없는 고립된 엔터티는 적절하지 않다.', true),
(2430, 854, '물리적 데이터베이스에서 테이블에 해당한다', '엔터티는 물리적 데이터베이스에서 테이블(Table)에 해당한다. 이는 올바른 설명이다.', false),

-- 문제 855
(2431, 855, '개념적 모델링', '개념적 모델링은 E-R 다이어그램을 작성하는 단계이다. 저장 구조 정의는 물리적 모델링 단계에서 수행한다.', false),
(2432, 855, '논리적 모델링', '논리적 모델링은 DBMS에 맞게 매핑하고 정규화를 수행하는 단계이다. DBMS 특성에 맞는 저장 구조를 정의하는 것은 물리적 모델링이다.', false),
(2433, 855, '물리적 모델링', '물리적 모델링은 논리적 모델을 실제 저장하기 위해 물리적 구조를 정의하는 단계이다. DBMS 특성에 맞는 저장 구조를 정의해야 최적의 성능을 얻을 수 있다.', true),
(2434, 855, '정규화 모델링', '정규화 모델링이라는 단계는 존재하지 않는다. 정규화는 논리적 모델링 단계에서 수행되는 작업이다.', false),

-- 문제 856
(2435, 856, '기본 속성', '기본 속성은 업무에서 추출한 원래 속성으로, 특성에 따른 분류에 해당한다.', false),
(2436, 856, '설계 속성', '설계 속성은 모델링 과정에서 새로 만든 속성으로, 특성에 따른 분류에 해당한다.', false),
(2437, 856, 'PK 속성', 'PK 속성은 엔터티 구성에 따른 분류이다. 특성에 따른 분류는 기본 속성, 설계 속성, 파생 속성으로 구분된다.', true),
(2438, 856, '파생 속성', '파생 속성은 다른 속성을 통해 계산된 속성으로, 특성에 따른 분류에 해당한다.', false),

-- 문제 858
(2439, 858, '관계에서 1:1, 1:N, M:N 등으로 표현되는 것이다', '이는 관계에서의 카디널리티에 대한 설명이다. 컬럼에서의 카디널리티는 고유한 값의 개수를 의미한다.', false),
(2440, 858, '특정 컬럼에 존재하는 고유한 값의 개수를 의미한다', '컬럼에서의 카디널리티는 특정 컬럼에 존재하는 고유한 값의 개수를 의미한다. 인덱스 설계 시 중요한 판단 기준이 된다.', true),
(2441, 858, '엔터티가 가진 속성의 총 개수를 의미한다', '엔터티가 가진 속성의 총 개수는 카디널리티가 아니다. 컬럼에서의 카디널리티는 고유한 값의 개수를 의미한다.', false),
(2442, 858, '테이블 간 외래키 연결의 개수를 의미한다', '외래키 연결의 개수는 카디널리티가 아니다. 컬럼에서의 카디널리티는 고유한 값의 개수를 의미한다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (245, 853, '카디널리티, Cardinality', '카디널리티(Cardinality)는 두 가지 의미로 사용된다. 관계에서는 두 테이블 간의 관계에서 각각의 레코드가 서로 어떻게 연결되는지를 나타내며(1:1, 1:N, M:N), 컬럼에서는 특정 컬럼에 존재하는 고유한 값의 개수를 의미한다.'),
       (246, 857, '다대다, M:N, M대N, 다:다', '다대다(M:N) 관계는 양쪽 모두 여러 개와 대응되는 관계이다. 학생-강좌 관계가 대표적인 예시로, 한 학생이 여러 강좌를 수강할 수 있고 한 강좌에 여러 학생이 등록할 수 있다. 물리적 데이터베이스에서는 연결 엔터티를 추가하여 일대다 관계로 해소한다.');

-- Lesson 3: 데이터 모델링 기초 3 (ID: 124)
INSERT INTO lesson (id, title, unit_id)
VALUES (124, '데이터 모델링 기초 3', 42);

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (859, 124, '다음 중 개념적 모델링에 대한 설명으로 올바른 것은?', '개념적 모델링은 데이터 모델링의 첫 번째 단계이다.', 'OBJECTIVE'),
       (860, 124, '다음 설명에 해당하는 관계 유형은?', '부서와 사원의 관계처럼 한쪽 엔터티가 여러 개의 다른 엔터티와 대응되는 관계이다.', 'OBJECTIVE'),
       (861, 124, '빈칸에 들어갈 용어를 작성하시오.', '다대다(M:N) 관계는 물리적 데이터베이스에서 직접 구현할 수 없으므로, ___을(를) 추가하여 일대다(1:N) 관계로 해소한다.', 'SUBJECTIVE'),
       (862, 124, '다음 중 카디널리티가 높은 컬럼의 예시로 적절한 것은?', '컬럼에서의 카디널리티는 특정 컬럼에 존재하는 고유한 값의 개수를 의미한다.', 'OBJECTIVE'),
       (863, 124, '다음 중 엔터티 구성에 따른 속성 분류로 올바르게 짝지어진 것은?', '속성은 엔터티 구성에 따라 분류할 수 있다.', 'OBJECTIVE'),
       (864, 124, '빈칸에 들어갈 모델링 단계를 작성하시오.', '___은(는) 정보 모델링이라고도 하며, 전체적인 뼈대를 만드는 과정이다.', 'SUBJECTIVE'),
       (865, 124, '다음 중 일대일(1:1) 관계에 대한 설명으로 올바른 것은?', '일대일 관계는 관계의 종류 중 하나이다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES
-- 문제 859
(2443, 859, 'DBMS에 맞게 매핑하는 단계이다', 'DBMS에 맞게 매핑하는 것은 논리적 모델링 단계이다. 개념적 모델링은 E-R 다이어그램을 작성하는 단계이다.', false),
(2444, 859, '저장 구조를 정의하는 단계이다', '저장 구조를 정의하는 것은 물리적 모델링 단계이다.', false),
(2445, 859, '정규화를 수행하는 단계이다', '정규화는 논리적 모델링 단계에서 수행한다.', false),
(2446, 859, 'E-R 다이어그램을 작성하는 단계이다', '개념적 모델링은 요구사항 분석을 기반으로 엔터티를 추출하고 엔터티 간의 관계를 정의하여 E-R 다이어그램을 작성하는 단계이다.', true),

-- 문제 860
(2447, 860, '일대일(1:1)', '일대일(1:1) 관계는 양쪽 엔터티가 각각 하나씩 대응되는 관계이다. 부서-사원 관계는 일대다(1:N) 관계이다.', false),
(2448, 860, '일대다(1:N)', '일대다(1:N) 관계는 한쪽 엔터티가 여러 개의 다른 엔터티와 대응되는 관계이다. 부서-사원 관계가 대표적인 예시로, 하나의 부서에 여러 사원이 속할 수 있다.',
 true),
(2449, 860, '다대다(M:N)', '다대다(M:N) 관계는 양쪽 모두 여러 개와 대응되는 관계이다. 부서-사원 관계는 일대다(1:N) 관계이다.', false),
(2450, 860, '다대일(N:1)', '다대일(N:1)은 일대다(1:N)를 반대 방향에서 본 것이다. 부서 관점에서는 일대다, 사원 관점에서는 다대일이 된다.', false),

-- 문제 862
(2451, 862, '성별', '성별은 보통 남/여 두 가지 값만 가지므로 카디널리티가 낮다.', false),
(2452, 862, '부서코드', '부서코드는 부서 수만큼의 값을 가지므로 성별보다는 높지만, 주민등록번호보다는 낮다.', false),
(2453, 862, '주민등록번호', '주민등록번호는 모든 사람이 고유한 값을 가지므로 카디널리티가 매우 높다. 인덱스 설계 시 카디널리티가 높은 컬럼을 선택하는 것이 효율적이다.', true),
(2454, 862, '활성화 여부', '활성화 여부는 보통 Y/N 또는 true/false 두 가지 값만 가지므로 카디널리티가 낮다.', false),

-- 문제 863
(2455, 863, '기본 속성, 설계 속성, 파생 속성', '기본 속성, 설계 속성, 파생 속성은 특성에 따른 분류이다. 엔터티 구성에 따른 분류는 PK 속성, FK 속성, 일반 속성이다.', false),
(2456, 863, 'PK 속성, FK 속성, 일반 속성', '엔터티 구성에 따른 분류는 PK 속성(엔터티를 유일하게 식별), FK 속성(다른 엔터티와의 관계 표현), 일반 속성(PK, FK가 아닌 나머지)으로 구분된다.', true),
(2457, 863, '단일 속성, 복합 속성, 다중값 속성', '이는 속성의 구조에 따른 분류 방법으로, 엔터티 구성에 따른 분류가 아니다.', false),
(2458, 863, '필수 속성, 선택 속성', '이는 속성의 NULL 허용 여부에 따른 분류로, 엔터티 구성에 따른 분류가 아니다.', false),

-- 문제 865
(2459, 865, '한쪽 엔터티가 여러 개의 다른 엔터티와 대응된다', '한쪽 엔터티가 여러 개와 대응되는 것은 일대다(1:N) 관계이다. 일대일 관계는 양쪽이 각각 하나씩 대응된다.', false),
(2460, 865, '양쪽 엔터티가 각각 하나씩 대응된다', '일대일(1:1) 관계는 양쪽 엔터티가 각각 하나씩 대응되는 관계이다. 사원과 사원 상세정보 테이블의 관계가 대표적인 예시이다.', true),
(2461, 865, '양쪽 모두 여러 개와 대응된다', '양쪽 모두 여러 개와 대응되는 것은 다대다(M:N) 관계이다.', false),
(2462, 865, '물리적 데이터베이스에서 직접 구현할 수 없다', '일대일 관계는 물리적 데이터베이스에서 직접 구현할 수 있다. 직접 구현할 수 없는 것은 다대다(M:N) 관계이다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (247, 861, '연결 엔터티, 중간 테이블, 연결 테이블, 매핑 테이블, 조인 테이블', '다대다(M:N) 관계는 물리적 데이터베이스에서 직접 구현할 수 없으므로, 연결 엔터티(중간 테이블)를 추가하여 일대다(1:N) 관계로 해소한다. 연결 엔터티는 양쪽 엔터티의 기본키를 외래키로 가지며,
        이 두 외래키의 조합이 기본키가 된다.'),
       (248, 864, '개념적 모델링, Conceptual Modeling', '개념적 모델링은 정보 모델링이라고도 하며, 요구사항 분석을 기반으로 전체적인 뼈대를 만드는 과정이다. 엔터티를 추출하고 엔터티 간의 관계를 정의하여 E-R 다이어그램을 작성한다.');

-- =====================================================
-- Chapter 4: 데이터베이스 (ID: 4)
-- Unit 43: 식별 관계와 비식별 관계
-- =====================================================

-- Lesson 1: 식별 관계와 비식별 관계 1 (ID: 125)
INSERT INTO lesson (id, title, unit_id)
VALUES (125, '식별 관계와 비식별 관계 1', 43);

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (866, 125, '다음 중 식별 관계(Identifying Relationship)에 대한 설명으로 올바른 것은?', '식별 관계는 부모 테이블과 자식 테이블 간의 관계 유형 중 하나이다.', 'OBJECTIVE'),
       (867, 125, '빈칸에 들어갈 용어를 작성하시오.', '___관계에서는 부모 테이블의 기본 키가 자식 테이블의 기본 키이자 외래 키 역할을 동시에 수행한다.', 'SUBJECTIVE'),
       (868, 125, '다음 중 비식별 관계(Non-Identifying Relationship)의 특징으로 올바른 것은?', '비식별 관계는 부모 테이블과 자식 테이블 간의 관계 유형 중 하나이다.', 'OBJECTIVE'),
       (869, 125, '다음 설명에 해당하는 관계 유형은?', 'ERD에서 실선으로 표현되며, 부모 데이터가 존재해야만 자식 데이터를 생성할 수 있다.', 'OBJECTIVE'),
       (870, 125, '빈칸에 들어갈 내용을 작성하시오.', '식별 관계에서는 부모와 자식의 ___이(가) 일치한다.', 'SUBJECTIVE'),
       (871, 125, '다음 중 식별 관계와 비식별 관계의 ERD 표현 방식으로 올바른 것은?', 'ERD에서 관계 유형에 따라 선의 종류가 다르게 표현된다.', 'OBJECTIVE'),
       (872, 125, '다음 중 비식별 관계를 선택해야 하는 경우로 적절한 것은?', '관계 유형은 엔터티 간의 결합도와 생명주기에 따라 선택한다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES
-- 문제 866
(2463, 866, '부모의 PK가 자식의 일반 속성(FK)으로만 사용된다', '부모의 PK가 자식의 일반 속성(FK)으로만 사용되는 것은 비식별 관계이다. 식별 관계에서는 부모의 PK가 자식의 PK이자 FK로 사용된다.', false),
(2464, 866, '자식 데이터는 부모 데이터 없이 독립적으로 생성 가능하다', '자식 데이터가 독립적으로 생성 가능한 것은 비식별 관계이다. 식별 관계에서는 부모 데이터가 존재해야만 자식 데이터를 생성할 수 있다.', false),
(2465, 866, 'ERD에서 점선으로 표현된다', 'ERD에서 점선으로 표현되는 것은 비식별 관계이다. 식별 관계는 실선으로 표현된다.', false),
(2466, 866, '부모와 자식의 생명주기가 일치한다', '식별 관계에서는 부모의 PK가 자식의 PK이자 FK 역할을 동시에 수행하므로, 부모 데이터가 존재해야만 자식 데이터를 생성할 수 있고, 부모와 자식의 생명주기가 일치한다.', true),

-- 문제 868
(2467, 868, '부모의 PK가 자식의 PK이자 FK 역할을 수행한다', '부모의 PK가 자식의 PK이자 FK 역할을 수행하는 것은 식별 관계이다.', false),
(2468, 868, '부모와 자식의 생명주기가 일치한다', '부모와 자식의 생명주기가 일치하는 것은 식별 관계이다. 비식별 관계에서는 생명주기가 분리된다.', false),
(2469, 868, '자식은 자체적인 기본 키를 가진다', '비식별 관계에서는 부모 테이블의 기본 키를 자식 테이블의 외래 키로만 사용하고, 자식은 자체적인 기본 키를 가진다.', true),
(2470, 868, 'ERD에서 실선으로 표현된다', 'ERD에서 실선으로 표현되는 것은 식별 관계이다. 비식별 관계는 점선으로 표현된다.', false),

-- 문제 869
(2471, 869, '비식별 관계', '비식별 관계는 ERD에서 점선으로 표현되며, 자식 데이터는 부모 데이터 없이 독립적으로 생성 가능하다.', false),
(2472, 869, '다대다 관계', '다대다 관계는 관계의 카디널리티를 나타내는 것으로, 식별 / 비식별 관계와는 다른 개념이다.', false),
(2473, 869, '식별 관계', '식별 관계는 ERD에서 실선으로 표현되며, 부모 데이터가 존재해야만 자식 데이터를 생성할 수 있다. 부모와 자식의 생명주기가 일치한다.', true),
(2474, 869, '일대다 관계', '일대다 관계는 관계의 카디널리티를 나타내는 것으로, 식별 / 비식별 관계와는 다른 개념이다.', false),

-- 문제 871
(2475, 871, '식별 관계는 점선, 비식별 관계는 실선', '반대이다. 식별 관계는 실선, 비식별 관계는 점선으로 표현된다.', false),
(2476, 871, '식별 관계와 비식별 관계 모두 실선', '비식별 관계는 점선으로 표현된다.', false),
(2477, 871, '식별 관계와 비식별 관계 모두 점선', '식별 관계는 실선으로 표현된다.', false),
(2478, 871, '식별 관계는 실선, 비식별 관계는 점선', 'ERD에서 식별 관계는 실선으로, 비식별 관계는 점선으로 표현된다. 실선은 강한 결합을, 점선은 약한 결합을 나타낸다.', true),

-- 문제 872
(2479, 872, '부모와 자식 엔터티가 강하게 결합되어 있을 때', '부모와 자식이 강하게 결합되어 있을 때는 식별 관계를 선택한다.', false),
(2480, 872, '부모 엔터티 없이는 자식 엔터티가 의미가 없을 때', '부모 없이 자식이 의미가 없을 때는 식별 관계를 선택한다.', false),
(2481, 872, '자식 엔터티가 독립적으로 존재할 수 있을 때', '비식별 관계는 자식 엔터티가 독립적으로 존재할 수 있거나, 부모 - 자식 관계가 선택적일 때 선택한다.', true),
(2482, 872, '부모와 자식의 생명주기가 반드시 일치해야 할 때', '생명주기가 일치해야 할 때는 식별 관계를 선택한다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (249, 867, '식별, Identifying', '식별 관계(Identifying Relationship)에서는 부모 테이블의 기본 키 또는 유니크 키를 자신의 기본 키로 사용한다. 즉, 부모 테이블의 PK가 자식 테이블의 PK이자 FK 역할을 동시에 수행한다.'),
       (250, 870, '생명주기, 라이프사이클, Life Cycle', '식별 관계에서는 부모와 자식의 생명주기가 일치한다. 부모 데이터가 존재해야만 자식 데이터를 생성할 수 있으며, 부모 데이터가 삭제되면 자식 데이터도 함께 영향을 받는다.');

-- Lesson 2: 식별 관계와 비식별 관계 2 (ID: 126)
INSERT INTO lesson (id, title, unit_id)
VALUES (126, '식별 관계와 비식별 관계 2', 43);

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (873, 126, '다음 중 식별 관계를 선택해야 하는 경우로 적절한 것은?', '관계 유형은 엔터티 간의 결합도와 생명주기에 따라 선택한다.', 'OBJECTIVE'),
       (874, 126, '빈칸에 들어갈 용어를 작성하시오.', '비식별 관계에서는 부모의 PK가 자식의 일반 속성인 ___로만 사용된다.', 'SUBJECTIVE'),
       (875, 126, '다음 설명에 해당하는 관계 유형은?', 'ERD에서 점선으로 표현되며, 부모와 자식의 생명주기가 분리된다.', 'OBJECTIVE'),
       (876, 126, '다음 중 비식별 관계의 특징으로 올바르지 않은 것은?', '비식별 관계는 자식 테이블이 자체적인 기본 키를 가지는 관계이다.', 'OBJECTIVE'),
       (877, 126, '다음 상황에서 적절한 관계 유형은?', '주문(Order) 테이블과 주문상세(OrderDetail) 테이블이 있다. 주문이 없으면 주문상세도 존재할 수 없다.', 'OBJECTIVE'),
       (878, 126, '빈칸에 들어갈 내용을 작성하시오.', '비식별 관계에서 자식 데이터는 부모 데이터 없이도 ___으로 생성 가능하다.', 'SUBJECTIVE'),
       (879, 126, '다음 중 식별 관계에 대한 설명으로 올바르지 않은 것은?', '식별 관계는 부모와 자식 간의 강한 결합을 나타낸다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES
-- 문제 873
(2483, 873, '자식 엔터티가 독립적으로 존재할 수 있을 때', '자식이 독립적으로 존재할 수 있을 때는 비식별 관계를 선택한다.', false),
(2484, 873, '부모-자식 관계가 선택적일 때', '관계가 선택적일 때는 비식별 관계를 선택한다.', false),
(2485, 873, '부모 엔터티 없이는 자식 엔터티가 의미가 없을 때', '식별 관계는 부모와 자식 엔터티가 강하게 결합되어 있거나, 부모 엔터티 없이는 자식 엔터티가 의미가 없을 때 선택한다.', true),
(2486, 873, '부모와 자식의 생명주기를 분리해야 할 때', '생명주기를 분리해야 할 때는 비식별 관계를 선택한다.', false),

-- 문제 875
(2487, 875, '식별 관계', '식별 관계는 ERD에서 실선으로 표현되며, 부모와 자식의 생명주기가 일치한다.', false),
(2488, 875, '비식별 관계', '비식별 관계는 ERD에서 점선으로 표현되며, 부모와 자식의 생명주기가 분리된다. 자식 데이터는 부모 데이터 없이도 독립적으로 생성 가능하다.', true),
(2489, 875, '일대일 관계', '일대일 관계는 카디널리티를 나타내는 것으로, ERD 선 종류와는 관련이 없다.', false),
(2490, 875, '다대다 관계', '다대다 관계는 카디널리티를 나타내는 것으로, ERD 선 종류와는 관련이 없다.', false),

-- 문제 876
(2491, 876, '자식은 자체적인 기본 키를 가진다', '비식별 관계에서 자식은 자체적인 기본 키를 가진다. 이는 올바른 설명이다.', false),
(2492, 876, '부모의 PK가 자식의 일반 속성(FK)으로만 사용된다', '비식별 관계에서 부모의 PK는 자식의 일반 속성인 FK로만 사용된다. 이는 올바른 설명이다.', false),
(2493, 876, 'ERD에서 점선으로 표현된다', '비식별 관계는 ERD에서 점선으로 표현된다. 이는 올바른 설명이다.', false),
(2494, 876, '부모와 자식의 생명주기가 일치한다', '부모와 자식의 생명주기가 일치하는 것은 식별 관계이다. 비식별 관계에서는 부모와 자식의 생명주기가 분리된다.', true),

-- 문제 877
(2495, 877, '비식별 관계', '주문이 없으면 주문상세도 존재할 수 없으므로 강한 결합 관계이다. 이 경우 식별 관계가 적절하다.', false),
(2496, 877, '다대다 관계', '다대다 관계는 카디널리티를 나타내는 것으로, 이 상황에서의 적절한 관계 유형과는 다른 개념이다.', false),
(2497, 877, '식별 관계', '주문이 없으면 주문상세도 존재할 수 없으므로, 부모 엔터티 없이는 자식 엔터티가 의미가 없는 경우에 해당한다. 이런 경우 식별 관계가 적절하다.', true),
(2498, 877, '일대일 관계', '일대일 관계는 카디널리티를 나타내는 것으로, 이 상황에서의 적절한 관계 유형과는 다른 개념이다.', false),

-- 문제 879
(2499, 879, '부모의 PK가 자식의 PK이자 FK 역할을 수행한다', '식별 관계에서 부모의 PK는 자식의 PK이자 FK 역할을 동시에 수행한다. 이는 올바른 설명이다.', false),
(2500, 879, '부모 데이터가 존재해야만 자식 데이터를 생성할 수 있다', '식별 관계에서는 부모 데이터가 존재해야만 자식 데이터를 생성할 수 있다. 이는 올바른 설명이다.', false),
(2501, 879, 'ERD에서 실선으로 표현된다', '식별 관계는 ERD에서 실선으로 표현된다. 이는 올바른 설명이다.', false),
(2502, 879, '자식 데이터는 부모 데이터 없이 독립적으로 생성 가능하다', '자식 데이터가 독립적으로 생성 가능한 것은 비식별 관계이다. 식별 관계에서는 부모 데이터가 존재해야만 자식 데이터를 생성할 수 있다.', true);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (251, 874, 'FK, 외래키, 외래 키, Foreign Key ', ' 비식별 관계에서는 부모 테이블의 기본 키를 자식 테이블의 외래 키(FK) 로만 사용하고, 자식은 자체적인 기본 키를 가진다. 부모의 PK가 자식의 일반 속성(FK)으로만 사용되는 것이 비식별 관계의 특징이다.'),
       (252, 878, '독립적, 독립', '비식별 관계에서는 자식 데이터가 부모 데이터 없이도 독립적으로 생성 가능하다. 부모와 자식의 생명주기가 분리되어 있기 때문이다.');

-- Lesson 3: 식별 관계와 비식별 관계 3 (ID: 127)
INSERT INTO lesson (id, title, unit_id)
VALUES (127, '식별 관계와 비식별 관계 3', 43);

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (880, 127, '다음 상황에서 적절한 관계 유형은?', '회원(Member) 테이블과 게시글(Post) 테이블이 있다. 회원이 탈퇴해도 게시글은 유지되어야 한다.', 'OBJECTIVE'),
       (881, 127, '빈칸에 들어갈 ERD 표현 방식을 작성하시오.', '식별 관계는 ERD에서 ___으로 표현된다.', 'SUBJECTIVE'),
       (882, 127, '다음 중 식별 관계와 비식별 관계를 구분하는 핵심 기준은?', '두 관계 유형은 특정 기준에 의해 구분된다.', 'OBJECTIVE'),
       (883, 127, '다음 설명이 올바른지 판단하시오.', '비식별 관계에서 부모의 PK는 자식의 PK로 사용되지 않고, FK로만 사용된다.', 'OBJECTIVE'),
       (884, 127, '다음 상황에서 적절한 관계 유형은?', '부서(Department) 테이블과 사원(Employee) 테이블이 있다. 사원은 부서에 소속되지 않을 수도 있다.', 'OBJECTIVE'),
       (885, 127, '빈칸에 들어갈 용어를 작성하시오.', '___관계에서는 ERD에서 점선으로 표현되며, 자식이 자체적인 기본 키를 가진다.', 'SUBJECTIVE'),
       (886, 127, '다음 중 관계 유형 선택에 대한 설명으로 올바른 것은?', '관계 유형은 비즈니스 요구사항에 따라 선택한다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES
-- 문제 880
(2503, 880, '식별 관계', '회원이 탈퇴해도 게시글이 유지되어야 하므로, 부모와 자식의 생명주기가 분리되어야 한다. 이 경우 비식별 관계가 적절하다.', false),
(2504, 880, '비식별 관계', '회원이 탈퇴해도 게시글이 유지되어야 하므로, 부모와 자식의 생명주기가 분리되어야 한다. 자식 엔터티가 독립적으로 존재할 수 있으므로 비식별 관계가 적절하다.', true),
(2505, 880, '다대다 관계', '다대다 관계는 카디널리티를 나타내는 것으로, 이 상황에서의 관계 유형과는 다른 개념이다.', false),
(2506, 880, '일대일 관계', '일대일 관계는 카디널리티를 나타내는 것으로, 이 상황에서의 관계 유형과는 다른 개념이다.', false),

-- 문제 882
(2507, 882, 'ERD에서 선의 종류', 'ERD에서 선의 종류는 식별/비식별 관계의 결과적 표현 방식이지, 구분하는 핵심 기준은 아니다.', false),
(2508, 882, '관계의 카디널리티', '카디널리티(1:1, 1:N, M:N)는 관계의 대응 수를 나타내는 것으로, 식별 / 비식별 관계를 구분하는 기준이 아니다.', false),
(2509, 882, '부모의 PK가 자식의 PK로 사용되는지 여부', '식별 관계는 부모의 PK가 자식의 PK이자 FK로 사용되고, 비식별 관계는 부모의 PK가 자식의 FK로만 사용된다. 이것이 두 관계를 구분하는 핵심 기준이다.', true),
(2510, 882, '테이블의 컬럼 수', '테이블의 컬럼 수는 식별/비식별 관계를 구분하는 기준이 아니다.', false),

-- 문제 883
(2511, 883, '올바르다', '비식별 관계에서는 부모 테이블의 기본 키를 자식 테이블의 외래 키로만 사용하고, 자식은 자체적인 기본 키를 가진다. 부모의 PK가 자식의 PK로 사용되지 않는 것이 비식별 관계의 특징이다.', true),
(2512, 883, '올바르지 않다', '이 설명은 올바르다. 비식별 관계에서 부모의 PK는 자식의 FK로만 사용되며, 자식은 자체적인 PK를 가진다.', false),
(2513, 883, '식별 관계에만 해당된다', '이 설명은 비식별 관계에 해당된다. 식별 관계에서는 부모의 PK가 자식의 PK이자 FK로 사용된다.', false),
(2514, 883, '상황에 따라 다르다', '비식별 관계의 정의상, 부모의 PK는 자식의 FK로만 사용되고 PK로는 사용되지 않는다. 이는 상황에 따라 달라지지 않는다.', false),

-- 문제 884
(2515, 884, '식별 관계', '사원이 부서에 소속되지 않을 수도 있으므로, 부모 - 자식 관계가 선택적이다. 이 경우 비식별 관계가 적절하다.', false),
(2516, 884, '일대일 관계', '일대일 관계는 카디널리티를 나타내는 것으로, 이 상황에서의 관계 유형과는 다른 개념이다.', false),
(2517, 884, '비식별 관계', '사원이 부서에 소속되지 않을 수도 있으므로, 부모 - 자식 관계가 선택적이다. 이런 경우 비식별 관계가 적절하며, 사원 테이블의 부서ID FK는 NULL을 허용할 수 있다.',
 true),
(2518, 884, '다대다 관계', '다대다 관계는 카디널리티를 나타내는 것으로, 이 상황에서의 관계 유형과는 다른 개념이다.', false),

-- 문제 886
(2519, 886, '항상 식별 관계를 선택하는 것이 좋다', '관계 유형은 비즈니스 요구사항에 따라 적절히 선택해야 한다. 항상 식별 관계가 좋은 것은 아니다.', false),
(2520, 886, '항상 비식별 관계를 선택하는 것이 좋다', '관계 유형은 비즈니스 요구사항에 따라 적절히 선택해야 한다. 항상 비식별 관계가 좋은 것은 아니다.', false),
(2521, 886, '엔터티 간의 결합도와 생명주기에 따라 선택한다', '식별 관계는 강한 결합과 동일한 생명주기가 필요할 때, 비식별 관계는 약한 결합과 독립적인 생명주기가 필요할 때 선택한다.', true),
(2522, 886, 'ERD 표현의 편의성에 따라 선택한다', 'ERD 표현은 관계 유형의 결과이지, 선택 기준이 아니다. 비즈니스 요구사항에 따라 관계 유형을 선택해야 한다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (253, 881, '실선', '식별 관계는 ERD에서 실선으로 표현된다. 실선은 부모와 자식 간의 강한 결합을 나타내며, 부모 데이터가 존재해야만 자식 데이터를 생성할 수 있음을 의미한다. 반면 비식별 관계는 점선으로 표현된다.'),
       (254, 885, '비식별, Non - Identifying', '비식별 관계(Non-Identifying Relationship)에서는 부모 테이블의 기본 키를 자식 테이블의 외래 키로만 사용하고, 자식은 자체적인 기본 키를 가진다. ERD에서 점선으로 표현되며,
        부모와 자식의 생명주기가 분리된다.');

-- =====================================================
-- Chapter 4: 데이터베이스 (ID: 4)
-- Unit 44: 관계형 모델 개념
-- =====================================================

-- Lesson 1: 관계형 모델 개념 1 (ID: 128)
INSERT INTO lesson (id, title, unit_id)
VALUES (128, '관계형 모델 개념 1', 44);

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (887, 128, '다음 중 관계형 데이터베이스에 대한 설명으로 올바른 것은?', '관계형 데이터베이스는 데이터를 특정 구조로 저장하고 관리하는 시스템이다.', 'OBJECTIVE'),
       (888, 128, '빈칸에 들어갈 용어를 작성하시오.', '관계형 데이터베이스에서 데이터를 표 형태로 표현한 것을 ___이라고 한다.', 'SUBJECTIVE'),
       (889, 128, '다음 중 릴레이션의 구성 요소와 대응 개념이 올바르게 연결된 것은?', '릴레이션은 여러 구성 요소로 이루어져 있다.', 'OBJECTIVE'),
       (890, 128, '다음 설명에 해당하는 릴레이션 구성 요소는?', '릴레이션을 구성하는 각각의 행으로, 레코드라고도 한다.', 'OBJECTIVE'),
       (891, 128, '빈칸에 들어갈 용어를 작성하시오.', '하나의 속성이 가질 수 있는 원자값들의 집합을 ___이라고 한다.', 'SUBJECTIVE'),
       (892, 128, '다음 중 릴레이션의 차수(Degree)에 대한 설명으로 올바른 것은?', '차수는 릴레이션의 특정 요소의 수를 나타낸다.', 'OBJECTIVE'),
       (893, 128, '다음 중 도메인(Domain)의 예시로 올바른 것은?', '도메인은 속성이 가질 수 있는 값의 범위를 정의한다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES
-- 문제 887
(2523, 887, '데이터를 계층 구조로 저장한다', '계층 구조로 데이터를 저장하는 것은 계층형 데이터베이스이다. 관계형 데이터베이스는 2차원 표 형태로 데이터를 저장한다.', false),
(2524, 887, '개체와 관계를 모두 릴레이션으로 표현한다', '관계형 데이터베이스는 개체(Entity)와 관계(Relationship)를 모두 릴레이션이라는 2차원 표로 표현한다.', true),
(2525, 887, '데이터 간의 관계를 포인터로 연결한다', '포인터로 데이터를 연결하는 것은 네트워크형 데이터베이스의 특징이다.', false),
(2526, 887, '비정형 데이터를 저장하는 데 최적화되어 있다', '비정형 데이터 저장에 최적화된 것은 NoSQL 데이터베이스이다. 관계형 데이터베이스는 정형 데이터를 테이블 형태로 저장한다.', false),

-- 문제 889
(2527, 889, '튜플 - 열, 속성 - 행', '튜플은 행(레코드)에, 속성은 열(필드)에 대응된다. 반대로 연결되어 있다.', false),
(2528, 889, '튜플 - 행, 속성 - 열', '튜플은 릴레이션을 구성하는 각각의 행으로 레코드에 대응되고, 속성은 각각의 열로 필드에 대응된다.', true),
(2529, 889, '도메인 - 행, 카디널리티 - 열', '도메인은 속성이 가질 수 있는 값의 범위이고, 카디널리티는 튜플의 수이다. 행이나 열과 직접 대응되지 않는다.', false),
(2530, 889, '차수 - 행, 카디널리티 - 열', '차수는 속성의 수이고, 카디널리티는 튜플의 수이다. 행이나 열 자체와 대응되지 않는다.', false),

-- 문제 890
(2531, 890, '속성(Attribute)', '속성은 릴레이션을 구성하는 각각의 열로, 필드라고도 한다.', false),
(2532, 890, '도메인(Domain)', '도메인은 하나의 속성이 가질 수 있는 원자값들의 집합이다.', false),
(2533, 890, '튜플(Tuple)', '튜플은 릴레이션을 구성하는 각각의 행으로, 레코드라고도 한다. 하나의 튜플은 릴레이션에서 하나의 개체를 나타낸다.', true),
(2534, 890, '카디널리티(Cardinality)', '카디널리티는 튜플의 수, 즉 행의 개수를 의미한다.', false),

-- 문제 892
(2535, 892, '튜플의 수를 의미한다', '튜플의 수는 카디널리티(Cardinality)이다.', false),
(2536, 892, '속성의 수를 의미한다', '차수(Degree)는 릴레이션을 구성하는 속성의 수, 즉 열의 개수를 의미한다.', true),
(2537, 892, '도메인의 크기를 의미한다', '도메인의 크기는 속성이 가질 수 있는 값의 범위를 나타내며, 차수와는 다른 개념이다.', false),
(2538, 892, '릴레이션의 전체 크기를 의미한다', '릴레이션의 전체 크기는 차수와 카디널리티의 조합으로 표현될 수 있지만, 차수 자체는 속성의 수만을 의미한다.', false),

-- 문제 893
(2539, 893, '학생 테이블의 전체 행 수', '행 수는 카디널리티에 해당하며, 도메인의 예시가 아니다.', false),
(2540, 893, '성별 속성의 값 집합 {남, 여}', '도메인은 하나의 속성이 가질 수 있는 원자값들의 집합이다. 성별 속성의 도메인은 {남, 여}로 정의될 수 있다.', true),
(2541, 893, '학생 테이블의 컬럼 수', '컬럼 수는 차수에 해당하며, 도메인의 예시가 아니다.', false),
(2542, 893, '학생 테이블과 수강 테이블의 관계', '테이블 간의 관계는 도메인과 다른 개념이다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (255, 888, '릴레이션, Relation, 테이블, Table ', ' 릴레이션(Relation) 은 관계형 데이터베이스에서 데이터를 2차원 표 형태로 표현한 것이다.물리적으로는 테이블(Table) 이라고도 한다.구조를 정의하는 릴레이션 스키마와 실제 데이터인 릴레이션
        인스턴스로 구성된다.'),
       (256, 891, ' 도메인, Domain ', ' 도메인(Domain) 은 하나의 속성이 가질 수 있는 원자값들의 집합이다.속성에 허용되는 값의 범위를 정의하며, 예를 들어 성별 속성의 도메인은 {남, 여}, 학년 속성의 도메인은 {1, 2, 3,
        4}로 정의할 수 있다.');

-- Lesson 2: 관계형 모델 개념 2 (ID: 129)
INSERT INTO lesson (id, title, unit_id)
VALUES (129, '관계형 모델 개념 2', 44);

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (894, 129, '다음 중 개체 무결성 제약에 대한 설명으로 올바른 것은?', '무결성 제약은 데이터의 정확성과 일관성을 보장하기 위한 규칙이다.', 'OBJECTIVE'),
       (895, 129, '빈칸에 들어갈 용어를 작성하시오.', '외래 키 값은 참조하는 테이블의 기본 키 값이거나 ___이어야 한다.', 'SUBJECTIVE'),
       (896, 129, '다음 설명에 해당하는 무결성 제약은?', '속성 값은 정의된 도메인에 속한 값이어야 하며, 데이터 타입, 길이, 형식 등의 제약을 만족해야 한다.', 'OBJECTIVE'),
       (897, 129, '다음 중 참조 무결성 위반의 예시로 올바른 것은?', '참조 무결성은 외래 키와 관련된 제약이다.', 'OBJECTIVE'),
       (898, 129, '빈칸에 들어갈 내용을 작성하시오.', '개체 무결성 제약에 따르면, 기본 키를 구성하는 속성은 ___ 값을 가질 수 없다.', 'SUBJECTIVE'),
       (899, 129, '다음 중 카디널리티(Cardinality)에 대한 설명으로 올바른 것은?', '카디널리티는 릴레이션의 특정 요소의 수를 나타낸다.', 'OBJECTIVE'),
       (900, 129, '다음 중 관계형 데이터베이스의 특징으로 올바르지 않은 것은?', '관계형 데이터베이스는 특정 특징을 가진다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES
-- 문제 894
(2543, 894, '외래 키 값은 참조하는 테이블의 기본 키 값이어야 한다', '이것은 참조 무결성 제약에 대한 설명이다.', false),
(2544, 894, '속성 값은 정의된 도메인에 속한 값이어야 한다', '이것은 도메인 무결성 제약에 대한 설명이다.', false),
(2545, 894, '기본 키는 NULL 값을 가질 수 없고 유일해야 한다', '개체 무결성 제약에 따르면, 기본 키를 구성하는 속성은 NULL 값을 가질 수 없으며, 릴레이션 내에서 유일해야 한다.',
 true),
(2546, 894, '모든 속성은 NOT NULL이어야 한다', '모든 속성이 NOT NULL일 필요는 없다. 개체 무결성은 기본 키에만 적용되는 제약이다.', false),

-- 문제 896
(2547, 896, '개체 무결성', '개체 무결성은 기본 키가 NULL이 아니고 유일해야 한다는 제약이다.', false),
(2548, 896, '참조 무결성', '참조 무결성은 외래 키 값이 참조하는 테이블의 기본 키 값이거나 NULL이어야 한다는 제약이다.', false),
(2549, 896, '도메인 무결성', '도메인 무결성은 속성 값이 정의된 도메인에 속한 값이어야 한다는 제약이다. 데이터 타입, 길이, 형식 등의 제약을 만족해야 한다.', true),
(2550, 896, '키 무결성', '키 무결성이라는 용어는 일반적으로 사용되지 않는다. 도메인 무결성이 정답이다.', false),

-- 문제 897
(2551, 897, '기본 키에 NULL 값을 삽입하는 경우', '이것은 개체 무결성 위반이다.', false),
(2552, 897, '문자열 속성에 숫자를 삽입하는 경우', '이것은 도메인 무결성 위반이다.', false),
(2553, 897, '존재하지 않는 부서ID를 사원 테이블에 삽입하는 경우', '참조 무결성은 외래 키 값이 참조하는 테이블의 기본 키 값이거나 NULL이어야 한다는 제약이다. 존재하지 않는 값을 참조하면 위반된다.', true),
(2554, 897, '동일한 기본 키 값을 중복 삽입하는 경우', '이것은 개체 무결성(유일성) 위반이다.', false),

-- 문제 899
(2555, 899, '속성의 수를 의미한다', '속성의 수는 차수(Degree)이다.', false),
(2556, 899, '도메인의 크기를 의미한다', '도메인의 크기는 속성이 가질 수 있는 값의 범위이며, 카디널리티와는 다른 개념이다.', false),
(2557, 899, '튜플의 수를 의미한다', '카디널리티(Cardinality)는 릴레이션을 구성하는 튜플의 수, 즉 행의 개수를 의미한다.', true),
(2558, 899, '릴레이션의 이름을 의미한다', '릴레이션의 이름은 카디널리티와 관련이 없다.', false),

-- 문제 900
(2559, 900, '구조가 간결하고 보기 편리하다', '관계형 데이터베이스는 2차원 표 형태로 데이터를 표현하므로 구조가 간결하고 보기 편리하다. 이는 올바른 특징이다.', false),
(2560, 900, '다른 데이터베이스로의 변환이 용이하다', '관계형 모델은 표준화되어 있어 다른 데이터베이스로의 변환이 용이하다. 이는 올바른 특징이다.', false),
(2561, 900, '대용량 처리 시에도 성능 저하가 없다', '관계형 데이터베이스는 대용량 처리 시 성능이 다소 떨어질 수 있다. 이는 관계형 데이터베이스의 한계점 중 하나이다.', true),
(2562, 900, '개체와 관계를 모두 릴레이션으로 표현한다', '관계형 데이터베이스는 개체와 관계를 모두 릴레이션이라는 표로 표현한다. 이는 올바른 특징이다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (257, 895, 'NULL, 널', '참조 무결성 제약에 따르면, 외래 키 값은 참조하는 테이블의 기본 키 값이거나 NULL이어야 한다. 존재하지 않는 값을 참조할 수 없으며, NULL은 아직 관계가 설정되지 않음을 의미한다.'),
       (258, 898, 'NULL, 널', '개체 무결성 제약에 따르면, 기본 키를 구성하는 속성은 NULL 값을 가질 수 없다. 또한 기본 키는 릴레이션 내에서 유일해야 한다. 이를 통해 각 튜플을 고유하게 식별할 수 있다.');

-- Lesson 3: 관계형 모델 개념 3 (ID: 130)
INSERT INTO lesson (id, title, unit_id)
VALUES (130, '관계형 모델 개념 3', 44);

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (901, 130, '다음 설명이 올바른지 판단하시오.', '릴레이션 스키마는 릴레이션의 구조를 정의하고, 릴레이션 인스턴스는 실제 데이터를 의미한다.', 'OBJECTIVE'),
       (902, 130, '빈칸에 들어갈 용어를 작성하시오.', '릴레이션을 구성하는 각각의 열을 ___이라고 하며, 필드라고도 한다.', 'SUBJECTIVE'),
       (903, 130, '다음 중 무결성 제약 조건과 그 설명이 올바르게 연결된 것은?', '무결성 제약은 데이터의 정확성을 보장한다.', 'OBJECTIVE'),
       (904, 130, '다음 상황에서 위반되는 무결성 제약은?', '학생 테이블의 학번(PK) 컬럼에 NULL 값을 삽입하려고 한다.', 'OBJECTIVE'),
       (905, 130, '다음 중 릴레이션의 특징으로 올바르지 않은 것은?', '릴레이션은 특정 규칙을 따르는 구조이다.', 'OBJECTIVE'),
       (906, 130, '빈칸에 들어갈 용어를 작성하시오.', '___무결성은 외래 키 값이 참조하는 테이블의 기본 키 값이거나 NULL이어야 한다는 제약이다.', 'SUBJECTIVE'),
       (907, 130, '다음 중 도메인 무결성 위반의 예시로 올바른 것은?', '도메인 무결성은 속성 값이 정의된 범위를 만족해야 한다는 제약이다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES
-- 문제 901
(2563, 901, '올바르다', '릴레이션은 구조를 정의하는 릴레이션 스키마와 실제 데이터인 릴레이션 인스턴스로 구성된다. 스키마는 속성의 이름과 도메인을 정의하고, 인스턴스는 특정 시점의 실제 튜플 집합이다.', true),
(2564, 901, '올바르지 않다', '이 설명은 올바르다. 릴레이션 스키마는 구조를, 릴레이션 인스턴스는 실제 데이터를 의미한다.', false),
(2565, 901, '스키마와 인스턴스의 설명이 반대이다', '설명이 반대가 아니다. 스키마는 구조를, 인스턴스는 데이터를 의미하는 것이 맞다.', false),
(2566, 901, '스키마만 올바르고 인스턴스는 틀리다', '둘 다 올바른 설명이다.', false),

-- 문제 903
(2567, 903, '개체 무결성 - 외래 키는 NULL이 아니어야 한다', '개체 무결성은 기본 키에 관한 제약이다. 외래 키는 NULL을 가질 수 있다.', false),
(2568, 903, '참조 무결성 - 기본 키는 유일해야 한다', '기본 키의 유일성은 개체 무결성에 해당한다.', false),
(2569, 903, '도메인 무결성 - 속성 값은 정의된 도메인에 속해야 한다', '도메인 무결성은 속성 값이 정의된 도메인에 속한 값이어야 한다는 제약이다. 데이터 타입, 길이, 형식 등을 만족해야 한다.',
 true),
(2570, 903, '개체 무결성 - 속성 값은 정의된 범위 내여야 한다', '속성 값이 정의된 범위 내여야 한다는 것은 도메인 무결성이다.', false),

-- 문제 904
(2571, 904, '참조 무결성', '참조 무결성은 외래 키 값에 관한 제약이다.', false),
(2572, 904, '도메인 무결성', '도메인 무결성은 속성 값이 정의된 범위에 속해야 한다는 제약이다.', false),
(2573, 904, '개체 무결성', '개체 무결성은 기본 키를 구성하는 속성이 NULL 값을 가질 수 없고 유일해야 한다는 제약이다. 기본 키에 NULL을 삽입하면 개체 무결성이 위반된다.', true),
(2574, 904, '키 무결성', '키 무결성이라는 용어는 일반적으로 사용되지 않는다.', false),

-- 문제 905
(2575, 905, '튜플의 순서는 의미가 없다', '릴레이션에서 튜플의 순서는 의미가 없다. 어떤 순서로 저장되든 동일한 릴레이션이다. 이는 올바른 특징이다.', false),
(2576, 905, '속성의 순서는 의미가 없다', '릴레이션에서 속성의 순서도 의미가 없다. 이는 올바른 특징이다.', false),
(2577, 905, '동일한 튜플이 존재할 수 있다', '릴레이션에서 동일한 튜플은 존재할 수 없다. 각 튜플은 기본 키에 의해 유일하게 식별되어야 한다.', true),
(2578, 905, '각 속성은 원자값만 가진다', '릴레이션의 각 속성은 더 이상 분해할 수 없는 원자값만 가져야 한다. 이는 제1정규형의 조건이기도 하다.', false),

-- 문제 907
(2579, 907, '기본 키에 NULL 값을 삽입하는 경우', '이것은 개체 무결성 위반이다.', false),
(2580, 907, '존재하지 않는 외래 키 값을 삽입하는 경우', '이것은 참조 무결성 위반이다.', false),
(2581, 907, '나이 속성에 음수 값을 삽입하는 경우', '도메인 무결성은 속성 값이 정의된 도메인에 속해야 한다는 제약이다. 나이가 양수로 정의되어 있다면 음수 값은 도메인 무결성을 위반한다.',
 true),
(2582, 907, '동일한 기본 키 값을 중복 삽입하는 경우', '이것은 개체 무결성(유일성) 위반이다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (259, 902, '속성, Attribute', '속성(Attribute)은 릴레이션을 구성하는 각각의 열로, 필드(Field)라고도 한다. 속성은 엔터티의 특성을 나타내며, 각 속성은 고유한 이름과 도메인을 가진다.'),
       (260, 906, '참조, Referential', '참조 무결성(Referential Integrity)은 외래 키 값이 참조하는 테이블의 기본 키 값이거나 NULL이어야 한다는 제약이다. 존재하지 않는 값을 참조할 수 없으며, 이를 통해 테이블 간의 관계 일관성을 보장한다.');

-- =====================================================
-- Chapter 4: 데이터베이스 (ID: 4)
-- Unit 45: 키(Key)
-- =====================================================

-- Lesson 1: 키 1 (ID: 131)
INSERT INTO lesson (id, title, unit_id)
VALUES (131, '키 1', 45);

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (908, 131, '다음 중 키(Key)의 특성에 대한 설명으로 올바른 것은?', '키는 유일성과 최소성이라는 두 가지 특성을 기준으로 분류된다.', 'OBJECTIVE'),
       (909, 131, '빈칸에 들어갈 용어를 작성하시오.', '하나의 키 값으로 하나의 튜플만 식별할 수 있는 성질을 ___이라고 한다.', 'SUBJECTIVE'),
       (910, 131, '다음 설명에 해당하는 키는?', '테이블에서 각 튜플을 유일하게 식별할 수 있는 하나 이상의 속성 집합으로, 유일성만 만족하면 된다.', 'OBJECTIVE'),
       (911, 131, '다음 중 슈퍼키(Super Key)에 대한 설명으로 올바른 것은?', '학번, 이름, 학과로 구성된 학생 테이블이 있다.', 'OBJECTIVE'),
       (912, 131, '빈칸에 들어갈 용어를 작성하시오.', '키를 구성하는 속성 중 하나라도 제거하면 유일하게 식별할 수 없는, 꼭 필요한 최소한의 속성만으로 구성된 성질을 ___이라고 한다.', 'SUBJECTIVE'),
       (913, 131, '다음 중 후보키(Candidate Key)에 대한 설명으로 올바른 것은?', '후보키는 기본키가 될 수 있는 키들이다.', 'OBJECTIVE'),
       (914, 131, '다음 중 {학번, 이름}이 슈퍼키가 될 수 있는 이유로 올바른 것은?', '학번은 학생을 유일하게 식별할 수 있다고 가정한다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES
-- 문제 908
(2583, 908, '유일성은 키 값이 중복되어도 된다는 성질이다', '유일성은 하나의 키 값으로 하나의 튜플만 식별할 수 있는 성질이다. 중복이 허용되지 않는다.', false),
(2584, 908, '최소성은 가능한 많은 속성을 포함해야 한다는 성질이다', '최소성은 꼭 필요한 최소한의 속성만으로 구성되어야 한다는 성질이다.', false),
(2585, 908, '유일성은 하나의 키 값으로 하나의 튜플만 식별할 수 있는 성질이다', '유일성(Uniqueness)은 하나의 키 값으로 하나의 튜플만 식별할 수 있는 성질이다. 동일한 키 값을 가진 튜플이 두 개 이상 존재하면 유일성을 만족하지 않는다.', true),
(2586, 908, '최소성과 유일성은 동일한 의미이다', '유일성과 최소성은 서로 다른 개념이다. 유일성은 식별 가능 여부, 최소성은 속성 구성의 최소화에 관한 것이다.', false),

-- 문제 910
(2587, 910, '후보키(Candidate Key)', '후보키는 유일성과 최소성을 모두 만족해야 한다.', false),
(2588, 910, '기본키(Primary Key)', '기본키는 후보키 중에서 선택된 대표 식별자이다.', false),
(2589, 910, '슈퍼키(Super Key)', '슈퍼키는 테이블에서 각 튜플을 유일하게 식별할 수 있는 하나 이상의 속성 집합이다. 유일성만 만족하면 슈퍼키가 될 수 있으며, 최소성은 요구되지 않는다.',
 true),
(2590, 910, '대체키(Alternate Key)', '대체키는 후보키 중에서 기본키로 선택되지 않은 나머지 키이다.', false),

-- 문제 911
(2591, 911, '{이름}은 슈퍼키이다', '이름은 동명이인이 존재할 수 있어 유일성을 만족하지 않으므로 슈퍼키가 아니다.', false),
(2592, 911, '{학번, 이름}은 최소성을 만족한다', '{학번}만으로도 유일하게 식별 가능하므로 {학번, 이름}은 최소성을 만족하지 않는다.', false),
(2593, 911, '{학번, 이름, 학과}는 슈퍼키이다', '{학번}이 유일성을 만족하므로 {학번, 이름, 학과}도 유일성을 만족한다. 슈퍼키는 유일성만 만족하면 되므로 이는 슈퍼키이다.', true),
(2594, 911, '{학과}는 슈퍼키이다', '같은 학과에 여러 학생이 있을 수 있으므로 {학과}는 유일성을 만족하지 않는다.', false),

-- 문제 913
(2595, 913, '유일성만 만족하면 후보키가 될 수 있다', '후보키는 유일성과 최소성을 모두 만족해야 한다.', false),
(2596, 913, '테이블에 하나만 존재할 수 있다', '후보키는 하나의 테이블에 여러 개가 존재할 수 있다.', false),
(2597, 913, '슈퍼키 중에서 유일성과 최소성을 모두 만족하는 키이다', '후보키는 슈퍼키 중에서 유일성과 최소성을 모두 만족하는 속성 집합이다. 기본키가 될 수 있는 후보들이다.', true),
(2598, 913, '기본키로 선택되지 않은 키만을 의미한다', '기본키로 선택되지 않은 키는 대체키이다. 후보키는 기본키가 될 수 있는 모든 키를 포함한다.', false),

-- 문제 914
(2599, 914, '이름이 유일성을 만족하기 때문이다', '이름은 동명이인이 존재할 수 있어 단독으로는 유일성을 만족하지 않는다.', false),
(2600, 914, '학번이 유일성을 만족하므로 학번을 포함한 집합도 유일성을 만족한다', '학번이 유일하게 식별 가능하면, 학번을 포함하는 모든 속성 집합도 유일성을 만족한다. 슈퍼키는 유일성만 요구하므로 {학번, 이름}은 슈퍼키가 된다.', true),
(2601, 914, '두 개의 속성을 조합했기 때문이다', '단순히 속성을 조합한다고 슈퍼키가 되는 것이 아니다. 유일성을 만족해야 한다.', false),
(2602, 914, '최소성을 만족하기 때문이다', '슈퍼키는 최소성을 요구하지 않는다. {학번, 이름}은 최소성을 만족하지 않지만 유일성을 만족하므로 슈퍼키이다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (261, 909, '유일성, Uniqueness', '유일성(Uniqueness)은 하나의 키 값으로 하나의 튜플만 식별할 수 있는 성질이다. 동일한 키 값을 가진 튜플이 두 개 이상 존재하면 유일성을 만족하지 않는다.'),
       (262, 912, '최소성, Minimality', '최소성(Minimality)은 키를 구성하는 속성 중 하나라도 제거하면 유일하게 식별할 수 없는, 꼭 필요한 최소한의 속성만으로 구성된 성질이다.');

-- Lesson 2: 키 2 (ID: 132)
INSERT INTO lesson (id, title, unit_id)
VALUES (132, '키 2', 45);

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (915, 132, '다음 중 기본키(Primary Key)의 제약 조건으로 올바른 것은?', '기본키는 테이블의 대표 식별자이다.', 'OBJECTIVE'),
       (916, 132, '빈칸에 들어갈 용어를 작성하시오.', '후보키 중에서 기본키로 선택되지 않은 나머지 키를 ___라고 한다.', 'SUBJECTIVE'),
       (917, 132, '다음 상황에서 기본키와 대체키를 올바르게 구분한 것은?', '학생 테이블에서 후보키가 {학번}, {주민등록번호} 이고, {학번} 을 기본키로 선택했다.', 'OBJECTIVE'),
       (918, 132, ' 다음 중 복합키(Composite Key) 에 대한 설명으로 올바른 것은 ? ', ' 복합키는 특정 조건에서 사용되는 키이다.', 'OBJECTIVE'),
       (919, 132, ' 빈칸에 들어갈 용어를 작성하시오.', ' 현실 세계의 의미와 무관하게 시스템에서 인위적으로 생성한 키를 ___라고 한다.', 'SUBJECTIVE'),
       (920, 132, ' 다음 중 자연키(Natural Key) 의 예시로 올바른 것은 ? ', ' 자연키는 현실 세계에서 고유한 의미를 가진 속성으로 구성된다.', 'OBJECTIVE'),
       (921, 132, ' 다음 중 대리키(Surrogate Key) 를 사용하는 이유로 올바른 것은 ? ', ' 대리키는 시스템에서 인위적으로 생성한 키이다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES
-- 문제 915
(2603, 915, ' NULL 값을 가질 수 있다 ', ' 기본키는 NOT NULL 제약이 적용되어 NULL 값을 가질 수 없다.', false),
(2604, 915, ' 중복된 값을 가질 수 있다 ', ' 기본키는 UNIQUE 제약이 적용되어 중복된 값을 가질 수 없다.', false),
(2605, 915, ' NOT NULL과 UNIQUE 제약이 적용된다 ', ' 기본키는 NOT NULL (NULL 값 불가) 과 UNIQUE (중복 값 불가) 제약이 모두 적용된다.', true),
(2606, 915, ' 테이블당 여러 개를 지정할 수 있다 ', ' 기본키는 테이블당 하나만 지정할 수 있다.', false),

-- 문제 917
(2607, 917, ' 기본키 : {주민등록번호}, 대체키: {학번}', '기본키로 {학번}을 선택했으므로 {학번}이 기본키이다.', false),
(2608, 917, '기본키: {학번}, 대체키: {주민등록번호}', '기본키로 {학번}을 선택했으므로 {학번}이 기본키이고, 선택되지 않은 {주민등록번호}가 대체키이다.', true),
(2609, 917, '기본키: {학번, 주민등록번호}, 대체키: 없음', '기본키는 후보키 중 하나를 선택하는 것이지, 모든 후보키를 합치는 것이 아니다.', false),
(2610, 917, '기본키: 없음, 대체키: {학번}, {주민등록번호} ', ' 후보키가 존재하면 반드시 기본키를 선택해야 한다.', false),

-- 문제 918
(2611, 918, ' 시스템에서 자동으로 생성되는 키이다 ', ' 시스템에서 자동으로 생성되는 키는 대리키(Surrogate Key) 이다.', false),
(2612, 918, ' 두 개 이상의 속성을 결합하여 구성된 키이다 ', ' 복합키(Composite Key) 는 두 개 이상의 속성을 결합하여 구성된 키이다.단일 속성으로는 유일성을 만족하지 못할 때 사용한다.',
 true),
(2613, 918, ' 후보키 중에서 선택되지 않은 키이다 ', ' 후보키 중에서 선택되지 않은 키는 대체키(Alternate Key) 이다.', false),
(2614, 918, ' 현실 세계에서 고유한 의미를 가진 키이다 ', ' 현실 세계에서 고유한 의미를 가진 키는 자연키(Natural Key) 이다.', false),

-- 문제 920
(2615, 920, ' AUTO_INCREMENT로 생성된 id ', ' AUTO_INCREMENT로 생성된 id는 시스템에서 인위적으로 생성한 대리키이다.', false),
(2616, 920, ' 주민등록번호 ', ' 주민등록번호는 현실 세계에서 개인을 고유하게 식별하는 의미를 가진 자연키이다.', true),
(2617, 920, ' UUID로 생성된 식별자 ', ' UUID로 생성된 식별자는 시스템에서 인위적으로 생성한 대리키이다.', false),
(2618, 920, ' 시퀀스로 생성된 번호 ', ' 시퀀스로 생성된 번호는 시스템에서 인위적으로 생성한 대리키이다.', false),

-- 문제 921
(2619, 921, ' 현실 세계의 의미를 반영하기 위해 ', ' 현실 세계의 의미를 반영하는 것은 자연키의 특징이다.', false),
(2620, 921, ' 자연키가 변경되거나 없을 때 안정적인 식별자가 필요하기 때문이다 ', ' 대리키는 자연키가 변경될 가능성이 있거나 적절한 자연키가 없을 때 사용한다.시스템에서 생성하므로 변경 가능성이 없고 안정적이다.', true),
(2621, 921, ' 데이터베이스 용량을 줄이기 위해 ', ' 대리키가 반드시 용량을 줄이는 것은 아니다.오히려 추가 컬럼이 필요할 수 있다.', false),
(2622, 921, ' 복합키를 사용하지 않기 위해 ', ' 복합키 대신 대리키를 사용할 수 있지만, 이것이 대리키의 주된 사용 이유는 아니다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (263, 916, '대체키, Alternate Key', '대체키(Alternate Key)는 후보키 중에서 기본키로 선택되지 않은 나머지 키이다. 기본키와 동일하게 유일성과 최소성을 만족하며, 필요시 기본키를 대체할 수 있다.'),
       (264, 919, '대리키, Surrogate Key', '대리키(Surrogate Key)는 현실 세계의 의미와 무관하게 시스템에서 인위적으로 생성한 키이다. 일반적으로 AUTO_INCREMENT 정수나 UUID 등을 사용한다.');

-- Lesson 3: 키 3 (ID: 133)
INSERT INTO lesson (id, title, unit_id)
VALUES (133, '키 3', 45);

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (922, 133, '다음 중 수강 테이블에서 복합 기본키로 적절한 것은?', '수강 테이블은 학번, 과목코드, 성적으로 구성되어 있다. 한 학생이 여러 과목을 수강할 수 있고, 한 과목을 여러 학생이 수강할 수 있다.', 'OBJECTIVE'),
       (923, 133, '빈칸에 들어갈 내용을 작성하시오.', '슈퍼키 중에서 ___과 ___을 모두 만족하는 키를 후보키라고 한다.', 'SUBJECTIVE'),
       (924, 133, '다음 설명이 올바른지 판단하시오.', '{학번}이 후보키이면 {학번, 이름}도 후보키이다.', 'OBJECTIVE'),
       (925, 133, '다음 중 키의 포함 관계로 올바른 것은?', '키는 유일성과 최소성에 따라 분류된다.', 'OBJECTIVE'),
       (926, 133, '다음 상황에서 후보키의 개수는?', '학생 테이블에 학번, 주민등록번호, 이메일이 있다. 학번, 주민등록번호, 이메일 모두 학생을 유일하게 식별할 수 있다.', 'OBJECTIVE'),
       (927, 133, '빈칸에 들어갈 용어를 작성하시오.', '___키는 유일성만 만족하면 되고, ___키는 유일성과 최소성을 모두 만족해야 한다.', 'SUBJECTIVE'),
       (928, 133, '다음 중 기본키 선택 시 고려사항으로 올바르지 않은 것은?', '기본키는 테이블의 대표 식별자로 신중하게 선택해야 한다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES
-- 문제 922
(2623, 922, '{학번}', '학번만으로는 한 학생이 여러 과목을 수강하는 경우를 구분할 수 없다.', false),
(2624, 922, '{과목코드}', '과목코드만으로는 한 과목을 여러 학생이 수강하는 경우를 구분할 수 없다.', false),
(2625, 922, '{학번, 과목코드}', '한 학생이 같은 과목을 중복 수강하지 않는다면, {학번, 과목코드}의 조합으로 각 수강 기록을 유일하게 식별할 수 있다.', true),
(2626, 922, '{성적}', '성적은 중복될 수 있으므로 유일하게 식별할 수 없다.', false),

-- 문제 924
(2627, 924, '올바르다', '{학번}이 후보키이면 이미 최소성을 만족한다. {학번, 이름}은 불필요한 속성이 추가되어 최소성을 만족하지 않으므로 후보키가 아니다.', false),
(2628, 924, '올바르지 않다', '후보키는 유일성과 최소성을 모두 만족해야 한다. {학번}이 후보키이면 {학번, 이름}은 최소성을 만족하지 않으므로 후보키가 아니라 슈퍼키이다.', true),
(2629, 924, '{학번, 이름}이 더 좋은 후보키이다', '더 많은 속성을 포함한다고 더 좋은 후보키가 되는 것이 아니다. 최소성을 만족해야 후보키이다.', false),
(2630, 924, '상황에 따라 다르다', '최소성의 정의에 따라 명확하게 판단할 수 있다. {학번, 이름}은 후보키가 아니다.', false),

-- 문제 925
(2631, 925, '후보키 ⊂ 슈퍼키 ⊂ 기본키', '기본키는 후보키 중 하나이므로 후보키에 포함된다.', false),
(2632, 925, '기본키 ⊂ 후보키 ⊂ 슈퍼키', '기본키는 후보키 중 선택된 하나이고, 후보키는 슈퍼키 중 최소성을 만족하는 것이다. 따라서 기본키 ⊂ 후보키 ⊂ 슈퍼키가 올바른 포함 관계이다.',
 true),
(2633, 925, '슈퍼키 ⊂ 후보키 ⊂ 기본키', '슈퍼키가 가장 넓은 범위이고, 기본키가 가장 좁은 범위이다.', false),
(2634, 925, '슈퍼키 = 후보키 = 기본키', '세 키는 서로 다른 조건을 가지며 동일하지 않다.', false),

-- 문제 926
(2635, 926, '1개', '학번, 주민등록번호, 이메일 모두 유일성과 최소성을 만족하므로 각각 후보키가 된다.', false),
(2636, 926, '2개', '세 속성 모두 단독으로 유일성과 최소성을 만족하므로 3개의 후보키가 존재한다.', false),
(2637, 926, '3개', '학번, 주민등록번호, 이메일 각각이 단독으로 학생을 유일하게 식별할 수 있고 최소성을 만족하므로, 후보키는 {학번}, {주민등록번호}, {이메일} 총 3개이다.', true),
(2638, 926, ' 0개 ', ' 유일하게 식별 가능한 속성이 있으므로 후보키가 존재한다.', false),

-- 문제 928
(2639, 928, ' NULL 값을 허용하지 않는 속성을 선택한다 ', ' 기본키는 NOT NULL 제약이 있으므로 NULL 값을 허용하지 않는 속성을 선택해야 한다.이는 올바른 고려사항이다.', false),
(2640, 928, ' 값이 자주 변경되는 속성을 선택한다 ', ' 기본키는 값이 자주 변경되지 않는 안정적인 속성을 선택해야 한다.기본키가 변경되면 참조하는 외래키도 모두 변경해야 하므로 비효율적이다.',
 true),
(2641, 928, ' 유일성을 만족하는 속성을 선택한다 ', ' 기본키는 UNIQUE 제약이 있으므로 유일성을 만족하는 속성을 선택해야 한다.이는 올바른 고려사항이다.', false),
(2642, 928, ' 가능한 단순한 속성을 선택한다 ', ' 기본키는 가능한 단순한(적은 수의 속성으로 구성된) 속성을 선택하는 것이 효율적이다.이는 올바른 고려사항이다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (265, 923, ' 유일성, 최소성', '후보키는 슈퍼키 중에서 유일성(Uniqueness)과 최소성(Minimality)을 모두 만족하는 키이다. 유일성은 하나의 키 값으로 하나의 튜플만 식별할 수 있는 성질이고, 최소성은 꼭 필요한 최소한의 속성만으로 구성된 성질이다.'),
       (266, 927, '슈퍼, 후보', '슈퍼키(Super Key)는 유일성만 만족하면 되고, 후보키(Candidate Key)는 유일성과 최소성을 모두 만족해야 한다. 후보키는 슈퍼키의 부분집합이다.');

-- =====================================================
-- Chapter 4: 데이터베이스 (ID: 4)
-- Unit 46: 외래키와 제약 조건
-- =====================================================

-- Lesson 1: 외래키와 제약 조건 1 (ID: 134)
INSERT INTO lesson (id, title, unit_id)
VALUES (134, '외래키와 제약 조건 1', 46);

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (929, 134, '다음 중 외래키(Foreign Key)에 대한 설명으로 올바른 것은?', '외래키는 테이블 간의 관계를 정의하는 키이다.', 'OBJECTIVE'),
       (930, 134, '빈칸에 들어갈 용어를 작성하시오.', '외래키는 다른 테이블의 기본키 또는 고유키를 참조하여 ___을 보장한다.', 'SUBJECTIVE'),
       (931, 134, '다음 중 외래키의 특성으로 올바른 것은?', '외래키는 테이블 간 관계를 표현한다.', 'OBJECTIVE'),
       (932, 134, '다음 상황에서 발생하는 오류의 원인은?', '부서 테이블에 부서ID ''999''가 존재하지 않는데, 사원 테이블에 부서ID ''999''를 가진 사원을 삽입하려고 한다.', 'OBJECTIVE'),
       (933, 134, '빈칸에 들어갈 용어를 작성하시오.', '외래키 값이 참조하는 부모 테이블에 존재하지 않으면 삽입이나 수정이 제한되는 것을 ___ 제약이라고 한다.', 'SUBJECTIVE'),
       (934, 134, '다음 중 외래키에 대한 설명으로 올바르지 않은 것은?', '외래키는 참조 무결성을 보장하기 위해 사용된다.', 'OBJECTIVE'),
       (935, 134, '다음 상황에서 삭제가 실패하는 이유는?', '부서 테이블에서 부서ID ''10''을 삭제하려 하는데, 사원 테이블에 부서ID ''10''을 참조하는 사원이 존재한다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES
-- 문제 929
(2643, 929, '자신의 테이블 내에서만 사용된다', '외래키는 다른 테이블의 기본키 또는 고유키를 참조하여 테이블 간 관계를 정의한다.', false),
(2644, 929, '다른 테이블의 기본키 또는 고유키를 참조한다', '외래키(Foreign Key)는 다른 테이블의 기본키(PK) 또는 고유키(Unique Key)를 참조하는 속성 또는 속성들의 집합이다. 테이블 간의 관계를 표현할 때 사용한다.', true),
(2645, 929, '반드시 기본키여야 한다', '외래키는 기본키가 아니며, 다른 테이블의 기본키를 참조하는 것이다.', false),
(2646, 929, '중복된 값을 가질 수 없다', '외래키는 중복된 값을 가질 수 있다. 예를 들어 여러 사원이 같은 부서에 속할 수 있다.', false),

-- 문제 931
(2647, 931, 'NULL 값을 가질 수 없다', '외래키는 NULL 값을 가질 수 있다. 참조 관계가 없는 경우 NULL이 허용된다.', false),
(2648, 931, '하나의 테이블에 하나만 존재할 수 있다', '하나의 테이블에 여러 개의 외래키가 존재할 수 있다.', false),
(2649, 931, '참조되는 부모 테이블의 기본키 또는 고유키 값만 가질 수 있다', '외래키는 참조하는 부모 테이블의 기본키 또는 고유키에 존재하는 값이거나 NULL만 가질 수 있다. 이를 통해 참조 무결성이 보장된다.', true),
(2650, 931, '반드시 단일 속성으로 구성되어야 한다', '외래키는 복합 속성으로 구성될 수 있다. 부모 테이블의 복합 기본키를 참조할 수 있다.', false),

-- 문제 932
(2651, 932, '기본키 제약 위반', '기본키 제약은 해당 테이블 내에서 NULL 불가와 유일성에 관한 것이다.', false),
(2652, 932, '외래키 제약 위반', '외래키가 참조하는 부모 테이블에 해당 값이 존재하지 않으면 외래키 제약 위반이 발생한다. 부서ID ''999''가 부서 테이블에 없으므로 삽입이 실패한다.',
 true),
(2653, 932, 'NOT NULL 제약 위반', 'NOT NULL 제약은 NULL 값 삽입 시 발생한다. 이 경우는 ''999''라는 값이 있으므로 해당되지 않는다.', false),
(2654, 932, 'UNIQUE 제약 위반', 'UNIQUE 제약은 중복된 값 삽입 시 발생한다.', false),

-- 문제 934
(2655, 934, '하나의 테이블에 여러 개의 외래키가 존재할 수 있다', '하나의 테이블에 여러 개의 외래키가 존재할 수 있다. 예를 들어 주문 테이블이 고객과 상품을 모두 참조할 수 있다. 이는 올바른 설명이다.', false),
(2656, 934, 'NULL 값을 가질 수 있다', '외래키는 참조 관계가 없는 경우 NULL 값을 가질 수 있다. 이는 올바른 설명이다.', false),
(2657, 934, '참조되는 부모 테이블의 기본키 값만 가질 수 있다', '외래키는 부모 테이블의 기본키뿐만 아니라 고유키(Unique Key)도 참조할 수 있다.', true),
(2658, 934, '테이블 간의 관계를 표현한다', '외래키는 테이블 간의 관계를 정의하고 참조 무결성을 보장한다. 이는 올바른 설명이다.', false),

-- 문제 935
(2659, 935, '기본키 제약 때문에', '기본키 제약은 삭제와 직접적인 관련이 없다.', false),
(2660, 935, '외래키가 해당 값을 참조하고 있기 때문에', '부모 테이블의 행을 삭제하려면 해당 행을 참조하는 자식 테이블의 행이 없어야 한다. 사원이 부서ID ''10''을 참조하고 있으므로 삭제가 제한된다.', true),
(2661, 935, 'NOT NULL 제약 때문에', 'NOT NULL 제약은 NULL 값에 관한 것으로 삭제와 직접적인 관련이 없다.', false),
(2662, 935, 'UNIQUE 제약 때문에', 'UNIQUE 제약은 중복에 관한 것으로 삭제와 직접적인 관련이 없다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (267, 930, '참조 무결성, Referential Integrity', '외래키는 다른 테이블의 기본키 또는 고유키를 참조하여 참조 무결성(Referential Integrity)을 보장한다. 참조 무결성은 외래키 값이 참조하는 테이블의 기본키 값이거나 NULL이어야 함을 의미한다.'),
       (268, 933, '외래키, FK, Foreign Key ', ' 외래키 제약은 자식 테이블의 외래키 값이 부모 테이블에 존재하지 않으면 삽입이나 수정을 제한한다.이를 통해 참조 무결성이 보장된다.');

-- Lesson 2: 외래키와 제약 조건 2 (ID: 135)
INSERT INTO lesson (id, title, unit_id)
VALUES (135, '외래키와 제약 조건 2', 46);

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (936, 135, ' 다음 중 참조 동작 옵션 CASCADE에 대한 설명으로 올바른 것은 ? ', ' 참조 동작 옵션은 부모 테이블의 데이터가 삭제되거나 수정될 때 자식 테이블의 처리 방식을 지정한다
        .', 'OBJECTIVE'),
       (937, 135, ' 빈칸에 들어갈 참조 동작 옵션을 작성하시오.', ' 부모 삭제 시 자식의 외래키를 NULL로 설정하는 옵션은 ___이다.', 'SUBJECTIVE'),
       (938, 135, ' 다음 중 RESTRICT 옵션에 대한 설명으로 올바른 것은 ? ', ' RESTRICT는 참조 동작 옵션 중 하나이다.', 'OBJECTIVE'),
       (939, 135, ' 다음 SQL에서 ON DELETE CASCADE의 의미는 ? ', ' FOREIGN KEY (department_id) REFERENCES departments(department_id) ON DELETE CASCADE ', 'OBJECTIVE'),
       (940, 135, ' 빈칸에 들어갈 참조 동작 옵션을 작성하시오.', ' 부모 삭제 시 자식의 외래키를 기본값으로 설정하는 옵션은 ___이다.', 'SUBJECTIVE'),
       (941, 135, ' 다음 상황에서 적절한 참조 동작 옵션은 ? ', ' 회원이 탈퇴하면 해당 회원의 모든 주문 기록도 함께 삭제되어야 한다.', 'OBJECTIVE'),
       (942, 135, ' 다음 중 NO ACTION 옵션에 대한 설명으로 올바른 것은 ? ', ' NO ACTION은 참조 동작 옵션 중 하나이다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES
-- 문제 936
(2663, 936, ' 자식이 참조 중이면 부모 삭제 / 수정이 불가하다 ', ' 이것은 RESTRICT 옵션의 설명이다.', false),
(2664, 936, ' 부모 삭제 / 수정 시 자식의 외래키를 NULL로 설정한다 ', ' 이것은 SET NULL 옵션의 설명이다.', false),
(2665, 936, ' 부모 삭제 / 수정 시 자식도 함께 삭제 / 수정된다 ', ' CASCADE 옵션은 부모 테이블의 데이터가 삭제되거나 수정될 때 자식 테이블의 해당 데이터도 함께 삭제되거나 수정된다.', true),
(2666, 936, ' 부모 삭제 / 수정 시 자식의 외래키를 기본값으로 설정한다 ', ' 이것은 SET DEFAULT 옵션의 설명이다.', false),

-- 문제 938
(2667, 938, ' 부모 삭제 시 자식도 함께 삭제된다 ', ' 이것은 CASCADE 옵션의 설명이다.', false),
(2668, 938, ' 부모 삭제 시 자식의 외래키를 NULL로 설정한다 ', ' 이것은 SET NULL 옵션의 설명이다.', false),
(2669, 938, ' 자식이 참조 중이면 부모 삭제 / 수정이 불가하다 ', ' RESTRICT 옵션은 자식 테이블이 부모 테이블의 데이터를 참조하고 있으면 부모의 삭제나 수정을 허용하지 않는다.', true),
(2670, 938, ' 부모 삭제 시 아무 동작도 하지 않는다 ', ' RESTRICT는 삭제 / 수정을 차단한다.아무 동작도 하지 않는 것이 아니다.', false),

-- 문제 939
(2671, 939, ' departments 테이블의 행이 삭제되면 해당 행을 참조하는 자식 행의 외래키가 NULL이 된다 ', ' 이것은 ON DELETE SET NULL의 동작이다.', false),
(2672, 939, ' departments 테이블의 행이 삭제되면 해당 행을 참조하는 자식 행도 함께 삭제된다 ', ' ON DELETE CASCADE는 부모 테이블의 행이 삭제될 때 해당 행을 참조하는 자식 테이블의 행도 자동으로 삭제된다.', true),
(2673, 939, ' departments 테이블의 행이 삭제되면 삭제가 차단된다 ', ' 이것은 ON DELETE RESTRICT의 동작이다.', false),
(2674, 939, ' departments 테이블의 행 삭제와 관계없이 동작한다 ', ' ON DELETE는 부모 테이블의 삭제 시 동작을 정의한다.', false),

-- 문제 941
(2675, 941, ' SET NULL ', ' SET NULL은 외래키를 NULL로 설정하므로 주문 기록이 남아있게 된다.', false),
(2676, 941, ' RESTRICT ', ' RESTRICT는 삭제를 차단하므로 회원 탈퇴가 불가능해진다.', false),
(2677, 941, ' CASCADE ', ' 회원 탈퇴 시 모든 주문 기록도 함께 삭제되어야 하므로 CASCADE가 적절하다.부모(회원) 삭제 시 자식(주문) 도 함께 삭제된다.', true),
(2678, 941, ' SET DEFAULT ', ' SET DEFAULT는 외래키를 기본값으로 설정하므로 주문 기록이 남아있게 된다.', false),

-- 문제 942
(2679, 942, ' RESTRICT와 동일하게 동작한다 ', ' NO ACTION은 RESTRICT와 동일하게 자식이 참조 중이면 부모의 삭제 / 수정을 허용하지 않는다.', true),
(2680, 942, ' CASCADE와 동일하게 동작한다 ', ' NO ACTION은 자동 삭제 / 수정을 수행하지 않는다.', false),
(2681, 942, ' SET NULL과 동일하게 동작한다 ', ' NO ACTION은 외래키를 NULL로 설정하지 않는다.', false),
(2682, 942, ' 아무런 제약 없이 삭제 / 수정을 허용한다 ', ' NO ACTION도 참조 무결성을 검사하며, 위반 시 작업을 차단한다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (269, 937, 'SET NULL', 'SET NULL 옵션은 부모 테이블의 데이터가 삭제되거나 수정될 때 자식 테이블의 외래키 값을 NULL로 설정한다. 외래키 컬럼이 NULL을 허용해야 사용할 수 있다.'),
       (270, 940, 'SET DEFAULT', 'SET DEFAULT 옵션은 부모 테이블의 데이터가 삭제되거나 수정될 때 자식 테이블의 외래키 값을 기본값(DEFAULT)으로 설정한다.');

-- Lesson 3: 외래키와 제약 조건 3 (ID: 136)
INSERT INTO lesson (id, title, unit_id)
VALUES (136, '외래키와 제약 조건 3', 46);

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (943, 136, '다음 중 NOT NULL 제약에 대한 설명으로 올바른 것은?', 'NOT NULL은 일반 제약 조건 중 하나이다.', 'OBJECTIVE'),
       (944, 136, '빈칸에 들어갈 제약 조건을 작성하시오.', '해당 속성의 값이 고유(중복 불가능)해야 함을 보장하는 제약 조건은 ___이다.', 'SUBJECTIVE'),
       (945, 136, '다음 중 CHECK 제약에 대한 설명으로 올바른 것은?', 'CHECK는 특정 조건을 검사하는 제약 조건이다.', 'OBJECTIVE'),
       (946, 136, '다음 SQL의 DEFAULT 제약의 의미는?', 'CREATE TABLE products (id INT PRIMARY KEY, stock INT DEFAULT 0);
', 'OBJECTIVE'),
       (947, 136, '빈칸에 들어갈 내용을 작성하시오.', 'UNIQUE 제약이 적용된 컬럼은 중복된 값을 가질 수 없지만, ___ 값은 가질 수 있다.', 'SUBJECTIVE'),
       (948, 136, '다음 중 CHECK 제약의 올바른 사용 예시는?', 'CHECK 제약은 속성 값이 특정 조건을 만족해야 한다.', 'OBJECTIVE'),
       (949, 136, '다음 중 UNIQUE 제약과 기본키의 차이점으로 올바른 것은?', '둘 다 중복을 허용하지 않는다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES
-- 문제 943
(2683, 943, '해당 속성의 값이 중복되면 안 된다', '이것은 UNIQUE 제약의 설명이다.', false),
(2684, 943, '해당 속성에 NULL 값을 허용하지 않는다', 'NOT NULL 제약은 해당 속성에 NULL 값을 허용하지 않는다. 반드시 값이 존재해야 한다.', true),
(2685, 943, '해당 속성의 값이 특정 조건을 만족해야 한다', '이것은 CHECK 제약의 설명이다.', false),
(2686, 943, '값이 지정되지 않으면 기본값을 설정한다', '이것은 DEFAULT 제약의 설명이다.', false),

-- 문제 945
(2687, 945, '해당 속성에 NULL 값을 허용하지 않는다', '이것은 NOT NULL 제약의 설명이다.', false),
(2688, 945, '해당 속성의 값이 고유해야 한다', '이것은 UNIQUE 제약의 설명이다.', false),
(2689, 945, '해당 속성의 값이 특정 조건을 만족해야 한다', 'CHECK 제약은 해당 속성의 값이 특정 조건을 만족해야 함을 정의한다. 예를 들어 price > 0과 같은 조건을 지정할 수 있다.',
 true),
(2690, 945, '값이 지정되지 않으면 기본값을 설정한다', '이것은 DEFAULT 제약의 설명이다.', false),

-- 문제 946
(2691, 946, 'stock 컬럼에 NULL을 허용하지 않는다', '이것은 NOT NULL 제약의 동작이다.', false),
(2692, 946, 'stock 컬럼에 중복 값을 허용하지 않는다', '이것은 UNIQUE 제약의 동작이다.', false),
(2693, 946, 'stock 값이 지정되지 않으면 0으로 설정된다', 'DEFAULT 제약은 INSERT 시 해당 컬럼의 값이 지정되지 않으면 기본값을 자동으로 설정한다. 여기서는 0이 기본값이다.',
 true),
(2694, 946, 'stock 값이 0보다 커야 한다', '이것은 CHECK 제약의 동작이다.', false),

-- 문제 948
(2695, 948, 'CHECK (name IS NOT NULL)', 'NULL 검사는 NOT NULL 제약을 사용하는 것이 일반적이다.', false),
(2696, 948, 'CHECK (email UNIQUE)', 'UNIQUE는 별도의 제약 조건이며 CHECK 내에서 사용하지 않는다.', false),
(2697, 948, 'CHECK (price > 0)', 'CHECK 제약은 속성 값이 특정 조건을 만족해야 함을 정의한다. price > 0은 가격이 양수여야 한다는 조건이다.', true),
(2698, 948, 'CHECK (id = PRIMARY KEY)', 'PRIMARY KEY는 별도의 제약 조건이며 CHECK 내에서 사용하지 않는다.', false),

-- 문제 949
(2699, 949, 'UNIQUE는 NULL 값을 허용하고, 기본키는 NULL 값을 허용하지 않는다', 'UNIQUE 제약이 적용된 컬럼은 NULL 값을 가질 수 있지만, 기본키는 NOT NULL 제약이 함께 적용되어 NULL 값을 가질 수 없다.', true),
(2700, 949, 'UNIQUE는 테이블에 여러 개 지정할 수 없다', 'UNIQUE 제약은 테이블에 여러 개 지정할 수 있다.', false),
(2701, 949, '기본키는 중복 값을 허용한다', '기본키도 UNIQUE 제약이 적용되어 중복 값을 허용하지 않는다.', false),
(2702, 949, 'UNIQUE와 기본키는 동일하다', 'UNIQUE는 NULL을 허용하고 여러 개 지정 가능하지만, 기본키는 NULL 불가하고 테이블당 하나만 지정 가능하다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (271, 944, 'UNIQUE', 'UNIQUE 제약은 해당 속성의 값이 고유(중복 불가능)해야 함을 보장하는 제약 조건이다. 기본키와 달리 NULL 값은 허용된다.'),
       (272, 947, 'NULL, 널', 'UNIQUE 제약이 적용된 컬럼은 중복된 값을 가질 수 없지만, NULL 값은 가질 수 있다. 이것이 기본키와의 주요 차이점이다. 기본키는 NOT NULL과 UNIQUE가 모두 적용된다.');

-- =====================================================
-- Chapter 4: 데이터베이스 (ID: 4)
-- Unit 47: DDL(Data Definition Language)
-- =====================================================

-- Lesson 1: DDL 1 (ID: 137)
INSERT INTO lesson (id, title, unit_id)
VALUES (137, 'DDL 1', 47);

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (950, 137, '다음 중 DDL(Data Definition Language)에 대한 설명으로 올바른 것은?', 'DDL은 SQL의 한 종류이다.', 'OBJECTIVE'),
       (951, 137, '빈칸에 들어갈 DDL 명령어를 작성하시오.', '데이터베이스, 테이블 등 객체를 생성하는 명령어는 ___이다.', 'SUBJECTIVE'),
       (952, 137, '다음 중 DDL 명령어가 아닌 것은?', 'DDL은 데이터베이스 구조를 정의하는 언어이다.', 'OBJECTIVE'),
       (953, 137, '다음 SQL 명령어의 역할은?', 'CREATE DATABASE school; ', 'OBJECTIVE'),
       (954, 137, '빈칸에 들어갈 DDL 명령어를 작성하시오.', '테이블의 구조를 수정하는 명령어는 ___이다.', 'SUBJECTIVE'),
       (955, 137, '다음 중 DROP 명령어에 대한 설명으로 올바른 것은?', 'DROP은 DDL 명령어 중 하나이다.', 'OBJECTIVE'),
       (956, 137, '다음 중 TRUNCATE와 DROP의 차이점으로 올바른 것은?', 'TRUNCATE와 DROP은 모두 DDL 명령어이다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES
-- 문제 950
(2703, 950, '데이터를 조회하고 조작하는 언어이다', '이것은 DML(Data Manipulation Language)의 설명이다.', false),
(2704, 950, '데이터베이스의 구조를 정의하는 언어이다', 'DDL(Data Definition Language)은 데이터베이스의 구조를 정의하는 언어이다. 테이블, 인덱스, 스키마 등 데이터베이스 객체를 생성, 수정, 삭제하는 역할을 한다.', true),
(2705, 950, '트랜잭션을 제어하는 언어이다', '이것은 TCL(Transaction Control Language)의 설명이다.', false),
(2706, 950, '사용자 권한을 관리하는 언어이다', '이것은 DCL(Data Control Language)의 설명이다.', false),

-- 문제 952
(2707, 952, 'CREATE', 'CREATE는 객체를 생성하는 DDL 명령어이다.', false),
(2708, 952, 'ALTER', 'ALTER는 테이블 구조를 수정하는 DDL 명령어이다.', false),
(2709, 952, 'SELECT', 'SELECT는 데이터를 조회하는 DML 명령어이다. DDL이 아니다.', true),
(2710, 952, 'DROP', 'DROP은 객체를 삭제하는 DDL 명령어이다.', false),

-- 문제 953
(2711, 953, '테이블을 생성한다', 'CREATE TABLE이 테이블을 생성한다.', false),
(2712, 953, 'school이라는 이름의 데이터베이스를 생성한다', 'CREATE DATABASE는 새로운 데이터베이스를 생성하는 명령어이다. school이라는 이름의 데이터베이스가 생성된다.', true),
(2713, 953, '데이터베이스를 삭제한다', 'DROP DATABASE가 데이터베이스를 삭제한다.', false),
(2714, 953, '데이터베이스 구조를 수정한다', 'ALTER DATABASE가 데이터베이스 구조를 수정한다.', false),

-- 문제 955
(2715, 955, '테이블의 데이터만 삭제한다', '이것은 TRUNCATE의 설명이다. DROP은 테이블 자체를 삭제한다.', false),
(2716, 955, '테이블의 구조를 수정한다', '이것은 ALTER의 설명이다.', false),
(2717, 955, '데이터베이스 객체를 삭제한다', 'DROP은 데이터베이스, 테이블 등 객체 자체를 삭제하는 명령어이다. 구조와 데이터가 모두 삭제된다.', true),
(2718, 955, '데이터베이스 객체를 생성한다', '이것은 CREATE의 설명이다.', false),

-- 문제 956
(2719, 956, 'TRUNCATE는 테이블 구조를 유지하고 데이터만 삭제한다', 'TRUNCATE는 테이블의 모든 데이터를 삭제하지만 테이블 구조는 유지한다. DROP은 테이블 자체를 삭제하여 구조도 사라진다.', true),
(2720, 956, 'DROP은 테이블 데이터만 삭제한다', 'DROP은 테이블 자체를 삭제하여 구조와 데이터가 모두 사라진다.', false),
(2721, 956, 'TRUNCATE는 테이블 구조도 함께 삭제한다', 'TRUNCATE는 테이블 구조를 유지한다.', false),
(2722, 956, '두 명령어는 동일하게 동작한다', 'TRUNCATE는 데이터만, DROP은 구조와 데이터 모두를 삭제한다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (273, 951, 'CREATE', 'CREATE는 데이터베이스, 테이블, 인덱스 등 데이터베이스 객체를 생성하는 DDL 명령어이다. CREATE DATABASE, CREATE TABLE 등의 형태로 사용한다.'),
       (274, 954, 'ALTER', 'ALTER는 테이블의 구조를 수정하는 DDL 명령어이다. 컬럼 추가, 수정, 삭제 및 제약 조건 관리 등에 사용한다.');

-- Lesson 2: DDL 2 (ID: 138)
INSERT INTO lesson (id, title, unit_id)
VALUES (138, 'DDL 2', 47);

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (957, 138, '다음 SQL 명령어의 역할은?', 'ALTER TABLE students ADD phone VARCHAR(20);
', 'OBJECTIVE'),
       (958, 138, '빈칸에 들어갈 키워드를 작성하시오.', 'ALTER TABLE students ___ COLUMN phone; -- phone 컬럼 삭제', 'SUBJECTIVE'),
(959, 138, '다음 중 ALTER TABLE 명령어로 수행할 수 없는 것은?', 'ALTER TABLE은 테이블 구조를 수정하는 명령어이다.', 'OBJECTIVE')
,
       (960, 138, '다음 SQL 명령어의 역할은?', 'ALTER TABLE students MODIFY name VARCHAR(100);', 'OBJECTIVE'),
       (961, 138, '빈칸에 들어갈 키워드를 작성하시오.', 'ALTER TABLE students ___ COLUMN name TO full_name; -- 컬럼명 변경', 'SUBJECTIVE'),
       (962, 138, '다음 중 제약 조건을 추가하는 올바른 SQL은?', 'ALTER TABLE을 사용하여 제약 조건을 관리할 수 있다.', 'OBJECTIVE'),
       (963, 138, '다음 SQL 명령어의 역할은?', 'ALTER TABLE students DROP CONSTRAINT uk_email;', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES
-- 문제 957
(2723, 957, 'students 테이블을 삭제한다', 'DROP TABLE이 테이블을 삭제한다.', false),
(2724, 957, 'students 테이블에 phone 컬럼을 추가한다', 'ALTER TABLE ... ADD는 테이블에 새로운 컬럼을 추가하는 명령이다. VARCHAR(20) 타입의 phone 컬럼이 추가된다.', true),
(2725, 957, 'students 테이블의 phone 컬럼을 삭제한다', 'ALTER TABLE ... DROP COLUMN이 컬럼을 삭제한다.', false),
(2726, 957, 'students 테이블의 phone 컬럼을 수정한다', 'ALTER TABLE ... MODIFY가 컬럼을 수정한다.', false),

-- 문제 959
(2727, 959, '컬럼 추가', 'ALTER TABLE ... ADD로 컬럼을 추가할 수 있다.', false),
(2728, 959, '컬럼 삭제', 'ALTER TABLE ... DROP COLUMN으로 컬럼을 삭제할 수 있다.', false),
(2729, 959, '데이터 삽입', '데이터 삽입은 DML의 INSERT 명령어를 사용한다. ALTER TABLE은 구조 수정용이다.', true),
(2730, 959, '제약 조건 추가', 'ALTER TABLE ... ADD CONSTRAINT로 제약 조건을 추가할 수 있다.', false),

-- 문제 960
(2731, 960, 'name 컬럼을 삭제한다', 'DROP COLUMN이 컬럼을 삭제한다.', false),
(2732, 960, 'name 컬럼의 데이터 타입을 VARCHAR(100)으로 변경한다', 'ALTER TABLE ... MODIFY는 기존 컬럼의 속성(데이터 타입, 크기 등)을 수정하는 명령이다.',
 true),
(2733, 960, 'name이라는 새 컬럼을 추가한다', 'ADD가 새 컬럼을 추가한다.', false),
(2734, 960, 'name 컬럼의 이름을 변경한다', 'RENAME COLUMN이 컬럼명을 변경한다.', false),

-- 문제 962
(2735, 962, 'ALTER TABLE students ADD uk_email UNIQUE (email)', '제약 조건 추가 시 ADD CONSTRAINT 키워드를 사용한다.', false),
(2736, 962, 'ALTER TABLE students ADD CONSTRAINT uk_email UNIQUE (email)', 'ADD CONSTRAINT를 사용하여 제약 조건 이름과 함께 제약 조건을 추가한다.', true),
(2737, 962, 'ALTER TABLE students CREATE CONSTRAINT uk_email UNIQUE (email)', 'CREATE CONSTRAINT는 올바른 문법이 아니다.', false),
(2738, 962, 'ALTER TABLE students INSERT CONSTRAINT uk_email UNIQUE (email)', 'INSERT CONSTRAINT는 올바른 문법이 아니다.', false),

-- 문제 963
(2739, 963, 'uk_email 제약 조건을 추가한다', 'ADD CONSTRAINT가 제약 조건을 추가한다.', false),
(2740, 963, 'uk_email 제약 조건을 삭제한다', 'DROP CONSTRAINT는 지정된 이름의 제약 조건을 삭제하는 명령이다.', true),
(2741, 963, 'email 컬럼을 삭제한다', 'DROP COLUMN이 컬럼을 삭제한다.', false),
(2742, 963, 'students 테이블을 삭제한다', 'DROP TABLE이 테이블을 삭제한다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (275, 958, 'DROP', 'ALTER TABLE ... DROP COLUMN은 테이블에서 기존 컬럼을 삭제하는 명령이다. 삭제된 컬럼의 데이터도 함께 사라진다.'),
       (276, 961, 'RENAME', 'ALTER TABLE ... RENAME COLUMN ... TO ...는 기존 컬럼의 이름을 변경하는 명령이다. 컬럼의 데이터와 속성은 유지된다.');

-- Lesson 3: DDL 3 (ID: 139)
INSERT INTO lesson (id, title, unit_id)
VALUES (139, 'DDL 3', 47);

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (964, 139, '다음 SQL 명령어의 역할은?', 'DROP TABLE IF EXISTS students;', 'OBJECTIVE'),
       (965, 139, '빈칸에 들어갈 키워드를 작성하시오.', 'DROP TABLE ___ EXISTS students; -- 테이블이 존재할 때만 삭제', 'SUBJECTIVE'),
       (966, 139, '다음 중 TRUNCATE 명령어에 대한 설명으로 올바른 것은?', 'TRUNCATE는 DDL 명령어 중 하나이다.', 'OBJECTIVE'),
       (967, 139, '다음 SQL 명령어 실행 후 테이블 구조는 어떻게 되는가?', 'TRUNCATE TABLE students;', 'OBJECTIVE'),
       (968, 139, '빈칸에 들어갈 명령어를 작성하시오.', '테이블의 모든 데이터를 삭제하고 초기 상태로 되돌리는 DDL 명령어는 ___이다.', 'SUBJECTIVE'),
       (969, 139, '다음 중 DELETE와 TRUNCATE의 차이점으로 올바른 것은?', 'DELETE는 DML, TRUNCATE는 DDL이다.', 'OBJECTIVE'),
       (970, 139, '다음 상황에서 적절한 명령어는?', '테이블의 모든 데이터를 빠르게 삭제하되, 테이블 구조는 유지해야 한다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES
-- 문제 964
(2743, 964, 'students 테이블을 무조건 삭제한다', 'IF EXISTS가 없으면 테이블이 없을 때 오류가 발생한다.', false),
(2744, 964, 'students 테이블이 존재하면 삭제한다', 'IF EXISTS는 테이블이 존재할 때만 삭제를 수행한다. 테이블이 없어도 오류가 발생하지 않는다.', true),
(2745, 964, 'students 테이블의 데이터만 삭제한다', 'DROP TABLE은 테이블 자체를 삭제한다.', false),
(2746, 964, 'students 테이블을 생성한다', 'CREATE TABLE이 테이블을 생성한다.', false),

-- 문제 966
(2747, 966, '특정 행만 삭제할 수 있다', 'TRUNCATE는 WHERE 절을 사용할 수 없어 특정 행만 삭제할 수 없다.', false),
(2748, 966, '테이블의 모든 데이터를 삭제하고 테이블 구조는 유지한다', 'TRUNCATE는 테이블의 모든 데이터를 삭제하고 초기 상태로 되돌리지만, 테이블 구조(스키마)는 그대로 유지된다.', true),
(2749, 966, '테이블 구조도 함께 삭제한다', 'DROP이 테이블 구조를 삭제한다.', false),
(2750, 966, 'ROLLBACK으로 복구할 수 있다', 'TRUNCATE는 DDL이므로 일반적으로 자동 커밋되어 ROLLBACK이 불가능하다.', false),

-- 문제 967
(2751, 967, '테이블 구조가 삭제된다', 'TRUNCATE는 데이터만 삭제하고 구조는 유지한다.', false),
(2752, 967, '테이블 구조는 그대로 유지된다', 'TRUNCATE는 테이블의 모든 데이터를 삭제하지만 테이블 구조(컬럼, 제약 조건 등)는 그대로 유지된다.', true),
(2753, 967, '테이블이 완전히 사라진다', 'DROP TABLE이 테이블을 완전히 삭제한다.', false),
(2754, 967, '아무 변화가 없다', 'TRUNCATE는 모든 데이터를 삭제한다.', false),

-- 문제 969
(2755, 969, 'DELETE는 ROLLBACK이 가능하고, TRUNCATE는 일반적으로 불가능하다', 'DELETE는 DML로 트랜잭션 내에서 ROLLBACK이 가능하다. TRUNCATE는 DDL로 자동 커밋되어 일반적으로 ROLLBACK이 불가능하다.', true),
(2756, 969, 'TRUNCATE는 WHERE 절을 사용할 수 있다', 'TRUNCATE는 WHERE 절을 사용할 수 없다. DELETE만 WHERE 절로 특정 행을 삭제할 수 있다.', false),
(2757, 969, 'DELETE가 TRUNCATE보다 빠르다', 'TRUNCATE가 DELETE보다 빠르다. TRUNCATE는 로그를 최소화하기 때문이다.', false),
(2758, 969, '두 명령어는 동일하게 동작한다', 'DELETE는 DML이고 TRUNCATE는 DDL로 동작 방식이 다르다.', false),

-- 문제 970
(2759, 970, 'DROP TABLE', 'DROP TABLE은 테이블 구조도 함께 삭제한다.', false),
(2760, 970, 'DELETE FROM', 'DELETE도 가능하지만 TRUNCATE가 더 빠르다.', false),
(2761, 970, 'TRUNCATE TABLE', 'TRUNCATE는 테이블의 모든 데이터를 빠르게 삭제하면서 구조는 유지한다. 대량 데이터 삭제 시 DELETE보다 효율적이다.', true),
(2762, 970, 'ALTER TABLE', 'ALTER TABLE은 테이블 구조를 수정하는 명령이다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (277, 965, 'IF', 'IF EXISTS는 테이블이 존재할 때만 삭제를 수행한다. 테이블이 없어도 오류가 발생하지 않아 스크립트 실행 시 안전하다.'),
       (278, 968, 'TRUNCATE', 'TRUNCATE는 테이블의 모든 데이터를 삭제하고 초기 상태로 되돌리는 DDL 명령어이다. DELETE보다 빠르지만 WHERE 절을 사용할 수 없고 ROLLBACK이 불가능하다.');

-- =====================================================
-- Chapter 4: 데이터베이스 (ID: 4)
-- Unit 48: DML(Data Manipulation Language)
-- =====================================================

-- Lesson 1: DML 1 (ID: 140)
INSERT INTO lesson (id, title, unit_id)
VALUES (140, 'DML 1', 48);

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (971, 140, '다음 중 DML(Data Manipulation Language)에 대한 설명으로 올바른 것은?', 'DML은 SQL의 한 종류이다.', 'OBJECTIVE'),
       (972, 140, '빈칸에 들어갈 DML 명령어를 작성하시오.', '테이블에 새로운 행을 삽입하는 명령어는 ___이다.', 'SUBJECTIVE'),
       (973, 140, '다음 중 DML 명령어가 아닌 것은?', 'DML은 데이터를 조작하는 언어이다.', 'OBJECTIVE'),
       (974, 140, '다음 SQL 명령어의 역할은?', 'INSERT INTO students (student_id, name) VALUES (1, ''홍길동'');', 'OBJECTIVE'),
       (975, 140, '빈칸에 들어갈 DML 명령어를 작성하시오.', '테이블의 기존 데이터를 수정하는 명령어는 ___이다.', 'SUBJECTIVE'),
       (976, 140, '다음 중 다중행 삽입 SQL로 올바른 것은?', 'INSERT 명령어로 여러 행을 한 번에 삽입할 수 있다.', 'OBJECTIVE'),
       (977, 140, '다음 SQL 명령어의 역할은?', 'DELETE FROM students;', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES
-- 문제 971
(2763, 971, '데이터베이스의 구조를 정의하는 언어이다', '이것은 DDL(Data Definition Language)의 설명이다.', false),
(2764, 971, '데이터베이스에 저장된 데이터를 조작하는 언어이다', 'DML(Data Manipulation Language)은 테이블의 행을 조회, 삽입, 수정, 삭제하는 역할을 한다.', true),
(2765, 971, '트랜잭션을 제어하는 언어이다', '이것은 TCL(Transaction Control Language)의 설명이다.', false),
(2766, 971, '사용자 권한을 관리하는 언어이다', '이것은 DCL(Data Control Language)의 설명이다.', false),

-- 문제 973
(2767, 973, 'SELECT', 'SELECT는 데이터를 조회하는 DML 명령어이다.', false),
(2768, 973, 'INSERT', 'INSERT는 데이터를 삽입하는 DML 명령어이다.', false),
(2769, 973, 'CREATE', 'CREATE는 객체를 생성하는 DDL 명령어이다. DML이 아니다.', true),
(2770, 973, 'UPDATE', 'UPDATE는 데이터를 수정하는 DML 명령어이다.', false),

-- 문제 974
(2771, 974, 'students 테이블의 데이터를 조회한다', 'SELECT가 데이터를 조회한다.', false),
(2772, 974, 'students 테이블에 새로운 행을 삽입한다', 'INSERT INTO ... VALUES는 테이블에 새로운 행을 삽입하는 명령이다. student_id가 1이고 name이 홍길동인 행이 추가된다.', true),
(2773, 974, 'students 테이블의 데이터를 수정한다', 'UPDATE가 데이터를 수정한다.', false),
(2774, 974, 'students 테이블을 생성한다', 'CREATE TABLE이 테이블을 생성한다.', false),

-- 문제 976
(2775, 976, 'INSERT INTO students VALUES (1, ''홍길동''), (2, ''김철수'')', 'VALUES 절에 여러 행을 쉼표로 구분하여 한 번에 삽입할 수 있다.', true),
(2776, 976, 'INSERT INTO students VALUES (1, ''홍길동'') AND (2, ''김철수'')', 'AND는 다중행 삽입에 사용하지 않는다.', false),
(2777, 976, 'INSERT INTO students VALUES (1, ''홍길동''); (2, ''김철수'')', '세미콜론은 문장 종료를 의미하므로 다중행 삽입이 아니다.', false),
(2778, 976, 'INSERT MULTIPLE INTO students VALUES (1, ''홍길동''), (2, ''김철수'')', 'INSERT MULTIPLE은 올바른 문법이 아니다.', false),

-- 문제 977
(2779, 977, 'students 테이블의 특정 행을 삭제한다', 'WHERE 절이 없으므로 특정 행이 아닌 모든 행을 삭제한다.', false),
(2780, 977, 'students 테이블의 모든 행을 삭제한다', 'DELETE FROM 테이블명; 형태로 WHERE 절이 없으면 테이블의 모든 행을 삭제한다.', true),
(2781, 977, 'students 테이블을 삭제한다', 'DROP TABLE이 테이블을 삭제한다.', false),
(2782, 977, 'students 테이블의 구조를 초기화한다', 'TRUNCATE가 테이블을 초기화한다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (279, 972, 'INSERT', 'INSERT는 테이블에 새로운 행을 삽입하는 DML 명령어이다. INSERT INTO 테이블명 (컬럼1, 컬럼2) VALUES (값1, 값2); 형태로 사용한다.'),
       (280, 975, 'UPDATE', 'UPDATE는 테이블의 기존 데이터를 수정하는 DML 명령어이다. UPDATE 테이블명 SET 컬럼=값 WHERE 조건; 형태로 사용한다.');

-- Lesson 2: DML 2 (ID: 141)
INSERT INTO lesson (id, title, unit_id)
VALUES (141, 'DML 2', 48);

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (978, 141, '다음 SQL 명령어의 역할은?', 'UPDATE students SET email = ''new@example.com'' WHERE student_id = 1;', 'OBJECTIVE'),
       (979, 141, '빈칸에 들어갈 키워드를 작성하시오.', 'UPDATE students ___ name = ''홍길동'' WHERE student_id = 1; -- name 컬럼 수정', 'SUBJECTIVE'),
       (980, 141, '다음 중 UPDATE 명령어에 대한 설명으로 틀린 것은?', 'UPDATE는 DML 명령어 중 하나이다.', 'OBJECTIVE'),
       (981, 141, '다음 SQL 명령어 실행 결과는?', 'UPDATE students SET name = ''테스트'';', 'OBJECTIVE'),
       (982, 141, '빈칸에 들어갈 DML 명령어를 작성하시오.', '테이블의 행을 삭제하는 명령어는 ___이다.', 'SUBJECTIVE'),
       (983, 141, '다음 SQL 명령어의 역할은?', 'DELETE FROM students WHERE student_id = 1;', 'OBJECTIVE'),
       (984, 141, '다음 중 DELETE와 TRUNCATE의 공통점은?', 'DELETE와 TRUNCATE는 모두 데이터를 삭제한다.', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES
-- 문제 978
(2783, 978, '모든 학생의 이메일을 수정한다', 'WHERE 절이 있으므로 조건에 맞는 행만 수정된다.', false),
(2784, 978, 'student_id가 1인 학생의 이메일을 수정한다', 'UPDATE ... SET ... WHERE는 조건에 맞는 행의 특정 컬럼 값을 수정한다.', true),
(2785, 978, 'student_id가 1인 학생을 삭제한다', 'DELETE가 행을 삭제한다.', false),
(2786, 978, '새로운 학생을 추가한다', 'INSERT가 새로운 행을 추가한다.', false),

-- 문제 980
(2787, 980, 'WHERE 절 없이 사용하면 모든 행이 수정된다', 'WHERE 절이 없으면 테이블의 모든 행이 수정된다.', false),
(2788, 980, '여러 컬럼을 동시에 수정할 수 있다', 'SET 절에 쉼표로 구분하여 여러 컬럼을 수정할 수 있다.', false),
(2789, 980, '테이블 구조를 변경할 수 있다', 'UPDATE는 데이터만 수정한다. 테이블 구조 변경은 ALTER를 사용한다.', true),
(2790, 980, '조건에 맞는 행만 수정할 수 있다', 'WHERE 절로 조건을 지정하여 특정 행만 수정할 수 있다.', false),

-- 문제 981
(2791, 981, '오류가 발생한다', 'WHERE 절 없이도 실행 가능하다.', false),
(2792, 981, 'student_id가 1인 학생만 수정된다', 'WHERE 절이 없으므로 모든 행이 수정된다.', false),
(2793, 981, '모든 학생의 name이 테스트로 변경된다', 'WHERE 절이 없으면 테이블의 모든 행이 수정된다.', true),
(2794, 981, '아무 변화가 없다', 'UPDATE 문이 실행되어 데이터가 변경된다.', false),

-- 문제 983
(2795, 983, '모든 학생을 삭제한다', 'WHERE 절이 있으므로 조건에 맞는 행만 삭제된다.', false),
(2796, 983, 'student_id가 1인 학생을 삭제한다', 'DELETE FROM ... WHERE는 조건에 맞는 행을 삭제한다.', true),
(2797, 983, 'student_id 컬럼을 삭제한다', 'ALTER TABLE ... DROP COLUMN이 컬럼을 삭제한다.', false),
(2798, 983, 'students 테이블을 삭제한다', 'DROP TABLE이 테이블을 삭제한다.', false),

-- 문제 984
(2799, 984, 'ROLLBACK으로 복구할 수 있다', 'DELETE는 ROLLBACK 가능하지만 TRUNCATE는 일반적으로 불가능하다.', false),
(2800, 984, 'WHERE 절을 사용할 수 있다', 'DELETE만 WHERE 절을 사용할 수 있다.', false),
(2801, 984, '테이블의 데이터를 삭제한다', 'DELETE와 TRUNCATE 모두 테이블의 데이터를 삭제한다. 단, 동작 방식과 특성이 다르다.', true),
(2802, 984, '테이블 구조도 함께 삭제한다', '두 명령어 모두 테이블 구조는 유지한다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (281, 979, 'SET', 'UPDATE 문에서 SET 키워드는 수정할 컬럼과 값을 지정한다. UPDATE 테이블명 SET 컬럼=값 형태로 사용한다.'),
       (282, 982, 'DELETE', 'DELETE는 테이블의 행을 삭제하는 DML 명령어이다. DELETE FROM 테이블명 WHERE 조건; 형태로 사용하며, WHERE 절이 없으면 모든 행이 삭제된다.');

-- Lesson 3: DML 3 (ID: 142)
INSERT INTO lesson (id, title, unit_id)
VALUES (142, 'DML 3', 48);

INSERT INTO problem (id, lesson_id, instruction, content, problem_type)
VALUES (985, 142, '다음 SQL 명령어의 역할은?', 'SELECT * FROM students;', 'OBJECTIVE'),
       (986, 142, '빈칸에 들어갈 키워드를 작성하시오.', 'SELECT * FROM students ___ student_id = 1; -- 조건 지정', 'SUBJECTIVE'),
       (987, 142, '다음 중 WHERE 절의 비교 연산자로 올바르지 않은 것은?', 'WHERE 절은 조건을 지정하는 데 사용한다.', 'OBJECTIVE'),
       (988, 142, '다음 SQL 명령어의 역할은?', 'SELECT * FROM students WHERE name LIKE ''홍%'';', 'OBJECTIVE'),
       (989, 142, '빈칸에 들어갈 키워드를 작성하시오.', 'SELECT * FROM students WHERE email ___ NULL; -- NULL 값 확인', 'SUBJECTIVE'),
       (990, 142, '다음 중 IN 연산자의 사용법으로 올바른 것은?', 'IN 연산자는 여러 값 중 하나와 일치하는지 확인한다.', 'OBJECTIVE'),
       (991, 142, '다음 SQL 명령어의 역할은?', 'SELECT * FROM students WHERE student_id BETWEEN 1 AND 10;', 'OBJECTIVE');

INSERT INTO option (id, problem_id, content, explanation, is_answer)
VALUES
-- 문제 985
(2803, 985, 'students 테이블의 특정 컬럼만 조회한다', '*는 모든 컬럼을 의미한다.', false),
(2804, 985, 'students 테이블의 모든 컬럼과 모든 행을 조회한다', 'SELECT *는 모든 컬럼을 조회하고, WHERE 절이 없으면 모든 행을 조회한다.', true),
(2805, 985, 'students 테이블을 생성한다', 'CREATE TABLE이 테이블을 생성한다.', false),
(2806, 985, 'students 테이블의 데이터를 삭제한다', 'DELETE가 데이터를 삭제한다.', false),

-- 문제 987
(2807, 987, '=', '= 연산자는 값이 같은지 비교한다.', false),
(2808, 987, '<>', '<> 연산자는 값이 다른지 비교한다. !=와 동일하다.', false),
(2809, 987, '==', 'SQL에서 동등 비교는 =를 사용한다. ==는 사용하지 않는다.', true),
(2810, 987, '>=', '>= 연산자는 크거나 같은지 비교한다.', false),

-- 문제 988
(2811, 988, '이름이 정확히 홍인 학생을 조회한다', '%는 0개 이상의 문자를 의미하는 와일드카드이다.', false),
(2812, 988, '이름이 홍으로 시작하는 학생을 조회한다', 'LIKE ''홍%''는 홍으로 시작하는 모든 값과 일치한다. %는 0개 이상의 임의 문자를 의미한다.', true),
(2813, 988, '이름이 홍으로 끝나는 학생을 조회한다', '''%홍''이 홍으로 끝나는 값과 일치한다.', false),
(2814, 988, '이름에 홍이 포함된 학생을 조회한다', '''%홍%''가 홍이 포함된 값과 일치한다.', false),

-- 문제 990
(2815, 990, 'WHERE department_id IN 1, 2, 3', '괄호가 필요하다.', false),
(2816, 990, 'WHERE department_id IN (1, 2, 3)', 'IN 연산자는 괄호 안에 값 목록을 지정하여 해당 값 중 하나와 일치하는지 확인한다.', true),
(2817, 990, 'WHERE department_id = IN (1, 2, 3)', '= 연산자와 IN을 함께 사용하지 않는다.', false),
(2818, 990, 'WHERE IN department_id (1, 2, 3)', 'IN은 컬럼명 뒤에 위치한다.', false),

-- 문제 991
(2819, 991, 'student_id가 1 또는 10인 학생을 조회한다', 'IN (1, 10)이 1 또는 10인 값을 조회한다.', false),
(2820, 991, 'student_id가 1부터 10 사이인 학생을 조회한다', 'BETWEEN A AND B는 A 이상 B 이하의 범위를 지정한다. 1부터 10까지 포함된다.', true),
(2821, 991, 'student_id가 1보다 크고 10보다 작은 학생을 조회한다', 'BETWEEN은 경계값을 포함한다.', false),
(2822, 991, 'student_id가 1이 아니고 10이 아닌 학생을 조회한다', 'NOT IN (1, 10)이 해당 조건이다.', false);

INSERT INTO answer (id, problem_id, content, explanation)
VALUES (283, 986, 'WHERE', 'WHERE 절은 조건을 지정하여 특정 행만 조회, 수정, 삭제하는 데 사용한다. SELECT, UPDATE, DELETE 문에서 사용할 수 있다.'),
       (284, 989, 'IS', 'NULL 값을 비교할 때는 = 연산자가 아닌 IS NULL 또는 IS NOT NULL을 사용한다. NULL은 값이 없음을 의미하므로 일반 비교 연산자로 비교할 수 없다.');
