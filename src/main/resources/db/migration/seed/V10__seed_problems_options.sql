-- V10__seed_problems_options.sql

DELETE FROM problem;

INSERT INTO problem (id, problem_type, question, content, answer, lesson_id) VALUES

-- Unit01 - 배열
(1, 'SUBJECTIVE', '빈칸에 들어갈 말은?', '일반적으로 배열은 _____ 종류의 데이터들이 순차적으로 저장되어 있는 자료구조를 의미한다.', '같은, 동일한, 일치하는', 1),
(2, 'SUBJECTIVE', '빈칸에 들어갈 말은?', '배열은 선언 시점에 크기가 _____되며, 런타임에 크기를 변경할 수 없다.', '고정, 결정', 1),
(3, 'SUBJECTIVE', '빈칸에 들어갈 말은?', '배열은 메모리 상에서 _____적인 위치에 저장하는 자료구조이다.', '연속', 1),
(4, 'SUBJECTIVE', '빈칸에 들어갈 말은?', '배열은 연속된 메모리에 저장되기 때문에, 할당받은 공간을 사용하지 않으면 메모리 _____가 발생한다.', '낭비, 누수', 1),
(5, 'SUBJECTIVE', '빈칸에 들어갈 말은?', '배열의 _____를 이용해서 값에 접근할 수 있다.', '인덱스', 1),
(6, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '배열의 첫 번째 요소 인덱스는?', '-', 1),
(7, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '배열의 인덱스 범위를 벗어난 접근을 시도할 때 발생하는 에러는?', '-', 1),
(8, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '2차원 배열 temp[i][j] 에서 i와 j가 나타내는 의미는?', '-', 1),
(9, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '2차원 배열 temp[i][j] 에서 사용하는 기본 메모리 주소 계산 방식은?', '-', 1),
(10, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '배열에서 인덱스를 이용한 특정 요소 접근의 시간복잡도는?', '-', 1),
(11, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '정렬되지 않은 배열에서 특정 요소를 찾는 선형 탐색의 시간복잡도는?', '-', 1),
(12, 'SUBJECTIVE', '빈칸에 들어갈 말은?', '배열을 순차적으로 접근할 때, 성능이 좋은 이유는 _____지역성 때문이다.', '캐시', 1),

-- Unit02 - 연결리스트 1
(13, 'SUBJECTIVE', '빈칸에 들어갈 말은?', '연결리스트는 배열리스트와 다르게 _____ 할당 방식을 사용하기 때문에 공간 낭비를 줄일 수 있다.', '동적', 2),
(14, 'OBJECTIVE', '빈칸에 들어갈 말은?', '단일 연결리스트의 노드는 원소를 저장하는 _____필드와 다음 노드를 가리키는 _____필드로 구성된다.', '-', 2),
(15, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '단일 연결리스트에서 헤드노드 포인터의 역할은?', '-', 2),
(16, 'SUBJECTIVE', '빈칸에 들어갈 말은?', '빈 연결리스트에서 헤드노드의 포인터는 _____을 가리킨다.', 'null', 2),
(17, 'OBJECTIVE', '빈칸에 들어갈 말은?', '연결리스트의 노드들은 메모리 상에서 _____ 위치에 저장된다.', '-', 2),
(18, 'SUBJECTIVE', '빈칸에 들어갈 말은?', '단일 연결 리스트에서 테일노드의 포인터는 _____을 가리킨다.', 'null', 2),
(19, 'OBJECTIVE', '빈칸에 들어갈 말은?', '원형 단일 연결리스트에서 테일노드의 포인터는 _____을 가리킨다.', '-', 2),
(20, 'SUBJECTIVE', '빈칸에 들어갈 말은?', '연결리스트는 런타임에 크기를 _____으로 변경할 수 있다.', '동적', 2),
(21, 'SUBJECTIVE', '빈칸에 들어갈 말은?', '연결리스트는 배열과 달리 _____ 기반 접근이 불가능하다.', '인덱스', 2),
(22, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '연결리스트가 배열보다 메모리를 더 많이 사용하는 이유는?', '-', 2),
(23, 'OBJECTIVE', '빈칸에 들어갈 말은?', '단일 연결리스트의 맨 앞에 새 노드를 삽입하는 연산의 시간복잡도는 _____이다.', '-', 2),
(24, 'OBJECTIVE', '빈칸에 들어갈 말은?', '단일 연결리스트에서 특정 값을 찾아 삭제하는 연산의 시간복잡도는 _____이다.', '-', 2),

-- Unit02 - 연결리스트 2
(25, 'SUBJECTIVE', '빈칸에 들어갈 말은?', '선형 양방향 연결리스트에서 헤드노드의 prev 포인터와 테일노드의 next 포인터는 _____을 가리킨다', 'null', 3),
(26, 'SUBJECTIVE', '빈칸에 들어갈 말은?', '원형 양방향 연결리스트에서 테일노드의 next 포인터는 _____노드를 가리킨다.', '헤드, 머리', 3),
(27, 'SUBJECTIVE', '빈칸에 들어갈 말은?', '선형 양방향 연결리스트에서 첫번째 노드는 _____노드의 next를 통해 접근할 수 있다.', '헤드, 머리', 3),
(28, 'SUBJECTIVE', '빈칸에 들어갈 말은?', '원형 양방향 연결리스트에서 마지막 노드는 _____노드의 prev를 통해 접근할 수 있다.', '테일, 꼬리', 3),
(29, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '양방향 연결리스트의 중간에 새로운 노드를 삽입하기 위해서는 몇 개의 포인터를 수정해야 하는가?', '-', 3),
(30, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '양방향 연결리스트의 중간에 위치한 노드를 삭제하기 위해서는 몇 개의 포인터를 수정해야 하는가?', '-', 3),
(31, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '원형 양방향 연결리스트에서 임의의 노드에서 시작해서 전체 노드를 한번 순회하는 연산의 시간복잡도는?', '-', 3),
(32, 'OBJECTIVE', '빈칸에 들어갈 말은?', '테일노드를 사용한 경우, 마지막 원소에 대한 삽입/삭제 연산의 시간복잡도는 _____이 된다.', '-', 3),
(33, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '양방향 연결리스트를 통해 구현할 수 있는 자료구조가 아닌 것은?', '-', 3),

-- Unit03 - 스택
(34, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '스택에 3, 5, 1, 2를 순차적으로 넣었을 때, 가장 위에 있는 원소는?', '-', 4),
(35, 'SUBJECTIVE', '빈칸에 들어갈 말은?', '스택은 _____ 구조를 따른다.', 'lifo, 후입선출', 4),
(36, 'OBJECTIVE', '빈칸에 들어갈 말은?', '스택은 _____의 원소만 접근이 가능하다.', '-', 4),
(37, 'SUBJECTIVE', '빈칸에 들어갈 말은?', '스택의 맨 위 원소를 _____이라고 한다.', '탑, top', 4),
(38, 'OBJECTIVE', '빈칸에 들어갈 말은?', '배열로 구현된 스택에서 아무 원소도 들어있지 않은 상황이라면, top을 가리키는 인덱스는 _____으로 초기화되어 있다.', '-', 4),
(39, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '연결리스트로 구현된 스택에서 원소 삽입이 발생하면 몇 개의 포인터가 변경되는가?', '-', 4),
(40, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '연결리스트로 구현된 스택에서 원소 삭제가 발생하면 몇 개의 포인터가 변경되는가?', '-', 4),
(41, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '후위표현법 "3 4 + 2"를 계산하면?', '-', 4),
(42, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '후위표현법 "5 3 - 2 4 + *"을 계산하면?', '-', 4),
(43, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '스택의 push, pop, peek 연산의 시간복잡도는?', '-', 4),

-- Unit04 - 큐
(44, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '큐에 2, 9, 7, 4를 순차적으로 넣었을 때, 원소 삭제시 반환되는 값은?', '-', 5),
(45, 'SUBJECTIVE', '빈칸에 들어갈 말은?', '큐는 _____ 구조를 따른다.', 'fifo, 선입선출', 5),
(46, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '큐를 구현할 때, 주로 원형 구조를 사용하는 이유는?', '-', 5),
(47, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '원형 배열로 구현된 크기가 n인 빈 큐에서 tail과 front가 가리키고 있는 인덱스는?', '-', 5),
(48, 'SUBJECTIVE', '빈칸에 들어갈 말은?', '원형 배열로 구현된 크기가 8인 빈 큐에서 삽입 3회, 삭제 1회가 일어났을 때 tail이 가리키는 인덱스는 _____이다.', '2', 5),
(49, 'SUBJECTIVE', '빈칸에 들어갈 말은?', '원형 배열로 구현된 크기가 8인 빈 큐에서 삽입 4회, 삭제 3회가 일어났을 때 tail이 가리키는 인덱스는 _____이다.', '3', 5),
(50, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '원형 연결리스트로 큐를 구현할 때, tail 포인터만 사용하는 이유는?', '-', 5),
(51, 'SUBJECTIVE', '빈칸에 들어갈 말은?', '원형 연결리스트로 구현된 큐에서 새로운 노드를 추가하는 경우 수정되는 포인터의 수는 _____개이다.', '3', 5),
(52, 'SUBJECTIVE', '빈칸에 들어갈 말은?', '원형 연결리스트로 구현된 큐에서 노드를 삭제하는 경우 수정되는 포인터의 수는 _____개이다.', '1', 5),
(53, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '스택을 이용해 문자열 "abba"가 회문(좌우동형)인지 검사할 때, 스택에 저장할 문자는?', '-', 5),
(54, 'SUBJECTIVE', '빈칸에 들어갈 말은?', '스택을 이용한 회문 검사에서 문자열 "level"의 경우, 스택에는 _____개의 문자를 저장한다.', '2', 5),

-- Unit05 - 힙
(55, 'SUBJECTIVE', '빈칸에 들어갈 말은?', '_____ _____를 구현한 자료구조를 힙이라고 한다.', '우선순위 큐', 6),
(56, 'SUBJECTIVE', '빈칸에 들어갈 말은?', '힙은 _____ _____ 트리 구조를 사용한다.', '완전 이진, 완전이진', 6),
(57, 'SUBJECTIVE', '다음 설명으로 옳은 것은?', '모든 노드가 자식 노드보다 크거나 같은 값을 갖는 힙은?', '최대힙', 6),
(58, 'SUBJECTIVE', '다음 설명으로 옳은 것은?', '모든 노드가 자식 노드보다 작거나 같은 값을 갖는 힙은?', '최소힙', 6),
(59, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '힙을 배열로 구현했을 때 부모노드의 인덱스가 k인 경우, 자식노드에 접근할 수 있는 인덱스는?', '-', 6),
(60, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '힙을 배열로 구현했을 때 자식노드의 인덱스가 k인 경우, 부모노드에 접근할 수 있는 인덱스는?', '-', 6),
(61, 'SUBJECTIVE', '다음 설명으로 옳은 것은?', '배열로 구현한 최대힙에 8 | 7 | 5 | 3 순으로 원소가 들어가 있다. 만약, 9를 힙에 넣게 되면 총 몇번의 교환 연산이 일어나는가?', '2번', 6),
(62, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '배열로 구현한 최대힙에 10 | 8 | 6 | 7 | 4 | 5 | 2 순으로 원소가 들어가 있다. 만약, 12를 힙에 넣게 되면 총 몇번의 교환 연산이 일어나는가?', '-', 6),
(63, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '배열로 구현한 최대힙에 15 | 12 | 10 | 8 | 9 | 6 | 7 | 3 | 5 순으로 원소가 들어가 있다. 만약, 14를 힙에 넣게 되면 총 몇번의 교환 연산이 일어나는가?', '-', 6),
(64, 'SUBJECTIVE', '다음 설명으로 옳은 것은?', '배열로 구현한 최대힙에 16 | 12 | 14 | 8 | 10 | 6 | 9 | 4 | 7 순으로 원소가 들어가 있다. 루트 노드를 삭제할 때 총 몇번의 교환 연산이 일어나는가?', '3', 6),
(65, 'SUBJECTIVE', '다음 설명으로 옳은 것은?', '배열로 구현한 최대힙에 18 | 15 | 16 | 10 | 12 | 8 | 14 | 4 | 6 | 9 순으로 원소가 들어가 있다. 루트 노드 삭제 및 스며내리기 과정이 완료된 후, 스며내리기 대상이었던 값의 최종 인덱스는?', '6', 6),

-- Unit06 - 해시
(66, 'OBJECTIVE', '빈칸에 들어갈 말은?', '해시 테이블의 조회, 삽입, 삭제 연산의 시간복잡도는 _____이다.', '-', 7),
(67, 'SUBJECTIVE', '빈칸에 들어갈 말은?', '해시 함수가 " h(x) = x % 10 " 라고할 때, key로 13과 3이 들어오면 같은 해시값을 갖게 되는데 이를 _____이라고 한다.', '충돌', 7),
(68, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '해시 테이블에서 전체 크기 대비 원소가 차 있는 비율을 무엇이라고 하는가?', '-', 7),
(69, 'SUBJECTIVE', '빈칸에 들어갈 말은?', '해시 테이블에서 충돌이 발생한 원소들을 같은 버킷에 연결 리스트로 관리하는 방식을 _____이라고 한다.', '체이닝, 채이닝, chaining', 7),
(70, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '해시 테이블에서 체이닝 방식으로 충돌을 해결하는 경우, 조회 연산에 대한 최악의 경우 시간복잡도는?', '-', 7),
(71, 'SUBJECTIVE', '빈칸에 들어갈 말은?', '해시 테이블에서 충돌이 발생했을 때, 테이블 내의 다른 빈 공간을 찾아 저장하는 방식을 _____ _____ 법이라고 한다.', '개방 주소', 7),
(72, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '개방 주소 방법에서 충돌이 발생했을 때 h(k), h(k)+1, h(k)+2, ... 순서로 빈 슬롯을 찾아 탐색하는 방식은?', '-', 7),
(73, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '개방 주소법에서 충돌이 발생했을 때 h(k), h(k)+1², h(k)+2², h(k)+3²... 순서로 탐색하는 방식은?', '-', 7),
(74, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '개방 주소법에서 두 개의 서로 다른 해시 함수를 사용하여 충돌을 해결하는 방식은?', '-', 7),
(75, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '선형 탐사법에서 연속된 해시 슬롯들이 채워지면서 데이터가 한 곳에 뭉치는 현상을 무엇이라고 하는가?', '-', 7),
(76, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '선형 탐사법에서 1차 군집 현상이 성능에 미치는 영향으로 가장 적절한 것은?', '-', 7),

-- Unit07 - 트리 1
(77, 'SUBJECTIVE', '빈칸에 들어갈 말은?', '트리(Tree)란 _____들이 나무 가지처럼 연결된 자료구조이다.', '노드, node', 8),
(78, 'SUBJECTIVE', '빈칸에 들어갈 말은?', '각 노드와 노드는 _____으로 연결된다.', '간선, edge', 8),
(79, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '트리에서 최상위에 위치한 노드를 무엇이라고 하는가?', '-', 8),
(80, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '트리에서 자식 노드를 갖고있지 않는 노드를 무엇이라고 하는가?', '-', 8),
(81, 'OBJECTIVE', '빈칸에 들어갈 말은?', '노드가 n개인 트리는 _____개의 간선을 갖고 있다.', '-', 8),
(82, 'SUBJECTIVE', '빈칸에 들어갈 말은?', '트리에서 루트 노드부터 특정 노드까지의 거리를 그 노드의 _____라고 한다.', '깊이, depth', 8),
(83, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '이진 트리에서 각 노드가 가질 수 있는 최대 자식 노드의 개수는?', '-', 8),
(84, 'SUBJECTIVE', '빈칸에 들어갈 말은?', '한 노드에서 다른 노드로 가는 일련의 간선들을 _____라고 한다.', '경로, path', 8),
(85, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '트리에서 사이클(순환)이 존재하는가?', '-', 8),
(86, 'SUBJECTIVE', '빈칸에 들어갈 말은?', '트리에서 한 노드가 갖고 있는 자식 노드의 개수를 그 노드의 _____라고 한다.', '차수, degree', 8),

-- Unit07 - 트리 2
(87, 'SUBJECTIVE', '다음 설명으로 옳은 것은?', '높이가 5인 이진트리에서 가질 수 있는 최대 노드의 개수는?', '63', 9),
(88, 'SUBJECTIVE', '빈칸에 들어갈 말은?', '이진트리에서 현재 노드, 왼쪽 자식 노드, 오른쪽 자식 노드 순서로 방문하는 순회방식을 _____순회라고 한다.', '전위, preorder', 9),
(89, 'SUBJECTIVE', '빈칸에 들어갈 말은?', '이진트리에서 왼쪽 자식 노드, 현재 노드, 오른쪽 자식 노드 순서로 방문하는 순회방식을 _____순회 라고 한다.', '중위, inorder', 9),
(90, 'SUBJECTIVE', '빈칸에 들어갈 말은?', '이진트리에서 왼쪽 자식 노드, 오른쪽 자식 노드, 현재 노드 순서로 방문하는 순회방식을 _____순회 라고 한다.', '후위, postorder', 9),
(91, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '이진탐색트리의 성질로 올바른 것은?', '-', 9),
(92, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '균형잡힌 이진탐색트리에서 특정 값을 조회하는데 걸리는 시간복잡도는?', '-', 9),
(93, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '균형잡힌 이진탐색트리에서 특정 값을 삽입/삭제하는데 걸리는 시간복잡도는?', '-', 9),
(94, 'SUBJECTIVE', '빈칸에 들어갈 말은?', '모든 레벨이 완전하게 채워져 있고, 마지막 레벨의 모든 노드가 존재하는 이진트리를 _____이진트리라고 한다.', '포화', 9),
(95, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '완전이진트리의 특징으로 올바른 것은?', '-', 9),
(96, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '완전이진트리를 구현할 때, 가장 적합한 자료구조는?', '-', 9),

-- Unit07 - 트리 3
(97, 'SUBJECTIVE', '빈칸에 들어갈 말은?', '각 노드가 블랙 또는 레드 색상으로 표기되며, 특정 규칙을 통해 스스로 균형을 유지하는 이진탐색트리를 _____트리라고 한다.', '레드블랙, 레드 블랙, 레드-블랙, red-black', 10),
(98, 'SUBJECTIVE', '빈칸에 들어갈 말은?', '레드-블랙트리에서 루트 노드의 색상은 _____이다', '블랙, 블렉, black, 검은색', 10),
(99, 'SUBJECTIVE', '빈칸에 들어갈 말은?', '레드-블랙트리에서 자식이 없는 모든 노드는 _____ 노드를 갖고있다.', 'nil', 10),
(100, 'SUBJECTIVE', '빈칸에 들어갈 말은?', '레드-블랙트리에서 새 노드를 삽입할 경우 _____ 색상으로 설정한다.', '레드, 빨간, 빨강, red', 10),
(101, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '레드-블랙 트리의 탐색, 삽입, 삭제 연산의 시간복잡도는?', '-', 10),
(102, 'SUBJECTIVE', '빈칸에 들어갈 말은?', '힙은 항상 _____이진트리의 형태를 유지해야 한다.', '완전', 10),
(103, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '힙에서 특정 데이터의 삽입/삭제 연산의 시간복잡도는?', '-', 10),
(104, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '최대 힙에서 새로운 데이터를 삽입하는 과정으로 올바른 것은?', '-', 10),

-- Chapter 2: 알고리즘

-- Unit08 - 정렬 1
(105, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '다음 중 기본적으로 불안정(unstable) 인 정렬은?', '-', 11),
(106, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '입력이 이미 정렬되어 있을 때 Θ(n) 시간에 끝낼 수 있는 정렬은?', '-', 11),
(107, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '길이 n 배열에서 선택 정렬의 총 비교 횟수는? (빅-Θ)', '-', 11),
(108, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '교환(swaps) 횟수가 항상 O(n) 인 정렬은?', '-', 11),
(109, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '버블정렬에서 i번째 패스가 끝나면 성립하는 사실은?', '-', 11),
(110, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '입력을 한 원소씩 읽으며 접두 구간을 항상 정렬 상태로 유지하는 정렬은?', '-', 11),
(111, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '기수정렬(LSD, 각 자리 안정 정렬) 시간복잡도는 자리수 d, 기수 k, 입력 크기 n일 때?', '-', 11),
(112, 'OBJECTIVE', '다음 설명으로 옳은 것은?', 'LSD 기수정렬에서 각 자리를 정렬할 때 반드시 필요한 성질은?', '-', 11),
(113, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '배열 [5, 1, 4, 2]에 버블정렬 첫 패스(왼→오) 후 배열은?', '-', 11),
(114, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '삽입정렬의 이동(shift) 횟수는 어떤 값과 가장 밀접히 비례하는가?', '-', 11),
(115, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '거의 정렬된 작은 데이터에 가장 적합한 것은?', '-', 11),
(116, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '다음 중 O(n + k) 의 추가 메모리가 필요한 것은?', '-', 11),

-- Unit09 - 정렬 2
(117, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '다음 중 기본적으로 안정적(stable)인 정렬은?', '-', 12),
(118, 'OBJECTIVE', '다음 설명으로 옳은 것은?', 'O(1) 보조 메모리(제자리)로 수행되는 것은?', '-', 12),
(119, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '최악의 경우 Θ(n²)이 될 수 있는 것은?', '-', 12),
(120, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '퀵정렬의 평균 성능을 안정화하는 전략으로 적절한 것은?', '-', 12),
(121, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '배열을 한 번에 힙으로 만드는 Floyd의 build-heap 시간은?', '-', 12),
(122, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '최대 힙을 이용해 힙에서 원소를 하나씩 꺼내 출력하면, 출력되는 값들의 순서는?', '-', 12),
(123, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '배열 기반 병합 정렬에서 일반적으로 필요한 추가 공간은?', '-', 12),
(124, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '배열의 역순쌍(인버전)을 효율적으로 세는 데 적합한 방법은?', '-', 12),
(125, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '퀵정렬의 파티션이 끝난 직후 피벗 p에 대해 참인 것은?', '-', 12),
(126, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '메모리에 다 안 들어가는 매우 큰 데이터를 정렬할 때 적합한 방법은?', '-', 12),
(127, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '퀵정렬에서 분할이 거의 균등할 때 각 재귀 레벨의 총 작업량과 높이는?', '-', 12),
(128, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '힙정렬이 기본적으로 불안정한 가장 큰 이유는?', '-', 12),

-- Unit10 - 그리디 알고리즘 1
(129, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '다음 중 그리디 알고리즘 설명으로 가장 가까운 것은?', '-', 13),
(130, 'SUBJECTIVE', '빈칸에 들어갈 말은?', '그리디-초이스 프로퍼티는 "지금 고른 선택을 포함하는 _____가 적어도 하나 존재한다"는 뜻이다.', '최적해', 13),
(131, 'SUBJECTIVE', '빈칸에 들어갈 말은?', '교환 논법은 임의의 최적해가 있을 때 그 해의 일부를 그리디가 고른 선택으로 _____해의 품질이 나빠지지 않음을 보이는 방법이다.', '바꿔도', 13),
(132, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '전형적으로 그리디가 최적을 보장하는 문제는?', '-', 13),
(133, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '동전 {1,5,10,50,100,500}으로 760원을 최소 개수로 거슬러줄 때 동전 개수는?', '-', 13),
(134, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '동전 {1,3,4}로 6원을 거슬러줄 때 그리디와 최적해는?', '-', 13),
(135, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '동전 {1,3,4}에서 큰 동전 우선 그리디가 처음 실패하는 최소 금액은?', '-', 13),
(136, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '새 동전 체계에서 그리디의 올바름을 빠르게 점검하는 방법은?', '-', 13),
(137, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '분할 가능 배낭에서 가치 최대화를 위한 전형적 정렬 기준은?', '-', 13),
(138, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '(무게, 가치) → A(4,20), B(2,14), C(6,24), 용량 7. 분할 가능 배낭 그리디의 최대 가치는?', '-', 13),
(139, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '0-1 배낭에서 비율 내림차순 그리디는 항상 최적인가?', '-', 13),
(140, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '0-1 배낭에서 비율 그리디가 실패하는 핵심 이유는?', '-', 13),

-- Unit11 - 그리디 알고리즘 2
(141, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '서로 겹치지 않는 구간을 최대 개수로 선택하려면 어떤 정렬 기준이 적절한가?', '-', 14),
(142, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '작업들의 마감시간이 주어질 때 최대 지연을 최소로 만드는 단일 머신 스케줄링 규칙은?', '-', 14),
(143, 'OBJECTIVE', '다음 설명으로 옳은 것은?', 'd는 마감 시간, 하나의 머신만 사용. J1(d=2, 이익=60), J2(d=1, 이익=100), J3(d=2, 이익=20). 총 이익을 최대로 하는 그리디 선택은?', '-', 14),
(144, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '구간 [1,4], [2,5], [3,6], [7,9]를 모두 배치할 때 필요한 최소 회의실 수는?', '-', 14),
(145, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '빈도 A=5, B=7, C=10, D=15일 때 Huffman 트리의 총 비용(병합 합의 합)은?', '-', 14),
(146, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '빈도 A=2, B=3, C=7, D=9에서 첫 병합 쌍은?', '-', 14),
(147, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '다음 중 접두부(prefix-free) 코드인 것은?', '-', 14),
(148, 'OBJECTIVE', '다음 설명으로 옳은 것은?', 'Huffman 코딩은 무엇을 최소화하는 그리디 알고리즘인가?', '-', 14),
(149, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '우주 U={1,2,3,4,5,6,7}, 집합 S1={1,2,3,4}, S2={3,4,5}, S3={5,6,7}, S4={6,7}. 무가중치 그리디(아직 덮지 않은 원소를 가장 많이 덮는 집합)를 적용할 때 선택 순서는?', '-', 14),
(150, 'OBJECTIVE', '다음 설명으로 옳은 것은?', 'U={a,b,c,d,e}, A={a,b,c}(비용3), B={c,d,e}(비용2), C={a,e}(비용1). 가중치 그리디(단위 비용당 신규 커버 수 최대)를 처음 적용할 때 선택은?', '-', 14),
(151, 'SUBJECTIVE', '빈칸에 들어갈 말은?', '가중치가 있을 때 그리디는 매 단계 _____가 최대인 집합을 고른다.', '신규 커버 수/비용', 14),
(152, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '무가중치 Set Cover에 대한 고전적 그리디 알고리즘의 근사 보장은?', '-', 14),

-- Unit12 - BFS, DFS
(153, 'OBJECTIVE', '다음 설명으로 옳은 것은?', 'DFS(깊이 우선 탐색)와 BFS(너비 우선 탐색)의 가장 중요한 차이점은?', '-', 15),
(154, 'OBJECTIVE', '다음 설명으로 옳은 것은?', 'BFS(너비 우선 탐색)에서 일반적으로 사용하는 자료구조는?', '-', 15),
(155, 'SUBJECTIVE', '빈칸에 들어갈 말은?', 'DFS(깊이 우선 탐색)에서는 일반적으로 _____나 재귀호출을 사용한다.', '스택', 15),
(156, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '가중치가 없는 그래프에서 최단 경로를 찾기에 적합한 알고리즘은?', '-', 15),
(157, 'SUBJECTIVE', '빈칸에 들어갈 말은?', 'DFS와 BFS 모두 그래프 탐색 시 무한루프를 방지하기 위해 노드의 _____ 여부를 반드시 검사해야 한다.', '방문, 탐색, 검사', 15),
(158, 'OBJECTIVE', '다음 설명으로 옳은 것은?', 'DFS의 주요 특징이 아닌 것은?', '-', 15),
(159, 'OBJECTIVE', '다음 설명으로 옳은 것은?', 'BFS가 DFS보다 유리한 상황은?', '-', 15),
(160, 'OBJECTIVE', '다음 설명으로 옳은 것은?', 'V개의 정점과 E개의 간선을 가진 그래프에서 BFS의 시간복잡도는?', '-', 15),
(161, 'OBJECTIVE', '다음 설명으로 옳은 것은?', 'V개의 정점과 E개의 간선을 가진 그래프에서 DFS의 시간복잡도는?', '-', 15),

-- Unit13 - Dynamic Programming
(162, 'SUBJECTIVE', '빈칸에 들어갈 말은?', '동적 프로그래밍(DP)에서 한 번 계산된 결과를 저장해 두었다가, 같은 문제가 호출되었을 때 저장된 결과를 사용하는 기법을 _____이라고 한다.', '메모이제이션, memoization', 16),
(163, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '동적 프로그래밍(DP)이 적용되기 위한 필수 조건이 아닌 것은?', '-', 16),
(164, 'SUBJECTIVE', '빈칸에 들어갈 말은?', '피보나치 수열에서 F(n) = F(n-1) + F(n-2)와 같은 수식을 _____식이라고 한다.', '점화', 16),
(165, 'SUBJECTIVE', '빈칸에 들어갈 말은?', 'Top-down 방식은 재귀 함수와 메모이제이션을 사용하고 Bottom-up 방식은 _____문을 사용한다.', '반복', 16),
(166, 'SUBJECTIVE', '빈칸에 들어갈 말은?', '동적 프로그래밍(DP)에서 작은 문제들의 최적해가 큰 문제의 최적해에 포함되는 성질을 _____ _____구조라고 한다.', '최적 부분, 최적부분', 16),
(167, 'SUBJECTIVE', '빈칸에 들어갈 말은?', '용량이 13인 배낭에 무게와 가치가 각각 (3,6), (4,8), (5,9), (6,11), (2,4), (4,7)인 물건들이 있을 때, 최적해에서 선택되는 물건의 개수는?', '4개', 16),
(168, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '편집 거리 문제에서 문자열 길이가 각각 m, n일 때 2차원 DP 테이블의 크기와 시간복잡도는?', '-', 16),
(169, 'SUBJECTIVE', '빈칸에 들어갈 말은?', '최장 증가 부분 수열(LIS) 문제에서 배열 [1, 3, 2, 5, 4, 7, 6, 8]의 LIS 길이는?', '5', 16),
(170, 'SUBJECTIVE', '빈칸에 들어갈 말은?', '동적 프로그래밍을 적절히 사용하면 지수 시간복잡도를 _____ 시간복잡도로 개선할 수 있다.', '다항식', 16),

-- Unit14 - 다익스트라 알고리즘
(171, 'SUBJECTIVE', '빈칸에 들어갈 말은?', '다익스트라 알고리즘은 _____의 가중치가 없는 그래프의 한 정점에서 모든 정점까지의 최단 경로를 구하는 알고리즘이다.', '음, -', 17),
(172, 'SUBJECTIVE', '빈칸에 들어갈 말은?', '다익스트라 알고리즘의 메커니즘은 방문하지 않은 정점 중에서 가장 적은 비용의 정점을 선택한다는 점에서 _____ 알고리즘의 성질을 가지고 있다고 볼 수 있다.', '그리디', 17),
(173, 'SUBJECTIVE', '빈칸에 들어갈 말은?', '다익스트라 알고리즘의 메커니즘은 선택된 노드로부터 갈 수 있는 노드들의 비용을 갱신한다는 점에서 _____의 성질을 가지고 있다고 볼 수 있다.', 'dp, dynamic programming, 디피, 동적 계획법, 동적 프로그래밍', 17),
(174, 'SUBJECTIVE', '빈칸에 들어갈 말은?', '다익스트라 알고리즘에서 거리 배열을 초기화할 때, 출발점은 0으로 나머지 정점들은 _____로 설정한다.', '무한대, inf, ∞', 17),
(175, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '5개 노드로 구성된 완전 그래프에서 다익스트라 알고리즘을 수행할 때, 최대 몇 번의 거리 갱신 연산이 발생할 수 있는가?', '-', 17),
(176, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '정점의 개수가 V, 간선의 개수가 E일 때 우선순위 큐를 사용한 다익스트라 알고리즘의 시간복잡도는?', '-', 17),
(177, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '정점의 개수가 V, 간선의 개수가 E일 때 선형탐색(반복문)을 사용한 다익스트라 알고리즘의 시간복잡도는?', '-', 17),
(178, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '다익스트라 알고리즘이 음수 간선이 있는 그래프에서 올바르게 동작하지 않는 이유는?', '-', 17),
(179, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '정점 5개, 간선 8개인 그래프에서 우선순위 큐(중복 허용)를 사용한 다익스트라 실행 시 우선순위 큐의 최대 크기는?', '-', 17),

-- Unit15 - 벨먼-포드 알고리즘
(180, 'SUBJECTIVE', '빈칸에 들어갈 말은?', '벨먼-포드 알고리즘과 다익스트라 알고리즘의 가장 중요한 차이점은?', '벨먼-포드는 음수 간선을 처리할 수 있다', 18),
(181, 'OBJECTIVE', '다음 설명으로 옳은 것은?', 'V개의 정점과 E개의 간선을 갖고 있는 그래프에서 벨먼-포드 알고리즘의 시간복잡도는?', '-', 18),
(182, 'OBJECTIVE', '다음 설명으로 옳은 것은?', 'V개의 정점을 갖고 있는 그래프에서 벨먼-포드 알고리즘은 최단 거리를 구하기 위해 모든 간선을 확인하는 과정을 몇 번 반복하는가?', '-', 18),
(183, 'OBJECTIVE', '다음 설명으로 옳은 것은?', 'V개의 정점을 갖고 있는 그래프에서 벨먼-포드 알고리즘으로 음수 사이클을 감지하는 방법은?', '-', 18),
(184, 'SUBJECTIVE', '빈칸에 들어갈 말은?', '벨먼-포드 알고리즘은 매 단계마다 모든 _____를 확인하여 거리를 갱신한다.', '간선, edge', 18),
(185, 'OBJECTIVE', '다음 설명으로 옳은 것은?', '음수 사이클이 존재하는 그래프에서 벨먼-포드 알고리즘의 결과는?', '-', 18);

INSERT INTO option (id, content, explanation, is_answer, problem_id) VALUES

-- Chapter 1

-- Unit01
-- 문제 6
(1, 'null', 'null은 넣을 수 없어요', false, 6),
(2, '-1', '음수 인덱스는 불가능해요', false, 6),
(3, '0', '배열의 첫 인덱스는 0이에요', true, 6),
(4, '1', '1부터 시작하지 않아요', false, 6),

-- 문제 7
(5, '언더플로우', '언더플로우는 메모리 부족 시 발생해요', false, 7),
(6, '오버플로우', '오버플로우는 범위 초과 접근 시 발생해요', true, 7),
(7, '타입 에러', '타입 에러는 자료형 불일치 에러예요', false, 7),
(8, '널포인터 에러', '널 포인터 에러는 포인터 관련 에러예요', false, 7),

-- 문제 8
(9, '행과 열', '행 번호와 열 번호를 나타내요', true, 8),
(10, '열과 행', '올바른 순서는 행과 열이에요', false, 8),
(11, '인덱스와 값', '인덱스를 의미하는 것은 맞지만 값은 아니에요', false, 8),
(12, '값과 인덱스', '인덱스를 의미하는 것은 맞지만 값은 아니에요', false, 8),

-- 문제 9
(13, '행 우선', '행을 먼저 채워나가는 방식이에요', true, 9),
(14, '열 우선', '열을 먼저 채우는 방식이에요', false, 9),
(15, '대각선 우선', '일반적이지 않은 방식이에요', false, 9),
(16, '임의 순서', '규칙이 없는 방식이에요', false, 9),

-- 문제 10
(17, 'O(1)', '상수 시간에 바로 접근 가능해요', true, 10),
(18, 'O(log n)', '이진 탐색의 시간복잡도예요', false, 10),
(19, 'O(n)', '전체 탐색의 시간복잡도예요', false, 10),
(20, 'O(n²)', '이중 반복문의 시간복잡도예요', false, 10),

-- 문제 11
(21, 'O(1)', '상수 시간은 불가능해요', false, 11),
(22, 'O(log n)', '이진 탐색 시 가능해요', false, 11),
(23, 'O(n)', '모든 요소를 확인해야 해요', true, 11),
(24, 'O(n²)', '이중 반복문이 아니에요', false, 11),

-- Unit02
-- 문제 14
(25, '데이터, 포인터', '노드의 기본 구성 요소예요', true, 14),
(26, '인덱스, 데이터', '인덱스와 포인터는 배열에서 사용되는 개념이에요', false, 14),
(27, '데이터, 인덱스', '인덱스라는 개념은 연결리스트에서 존재하지 않아요', false, 14),
(28, '포인터, 데이터', '올바른 순서는 데이터와 포인터에요', false, 14),

-- 문제 15
(29, '마지막 노드 가리킴', '마지막 노드를 가리키는 것은 테일 노드의 역할이에요', false, 15),
(30, '첫번째 노드 가리킴', '첫번째 노드를 가리키는 것은 헤드노드의 올바른 역할이에요', true, 15),
(31, '중간 노드 가리킴', '특정 중간 노드는 아니에요', false, 15),
(32, '모든 노드 가리킴', '하나의 노드만 가리켜요', false, 15),

-- 문제 17
(33, '연속적인', '배열의 특징이에요', false, 17),
(34, '불연속적인', '연결리스트의 노드들은 메모리상에서 불연속적인 위치에 저장돼요', true, 17),
(35, '고정된', '메모리 상에서 고정적으로 위치하지 않아요', false, 17),
(36, '정렬된', '저장 위치와는 다른 개념이에요', false, 17),

-- 문제 19
(37, 'null', '일반 연결리스트에서의 특징이에요', false, 19),
(38, '이전 노드', '이전 노드는 단일 연결리스트에는 존재하지 않는 개념이에요', false, 19),
(39, '헤드노드', '테일 노드는 원형 단일 연결리스트에서 헤드노드를 가리켜요', true, 19),
(40, '중간 노드', '테일 노드는 임의의 중간 노드를 가리키지 않아요 ', false, 19),

-- 문제 22
(41, '데이터 중복', '중복 저장하지 않아요', false, 22),
(42, '포인터', '추가 포인터 저장이 필요해요', true, 22),
(43, '인덱스', '인덱스를 저장하지 않아요', false, 22),
(44, '캐시미스', '메모리 사용량과는 다른 문제예요', false, 22),

-- 문제 23
(45, 'O(1)', '헤드 포인터만 새 노드로 변경하면 되므로 상수 시간이에요', true, 23),
(46, 'O(log n)', 'O(log n)은 이진 탐색과 같은 분할 정복 알고리즘의 시간복잡도에요', false, 23),
(47, 'O(n)', '맨 앞 삽입은 전체 리스트를 탐색할 필요가 없어요', false, 23),
(48, 'O(n²)', 'O(n²)는 이중 반복문을 사용하는 알고리즘의 시간복잡도에요', false, 23),

-- 문제 24
(49, 'O(n)', '특정 값을 찾기 위해 처음부터 순회해야 하므로 선형 시간이에요', true, 24),
(50, 'O(log n)', '연결리스트는 이진 탐색이 불가능하므로 O(log n)이 될 수 없어요', false, 24),
(51, 'O(1)', '삭제할 노드를 먼저 찾는 과정이 필요하므로 상수 시간이 아니에요', false, 24),
(52, 'O(n²)', 'O(n²)는 이중 반복문을 사용하는 알고리즘의 시간복잡도에요', false, 24),

-- Unit03
-- 문제 29
(53, '2개', '삽입할 위치의 앞뒤 노드의 포인터만 수정하면 되므로 2개에요', true, 29),
(54, '3개', '양방향 연결리스트에서는 2개의 포인터만 수정하면 돼요', false, 29),
(55, '4개', '양방향 연결리스트에서는 2개의 포인터만 수정하면 돼요', false, 29),
(56, '5개', '양방향 연결리스트에서는 2개의 포인터만 수정하면 돼요', false, 29),

-- 문제 30
(57, '2개', '삭제할 노드의 앞뒤 노드를 서로 연결하기 위해 2개 포인터를 수정해요', true, 30),
(58, '3개', '양방향 연결리스트에서는 2개의 포인터만 수정하면 돼요', false, 30),
(59, '4개', '양방향 연결리스트에서는 2개의 포인터만 수정하면 돼요', false, 30),
(60, '5개', '양방향 연결리스트에서는 2개의 포인터만 수정하면 돼요', false, 30),

-- 문제 31
(61, 'O(1)', '모든 노드를 방문하려면 상수 시간으로는 불가능해요', false, 31),
(62, 'O(log n)', 'O(log n)은 이진 탐색과 같은 분할 정복 알고리즘의 시간복잡도에요', false, 31),
(63, 'O(n)', '모든 노드를 한 번씩 방문해야 하므로 노드 수에 비례하는 선형 시간이에요', true, 31),
(64, 'O(n²)', 'O(n²)는 이중 반복문을 사용하는 알고리즘의 시간복잡도에요', false, 31),

-- 문제 32
(65, 'O(1)', '테일 포인터를 통해 마지막 노드에 직접 접근할 수 있어서 상수 시간이에요', true, 32),
(66, 'O(log n)', '테일 포인터가 있으면 탐색 과정이 필요하지 않아요', false, 32),
(67, 'O(n)', '테일 포인터가 있으면 전체 리스트를 순회할 필요가 없어요', false, 32),
(68, 'O(n²)', 'O(n²)는 이중 반복문을 사용하는 알고리즘의 시간복잡도에요', false, 32),

-- 문제 33
(69, '스택', '스택은 양방향 연결리스트로 쉽게 구현할 수 있어요', false, 33),
(70, '큐', '큐는 양방향 연결리스트로 쉽게 구현할 수 있어요', false, 33),
(71, '덱', '덱은 양방향 연결리스트로 쉽게 구현할 수 있어요', false, 33),
(72, '힙', '힙은 완전 이진 트리 구조가 필요해서 연결리스트로는 구현이 어려워요', true, 33),

-- Unit04
-- 문제 34
(73, '3', '3은 가장 먼저 들어갔으므로 가장 아래에 있어요', false, 34),
(74, '5', '5는 두 번째로 들어갔으므로 위에서 세 번째에 있어요', false, 34),
(75, '1', '1은 세 번째로 들어갔으므로 위에서 두 번째에 있어요', false, 34),
(76, '2', '2는 가장 마지막에 들어갔으므로 스택의 맨 위에 있어요', true, 34),

-- 문제 36
(77, '맨 아래', '스택은 LIFO 구조라 맨 아래 원소에는 직접 접근할 수 없어요', false, 36),
(78, '맨 위', '스택은 LIFO 구조라 항상 맨 위 원소(top)만 접근 가능해요', true, 36),
(79, '가운데', '스택은 중간 원소에 직접 접근할 수 없어요', false, 36),
(80, '임의', '스택은 임의의 위치에 있는 원소에 직접 접근할 수 없어요', false, 36),

-- 문제 38
(81, '-999', '-999는 임의의 값으로 top 초기값으로 사용하지 않아요', false, 38),
(82, '-1', '빈 스택을 나타내기 위해 top을 -1로 초기화해요', true, 38),
(83, '0', '0은 첫 번째 원소가 들어있을 때의 top 값이에요', false, 38),
(84, '1', '1은 두 번째 원소가 들어있을 때의 top 값이에요', false, 38),

-- 문제 39
(85, '1개', '새 노드의 next와 head 포인터 두 개가 변경되어야 해요', false, 39),
(86, '2개', '새 노드의 next 포인터와 head 포인터 총 2개가 변경돼요', true, 39),
(87, '3개', '연결리스트 스택에서는 2개의 포인터만 변경하면 돼요', false, 39),
(88, '4개', '연결리스트 스택에서는 2개의 포인터만 변경하면 돼요', false, 39),

-- 문제 40
(89, '1개', 'head 포인터만 다음 노드로 이동시키면 되므로 1개에요', true, 40),
(90, '2개', '삭제 시에는 head 포인터만 변경하면 돼요', false, 40),
(91, '3개', '삭제 시에는 head 포인터만 변경하면 돼요', false, 40),
(92, '4개', '삭제 시에는 head 포인터만 변경하면 돼요', false, 40),

-- 문제 41
(93, '11', '"3 4 +"는 7이고, 7과 2를 연산하면 14가 아닌 9나 14가 나와요', false, 41),
(94, '7', '3과 4를 더하면 7이고, 연산자가 없으므로 최종 스택 상단 값은 7이에요', true, 41),
(95, '10', '"3 4 +"는 7이고, 7과 2를 곱하면 14예요', false, 41),
(96, '24', '"3 4 +"는 7이고, 7과 2를 곱해도 14예요', false, 41),

-- 문제 42
(97, '12', '5-3=2, 2+4=6, 따라서 2*6=12', true, 42),
(98, '10', '계산 순서를 다시 확인해보세요', false, 42),
(99, '8', '계산 순서를 다시 확인해보세요', false, 42),
(100, '6', '계산 순서를 다시 확인해보세요', false, 42),

-- 문제 43
(101, 'O(1)', '스택의 모든 기본 연산은 맨 위 원소만 다루므로 상수 시간이에요', true, 43),
(102, 'O(log n)', 'O(log n)은 이진 탐색과 같은 분할 정복 알고리즘의 시간복잡도에요', false, 43),
(103, 'O(n)', '스택의 기본 연산은 전체 원소를 순회할 필요가 없어요', false, 43),
(104, 'O(n²)', 'O(n²)는 이중 반복문을 사용하는 알고리즘의 시간복잡도에요', false, 43),

-- Unit05
-- 문제 44
(105, '2', '큐는 FIFO 구조라 가장 먼저 들어간 2가 먼저 나와요', true, 44),
(106, '9', '9는 두 번째로 들어간 원소라 두 번째로 나와요', false, 44),
(107, '7', '7은 세 번째로 들어간 원소라 세 번째로 나와요', false, 44),
(108, '4', '4는 가장 마지막에 들어간 원소라 마지막에 나와요', false, 44),

-- 문제 46
(109, '낭비되는 공간을 재사용하기 위해', '선형 배열에서는 앞쪽 빈 공간을 활용하기 위해 원형 구조를 써요', true, 46),
(110, '삽입/삭제 연산 속도를 높이기 위해', '원형 구조 자체가 연산 속도를 높이지는 않아요', false, 46),
(111, '메모리 할당을 동적으로 하기 위해', '원형 구조는 동적 할당과는 관련이 없어요', false, 46),
(112, '데이터의 순서를 보장하기 위해', '큐 자체가 FIFO로 순서를 보장하므로 원형 구조와는 별개예요', false, 46),

-- 문제 47
(113, '0, 0', '일반적으로 tail과 front가 같은 값으로 초기화되지 않아요', false, 47),
(114, '0, 1', '이 조합은 일반적인 초기화 방식이 아니에요', false, 47),
(115, 'n-1, 0', '빈 큐에서 tail은 n-1, front는 0으로 초기화하는 것이 일반적이에요', true, 47),
(116, 'n, 0', 'n은 배열 크기를 벗어나는 인덱스라 사용할 수 없어요', false, 47),

-- 문제 50
(117, 'tail -> next가 front를 가리키기 때문', '원형 구조에서 tail의 next가 front를 가리켜 두 포인터 역할을 해요', true, 50),
(118, 'front 개념이 존재하지 않음', '큐에서는 front 개념이 반드시 필요해요', false, 50),
(119, 'tail 포인터가 더 빠른 접근을 제공', '접근 속도는 같으므로 이것이 이유가 아니에요', false, 50),
(120, '연산 속도가 더 빠름', '포인터 개수와 연산 속도는 직접적인 관련이 없어요', false, 50),

-- 문제 53
(121, 'a, b', '문자열의 앞쪽 절반인 a, b만 스택에 저장해서 뒤쪽과 비교해요', true, 53),
(122, 'a, b, b, a', '모든 문자를 저장하면 비교가 불가능해요', false, 53),
(123, 'b, b', '중간 문자들만 저장하는 것은 올바른 방법이 아니에요', false, 53),
(124, 'a, a', '같은 문자만 저장해서는 회문 검사를 할 수 없어요', false, 53),

-- Unit06
-- 문제 59
(125, '2k', '배열 인덱스가 1부터 시작할 때의 공식이에요', false, 59),
(126, '2k+1', '배열 인덱스가 0부터 시작할 때 왼쪽 자식은 2k+1, 오른쪽은 2k+2예요', true, 59),
(127, '2k-1', '이 공식은 부모-자식 관계에 맞지 않아요', false, 59),
(128, '2k-2', '이 공식은 부모-자식 관계에 맞지 않아요', false, 59),

-- 문제 60
(129, '(k-1) / 2의 올림', '올림이 아니라 내림(버림)을 사용해야 해요', false, 60),
(130, '(k-2) / 2의 올림', '공식이 틀렸어요', false, 60),
(131, '(k-1) / 2의 내림', '배열 인덱스가 0부터 시작할 때 부모 인덱스는 (k-1)/2의 내림이에요', true, 60),
(132, '(k-2) / 2의 내림', '공식이 틀렸어요', false, 60),

-- 문제 62
(133, '1번', '12가 루트까지 올라가려면 더 많은 교환이 필요해요', false, 62),
(134, '2번', '12가 루트까지 올라가려면 한 번 더 교환이 필요해요', false, 62),
(135, '3번', '12는 최댓값이므로 루트까지 올라가는데 3번의 교환이 필요해요', true, 62),
(136, '4번', '힙의 높이를 고려하면 3번의 교환으로 충분해요', false, 62),

-- 문제 63
(137, '1번', '14가 적절한 위치까지 올라가려면 더 많은 교환이 필요해요', false, 63),
(138, '2번', '14는 15보다 작으므로 2번의 교환 후 적절한 위치에 도달해요', true, 63),
(139, '3번', '14는 루트까지 올라갈 필요가 없으므로 2번이면 충분해요', false, 63),
(140, '0번', '14는 삽입 위치에서 이동이 필요해요', false, 63),

-- Unit07
-- 문제 66
(141, 'O(1)', '해시 테이블의 이상적인 경우 모든 기본 연산이 상수 시간에 수행돼요', true, 66),
(142, 'O(log n)', '해시 테이블은 이진 탐색보다 빠른 상수 시간을 목표로 해요', false, 66),
(143, 'O(n)', '충돌이 많이 발생하는 최악의 경우에만 O(n)이 돼요', false, 66),
(144, 'O(n²)', 'O(n²)는 해시 테이블의 일반적인 시간복잡도가 아니에요', false, 66),

-- 문제 68
(145, '적재율', '전체 크기 대비 저장된 원소의 비율을 적재율(load factor)이라고 해요', true, 68),
(146, '충돌율', '충돌율은 충돌이 발생하는 빈도를 나타내는 별개의 개념이에요', false, 68),
(147, '성공률', '성공률은 탐색 성공 확률을 나타내는 별개의 개념이에요', false, 68),
(148, '이용률', '이용률보다는 적재율이 정확한 용어예요', false, 68),

-- 문제 70
(149, 'O(1)', '최악의 경우 모든 원소가 한 체인에 연결되면 O(n)이 돼요', false, 70),
(150, 'O(log n)', '체이닝에서는 연결리스트를 순차 탐색하므로 O(log n)이 아니에요', false, 70),
(151, 'O(n)', '모든 원소가 같은 해시값을 가져 한 체인에 연결되면 O(n)이에요', true, 70),
(152, 'O(n²)', '체이닝의 최악 시간복잡도는 O(n)이에요', false, 70),

-- 문제 72
(153, '선형 탐사법', '충돌 시 h(k)+1, h(k)+2... 순으로 빈 슬롯을 찾는 방식이에요', true, 72),
(154, '이차 탐사법', '이차 탐사법은 h(k)+1², h(k)+2²... 형태로 탐색해요', false, 72),
(155, '이중 해싱', '이중 해싱은 두 개의 서로 다른 해시 함수를 사용해요', false, 72),
(156, '랜덤 탐사법', '랜덤 탐사법은 임의의 위치를 탐색하는 방식이에요', false, 72),

-- 문제 73
(157, '선형 탐사법', '선형 탐사법은 +1, +2, +3... 형태로 선형적으로 탐색해요', false, 73),
(158, '이차 탐사법', '충돌 시 h(k)+1², h(k)+2², h(k)+3²... 형태로 탐색하는 방식이에요', true, 73),
(159, '이중 해싱', '이중 해싱은 두 개의 해시 함수를 조합해서 사용해요', false, 73),
(160, '랜덤 탐사법', '랜덤 탐사법은 임의의 위치를 탐색하는 방식이에요', false, 73),

-- 문제 74
(161, '선형 탐사법', '선형 탐사법은 고정된 간격으로 탐색해요', false, 74),
(162, '이차 탐사법', '이차 탐사법은 제곱 형태의 간격으로 탐색해요', false, 74),
(163, '이중 해싱', '두 개의 서로 다른 해시 함수를 사용해서 충돌을 해결하는 방식이에요', true, 74),
(164, '랜덤 탐사법', '랜덤 탐사법은 임의의 위치를 탐색하는 방식이에요', false, 74),

-- 문제 75
(165, '1차 군집', '선형 탐사법에서 연속된 슬롯이 채워지며 데이터가 뭉치는 현상이에요', true, 75),
(166, '2차 군집', '2차 군집은 이차 탐사법에서 발생하는 현상이에요', false, 75),
(167, '해시 충돌', '해시 충돌은 같은 해시값이 나오는 현상으로 군집과는 다른 개념이에요', false, 75),
(168, '로드 팩터', '로드 팩터는 적재율을 나타내는 지표로 군집과는 다른 개념이에요', false, 75),

-- 문제 76
(169, '메모리 사용량이 증가한다', '1차 군집은 메모리 사용량이 아닌 탐색 시간에 영향을 줘요', false, 76),
(170, '평균 탐색 시간이 길어진다', '군집이 형성되면 빈 슬롯을 찾기까지 더 많은 탐색이 필요해요', true, 76),
(171, '해시 함수의 성능이 저하된다', '해시 함수 자체의 성능은 변하지 않아요', false, 76),
(172, '적재율이 감소한다', '1차 군집은 적재율과는 직접적인 관련이 없어요', false, 76),

-- Chapter 2

-- Unit08
-- 문제 105
(173, '버블정렬', '버블정렬은 인접한 원소만 교환하므로 안정해요', false, 105),
(174, '선택정렬', '멀리 떨어진 원소를 교환하므로 불안정해요', true, 105),
(175, '삽입정렬', '이미 정렬된 부분에 삽입하므로 안정해요', false, 105),
(176, '병합정렬', '같은 값이면 왼쪽 배열 먼저 선택하므로 안정해요', false, 105),

-- 문제 106
(177, '선택정렬', '항상 모든 원소를 비교하므로 Θ(n²)이에요', false, 106),
(178, '퀵정렬', '피벗 위치에 따라 다르지만 기본적으로 Θ(n²)이에요', false, 106),
(179, '삽입정렬', '이미 정렬되면 각 원소마다 한 번씩만 비교해서 Θ(n)이에요', true, 106),
(180, '힙정렬', '힙 구성과 추출 과정이 항상 필요해서 Θ(n log n)이에요', false, 106),

-- 문제 107
(181, 'Θ(n²)', '첫째 자리부터 (n-1) + (n-2) + ... + 1 = n(n-1)/2번 비교해요', true, 107),
(182, 'Θ(n log n)', '분할정복이 아니므로 log n 요인이 없어요', false, 107),
(183, 'Θ(n)', '각 자리마다 남은 모든 원소를 확인해야 해요', false, 107),
(184, 'Θ(1)', '모든 원소를 비교해야 하므로 상수시간이 불가능해요', false, 107),

-- 문제 108
(185, '버블정렬', '최악의 경우 O(n²)번 교환해요', false, 108),
(186, '선택정렬', '각 자리마다 최대 1번씩만 교환하므로 총 n-1번이에요', true, 108),
(187, '퀵정렬', '파티션 과정에서 O(n²)번 교환 가능해요', false, 108),
(188, '힙정렬', '힙 조정 과정에서 여러 번 교환해요', false, 108),

-- 문제 109
(189, '처음 i개가 정렬됨', '뒤에서부터 정렬되는 것이 버블정렬의 특징이에요', false, 109),
(190, '중간 i개가 정렬됨', '버블정렬은 특정 위치부터 정렬되는 게 아니에요', false, 109),
(191, '마지막 i개가 정렬됨', '큰 원소가 뒤로 이동해서 끝부분부터 정렬돼요', true, 109),
(192, '모든 원소가 섞임', 'i번째 패스 후에는 일부 구간이 정렬 상태에요', false, 109),

-- 문제 110
(193, '삽입정렬', '앞부분을 항상 정렬된 상태로 유지하며 새 원소를 삽입해요', true, 110),
(194, '선택정렬', '가장 작은 원소를 찾아 앞으로 보내는 방식이에요', false, 110),
(195, '버블정렬', '인접한 원소들을 교환하며 정렬해요', false, 110),
(196, '병합정렬', '분할 후 병합하는 방식으로 전체를 처리해요', false, 110),

-- 문제 111
(197, 'O(d + k + n)', '각 자리마다 n개 원소를 k개 버킷으로 분류해요', false, 111),
(198, 'O(d(n + k))', 'd번 반복하며 각 자리마다 O(n + k) 시간이 걸려요', true, 111),
(199, 'O(n log k)', '기수정렬은 비교 기반이 아니므로 log 요인이 없어요', false, 111),
(200, 'O(d × n × k)', '버킷 정렬 과정이 O(n + k)이므로 곱셈이 아니에요', false, 111),

-- 문제 112
(201, '안정성(stability)', '이전 자리의 순서를 유지해야 전체 정렬이 올바르게 돼요', true, 112),
(202, '제자리성(in-place)', '기수정렬은 추가 공간을 사용해도 돼요', false, 112),
(203, '적응성(adaptive)', '입력 상태와 관계없이 모든 자리를 처리해요', false, 112),
(204, '비교기반', '기수정렬은 원소 값을 직접 비교하지 않아요', false, 112),

-- 문제 113
(205, '[1, 5, 4, 2]', '한 패스로는 모든 교환이 완료되지 않아요', false, 113),
(206, '[5, 4, 2, 1]', '역순으로 정렬되지 않아요', false, 113),
(207, '[1, 2, 4, 5]', '한 패스로는 완전 정렬되지 않아요', false, 113),
(208, '[1, 4, 2, 5]', '5→1→4: [1,5,4,2], 5→4: [1,4,5,2], 5→2: [1,4,2,5]', true, 113),

-- 문제 114
(209, '배열 크기', '배열 크기보다는 순서 관계가 중요해요', false, 114),
(210, '역순쌍 개수', '뒤바뀐 순서쌍만큼 원소를 이동시켜야 해요', true, 114),
(211, '최댓값', '최댓값과는 직접적인 관련이 없어요', false, 114),
(212, '중복 원소 수', '중복 원소 개수와는 관련이 적어요', false, 114),

-- 문제 115
(213, '삽입정렬', '거의 정렬되면 O(n)에 가깝고 구현이 간단해요', true, 115),
(214, '퀵정렬', '이미 정렬된 데이터에서 성능이 떨어질 수 있어요', false, 115),
(215, '힙정렬', '작은 데이터에는 오버헤드가 커요', false, 115),
(216, '병합정렬', '추가 메모리가 필요하고 작은 데이터에는 과한 면이 있어요', false, 115),

-- 문제 116
(217, '퀵정렬', '제자리 정렬로 O(1) 추가 메모리만 필요해요', false, 116),
(218, '힙정렬', '제자리 정렬로 O(1) 추가 메모리만 필요해요', false, 116),
(219, '계수정렬', '값 범위만큼 카운팅 배열이 필요해서 O(k) 공간 사용해요', true, 116),
(220, '삽입정렬', '제자리 정렬로 O(1) 추가 메모리만 필요해요', false, 116),

-- Unit09
-- 문제 117
(221, '병합정렬', '같은 값이면 왼쪽 배열을 먼저 선택해서 안정해요', true, 117),
(222, '퀵정렬', '파티션 과정에서 순서가 바뀔 수 있어요', false, 117),
(223, '힙정렬', '힙 조정 과정에서 멀리 떨어진 원소가 교환돼요', false, 117),
(224, '선택정렬', '최솟값을 찾아 교환할 때 순서가 바뀔 수 있어요', false, 117),

-- 문제 118
(225, '병합정렬', '병합 과정에서 O(n) 추가 배열이 필요해요', false, 118),
(226, '힙정렬', '배열을 힙으로 만들고 제자리에서 정렬해요', true, 118),
(227, '기수정렬', '버킷을 위한 추가 공간이 필요해요', false, 118),
(228, '계수정렬', '카운팅 배열을 위한 추가 공간이 필요해요', false, 118),

-- 문제 119
(229, '병합정렬', '항상 O(n log n) 시간복잡도를 보장해요', false, 119),
(230, '힙정렬', '항상 O(n log n) 시간복잡도를 보장해요', false, 119),
(231, '퀵정렬', '피벗이 계속 극값이면 분할이 불균등해져서 Θ(n²)가 돼요', true, 119),
(232, '기수정렬', '자릿수가 일정하면 항상 O(dn) 시간이에요', false, 119),

-- 문제 120
(233, '무작위 피벗 선택', '랜덤하게 피벗을 선택하면 최악 상황을 피할 수 있어요', true, 120),
(234, '첫 원소를 피벗으로', '정렬된 데이터에서 최악 성능을 보여요', false, 120),
(235, '마지막 원소를 피벗으로', '역순 정렬된 데이터에서 최악 성능을 보여요', false, 120),
(236, '가장 큰 값을 피벗으로', '극값을 피벗으로 하면 분할이 매우 불균등해져요', false, 120),

-- 문제 121
(237, 'O(n log n)', '각 원소를 하나씩 삽입하는 방법의 시간복잡도에요', false, 121),
(238, 'O(n)', '바닥부터 위로 올라가며 조정하면 선형 시간이 가능해요', true, 121),
(239, 'O(n²)', 'Floyd 방법은 더 효율적이에요', false, 121),
(240, 'O(log n)', '모든 원소를 처리해야 하므로 log n은 불가능해요', false, 121),

-- 문제 122
(241, '오름차순', '최대 힙에서는 큰 값부터 나와요', false, 122),
(242, '무작위 순서', '힙의 루트는 항상 최댓값이에요', false, 122),
(243, '내림차순', '최대 힙에서 루트(최댓값)을 계속 꺼내므로 큰 순서대로 나와요', true, 122),
(244, '삽입 순서', '힙에서는 삽입 순서와 추출 순서가 다를 수 있어요', false, 122),

-- 문제 123
(245, 'O(n)', '두 부분을 병합할 때 임시 배열이 필요해요', true, 123),
(246, 'O(log n)', '재귀 호출 스택은 O(log n)이지만 배열 공간은 더 필요해요', false, 123),
(247, 'O(n log n)', '입력 크기만큼의 추가 공간이면 충분해요', false, 123),
(248, 'O(1)', '제자리 정렬이 아니므로 상수 공간으로는 불가능해요', false, 123),

-- 문제 124
(249, '버블정렬 응용', '버블정렬로도 가능하지만 O(n²) 시간이 걸려요', false, 124),
(250, '병합정렬 응용', '병합 과정에서 O(n log n) 시간에 역순쌍을 셀 수 있어요', true, 124),
(251, '선택정렬 응용', '선택정렬로는 역순쌍을 효율적으로 세기 어려워요', false, 124),
(252, '삽입정렬 응용', '삽입정렬로도 가능하지만 최악의 경우 O(n²) 시간이에요', false, 124),

-- 문제 125
(253, 'p 왼쪽이 모두 정렬됨', '파티션 후에도 양쪽은 정렬되지 않은 상태에요', false, 125),
(254, 'p 오른쪽이 모두 정렬됨', '파티션 후에도 양쪽은 정렬되지 않은 상태에요', false, 125),
(255, 'p가 최종 위치에 있음', '파티션 후 피벗은 정렬 완료된 최종 위치에 있어요', true, 125),
(256, 'p가 최댓값임', '피벗이 반드시 최댓값일 필요는 없어요', false, 125),

-- 문제 126
(257, '외부 병합정렬', '디스크의 큰 파일을 작은 단위로 나눠 정렬 후 병합해요', true, 126),
(258, '퀵정렬', '메모리에서 수행하는 내부 정렬이에요', false, 126),
(259, '힙정렬', '메모리에서 수행하는 내부 정렬이에요', false, 126),
(260, '버블정렬', '메모리에서 수행하는 내부 정렬이고 효율성도 떨어져요', false, 126),

-- 문제 127
(261, 'O(log n), O(n)', '레벨별 작업량이 O(n), 높이가 O(log n)이에요', false, 127),
(262, 'O(n), O(log n)', '각 레벨에서 모든 원소를 한 번씩 처리하고 높이는 log n이에요', true, 127),
(263, 'O(n log n), O(n)', '총 작업량은 O(n log n)이지만 레벨별로는 O(n)이에요', false, 127),
(264, 'O(n²), O(log n)', '분할이 균등하면 레벨별 작업량이 O(n²)가 되지 않아요', false, 127),

-- 문제 128
(265, '멀리 떨어진 원소들이 교환됨', '힙 조정 과정에서 부모-자식 간 교환이 일어나요', true, 128),
(266, '비교 횟수가 많음', '비교 횟수와 안정성은 직접적인 관련이 없어요', false, 128),
(267, '재귀적으로 동작함', '재귀 여부와 안정성은 관련이 없어요', false, 128),
(268, '추가 메모리를 사용함', '힙정렬은 제자리 정렬이에요', false, 128),

-- Unit10
-- 문제 129
(269, '매 단계에서 지역 최적을 선택', '그 순간 가장 좋아 보이는 선택을 하는 것이 그리디의 핵심이에요', true, 129),
(270, '모든 경우를 탐색한다', '모든 경우를 살펴보는 것은 브루트 포스 방법이에요', false, 129),
(271, '이전 결과를 기억한다', '이전 결과를 기억하는 것은 동적 계획법의 특징이에요', false, 129),
(272, '재귀적으로 문제를 나눠', '재귀는 분할정복법의 특징이에요', false, 129),

-- 문제 132
(273, '배낭 문제', '0-1 배낭은 그리디로 최적해를 구할 수 없어요', false, 132),
(274, '최소 스패닝 트리', '그리디로 최소 비용의 스패닝 트리를 구할 수 있어요', true, 132),
(275, '최단 경로', '음수 가중치가 있으면 그리디로 해결할 수 없어요', false, 132),
(276, '함수 최적화', '단순한 그리디로는 복잡한 함수를 최적화하기 어려워요', false, 132),

-- 문제 133
(277, '10개', '더 큰 동전을 우선 사용하는 그리디가 최소개를 보장해요', false, 133),
(278, '12개', '더 효율적인 조합이 있어요', false, 133),
(279, '6개', '500원 1개 + 100원 2개 + 50원 1개 + 10원 1개 = 6개', true, 133),
(280, '8개', '더 효율적인 조합이 있어요', false, 133),

-- 문제 134
(281, '그리디: 4+1+1=3개, 최적: 3+3=2개', '큰 동전 우선 그리디는 3개, 최적은 2개에요', true, 134),
(282, '그리디: 3+3=2개, 최적: 4+1+1=3개', '그리디가 최적이 아닌 경우의 예시에요', false, 134),
(283, '둘 다 2개', '그리디와 최적해가 다를 수 있어요', false, 134),
(284, '둘 다 3개', '최적해는 2개에요', false, 134),

-- 문제 135
(285, '5원', '5원은 그리디(4+1), 최적(4+1) 모두 2개에요', false, 135),
(286, '6원', '6원은 그리디(4+1+1=3개), 최적(3+3=2개)로 처음 다르죠', true, 135),
(287, '7원', '6원에서 이미 실패해요', false, 135),
(288, '8원', '6원에서 이미 실패해요', false, 135),

-- 문제 136
(289, '모든 금액을 전수 탐색', '전수 탐색은 상대적으로 빠른 방법이 아니에요', false, 136),
(290, '확률적 검증', '확률적 방법보다 확실한 방법이 있어요', false, 136),
(291, '작은 범위에서 그리디 실패 사례 찾기', '작은 범위에서 그리디와 최적해를 비교하면 빠르게 확인 가능해요', true, 136),
(292, '수학적 증명', '수학적 증명은 빠른 방법이 아니에요', false, 136),

-- 문제 137
(293, '가치/무게 비율 내림차순', '단위 무게당 가치가 높은 물건부터 선택해요', true, 137),
(294, '가치 내림차순', '무게를 고려하지 않으면 최적이 아니에요', false, 137),
(295, '무게 오름차순', '가벼운 것부터 넣는 것만으로는 가치가 최대화되지 않아요', false, 137),
(296, '무게 내림차순', '무거운 것부터 넣는 것은 좋지 않은 전략이에요', false, 137),

-- 문제 138
(297, '34', '비율을 계산해 올바른 순서로 넣어야 해요', false, 138),
(298, '38', 'B(7), A(5), C(4) 비율 순으로: B전체+A전체+C일부 = 14+20+4 = 38', true, 138),
(299, '42', '모든 물건을 다 넣을 수는 없어요', false, 138),
(300, '30', '비율을 고려하지 않은 결과에요', false, 138),

-- 문제 139
(301, '항상 최적이다', '0-1 배낭에서는 그리디가 최적을 보장하지 않아요', false, 139),
(302, '대부분의 경우 최적이다', '대부분의 경우라는 보장은 없어요', false, 139),
(303, '예외가 있지만 거의 최적이다', '예외가 많이 있어요', false, 139),
(304, '아니다, 예외가 있다', '0-1 배낭에서 그리디는 최적을 보장하지 않아요', true, 139),

-- 문제 140
(305, '계산이 복잡해서', '계산 복잡도가 문제가 아니에요', false, 140),
(306, '물건을 나눠넣을 수 없어서', '물건을 통째로만 넣을 수 있어서 부분 최적이 전체 최적을 보장하지 않아요', true, 140),
(307, '가치가 너무 커서', '가치 크기가 문제가 아니에요', false, 140),
(308, '무게가 너무 다양해서', '무게 다양성이 문제가 아니에요', false, 140),

-- Unit11
-- 문제 141
(309, '시작 시간 오름차순', '시작 시간만 보면 끝 시간이 매우 늦을 수 있어요', false, 141),
(310, '길이 오름차순', '짧은 구간이 좋지만 끝 시간을 고려해야 해요', false, 141),
(311, '끝 시간 오름차순', '끝 시간이 빠른 구간부터 선택하면 최대 개수를 보장해요', true, 141),
(312, '중간 시간 오름차순', '중간 시간은 최적 기준이 아니에요', false, 141),

-- 문제 142
(313, '마감시간 오름차순', '마감시간이 빠른 작업부터 처리하면 지연을 최소화해요', true, 142),
(314, '작업시간 오름차순', '작업 시간보다 마감시간이 중요해요', false, 142),
(315, '이익 내림차순', '이익과 지연 최소화는 다른 목표에요', false, 142),
(316, '중요도 내림차순', '중요도보다 마감시간이 지연 최소화에 중요해요', false, 142),

-- Unit12
-- 문제 153
(317, '사용하는 자료구조', 'DFS는 스택(재귀), BFS는 큐를 사용해요', true, 153),
(318, '시간복잡도', '둘 다 O(V+E) 시간복잡도를 가져요', false, 153),
(319, '공간복잡도', '둘 다 비슷한 공간을 사용해요', false, 153),
(320, '응용 분야', '둘 다 그래프 탐색에 사용돼요', false, 153),

-- 문제 154
(321, '스택', '스택은 DFS에서 사용하는 자료구조에요', false, 154),
(322, '큐', 'BFS는 레벨별로 탐색하므로 큐를 사용해요', true, 154),
(323, '힙', '힙은 우선순위가 있는 탐색에 사용해요', false, 154),
(324, '트리', '트리는 자료구조이지 알고리즘 구현 도구가 아니에요', false, 154),

-- 문제 156
(325, 'BFS', '가중치가 없으면 BFS가 최단 경로를 보장해요', true, 156),
(326, 'DFS', 'DFS는 최단 경로를 보장하지 않아요', false, 156),
(327, '다익스트라', '가중치가 없으면 BFS가 더 간단해요', false, 156),
(328, '벨만-포드', '가중치가 없으면 BFS가 더 효율적이에요', false, 156),

-- Unit13
-- 문제 163
(329, '최적 부분 구조', '작은 문제의 최적해이 큰 문제의 최적해에 포함되어야 해요', false, 163),
(330, '중복되는 부분 문제', '같은 부분 문제가 여러 번 호출되어야 DP의 의미가 있어요', false, 163),
(331, '무메모리 성질', '과거의 결과가 현재 선택에 영향을 주지 않아야 해요', false, 163),
(332, '그래프 구조', '그래프 구조는 DP의 필수 조건이 아니에요', true, 163),

-- 문제 168
(333, '(m+1) × (n+1), O(mn)', '테이블 크기는 맞지만 시간복잡도 표기에 오류가 있어요', false, 168),
(334, '(m+1) × (n+1), O(m × n)', '빈 문자열을 포함하여 (m+1) × (n+1) 크기이고 O(mn) 시간이 걸려요', true, 168),
(335, 'm × n, O(m + n)', '테이블에서 빈 문자열 경우를 고려해야 해요', false, 168),
(336, 'm × n, O(mn²)', '시간복잡도가 과대예상돼어요', false, 168),

-- Unit14
-- 문제 175
(337, '8번', '완전 그래프에서는 더 많은 갱신이 일어날 수 있어요', false, 175),
(338, '12번', '완전 그래프에서는 모든 노드 쌍이 연결돐어 있어요', false, 175),
(339, '10번', '5개 노드 완전 그래프에서는 최대 10번의 갱신이 가능해요', true, 175),
(340, '16번', '간선 수보다 많은 갱신이 일어날 수는 없어요', false, 175),

-- 문제 176
(341, 'O((V+E) log V)', '우선순위 큐 사용 시 표준 시간복잡도에요', true, 176),
(342, 'O(V²)', '우선순위 큐가 아닌 선형 탐색 시의 시간복잡도에요', false, 176),
(343, 'O(E log V)', '방문 처리도 고려해야 해요', false, 176),
(344, 'O(V log E)', '정점과 간선 모두 처리해야 해요', false, 176),

-- Unit15
-- 문제 181
(345, 'O(VE)', '정점 수만큼 반복하는 과정이 빠졌어요', false, 181),
(346, 'O(V × E)', 'V-1번 반복하며 매번 E개 간선을 확인해요', true, 181),
(347, 'O(V²)', '간선 수도 고려해야 해요', false, 181),
(348, 'O(E log V)', '우선순위 큐를 사용하지 않아요', false, 181),

-- 문제 182
(349, 'V-1번', '최대 V-1번의 간선 이완이 있으므로 V-1번 반복해요', true, 182),
(350, 'V번', 'V-1번의 이완만 고려하면 돼요', false, 182),
(351, 'E번', '간선 수와는 관련이 없어요', false, 182),
(352, 'log V번', '로그 시간이 아니에요', false, 182),

-- 문제 183
(353, '초기에 음수 간선 확인', '간선의 음수 여부만으로는 사이클을 알 수 없어요', false, 183),
(354, 'DFS로 사이클 탐지', '벨만-포드 내에서 해결할 수 있어요', false, 183),
(355, 'V번째 라운드에서 업데이트 발생 여부 확인', 'V-1번 후에도 업데이트가 일어나면 음수 사이클이 있어요', true, 183),
(356, '다익스트라 결과와 비교', '다익스트라는 음수 간선을 처리할 수 없어요', false, 183),

-- 문제 185
(357, '정상 종료', '음수 사이클이 있으면 정상 종료할 수 없어요', false, 185),
(358, '최단 경로 반환', '음수 사이클이 있으면 최단 경로가 정의되지 않아요', false, 185),
(359, '무한 루프', '알고리즘이 무한 루프에 빠지지는 않아요', false, 185),
(360, '음수 사이클 감지 리포트', '음수 사이클을 감지하고 이를 알려주는 것이 알고리즘의 결과에요', true, 185);