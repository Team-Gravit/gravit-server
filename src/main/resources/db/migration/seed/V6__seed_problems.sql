-- 1번 레슨(lesson_id = 1)의 문제 12개 삽입 (컬럼 순서: question, answer, options, problem_type, lesson_id)
INSERT INTO problem (question, answer, options, problem_type, lesson_id)
VALUES
    ('배열의 인덱스 범위를 벗어난 접근을 시도할 때 발생하는 오류를 무엇이라고 하는가?',
     '오버플로우', '-', 'SELECT_DESCRIPTION', 1),
    ('arr[i][j]에서 i는 ( ), j는 ( )를 나타낸다.',
     '1', '1. 행,열; 2. 열,행; 3. 인덱스,값; 4. 값,인덱스', 'FILL_BLANK', 1),
    ('2차원 배열에서 행 우선 순서로 메모리에 저장되는 방식의 장점은?',
     '2', '1. 메모리 절약; 2. 캐시 효율성; 3. 접근 속도; 4. 구현 단순성', 'SELECT_DESCRIPTION', 1),
    ('배열에서 첫 번째 요소의 메모리 주소를 ( ) 주소라고 한다.',
     '베이스', '-', 'FILL_BLANK', 1),
    ('배열의 모든 요소가 메모리에서 같은 크기를 차지하는 이유는?',
     '2', '1. 효율성; 2. 동일한 데이터 타입; 3. 인덱싱; 4. 성능', 'SELECT_DESCRIPTION', 1),
    ('int arr[5]로 선언된 배열의 유효한 인덱스 범위는 ( )이다.',
     '1', '1. 0-4; 2. 1-5; 3. 0-5; 4. 1-4', 'FILL_BLANK', 1),
    ('배열에 저장된 요소의 개수를 나타내는 속성을 무엇이라고 하는가?',
     '길이', '-', 'SELECT_DESCRIPTION', 1),
    ('배열에서 특정 인덱스의 요소에 접근하는 시간 복잡도는 O( )이다.',
     '1', '-', 'FILL_BLANK', 1),
    ('배열의 크기가 생성 시점에 결정되고 실행 중에 변경할 수 없는 배열의 특성은?',
     '2', '1. 가변성; 2. 정적; 3. 동적; 4. 유연성', 'SELECT_DESCRIPTION', 1),
    ('대부분의 프로그래밍 언어에서 배열의 인덱스는 ( )부터 시작한다.',
     '1', '1. 0; 2. 1; 3. -1; 4. 2', 'FILL_BLANK', 1),
    ('배열에서 각 요소의 위치를 나타내는 번호를 무엇이라고 하는가?',
     '인덱스', '-', 'SELECT_DESCRIPTION', 1),
    ('배열은 동일한 데이터 타입의 요소들을 ( )적인 메모리 공간에 저장하는 자료구조이다.',
     '연속', '-', 'FILL_BLANK', 1);

-- 2번 레슨(lesson_id = 2)의 문제 12개 삽입
INSERT INTO problem (question, answer, options, problem_type, lesson_id)
VALUES
    ('배열을 이용하여 구현할 수 있는 선형 자료구조 중 LIFO 특성을 가진 것은?',
     '스택', '-', 'SELECT_DESCRIPTION', 2),
    ('희소 행렬에서 0이 아닌 원소만 저장하는 방식의 주요 목적은 ( ) 절약이다.',
     '2', '1. 시간; 2. 메모리; 3. CPU; 4. 네트워크', 'FILL_BLANK', 2),
    ('동적 배열에서 용량이 부족할 때 새로운 메모리를 할당하고 기존 데이터를 복사하는 작업의 분할상환 시간 복잡도는?',
     '1', '1. O(1); 2. O(log n); 3. O(n); 4. O(n²)', 'SELECT_DESCRIPTION', 2),
    ('배열의 요소들을 크기 순으로 재배열하는 과정을 ( )이라고 한다.',
     '정렬', '-', 'FILL_BLANK', 2),
    ('두 개의 정렬된 배열을 하나의 정렬된 배열로 결합하는 알고리즘을 무엇이라고 하는가?',
     '병합', '-', 'SELECT_DESCRIPTION', 2),
    ('배열에서 최댓값을 찾기 위해 필요한 최소 비교 횟수는 ( )번이다.',
     'n-1', '-', 'FILL_BLANK', 2),
    ('배열의 모든 요소를 방문하는 연산의 시간 복잡도는?',
     '3', '1. O(1); 2. O(log n); 3. O(n); 4. O(n²)', 'SELECT_DESCRIPTION', 2),
    ('배열에서 요소를 삭제한 후 빈 공간을 메우기 위해 뒤의 요소들을 앞으로 당기는 것을 ( ) 연산이라고 한다.',
     '압축', '-', 'FILL_BLANK', 2),
    ('배열의 중간에 요소를 삽입할 때 기존 요소들을 뒤로 밀어내는 작업을 무엇이라고 하는가?',
     '시프트', '-', 'SELECT_DESCRIPTION', 2),
    ('배열의 끝에 새로운 요소를 추가하는 연산의 시간 복잡도는 O( )이다.',
     '1', '1. 1; 2. n; 3. log n; 4. n²', 'FILL_BLANK', 2),
    ('정렬된 배열에서 특정 값을 찾는 가장 효율적인 탐색 방법은?',
     '2', '1. 선형 탐색; 2. 이진 탐색; 3. 해시 탐색; 4. 트리 탐색', 'SELECT_DESCRIPTION', 2),
    ('배열에서 특정 값을 찾기 위해 처음부터 끝까지 순서대로 검사하는 방법을 ( ) 탐색이라고 한다.',
     '선형', '-', 'FILL_BLANK', 2);

-- 3번 레슨(lesson_id = 3)의 문제 12개 삽입 (컬럼 순서: question, answer, options, problem_type, lesson_id)
INSERT INTO problem (question, answer, options, problem_type, lesson_id)
VALUES
    ('연결리스트의 각 요소는 데이터와 다음 노드를 가리키는 ( )로 구성된다.',
     '포인터', '-', 'FILL_BLANK', 3),
    ('연결리스트에서 데이터와 포인터를 포함하는 기본 단위를 무엇이라고 하는가?',
     '노드', '-', 'SELECT_DESCRIPTION', 3),
    ('연결리스트는 메모리에서 ( )적으로 저장되지 않아도 된다.',
     '1', '1. 연속; 2. 순차; 3. 정렬; 4. 고정', 'FILL_BLANK', 3),
    ('단일 연결리스트에서 첫 번째 노드를 가리키는 포인터를 무엇이라고 하는가?',
     '2', '1. tail; 2. head; 3. root; 4. start', 'SELECT_DESCRIPTION', 3),
    ('단일 연결리스트의 마지막 노드의 포인터는 ( )을 가리킨다.',
     'null, Null, NULL', '-', 'FILL_BLANK', 3),
    ('연결리스트에서 특정 위치의 요소에 접근하는 시간 복잡도는?',
     '3', '1. O(1); 2. O(log n); 3. O(n); 4. O(n²)', 'SELECT_DESCRIPTION', 3),
    ('연결리스트는 실행 중에 크기를 ( )으로 변경할 수 있다.',
     '2', '1. 정적; 2. 동적; 3. 고정; 4. 제한적', 'FILL_BLANK', 3),
    ('연결리스트에서 노드들을 차례대로 방문하는 과정을 무엇이라고 하는가?',
     '순회', '-', 'SELECT_DESCRIPTION', 3),
    ('연결리스트는 배열과 달리 메모리를 ( )으로 할당받는다.',
     '동적', '-', 'FILL_BLANK', 3),
    ('연결리스트가 배열 대비 가지는 주요 단점은?',
     '2', '1. 동적 크기; 2. 추가 메모리 오버헤드; 3. 삽입 용이성; 4. 삭제 용이성', 'SELECT_DESCRIPTION', 3),
    ('단일 연결리스트에서 이전 노드로 이동하는 것은 ( )하다.',
     '2', '1. 가능; 2. 불가능; 3. 조건부 가능; 4. 효율적', 'FILL_BLANK', 3),
    ('연결리스트에서 캐시 지역성이 배열보다 떨어지는 이유는 메모리의 어떤 특성 때문인가?',
     '비연속성', '-', 'SELECT_DESCRIPTION', 3);

-- 4번 레슨(lesson_id = 4)의 문제 12개 삽입 (컬럼 순서: question, answer, options, problem_type, lesson_id)
INSERT INTO problem (question, answer, options, problem_type, lesson_id)
VALUES
    ('이중 연결리스트의 각 노드는 다음 노드와 ( ) 노드를 가리키는 두 개의 포인터를 가진다.',
     '이전', '-', 'FILL_BLANK', 4),
    ('이중 연결리스트에서 양방향 탐색이 가능한 이유는?',
     '2', '1. 크기가 큼; 2. 두 개의 포인터; 3. 메모리 효율성; 4. 정렬 상태', 'SELECT_DESCRIPTION', 4),
    ('이중 연결리스트의 첫 번째 노드의 이전 포인터는 ( )을 가리킨다.',
     '3', '1. head; 2. tail; 3. NULL; 4. 자기자신', 'FILL_BLANK', 4),
    ('원형 연결리스트에서 마지막 노드의 포인터가 가리키는 곳은?',
     '1', '1. head; 2. tail; 3. null; 4. index', 'SELECT_DESCRIPTION', 4),
    ('원형 연결리스트에서는 NULL 포인터가 존재한다.',
     '2', '1. O; 2. X', 'SELECT_DESCRIPTION', 4),
    ('이중 연결리스트에서 노드 삭제 시 단일 연결리스트 대비 장점은?',
     '2', '1. 메모리 절약; 2. 이전 노드 탐색 불필요; 3. 속도 향상; 4. 구현 단순성', 'SELECT_DESCRIPTION', 4),
    ('원형 이중 연결리스트는 ( ) 방향으로 순회가 가능하다.',
     '2', '1. 한; 2. 두; 3. 세; 4. 네', 'FILL_BLANK', 4),
    ('이중 연결리스트에서 이전 노드를 가리키는 포인터의 일반적인 명칭은?',
     'prev', '-', 'SELECT_DESCRIPTION', 4),
    ('원형 연결리스트의 순회에서 무한루프를 방지하기 위해 ( ) 조건을 확인해야 한다.',
     '종료', '-', 'FILL_BLANK', 4),
    ('이중 연결리스트가 단일 연결리스트 대비 더 많은 메모리를 사용하는 이유는?',
     '2', '1. 큰 데이터; 2. 추가 포인터; 3. 복잡한 구조; 4. 동적 할당', 'SELECT_DESCRIPTION', 4),
    ('원형 연결리스트에서 임의의 노드에서 시작해도 모든 노드에 ( )할 수 있다.',
     '1', '1. 접근; 2. 삽입; 3. 삭제; 4. 정렬', 'FILL_BLANK', 4),
    ('원형 연결리스트가 가장 적합한 용도는 무엇인가?',
     '스케줄링', '-', 'SELECT_DESCRIPTION', 4);

-- 5번 레슨(lesson_id = 5)의 문제 12개 삽입 (컬럼 순서: question, answer, options, problem_type, lesson_id)
INSERT INTO problem (question, answer, options, problem_type, lesson_id)
VALUES
    ('연결리스트의 맨 앞에 새 노드를 삽입하는 시간 복잡도는 O( )이다.',
     '1', '-', 'FILL_BLANK', 5),
    ('연결리스트의 중간에 노드를 삽입할 때 먼저 해야 할 작업은?',
     '2', '1. 메모리 할당; 2. 삽입 위치 탐색; 3. 포인터 조정; 4. 데이터 복사', 'SELECT_DESCRIPTION', 5),
    ('연결리스트에서 첫 번째 노드를 삭제하는 시간 복잡도는 O( )이다.',
     '1', '1. 1; 2. log n; 3. n; 4. n²', 'FILL_BLANK', 5),
    ('연결리스트에서 노드 삭제 후 반드시 메모리를 (  )해야 한다.',
     '반납, 해제', '-', 'FILL_BLANK', 5),
    ('연결리스트에서 특정 값을 가진 노드를 찾는 연산을 ( )이라고 한다.',
     '탐색', '-', 'FILL_BLANK', 5),
    ('정렬된 연결리스트에 새 노드를 올바른 위치에 삽입하는 평균 시간 복잡도는?',
     '3', '1. O(1); 2. O(log n); 3. O(n); 4. O(n²)', 'SELECT_DESCRIPTION', 5),
    ('연결리스트를 역순으로 만드는 연산을 ( )라고 한다.',
     '반전', '1. 반전; 2. 정렬; 3. 순회; 4. 병합', 'FILL_BLANK', 5),
    ('두 개의 정렬된 연결리스트를 하나로 합치는 과정을 무엇이라고 하는가?',
     '병합', '-', 'SELECT_DESCRIPTION', 5),
    ('연결리스트에서 사이클 존재 여부를 확인하는 대표적인 알고리즘은 ( ) 알고리즘이다.',
     '플로이드', '-', 'FILL_BLANK', 5),
    ('연결리스트로 구현한 스택에서 push 연산이 수행되는 위치는?',
     '2', '1. 맨 뒤; 2. 맨 앞; 3. 중간; 4. 임의의 위치', 'SELECT_DESCRIPTION', 5),
    ('연결리스트의 중간 지점을 찾는 효율적인 방법은 ( ) 포인터 기법이다.',
     '이중', '1. 단일; 2. 이중; 3. 삼중; 4. 다중', 'FILL_BLANK', 5),
    ('연결리스트에서 메모리 누수를 방지하기 위해 삭제 시 반드시 호출해야 하는 함수는?',
     'free, free()', '-', 'SELECT_DESCRIPTION', 5);

-- 6번 레슨(lesson_id = 6)의 문제 12개 삽입 (컬럼 순서: question, answer, options, problem_type, lesson_id)
INSERT INTO problem (question, answer, options, problem_type, lesson_id)
VALUES
    ('스택은 (    ) 구조를 따르는 자료구조이다.',
     'LIFO, 후입선출', '-', 'FILL_BLANK', 6),
    ('스택에서 데이터를 삽입하는 연산을 (  )라고 한다.',
     '1', '1. push; 2. pop; 3. peek; 4. insert', 'FILL_BLANK', 6),
    ('스택에서 가장 최근에 삽입된 데이터가 저장된 위치를 가리키는 포인터는?',
     'top', '-', 'SELECT_DESCRIPTION', 6),
    ('스택이 가득 찬 상태에서 데이터를 삽입하려 할 때 발생하는 현상은?',
     '1', '1. overflow; 2. underflow; 3. 널포인터; 4. 메모리누수', 'SELECT_DESCRIPTION', 6),
    ('스택에서 데이터를 제거하는 연산을 ( )라고 한다.',
     'pop', '-', 'FILL_BLANK', 6),
    ('빈 스택에서 pop 연산을 수행하려 할 때 발생하는 현상을 (       )라고 한다.',
     '2', '1. overflow; 2. underflow; 3. 널에러; 4. 런타임에러', 'FILL_BLANK', 6),
    ('함수가 호출될 때 지역변수와 매개변수가 저장되는 메모리 영역은?',
     '스택', '-', 'SELECT_DESCRIPTION', 6),
    ('수학식 "2 3 + 4 *"와 같이 연산자가 피연산자 뒤에 오는 표기법은?',
     '3', '1. 전위표기법; 2. 중위표기법; 3. 후위표기법; 4. 혼합표기법', 'SELECT_DESCRIPTION', 6),
    ('함수 호출 시 생성되는 메모리 공간의 단위를 (    )라고 한다.',
     '프레임', '-', 'FILL_BLANK', 6),
    ('괄호의 짝이 올바르게 맞는지 검사하는 알고리즘에서 주로 사용되는 자료구조는?',
     '2', '1. 큐; 2. 스택; 3. 트리; 4. 그래프', 'SELECT_DESCRIPTION', 6),
    ('재귀 함수에서 함수 호출 정보를 관리하기 위해 시스템이 내부적으로 사용하는 자료구조는 (   )이다.',
     '스택', '-', 'FILL_BLANK', 6),
    ('중위 표기법을 후위 표기법으로 변환할 때 연산자의 우선순위를 관리하기 위해 사용하는 자료구조는?',
     '2', '1. 큐; 2. 스택; 3. 힙; 4. 해시테이블', 'SELECT_DESCRIPTION', 6);

-- 7번 레슨(lesson_id = 7)의 문제 12개 삽입 (컬럼 순서: question, answer, options, problem_type, lesson_id)
INSERT INTO problem (question, answer, options, problem_type, lesson_id)
VALUES
    ('DBMS는 데이터베이스를 효율적으로 (  )하는 소프트웨어이다.',
     '관리', '-', 'FILL_BLANK', 7),
    ('DBMS는 데이터 정의, 조작, 제어 기능을 통해 데이터의 (   )을 보장한다.',
     '1', '1. 안정성; 2. 보안성; 3. 가용성; 4. 확장성', 'FILL_BLANK', 7),
    ('관계형 데이터베이스는 데이터를 테이블의 (   ) 구조로 저장한다.',
     '2차원', '-', 'FILL_BLANK', 7),
    ('NoSQL은 스키마 없이 (   ) 확장이 가능한 데이터 저장소이다.',
     '1', '1. 수평적; 2. 수직적; 3. 수치적; 4. 수반적', 'FILL_BLANK', 7),
    ('Oracle은 대표적인 상용 (   ) DBMS 제품이다.',
     '관계형', '-', 'FILL_BLANK', 7),
    ('다음 중 대표적인 RDBMS가 아닌 것은 (       )이다.',
     '3', '1. Oracle; 2. MySQL; 3. MongoDB; 4. PostgreSQL', 'SELECT_DESCRIPTION', 7),
    ('분산 DBMS는 데이터와 서비스를 여러 노드에 (  )하여 처리 효율을 높이는 시스템이다.',
     '분산', '-', 'FILL_BLANK', 7),
    ('분산 DBMS는 네트워크 파티션 발생 시 시스템 운영을 위해 (  ) 일관성을 허용하기도 한다.',
     '2', '1. 즉시; 2. 최종; 3. 엄격; 4. 강제', 'FILL_BLANK', 7),
    ('분산 DBMS는 장애 복구를 위해 동기와 (   ) 복제 방식을 지원한다.',
     '비동기', '-', 'FILL_BLANK', 7),
    ('CAP 이론에서 네트워크 분할 발생 시에도 일관성은 보장하되 가용성을 포기하는 시스템 유형은 무엇인가?',
     'CP', '-', 'SELECT_DESCRIPTION', 7),
    ('분산 DBMS에서 데이터를 여러 서버에 분할 저장하여 부하를 분산하는 방식을 무엇이라 하는가?',
     '3', '1. 파티셔닝; 2. 복제; 3. 샤딩; 4. 인덱싱', 'SELECT_DESCRIPTION', 7),
    ('분산 시스템에서 강한 일관성 대신 최종 일관성을 허용하여 가용성과 확장성을 강조하는 모델은 무엇인가?',
     'BASE', '-', 'SELECT_DESCRIPTION', 7);


-- 8번 레슨(lesson_id = 8)의 문제 12개 삽입 (컬럼 순서: question, answer, options, problem_type, lesson_id)
INSERT INTO problem (question, answer, options, problem_type, lesson_id)
VALUES
    ('DBMS는 데이터베이스를 효율적으로 (  )하는 소프트웨어이다.',
     '관리', '-', 'FILL_BLANK', 8),
    ('DBMS는 데이터 정의, 조작, 제어 기능을 통해 데이터의 (   )을 보장한다.',
     '1', '1. 안정성; 2. 보안성; 3. 가용성; 4. 확장성', 'FILL_BLANK', 8),
    ('관계형 데이터베이스는 테이블의 (   ) 구조로 저장한다.',
     '2차원', '-', 'FILL_BLANK', 8),
    ('NoSQL은 스키마 없이 (   ) 확장이 가능한 데이터 저장소이다.',
     '1', '1. 수평적; 2. 수직적; 3. 수치적; 4. 수반적', 'FILL_BLANK', 8),
    ('Oracle은 대표적인 상용 (   ) DBMS 제품이다.',
     '관리형', '-', 'FILL_BLANK', 8),
    ('다음 중 대표적인 RDBMS가 아닌 것은 (       )이다.',
     '3', '1. Oracle; 2. MySQL; 3. MongoDB; 4. PostgreSQL', 'SELECT_DESCRIPTION', 8),
    ('분산 DBMS는 데이터와 서비스를 여러 노드에 (  )하여 처리 효율을 높이는 시스템이다.',
     '분산', '-', 'FILL_BLANK', 8),
    ('분산 DBMS는 네트워크 파티션 발생 시 시스템 운영을 위해 (  ) 일관성을 허용하기도 한다.',
     '2', '1. 즉시; 2. 최종; 3. 엄격; 4. 강제', 'FILL_BLANK', 8),
    ('분산 DBMS는 장애 복구를 위해 동기와 (   ) 복제 방식을 지원한다.',
     '비동기', '-', 'FILL_BLANK', 8),
    ('CAP 이론에서 네트워크 분할 발생 시에도 일관성은 보장하되 가용성을 포기하는 시스템 유형은 무엇인가?',
     'CP', '-', 'SELECT_DESCRIPTION', 8),
    ('분산 DBMS에서 데이터를 여러 서버에 분할 저장하여 부하를 분산하는 방식을 무엇이라 하는가?',
     '3', '1. 파티셔닝; 2. 복제; 3. 샤딩; 4. 인덱싱', 'SELECT_DESCRIPTION', 8),
    ('분산 시스템에서 강한 일관성 대신 최종 일관성을 허용하여 가용성과 확장성을 강조하는 모델은 무엇인가?',
     '2', '1. ACID; 2. BASE; 3. CRUD; 4. CAP', 'SELECT_DESCRIPTION', 8);

-- 9번 레슨(lesson_id = 9)의 문제 12개 삽입
INSERT INTO problem (question, answer, options, problem_type, lesson_id)
VALUES
    ('관계형 DB에서 각 행은 (  )으로 표현되는 데이터의 단위이다.',
     '튜플', '-', 'FILL_BLANK', 9),
    ('테이블에서 각 열은 (  ) 값으로 이루어진다.',
     '2', '1. 도메인; 2. 속성; 3. 엔트리; 4. 레코드', 'FILL_BLANK', 9),
    ('기본 키는 테이블의 각 행을 (  )한 식별자이다.',
     '고유', '-', 'FILL_BLANK', 9),
    ('트랜잭션은 하나의 논리적 (  ) 단위이다.',
     '3', '1. 연산; 2. 처리; 3. 작업; 4. 기능', 'FILL_BLANK', 9),
    ('트랜잭션에서 모든 작업이 완료되거나 전혀 수행되지 않는 특성을 (  )성이라 한다.',
     '원자', '-', 'FILL_BLANK', 9),
    ('ACID 속성 중 장애 발생 후에도 수행 결과를 보존하는 특성은 무엇인가?',
     '4', '1. 원자성; 2. 일관성; 3. 격리성; 4. 지속성', 'SELECT_DESCRIPTION', 9),
    ('ACID의 I가 의미하는 속성명은 무엇인가?',
     '격리성', '-', 'FILL_BLANK', 9),
    ('데이터 무결성 제약 중 컬럼 값이 NULL이 될 수 없음을 강제하는 것은?',
     '1', '1. NOT NULL; 2. UNIQUE; 3. PRIMARY KEY; 4. FOREIGN KEY', 'SELECT_DESCRIPTION', 9),
    ('체크 제약조건은 컬럼 값이 특정 (  )을 만족하는지 검증한다.',
     '조건', '-', 'FILL_BLANK', 9),
    ('NULL과 비교할 때 일반 비교 연산자를 사용할 수 없고 특수 연산자를 사용해야 하는 것은?',
     '3', '1. =; 2. <>; 3. IS NULL; 4. BETWEEN', 'SELECT_DESCRIPTION', 9),
    ('SQL Server는 마이크로소프트에서 개발한 대표적인 (   ) DBMS이다.',
     '1', '1. 관계형; 2. 비관계형; 3. 문서지향; 4. 키-값', 'FILL_BLANK', 9),
    ('MySQL, PostgreSQL과 달리 상용 라이선스 기반으로 제공되는 RDBMS 제품은 무엇인가?',
     'Oracle', '-', 'FILL_BLANK', 9);

-- 10번 레슨(lesson_id = 10)의 문제 12개 삽입 (컬럼 순서: question, answer, options, problem_type, lesson_id)
INSERT INTO problem (question, answer, options, problem_type, lesson_id)
VALUES
    ('데이터 조작 작업을 수행하는 SQL 명령어 분류는 DML이다. 다음 중 DML에 속하지 않는 명령어는 무엇인가?',
     '4', '1. INSERT; 2. UPDATE; 3. DELETE; 4. CREATE', 'SELECT_DESCRIPTION', 10),
    ('데이터베이스를 생성하는 SQL 명령어는 (      ) DATABASE database_name이다.',
     'CREATE', '-', 'FILL_BLANK', 10),
    ('현재 서버의 데이터베이스 목록을 확인하는 명령어는 (    ) DATABASES이다.',
     '1', '1. SHOW; 2. LIST; 3. GET; 4. SELECT', 'FILL_BLANK', 10),
    ('새로운 테이블을 생성할 때 사용하는 SQL 키워드는 (      ) TABLE table_name이다.',
     'CREATE', '-', 'FILL_BLANK', 10),
    ('테이블을 삭제할 때 사용하는 SQL 키워드는 (    ) TABLE table_name이다.',
     '1', '1. DROP; 2. DELETE; 3. TRUNCATE; 4. ALTER', 'FILL_BLANK', 10),
    ('테이블을 삭제할 때 사용하는 SQL 키워드는 (    ) TABLE table_name이다.',
     '1', '1. DROP; 2. DELETE; 3. TRUNCATE; 4. ALTER', 'FILL_BLANK', 10),
    ('테이블에서 데이터를 조회할 때 사용하는 SQL 키워드는 (      )이다.',
     'SELECT', '-', 'FILL_BLANK', 10),
    ('조회 조건을 지정할 때 사용하는 절은 (    )이다.',
     '1', '1. WHERE; 2. HAVING; 3. GROUP; 4. ORDER', 'FILL_BLANK', 10),
    ('조회 결과를 정렬할 때 사용하는 절은 ORDER (  )이다.',
     'BY', '-', 'FILL_BLANK', 10),
    ('복수의 컬럼을 순차적으로 정렬하려면 ORDER BY col1 (    ), col2 ASC와 같이 지정해야 한다. 이때 괄호에 들어갈 키워드는 무엇인가?',
     '2', '1. ASC; 2. DESC; 3. LIMIT; 4. OFFSET', 'FILL_BLANK', 10),
    ('트랜잭션 격리 수준을 조회하려면 SHOW 명령을 사용해야 한다. 다음 중 격리 수준 조회에 사용되는 SQL 키워드는 무엇인가?',
     '1', '1. SHOW; 2. SET; 3. SELECT; 4. DELETE', 'SELECT_DESCRIPTION', 10),
    ('서브쿼리를 이용해 그룹 전체의 평균 값을 계산할 때 사용하는 SQL 함수는 무엇인가?',
     'AVG', '-', 'SELECT_DESCRIPTION', 10);

-- 11번 레슨(lesson_id = 11)의 문제 12개 삽입
INSERT INTO problem (question, answer, options, problem_type, lesson_id)
VALUES
    ('정수형 INT, 소수형 DECIMAL 등은 (  ) 타입이다.',
     '숫자', '-', 'FILL_BLANK', 11),
    ('DATE 타입은 년-월-일 정보를 저장하지만, 시-분-초 정보는 저장할 수 없다. 시-분-초 정보까지 저장하려면 (        ) 타입을 사용해야 한다.',
     'DATETIME', '-', 'FILL_BLANK', 11),
    ('TEXT와 BLOB은 대용량 데이터를 저장하기 위해 사용한다. 이 중 바이너리 데이터를 저장하는 타입은 무엇인가?',
     '2', '1. TEXT; 2. BLOB; 3. VARCHAR; 4. CHAR', 'SELECT_DESCRIPTION', 11),
    ('고정 길이 문자열을 저장할 때는 (    ) 타입을 사용한다.',
     '1', '1. CHAR; 2. VARCHAR; 3. TEXT; 4. BLOB', 'FILL_BLANK', 11),
    ('(   ) NULL 제약은 컬럼에 NULL 저장을 허용하지 않는다.',
     '1', '1. NOT; 2. NO; 3. NON; 4. NUL', 'FILL_BLANK', 11),
    ('컬럼 값의 중복을 금지하려면 (      ) 제약을 사용해야 한다.',
     'UNIQUE', '-', 'FILL_BLANK', 11),
    ('(       ) KEY 제약은 테이블의 각 행을 고유하게 식별한다.',
     'PRIMARY', '-', 'FILL_BLANK', 11),
    ('(       ) KEY 제약은 테이블 간 참조 무결성을 보장한다.',
     'FOREIGN', '-', 'FILL_BLANK', 11),
    ('(     ) 제약을 사용하면 컬럼 값에 조건식을 지정할 수 있다.',
     '1', '1. CHECK; 2. LIMIT; 3. WHERE; 4. ASSERT', 'FILL_BLANK', 11),
    ('두 개 이상의 컬럼을 조합해 고유 제약을 적용하는 것을 (  ) 제약이라고 한다.',
     '복합', '-', 'FILL_BLANK', 11),
    ('컬럼에 값이 지정되지 않았을 때 미리 정의된 값을 자동으로 입력하려면 (       ) 절을 사용한다.',
     'DEFAULT', '-', 'FILL_BLANK', 11),
    ('열거형 타입을 정의할 때 사용하는 SQL 키워드는 무엇인가?',
     '1', '1. ENUM; 2. SET; 3. LIST; 4. TYPE', 'SELECT_DESCRIPTION', 11);

-- 12번 레슨(lesson_id = 12)의 문제 12개 삽입 (컬럼 순서: question, answer, options, problem_type, lesson_id)
INSERT INTO problem (question, answer, options, problem_type, lesson_id)
VALUES
    ('새 레코드를 추가하려면 INSERT (    ) VALUES 구문을 사용한다.',
     'INTO', '-', 'FILL_BLANK', 12),
    ('다른 테이블의 데이터를 활용해 레코드를 삽입하려면 INSERT … (      ) 구문을 사용한다.',
     '1', '1. SELECT; 2. INSERT; 3. UPDATE; 4. DELETE', 'FILL_BLANK', 12),
    ('UPDATE 구문에서 변경할 컬럼과 값을 명시하는 키워드는 무엇인가?',
     'SET', '-', 'SELECT_DESCRIPTION', 12),
    ('DELETE 구문에서 특정 조건을 지정하여 행을 제거하려면 어떤 절을 사용해야 하는가?',
     '1', '1. WHERE; 2. HAVING; 3. ORDER BY; 4. GROUP BY', 'SELECT_DESCRIPTION', 12),
    ('트랜잭션을 시작할 때 사용하는 키워드는 무엇인가?',
     'BEGIN', '-', 'FILL_BLANK', 12),
    ('트랜잭션 중 오류 발생 시 이전 상태로 되돌리려면 (        ) 명령어를 사용한다.',
     'ROLLBACK', '-', 'FILL_BLANK', 12),
    ('SELECT 결과를 UPDATE에 활용하는 내부 쿼리를 (     )라고 부른다.',
     '1', '1. 서브쿼리; 2. 조인; 3. 트랜잭션; 4. 파티션', 'FILL_BLANK', 12),
    ('다중 테이블 삭제를 수행할 때 다른 테이블과의 관계 설정을 위해 어떤 절을 추가로 사용해야 하는가?',
     '1', '1. JOIN; 2. LIMIT; 3. GROUP BY; 4. ORDER BY', 'SELECT_DESCRIPTION', 12),
    ('자동 증가로 만들려면 PRIMARY KEY 뒤에 (              ) 속성을 추가해야 한다.',
     'AUTO_INCREMENT', '-', 'FILL_BLANK', 12),
    ('MERGE(UPSERT)를 대체하기 위해 MySQL에서 사용하는 구문은 무엇인가?',
     '3',
     '1. INSERT IGNORE; 2. REPLACE; 3. INSERT ... ON DUPLICATE KEY UPDATE; 4. UPSERT',
     'SELECT_DESCRIPTION', 12),
    ('파티션된 테이블에서 특정 파티션만 대상이 되도록 명시하려면 PARTITION (    ) 절을 사용한다.',
     '파티션명', '-', 'FILL_BLANK', 12),
    ('UNIQUE 제약 위반 시 MySQL이 반환하는 에러 코드는 무엇인가?',
     '2', '1. 1045; 2. 1062; 3. 1146; 4. 1054', 'SELECT_DESCRIPTION', 12);