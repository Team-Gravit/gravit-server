-- Chapter 1
-- Unit01 - 배열 (Lesson ID: 1)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (1, 'FILL_BLANK', '일반적으로 배열은 _____ 종류의 데이터들이 순차적으로 저장되어 있는 자료구조를 의미한다.', '같은, 동일한, 일치하는', '-', 1),

    (2, 'FILL_BLANK', '배열은 선언 시점에 크기가 _____되며, 런타임에 크기를 변경할 수 없다.', '고정, 결정', '-', 1),

    (3, 'FILL_BLANK', '배열은 메모리 상에서 _____적인 위치에 저장하는 자료구조이다.', '연속', '-', 1),

    (4, 'FILL_BLANK', '배열은 연속된 메모리에 저장되기 때문에, 할당받은 공간을 사용하지 않으면 메모리 _____가 발생한다.', '낭비, 누수', '-', 1),

    (5, 'FILL_BLANK', '배열의 _____를 이용해서 값에 접근할 수 있다.', '인덱스', '-', 1),

    (6, 'SELECT_DESCRIPTION', '배열의 첫 번째 요소 인덱스는?', '3', '1.null;2.-1;3.0;4.1', 1),

    (7, 'SELECT_DESCRIPTION', '배열의 인덱스 범위를 벗어난 접근을 시도할 때 발생하는 에러는?', '2', '1.언더플로우;2.오버플로우;3.타입 에러;4.널포인터 에러', 1),

    (8, 'SELECT_DESCRIPTION', '2차원 배열 temp[i][j] 에서 i와 j가 나타내는 의미는?', '1', '1.행과 열;2.열과 행;3.인덱스와 값;4.값과 인덱스', 1),

    (9, 'SELECT_DESCRIPTION', '2차원 배열 temp[i][j] 에서 사용하는 기본 메모리 주소 계산 방식은?', '1', '1.행 우선;2.열 우선;3.대각선 우선;4.임의 순서', 1),

    (10, 'SELECT_DESCRIPTION', '배열에서 인덱스를 이용한 특정 요소 접근의 시간복잡도는?', '1', '1.O(1);2.O(log n);3.O(n);4.O(n²)', 1),

    (11, 'SELECT_DESCRIPTION', '정렬되지 않은 배열에서 특정 요소를 찾는 선형 탐색의 시간복잡도는?', '3', '1.O(1);2.O(log n);3.O(n);4.O(n²)', 1),

    (12, 'FILL_BLANK', '배열을 순차적으로 접근할 때, 성능이 좋은 이유는 _____지역성 때문이다.', '캐시', '-', 1);

-- Unit02 - 연결리스트 1 (Lesson ID: 2)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES
    (13, 'FILL_BLANK', '연결리스트는 배열리스트와 다르게 _____ 할당 방식을 사용하기 때문에 공간 낭비를 줄일 수 있다.', '동적', '-', 2),

    (14, 'FILL_BLANK', '단일 연결리스트의 노드는 원소를 저장하는 _____필드와 다음 노드를 가리키는 _____필드로 구성된다.', '데이터, 포인터', '1.데이터, 포인터;2.인덱스, 데이터;3.데이터, 인덱스;4.포인터, 데이터', 2),

    (15, 'SELECT_DESCRIPTION', '단일 연결리스트에서 헤드노드 포인터의 역할은?', '2', '1.마지막 노드 가리킴;2.첫번째 노드 가리킴;3.중간 노드 가리킴;4.모든 노드 가리킴', 2),

    (16, 'FILL_BLANK', '빈 연결리스트에서 헤드노드의 포인터는 _____을 가리킨다.', 'null', '-', 2),

    (17, 'FILL_BLANK', '연결리스트의 노드들은 메모리 상에서 _____ 위치에 저장된다.', '불연속적인', '1.연속적인;2.불연속적인;3.임의의;4.정렬된', 2),

    (18, 'FILL_BLANK', '단일 연결 리스트에서 테일노드의 포인터는 _____을 가리킨다.', 'null', '-', 2),

    (19, 'FILL_BLANK', '원형 단일 연결리스트에서 테일노드의 포인터는 _____을 가리킨다.', '헤드 노드', '1.null;2.이전 노드;3.헤드 노드;4.중간노드', 2),

    (20, 'FILL_BLANK', '연결리스트는 런타임에 크기를 _____으로 변경할 수 있다.', '동적', '-', 2),

    (21, 'FILL_BLANK', '연결리스트는 배열과 달리 _____ 기반 접근이 불가능하다.', '인덱스', '-', 2),

    (22, 'SELECT_DESCRIPTION', '연결리스트가 배열보다 메모리를 더 많이 사용하는 이유는?', '2', '1.데이터 중복;2.포인터;3.인덱스;4.캐시미스', 2),

    (23, 'FILL_BLANK', '단일 연결리스트의 맨 앞에 새 노드를 삽입하는 연산의 시간복잡도는 _____이다.', 'o(1)', '1.O(1);2.O(log n);3.O(n);4.O(n²)', 2),

    (24, 'FILL_BLANK', '단일 연결리스트에서 특정 값을 찾아 삭제하는 연산의 시간복잡도는 _____이다.', 'o(n)', '1.O(1);2.O(log n);3.O(n);4.O(n²)', 2);

-- Unit02 - 연결리스트 2 (Lesson ID: 3)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (25, 'FILL_BLANK', '선형 양방향 연결리스트에서 헤드노드의 prev 포인터와 테일노드의 next 포인터는 _____을 가리킨다', 'null', '-', 3),

    (26, 'FILL_BLANK', '원형 양방향 연결리스트에서 테일노드의 next 포인터는 _____노드를 가리킨다.', '헤드, 머리', '-', 3),

    (27, 'FILL_BLANK', '선형 양방향 연결리스트에서 첫번째 노드는 _____노드의 next를 통해 접근할 수 있다.', '헤드, 머리', '-', 3),

    (28, 'FILL_BLANK', '원형 양방향 연결리스트에서 마지막 노드는 _____노드의 prev를 통해 접근할 수 있다.', '테일, 꼬리', '-', 3),

    (29, 'SELECT_DESCRIPTION', '양방향 연결리스트의 중간에 새로운 노드를 삽입하기 위해서는 몇 개의 포인터를 수정해야 하는가?', '1', '1.2개;2.3개;3.4개;4.5개', 3),

    (30, 'SELECT_DESCRIPTION', '양방향 연결리스트의 중간에 위치한 노드를 삭제하기 위해서는 몇 개의 포인터를 수정해야 하는가?', '1', '1.2개;2.3개;3.4개;4.5개', 3),

    (31, 'SELECT_DESCRIPTION', '원형 양방향 연결리스트에서 임의의 노드에서 시작해서 전체 노드를 한번 순회하는 연산의 시간복잡도는?', '3', '1.O(1);2.O(log n);3.O(n);4.O(n²)', 3),

    (32, 'SELECT_DESCRIPTION', '테일노드를 사용한 경우, 마지막 원소에 대한 삽입/삭제 연산의 시간복잡도는 _____이 된다.', '1', '1.O(1);2.O(log n);3.O(n);4.O(n²)', 3),

    (33, 'SELECT_DESCRIPTION', '양방향 연결리스트를 통해 구현할 수 있는 자료구조가 아닌 것은?', '4', '1.스택;2.큐;3.덱;4.힙', 3);

-- Unit03 - 스택 (Lesson ID: 4)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (34, 'SELECT_DESCRIPTION', '스택에 3, 5, 1, 2를 순차적으로 넣었을 때, 가장 위에 있는 원소는?', '4', '1.3;2.5;3.1;4.2', 4),

    (35, 'FILL_BLANK', '스택은 _____ 구조를 따른다.', 'lifo, 후입선출', '-', 4),

    (36, 'SELECT_DESCRIPTION', '스택은 _____의 원소만 접근이 가능하다.', '2', '1.맨 아래;2.맨 위;3.가운데;4.임의', 4),

    (37, 'FILL_BLANK', '스택의 맨 위 원소를 _____이라고 한다.', '탑, top', '-', 4),

    (38, 'FILL_BLANK', '배열로 구현된 스택에서 아무 원소도 들어있지 않은 상황이라면, top을 가리키는 인덱스는 _____으로 초기화되어 있다.', '-1', '1.-999;2.-1;3.0;4.1', 4),

    (39, 'SELECT_DESCRIPTION', '연결리스트로 구현된 스택에서 원소 삽입이 발생하면 몇 개의 포인터가 변경되는가?', '2', '1.1개;2.2개;3.3개;4.4개', 4),

    (40, 'SELECT_DESCRIPTION', '연결리스트로 구현된 스택에서 원소 삭제가 발생하면 몇 개의 포인터가 변경되는가?', '1', '1.1개;2.2개;3.3개;4.4개', 4),

    (41, 'SELECT_DESCRIPTION', '후위표현법 "3 4 + 2"를 계산하면?', '2', '1.11;2.14;3.10;4.24', 4),

    (42, 'SELECT_DESCRIPTION', '후위표현법 "5 3 - 2 4 + *"을 계산하면?', '1', '1.12;2.10;3.8;4.6', 4),

    (43, 'SELECT_DESCRIPTION', '스택의 push, pop, peek 연산의 시간복잡도는?', '1', '1.O(1);2.O(log n);3.O(n);4.O(n²)', 4);

-- Unit04 - 큐 (Lesson ID: 5)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (44, 'SELECT_DESCRIPTION', '큐에 2, 9, 7, 4를 순차적으로 넣었을 때, 원소 삭제시 반환되는 값은?', '1', '1.2;2.9;3.7;4.4', 5),

    (45, 'FILL_BLANK', '큐는 _____ 구조를 따른다.', 'fifo, 선입선출', '-', 5),

    (46, 'SELECT_DESCRIPTION', '큐를 구현할 때, 주로 원형 구조를 사용하는 이유는?', '1', '1.낭비되는 공간을 재사용하기 위해;2.삽입/삭제 연산 속도를 높이기 위해;3.메모리 할당을 동적으로 하기 위해;4.데이터의 순서를 보장하기 위해', 5),

    (47, 'FILL_BLANK', '원형 배열로 구현된 크기가 n인 빈 큐에서 tail과 front가 가리키고 있는 인덱스는?', 'n-1, 0', '1.0, 0;2.0, 1;3.n-1, 0;4.n, 0', 5),

    (48, 'FILL_BLANK', '원형 배열로 구현된 크기가 8인 빈 큐에서 삽입 3회, 삭제 1회가 일어났을 때 tail이 가리키는 인덱스는 _____이다.', '2', '-', 5),

    (49, 'FILL_BLANK', '원형 배열로 구현된 크기가 8인 빈 큐에서 삽입 4회, 삭제 3회가 일어났을 때 tail이 가리키는 인덱스는 _____이다.', '3', '-', 5),

    (50, 'SELECT_DESCRIPTION', '원형 연결리스트로 큐를 구현할 때, tail 포인터만 사용하는 이유는?', '1', '1.tail -> next가 front를 가리키기 때문;2.front 개념이 존재하지 않음;3.tail 포인터가 더 빠른 접근을 제공;4.연산 속도가 더 빠름', 5),

    (51, 'FILL_BLANK', '원형 연결리스트로 구현된 큐에서 새로운 노드를 추가하는 경우 수정되는 포인터의 수는 _____개이다.', '3', '-', 5),

    (52, 'FILL_BLANK', '원형 연결리스트로 구현된 큐에서 노드를 삭제하는 경우 수정되는 포인터의 수는 _____개이다.', '1', '-', 5),

    (53, 'SELECT_DESCRIPTION', '스택을 이용해 문자열 "abba"가 회문(좌우동형)인지 검사할 때, 스택에 저장할 문자는?', '1', '1.a, b;2.a, b, b, a;3.b, b;4.a, a', 5),

    (54, 'FILL_BLANK', '스택을 이용한 회문 검사에서 문자열 "level"의 경우, 스택에는 _____개의 문자를 저장한다.', '2', '-', 5);

-- Unit05 - 힙 (Lesson ID: 6)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (55, 'FILL_BLANK', '_____ _____를 구현한 자료구조를 힙이라고 한다.', '우선순위 큐', '-', 6),

    (56, 'FILL_BLANK', '힙은 _____ _____ 트리 구조를 사용한다.', '완전 이진, 완전이진', '-', 6),

    (57, 'SELECT_DESCRIPTION', '모든 노드가 자식 노드보다 크거나 같은 값을 갖는 힙은?', '최대힙', '-', 6),

    (58, 'SELECT_DESCRIPTION', '모든 노드가 자식 노드보다 작거나 같은 값을 갖는 힙은?', '최소힙', '-', 6),

    (59, 'SELECT_DESCRIPTION', '힙을 배열로 구현했을 때 부모노드의 인덱스가 k인 경우, 자식노드에 접근할 수 있는 인덱스는?', '2', '1.2k;2.2k+1;3.2k-1;4.2k-2', 6),

    (60, 'SELECT_DESCRIPTION', '힙을 배열로 구현했을 때 자식노드의 인덱스가 k인 경우, 부모노드에 접근할 수 있는 인덱스는?', '3', '1.(k-1) / 2의 올림;2.(k-2) / 2의 올림;3.(k-1) / 2의 내림;4.(k-2) / 2의 내림', 6),

    (61, 'SELECT_DESCRIPTION', '배열로 구현한 최대힙에 8 | 7 | 5 | 3 순으로 원소가 들어가 있다. 만약, 9를 힙에 넣게 되면 총 몇번의 교환 연산이 일어나는가?', '2번', '-', 6),

    (62, 'SELECT_DESCRIPTION', '배열로 구현한 최대힙에 10 | 8 | 6 | 7 | 4 | 5 | 2 순으로 원소가 들어가 있다. 만약, 12를 힙에 넣게 되면 총 몇번의 교환 연산이 일어나는가?', '3', '1.1번;2.2번;3.3번;4.4번', 6),

    (63, 'SELECT_DESCRIPTION', '배열로 구현한 최대힙에 15 | 12 | 10 | 8 | 9 | 6 | 7 | 3 | 5 순으로 원소가 들어가 있다. 만약, 14를 힙에 넣게 되면 총 몇번의 교환 연산이 일어나는가?', '2', '1.1번;2.2번;3.3번;4.0번', 6),

    (64, 'SELECT_DESCRIPTION', '배열로 구현한 최대힙에 16 | 12 | 14 | 8 | 10 | 6 | 9 | 4 | 7 순으로 원소가 들어가 있다. 루트 노드를 삭제할 때 총 몇번의 교환 연산이 일어나는가?', '3', '-', 6),

    (65, 'SELECT_DESCRIPTION', '배열로 구현한 최대힙에 18 | 15 | 16 | 10 | 12 | 8 | 14 | 4 | 6 | 9 순으로 원소가 들어가 있다. 루트 노드 삭제 및 스며내리기 과정이 완료된 후, 스며내리기 대상이었던 값의 최종 인덱스는?', '6', '-', 6);

-- Unit06 - 해시 (Lesson ID: 7)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (66, 'FILL_BLANK', '해시 테이블의 조회, 삽입, 삭제 연산의 시간복잡도는 _____이다.', 'o(1)', '1.O(1);2.O(log n);3.O(n);4.O(n²)', 7),

    (67, 'FILL_BLANK', '해시 함수가 " h(x) = x % 10 " 라고할 때, key로 13과 3이 들어오면 같은 해시값을 갖게 되는데 이를 _____이라고 한다.', '충돌', '-', 7),

    (68, 'SELECT_DESCRIPTION', '해시 테이블에서 전체 크기 대비 원소가 차 있는 비율을 무엇이라고 하는가?', '1', '1.적재율;2.충돌율;3.성공률;4.이용률', 7),

    (69, 'FILL_BLANK', '해시 테이블에서 충돌이 발생한 원소들을 같은 버킷에 연결 리스트로 관리하는 방식을 _____이라고 한다.', '체이닝, 채이닝, chaining', '-', 7),

    (70, 'SELECT_DESCRIPTION', '해시 테이블에서 체이닝 방식으로 충돌을 해결하는 경우, 조회 연산에 대한 최악의 경우 시간복잡도는?', '3', '1.O(1);2.O(log n);3.O(n);4.O(n²)', 7),

    (71, 'FILL_BLANK', '해시 테이블에서 충돌이 발생했을 때, 테이블 내의 다른 빈 공간을 찾아 저장하는 방식을 _____ _____ 법이라고 한다.', '개방 주소', '-', 7),

    (72, 'SELECT_DESCRIPTION', '개방 주소 방법에서 충돌이 발생했을 때 h(k), h(k)+1, h(k)+2, ... 순서로 빈 슬롯을 찾아 탐색하는 방식은?', '1', '1.선형 탐사법;2.이차 탐사법;3.이중 해싱;4.랜덤 탐사법', 7),

    (73, 'SELECT_DESCRIPTION', '개방 주소법에서 충돌이 발생했을 때 h(k), h(k)+1², h(k)+2², h(k)+3²... 순서로 탐색하는 방식은?', '2', '1.선형 탐사법;2.이차 탐사법;3.이중 해싱;4.랜덤 탐사법', 7),

    (74, 'SELECT_DESCRIPTION', '개방 주소법에서 두 개의 서로 다른 해시 함수를 사용하여 충돌을 해결하는 방식은?', '3', '1.선형 탐사법;2.이차 탐사법;3.이중 해싱;4.랜덤 탐사법', 7),

    (75, 'SELECT_DESCRIPTION', '선형 탐사법에서 연속된 해시 슬롯들이 채워지면서 데이터가 한 곳에 뭉치는 현상을 무엇이라고 하는가?', '1', '1.1차 군집;2.2차 군집;3.해시 충돌;4.로드 팩터', 7),

    (76, 'SELECT_DESCRIPTION', '선형 탐사법에서 1차 군집 현상이 성능에 미치는 영향으로 가장 적절한 것은?', '2', '1.메모리 사용량이 증가한다;2.평균 탐색 시간이 길어진다;3.해시 함수의 성능이 저하된다;4.적재율이 감소한다', 7);

-- Unit07 - 트리 1 (Lesson ID: 8)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (77, 'FILL_BLANK', '트리(Tree)란 _____들이 나무 가지처럼 연결된 자료구조이다.', '노드, node', '-', 8),

    (78, 'FILL_BLANK', '각 노드와 노드는 _____으로 연결된다.', '간선, edge', '-', 8),

    (79, 'SELECT_DESCRIPTION', '트리에서 최상위에 위치한 노드를 무엇이라고 하는가?', '4', '1.부모 노드;2.자식 노드;3.리프 노드;4.루트 노드', 8),

    (80, 'SELECT_DESCRIPTION', '트리에서 자식 노드를 갖고있지 않는 노드를 무엇이라고 하는가?', '3', '1.부모 노드;2.자식 노드;3.리프 노드;4.부모 노드', 8),

    (81, 'FILL_BLANK', '노드가 n개인 트리는 _____개의 간선을 갖고 있다.', 'n-1', '1.2n;2.n;3.n+1;4.n-1', 8),

    (82, 'FILL_BLANK', '트리에서 루트 노드부터 특정 노드까지의 거리를 그 노드의 _____라고 한다.', '깊이, depth', '-', 8),

    (83, 'SELECT_DESCRIPTION', '이진 트리에서 각 노드가 가질 수 있는 최대 자식 노드의 개수는?', '2', '1.1개;2.2개;3.3개;4.제한 없음', 8),

    (84, 'FILL_BLANK', '한 노드에서 다른 노드로 가는 일련의 간선들을 _____라고 한다.', '경로, path', '-', 8),

    (85, 'SELECT_DESCRIPTION', '트리에서 사이클(순환)이 존재하는가?', '2', '1.항상 존재한다;2.존재하지 않는다;3.경우에 따라 다르다;4.루트 노드에만 존재한다', 8),

    (86, 'FILL_BLANK', '트리에서 한 노드가 갖고 있는 자식 노드의 개수를 그 노드의 _____라고 한다.', '차수, degree', '-', 8);

-- Unit07 - 트리 2 (Lesson ID: 9)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (87, 'SELECT_DESCRIPTION', '높이가 5인 이진트리에서 가질 수 있는 최대 노드의 개수는?', '63', '-', 9),

    (88, 'FILL_BLANK', '이진트리에서 현재 노드, 왼쪽 자식 노드, 오른쪽 자식 노드 순서로 방문하는 순회방식을 _____순회라고 한다.', '전위, preorder', '-', 9),

    (89, 'FILL_BLANK', '이진트리에서 왼쪽 자식 노드, 현재 노드, 오른쪽 자식 노드 순서로 방문하는 순회방식을 _____순회 라고 한다.', '중위, inorder', '-', 9),

    (90, 'FILL_BLANK', '이진트리에서 왼쪽 자식 노드, 오른쪽 자식 노드, 현재 노드 순서로 방문하는 순회방식을 _____순회 라고 한다.', '후위, postorder', '-', 9),

    (91, 'SELECT_DESCRIPTION', '이진탐색트리의 성질로 올바른 것은?', '2', '1.부모노드 > 왼쪽 자식노드 > 오른쪽 자식노드;2.오른쪽 자식노드 > 부모노드 > 왼쪽 자식노드;3.왼쪽 자식노드 > 부모노드 > 오른쪽 자식노드;4.부모노드 > 오른쪽 자식노드 > 왼쪽 자식노드', 9),

    (92, 'SELECT_DESCRIPTION', '균형잡힌 이진탐색트리에서 특정 값을 조회하는데 걸리는 시간복잡도는?', '2', '1.O(1);2.O(log n);3.O(n);4.O(n log n)', 9),

    (93, 'SELECT_DESCRIPTION', '균형잡힌 이진탐색트리에서 특정 값을 삽입/삭제하는데 걸리는 시간복잡도는?', '2', '1.O(1);2.O(log n);3.O(n);4.O(n log n)', 9),

    (94, 'FILL_BLANK', '모든 레벨이 완전하게 채워져 있고, 마지막 레벨의 모든 노드가 존재하는 이진트리를 _____이진트리라고 한다.', '포화', '-', 9),

    (95, 'SELECT_DESCRIPTION', '완전이진트리의 특징으로 올바른 것은?', '2', '1.모든 레벨이 완전히 채워져 있다;2.마지막 레벨을 제외하고 모든 레벨이 채워져 있으며, 마지막 레벨은 왼쪽부터 채워진다.;3.같은 레벨에 있는 노드의 값은 항상 동일하다.;4.모든 리프노드의 높이는 최대 2까지 차이난다.', 9),

    (96, 'SELECT_DESCRIPTION', '완전이진트리를 구현할 때, 가장 적합한 자료구조는?', '1', '1.배열;2.연결 리스트;3.스택;4.힙', 9);

-- Unit07 - 트리 3 (Lesson ID: 10)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (97, 'FILL_BLANK', '각 노드가 블랙 또는 레드 색상으로 표기되며, 특정 규칙을 통해 스스로 균형을 유지하는 이진탐색트리를 _____트리라고 한다.', '레드블랙, 레드 블랙, 레드-블랙, red-black', '-', 10),

    (98, 'FILL_BLANK', '레드-블랙트리에서 루트 노드의 색상은 _____이다', '블랙, 블렉, black, 검은색', '-', 10),

    (99, 'FILL_BLANK', '레드-블랙트리에서 자식이 없는 모든 노드는 _____ 노드를 갖고있다.', 'nil', '-', 10),

    (100, 'FILL_BLANK', '레드-블랙트리에서 새 노드를 삽입할 경우 _____ 색상으로 설정한다.', '레드, 빨간, 빨강, red', '-', 10),

    (101, 'SELECT_DESCRIPTION', '레드-블랙 트리의 탐색, 삽입, 삭제 연산의 시간복잡도는?', '2', '1.O(1);2.O(log N);3.O(N);4.O(N log N)', 10),

    (102, 'FILL_BLANK', '힙은 항상 _____이진트리의 형태를 유지해야 한다.', '완전', '-', 10),

    (103, 'SELECT_DESCRIPTION', '힙에서 특정 데이터의 삽입/삭제 연산의 시간복잡도는?', '2', '1.O(1);2.O(log N);3.O(N);4.O(N log N)', 10),

    (104, 'SELECT_DESCRIPTION', '최대 힙에서 새로운 데이터를 삽입하는 과정으로 올바른 것은?', '2', '1.루트노드에 삽입 후 아래로 내려감;2.마지막 노드에 삽입 후 위로 올라감;3.임의의 위치에 삽입하고 정렬함;4.왼쪽 자식부터 삽입함', 10);


-- Chapter 2
-- Unit08 - 정렬 1 (Lesson ID: 11)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (105, 'SELECT_DESCRIPTION', '다음 중 기본적으로 불안정(unstable) 인 정렬은?', '2', '1.버블정렬;2.선택정렬;3.삽입정렬;4.기수정렬(LSD, 안정 카운팅 사용)', 11),

    (106, 'SELECT_DESCRIPTION', '입력이 이미 정렬되어 있을 때 Θ(n) 시간에 끝낼 수 있는 정렬은?', '3', '1.버블정렬(조기종료 미적용);2.선택정렬;3.삽입정렬;4.기수정렬', 11),

    (107, 'SELECT_DESCRIPTION', '길이 n 배열에서 선택 정렬의 총 비교 횟수는? (빅-Θ)', '3', '1.Θ(n);2.Θ(n log n);3.Θ(n²);4.Θ(n³)', 11),

    (108, 'SELECT_DESCRIPTION', '교환(swaps) 횟수가 항상 O(n) 인 정렬은?', '2', '1.버블정렬;2.선택정렬;3.삽입정렬;4.기수정렬', 11),

    (109, 'SELECT_DESCRIPTION', '버블정렬에서 i번째 패스가 끝나면 성립하는 사실은?', '2', '1.첫 i개의 원소가 정렬 완료;2.마지막 i개의 원소가 정렬 위치에 고정;3.중간 i개의 원소가 정렬 완료;4.어떤 부분도 보장되지 않음', 11),

    (110, 'SELECT_DESCRIPTION', '입력을 한 원소씩 읽으며 접두 구간을 항상 정렬 상태로 유지하는 정렬은?', '3', '1.버블정렬;2.선택정렬;3.삽입정렬;4.기수정렬', 11),

    (111, 'SELECT_DESCRIPTION', '기수정렬(LSD, 각 자리 안정 정렬) 시간복잡도는 자리수 d, 기수 k, 입력 크기 n일 때?', '2', '1.Θ(n log n);2.Θ(d·(n + k));3.Θ(d·k·log n);4.Θ(n² / d)', 11),

    (112, 'SELECT_DESCRIPTION', 'LSD 기수정렬에서 각 자리를 정렬할 때 반드시 필요한 성질은?', '2', '1.불안정 정렬;2.안정 정렬;3.비교 기반 정렬;4.제자리(in-place) 정렬', 11),

    (113, 'SELECT_DESCRIPTION', '배열 [5, 1, 4, 2]에 버블정렬 첫 패스(왼→오) 후 배열은?', '1', '1.[1, 4, 2, 5];2.[1, 5, 4, 2];3.[4, 1, 2, 5];4.[5, 4, 2, 1]', 11),

    (114, 'SELECT_DESCRIPTION', '삽입정렬의 이동(shift) 횟수는 어떤 값과 가장 밀접히 비례하는가?', '1', '1.역순쌍(인버전) 개수;2.최대값의 크기;3.최소값의 위치;4.중복 원소의 수', 11),

    (115, 'SELECT_DESCRIPTION', '거의 정렬된 작은 데이터에 가장 적합한 것은?', '3', '1.버블정렬;2.선택정렬;3.삽입정렬;4.기수정렬', 11),

    (116, 'SELECT_DESCRIPTION', '다음 중 O(n + k) 의 추가 메모리가 필요한 것은?', '4', '1.버블정렬;2.선택정렬;3.삽입정렬;4.기수정렬', 11);

-- Unit08 - 정렬 2 (Lesson ID: 12)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (117, 'SELECT_DESCRIPTION', '다음 중 기본적으로 안정적(stable)인 정렬은?', '3', '1.힙정렬;2.퀵정렬;3.병합정렬;4.모두 불안정', 12),

    (118, 'SELECT_DESCRIPTION', 'O(1) 보조 메모리(제자리)로 수행되는 것은?', '2', '1.병합정렬;2.힙정렬;3.퀵정렬(재귀 스택 제외);4.카운팅정렬', 12),

    (119, 'SELECT_DESCRIPTION', '최악의 경우 Θ(n²)이 될 수 있는 것은?', '2', '1.힙정렬;2.퀵정렬;3.병합정렬;4.위 모두 아님', 12),

    (120, 'SELECT_DESCRIPTION', '퀵정렬의 평균 성능을 안정화하는 전략으로 적절한 것은?', '3', '1.항상 첫 원소를 피벗;2.항상 마지막 원소를 피벗;3.랜덤 피벗 선택;4.정렬된 입력에서 중앙값을 피벗', 12),

    (121, 'SELECT_DESCRIPTION', '배열을 한 번에 힙으로 만드는 Floyd의 build-heap 시간은?', '1', '1.Θ(n);2.Θ(n log n);3.Θ(log n);4.Θ(n²)', 12),

    (122, 'SELECT_DESCRIPTION', '최대 힙을 이용해 힙에서 원소를 하나씩 꺼내 출력하면, 출력되는 값들의 순서는?', '2', '1.오름차순;2.내림차순;3.입력과 동일;4.무작위', 12),

    (123, 'SELECT_DESCRIPTION', '배열 기반 병합 정렬에서 일반적으로 필요한 추가 공간은?', '4', '1.Θ(1);2.Θ(log n);3.Θ(√n);4.Θ(n)', 12),

    (124, 'SELECT_DESCRIPTION', '배열의 역순쌍(인버전)을 효율적으로 세는 데 적합한 방법은?', '2', '1.힙정렬 수정;2.병합정렬 응용;3.퀵정렬 응용;4.버킷정렬', 12),

    (125, 'SELECT_DESCRIPTION', '퀵정렬의 파티션이 끝난 직후 피벗 p에 대해 참인 것은?', '3', '1.p보다 작은 원소가 모두 오른쪽에 있다;2.p보다 큰 원소가 모두 왼쪽에 있다;3.p는 최종 위치에 있고, 왼쪽 ≤ p, 오른쪽 ≥ p가 된다;4.정렬이 모두 끝난다', 12),

    (126, 'SELECT_DESCRIPTION', '메모리에 다 안 들어가는 매우 큰 데이터를 정렬할 때 적합한 방법은?', '2', '1.힙정렬;2.병합정렬(외부 정렬);3.퀵정렬;4.삽입정렬', 12),

    (127, 'SELECT_DESCRIPTION', '퀵정렬에서 분할이 거의 균등할 때 각 재귀 레벨의 총 작업량과 높이는?', '1', '1.레벨 합 Θ(n), 높이 Θ(log n);2.레벨 합 Θ(log n), 높이 Θ(n);3.레벨 합 Θ(n log n), 높이 Θ(n);4.레벨 합 Θ(1), 높이 Θ(log n)', 12),

    (128, 'SELECT_DESCRIPTION', '힙정렬이 기본적으로 불안정한 가장 큰 이유는?', '2', '1.비교 기반이 아니라서;2.루트-말단 교환으로 동일 키의 상대 순서가 뒤섞일 수 있어서;3.힙 구성 비용이 커서;4.재귀가 깊어서', 12);

-- Unit09 - 그리디 알고리즘 1 (Lesson ID: 13)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (129, 'SELECT_DESCRIPTION', '다음 중 그리디 알고리즘 설명으로 가장 가까운 것은?', '2', '1.모든 경우를 다 탐색해 최적을 찾는다;2.현재 순간 최선처럼 보이는 선택을 한다;3.이전 결과를 저장하고 그 값을 활용한다;4.무작위로 선택해도 평균적으로 맞는다', 13),

    (130, 'FILL_BLANK', '그리디-초이스 프로퍼티는 "지금 고른 선택을 포함하는 _____가 적어도 하나 존재한다"는 뜻이다.', '최적해', '1.해답 후보;2.국소해;3.최적해;4.근사해', 13),

    (131, 'FILL_BLANK', '교환 논법은 임의의 최적해가 있을 때 그 해의 일부를 그리디가 고른 선택으로 _____해의 품질이 나빠지지 않음을 보이는 방법이다.', '바꿔도', '1.추가해도;2.제거해도;3.바꿔도;4.섞어도', 13),

    (132, 'SELECT_DESCRIPTION', '전형적으로 그리디가 최적을 보장하는 문제는?', '2', '1.0-1 배낭 최적값;2.겹치지 않는 구간(회의) 최대 개수 선택;3.음수 간선 허용 최단경로;4.임의 동전 체계 거스름돈', 13),

    (133, 'SELECT_DESCRIPTION', '동전 {1,5,10,50,100,500}으로 760원을 최소 개수로 거슬러줄 때 동전 개수는?', '2', '1.4개;2.5개;3.6개;4.7개', 13),

    (134, 'SELECT_DESCRIPTION', '동전 {1,3,4}로 6원을 거슬러줄 때 그리디와 최적해는?', '1', '1.그리디=3개(4+1+1), 최적=2개(3+3);2.그리디=2개(3+3), 최적=3개(4+1+1);3.둘 다 2개;4.둘 다 3개', 13),

    (135, 'SELECT_DESCRIPTION', '동전 {1,3,4}에서 큰 동전 우선 그리디가 처음 실패하는 최소 금액은?', '3', '1.4;2.5;3.6;4.7', 13),

    (136, 'SELECT_DESCRIPTION', '새 동전 체계에서 그리디의 올바름을 빠르게 점검하는 방법은?', '2', '1.임의의 큰 금액 하나만 테스트;2.작은 금액부터 1~N까지 최적과 비교해 반례 탐색;3.동전 개수만 세면 된다;4.항상 맞다고 가정한다', 13),

    (137, 'SELECT_DESCRIPTION', '분할 가능 배낭에서 가치 최대화를 위한 전형적 정렬 기준은?', '3', '1.무게 오름차순;2.가치 오름차순;3.가치/무게 비율 내림차순;4.무작위', 13),

    (138, 'SELECT_DESCRIPTION', '(무게, 가치) → A(4,20), B(2,14), C(6,24), 용량 7. 분할 가능 배낭 그리디의 최대 가치는?', '2', '1.36;2.38;3.40;4.42', 13),

    (139, 'SELECT_DESCRIPTION', '0-1 배낭에서 비율 내림차순 그리디는 항상 최적인가?', '1', '1.아니다. 반례가 있다;2.그렇다. 항상 최적이다;3.물건이 2개면 항상 최적이다;4.용량이 크면 항상 최적이다', 13),

    (140, 'SELECT_DESCRIPTION', '0-1 배낭에서 비율 그리디가 실패하는 핵심 이유는?', '2', '1.교환 논법을 적용할 수 없다;2.물건을 쪼갤 수 없어 부분 채움 이득을 쓰지 못한다;3.비율 계산이 부정확하다;4.정렬이 비안정이라서', 13);

-- Unit09 - 그리디 알고리즘 2 (Lesson ID: 14)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (141, 'SELECT_DESCRIPTION', '서로 겹치지 않는 구간을 최대 개수로 선택하려면 어떤 정렬 기준이 적절한가?', '3', '1.시작 시간 오름차순;2.길이(끝-시작) 오름차순;3.끝나는 시간 오름차순;4.이득/시간 비율 내림차순', 14),

    (142, 'SELECT_DESCRIPTION', '작업들의 마감시간이 주어질 때 최대 지연을 최소로 만드는 단일 머신 스케줄링 규칙은?', '3', '1.시작 시간 오름차순;2.처리 시간 짧은 순(SPT);3.마감 시간 오름차순(EDD);4.가치/시간 비율 내림차순', 14),

    (143, 'SELECT_DESCRIPTION', 'd는 마감 시간, 하나의 머신만 사용. J1(d=2, 이익=60), J2(d=1, 이익=100), J3(d=2, 이익=20). 총 이익을 최대로 하는 그리디 선택은?', '1', '1.{J1, J2};2.{J1, J3};3.{J2, J3};4.{J1, J2, J3}', 14),

    (144, 'SELECT_DESCRIPTION', '구간 [1,4], [2,5], [3,6], [7,9]를 모두 배치할 때 필요한 최소 회의실 수는?', '3', '1.1;2.2;3.3;4.4', 14),

    (145, 'SELECT_DESCRIPTION', '빈도 A=5, B=7, C=10, D=15일 때 Huffman 트리의 총 비용(병합 합의 합)은?', '2', '1.69;2.71;3.72;4.73', 14),

    (146, 'SELECT_DESCRIPTION', '빈도 A=2, B=3, C=7, D=9에서 첫 병합 쌍은?', '1', '1.(A,B);2.(A,C);3.(B,C);4.(C,D)', 14),

    (147, 'SELECT_DESCRIPTION', '다음 중 접두부(prefix-free) 코드인 것은?', '1', '1.{A:0, B:10, C:110, D:111};2.{A:0, B:01, C:011, D:0111};3.{A:1, B:10, C:101, D:1011};4.{A:0, B:00, C:10, D:11}', 14),

    (148, 'SELECT_DESCRIPTION', 'Huffman 코딩은 무엇을 최소화하는 그리디 알고리즘인가?', '2', '1.최대 코드 길이;2.평균(기대) 코드 길이;3.심볼 개수;4.엔트로피', 14),

    (149, 'SELECT_DESCRIPTION', '우주 U={1,2,3,4,5,6,7}, 집합 S1={1,2,3,4}, S2={3,4,5}, S3={5,6,7}, S4={6,7}. 무가중치 그리디(아직 덮지 않은 원소를 가장 많이 덮는 집합)를 적용할 때 선택 순서는?', '1', '1.S1 → S3;2.S3 → S1;3.S1 → S4;4.S2 → S3', 14),

    (150, 'SELECT_DESCRIPTION', 'U={a,b,c,d,e}, A={a,b,c}(비용3), B={c,d,e}(비용2), C={a,e}(비용1). 가중치 그리디(단위 비용당 신규 커버 수 최대)를 처음 적용할 때 선택은?', '3', '1.A;2.B;3.C', 14),

    (151, 'FILL_BLANK', '가중치가 있을 때 그리디는 매 단계 _____가 최대인 집합을 고른다.', '신규 커버 수/비용', '1.비용/신규 커버 수;2.신규 커버 수/비용;3.전체 크기;4.이미 덮인 원소 수', 14),

    (152, 'SELECT_DESCRIPTION', '무가중치 Set Cover에 대한 고전적 그리디 알고리즘의 근사 보장은?', '3', '1.항상 최적;2.2-근사;3.H(n)≈ln|U| 근사;4.보장 없음', 14);

-- Unit10 - BFS, DFS (Lesson ID: 15)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (153, 'SELECT_DESCRIPTION', 'DFS(깊이 우선 탐색)와 BFS(너비 우선 탐색)의 가장 중요한 차이점은?', '3', '1.DFS는 모든 노드를 방문하지만, BFS는 일부만 방문한다;2.DFS는 재귀를 사용하고 BFS는 반복문을 사용한다;3.DFS는 깊게 탐색하고 BFS는 넓게 탐색한다;4.DFS는 최단 경로를 보장하지만, BFS는 그렇지 않다', 15),

    (154, 'SELECT_DESCRIPTION', 'BFS(너비 우선 탐색)에서 일반적으로 사용하는 자료구조는?', '2', '1.스택;2.큐;3.힙;4.해시테이블', 15),

    (155, 'SELECT_DESCRIPTION', 'DFS(깊이 우선 탐색)에서는 일반적으로 _____나 재귀호출을 사용한다.', '스택', '-', 15),

    (156, 'SELECT_DESCRIPTION', '가중치가 없는 그래프에서 최단 경로를 찾기에 적합한 알고리즘은?', '2', '1.DFS;2.BFS;3.DFS, BFS 둘 다;4.둘 다 불가능', 15),

    (157, 'FILL_BLANK', 'DFS와 BFS 모두 그래프 탐색 시 무한루프를 방지하기 위해 노드의 _____ 여부를 반드시 검사해야 한다.', '방문, 탐색, 검사', '-', 15),

    (158, 'SELECT_DESCRIPTION', 'DFS의 주요 특징이 아닌 것은?', '3', '1.재귀적으로 구현 가능;2.백트래킹에 사용;3.FIFO 원칙으로 동작;4.메모리 사용량이 적음', 15),

    (159, 'SELECT_DESCRIPTION', 'BFS가 DFS보다 유리한 상황은?', '3', '1.모든 노드를 방문해야 할 때;2.메모리 사용량을 줄여야 할 때;3.시작점에서 목표점까지의 최단 거리를 구할 때;4.깊은 단계의 해를 찾을 때', 15),

    (160, 'SELECT_DESCRIPTION', 'V개의 정점과 E개의 간선을 가진 그래프에서 BFS의 시간복잡도는?', '1', '1.O(V + E);2.O(V × E);3.O(V²);4.O(E log V)', 15),

    (161, 'SELECT_DESCRIPTION', 'V개의 정점과 E개의 간선을 가진 그래프에서 DFS의 시간복잡도는?', '1', '1.O(V + E);2.O(V × E);3.O(V²);4.O(E log V)', 15);

-- Unit11 - Dynamic Programming (Lesson ID: 16)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (162, 'FILL_BLANK', '동적 프로그래밍(DP)에서 한 번 계산된 결과를 저장해 두었다가, 같은 문제가 호출되었을 때 저장된 결과를 사용하는 기법을 _____이라고 한다.', '메모이제이션, memoization', '-', 16),

    (163, 'SELECT_DESCRIPTION', '동적 프로그래밍(DP)이 적용되기 위한 필수 조건이 아닌 것은?', '3', '1.중복 부분 문제;2.최적 부분 구조;3.정렬된 입력 데이터;4.점화식 도출 가능', 16),

    (164, 'FILL_BLANK', '피보나치 수열에서 F(n) = F(n-1) + F(n-2)와 같은 수식을 _____식이라고 한다.', '점화', '-', 16),

    (165, 'FILL_BLANK', 'Top-down 방식은 재귀 함수와 메모이제이션을 사용하고 Bottom-up 방식은 _____문을 사용한다.', '반복', '-', 16),

    (166, 'FILL_BLANK', '동적 프로그래밍(DP)에서 작은 문제들의 최적해가 큰 문제의 최적해에 포함되는 성질을 _____ _____구조라고 한다.', '최적 부분, 최적부분', '-', 16),

    (167, 'SELECT_DESCRIPTION', '용량이 13인 배낭에 무게와 가치가 각각 (3,6), (4,8), (5,9), (6,11), (2,4), (4,7)인 물건들이 있을 때, 최적해에서 선택되는 물건의 개수는?', '4개', '-', 16),

    (168, 'SELECT_DESCRIPTION', '편집 거리 문제에서 문자열 길이가 각각 m, n일 때 2차원 DP 테이블의 크기와 시간복잡도는?', '4', '1.(m×n), O(mn);2.(m+n), O(m+n);3.(m×n), O(m²n²);4.(m+1)×(n+1), O(mn)', 16),

    (169, 'SELECT_DESCRIPTION', '최장 증가 부분 수열(LIS) 문제에서 배열 [1, 3, 2, 5, 4, 7, 6, 8]의 LIS 길이는?', '5', '-', 16),

    (170, 'FILL_BLANK', '동적 프로그래밍을 적절히 사용하면 지수 시간복잡도를 _____ 시간복잡도로 개선할 수 있다.', '다항식', '-', 16);

-- Unit12 - 다익스트라 알고리즘 (Lesson ID: 17)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (171, 'FILL_BLANK', '다익스트라 알고리즘은 _____의 가중치가 없는 그래프의 한 정점에서 모든 정점까지의 최단 경로를 구하는 알고리즘이다.', '음, -', '-', 17),

    (172, 'FILL_BLANK', '다익스트라 알고리즘의 메커니즘은 방문하지 않은 정점 중에서 가장 적은 비용의 정점을 선택한다는 점에서 _____ 알고리즘의 성질을 가지고 있다고 볼 수 있다.', '그리디', '-', 17),

    (173, 'FILL_BLANK', '다익스트라 알고리즘의 메커니즘은 선택된 노드로부터 갈 수 있는 노드들의 비용을 갱신한다는 점에서 _____의 성질을 가지고 있다고 볼 수 있다.', 'dp, dynamic programming, 디피, 동적 계획법, 동적 프로그래밍', '-', 17),

    (174, 'FILL_BLANK', '다익스트라 알고리즘에서 거리 배열을 초기화할 때, 출발점은 0으로 나머지 정점들은 _____로 설정한다.', '무한대, inf, ∞', '-', 17),

    (175, 'SELECT_DESCRIPTION', '5개 노드로 구성된 완전 그래프에서 다익스트라 알고리즘을 수행할 때, 최대 몇 번의 거리 갱신 연산이 발생할 수 있는가?', '3', '1.10번;2.16번;3.20번;4.25번', 17),

    (176, 'SELECT_DESCRIPTION', '정점의 개수가 V, 간선의 개수가 E일 때 우선순위 큐를 사용한 다익스트라 알고리즘의 시간복잡도는?', '2', '1.O(V²);2.O(E log V);3.O(V + E);4.O(E²)', 17),

    (177, 'SELECT_DESCRIPTION', '정점의 개수가 V, 간선의 개수가 E일 때 선형탐색(반복문)을 사용한 다익스트라 알고리즘의 시간복잡도는?', '1', '1.O(V²);2.O(E log V);3.O(V + E);4.O(E²)', 17),

    (178, 'SELECT_DESCRIPTION', '다익스트라 알고리즘이 음수 간선이 있는 그래프에서 올바르게 동작하지 않는 이유는?', '2', '1.우선순위 큐가 음수를 처리할 수 없어서;2.그리디 방식으로 한 번 방문한 노드를 재방문하지 않아서;3.메모리 부족 때문에;4.무한루프가 발생해서', 17),

    (179, 'SELECT_DESCRIPTION', '정점 5개, 간선 8개인 그래프에서 우선순위 큐(중복 허용)를 사용한 다익스트라 실행 시 우선순위 큐의 최대 크기는?', '2', '1.5;2.8;3.13;4.40', 17);

-- Unit13 - 벨먼-포드 알고리즘 (Lesson ID: 18)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (180, 'FILL_BLANK', '벨먼-포드 알고리즘과 다익스트라 알고리즘의 가장 중요한 차이점은?', '벨먼-포드는 음수 간선을 처리할 수 있다', '1.벨먼-포드는 음수 간선을 처리할 수 있다;2.벨먼-포드가 더 빠르다;3.다익스트라는 모든 간선을 확인한다;4.벨먼-포드는 우선순위 큐를 사용한다', 18),

    (181, 'SELECT_DESCRIPTION', 'V개의 정점과 E개의 간선을 갖고 있는 그래프에서 벨먼-포드 알고리즘의 시간복잡도는?', '1', '1.O(VE);2.O(V²);3.O(E log V);4.O(V + E)', 18),

    (182, 'SELECT_DESCRIPTION', 'V개의 정점을 갖고 있는 그래프에서 벨먼-포드 알고리즘은 최단 거리를 구하기 위해 모든 간선을 확인하는 과정을 몇 번 반복하는가?', '1', '1.V-1번;2.V번;3.V+1번;4.2V번', 18),

    (183, 'SELECT_DESCRIPTION', 'V개의 정점을 갖고 있는 그래프에서 벨먼-포드 알고리즘으로 음수 사이클을 감지하는 방법은?', '1', '1.V-1번 반복 후 추가로 한 번 더 실행했을 때 거리가 갱신되면;2.음수 간선의 개수를 센다;3.우선순위 큐가 비어있으면;4.거리 배열에 음수가 있으면', 18),

    (184, 'FILL_BLANK', '벨먼-포드 알고리즘은 매 단계마다 모든 _____를 확인하여 거리를 갱신한다.', '간선, edge', '-', 18),

    (185, 'SELECT_DESCRIPTION', '음수 사이클이 존재하는 그래프에서 벨먼-포드 알고리즘의 결과는?', '3', '1.정확한 최단 거리를 구할 수 있다;2.최단 거리를 무한히 줄일 수 있어 정확한 값을 보장할 수 없다;3.음수 사이클을 감지하고 이를 알려준다;4.알고리즘이 실행되지 않는다', 18);

-- CHapter 3
-- Unit14 - 네트워크 기초 (Lesson ID: 19)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (186, 'SELECT_DESCRIPTION', '다음 중 작은 지역(사무실, 건물) 내에서 컴퓨터와 장치를 연결하는 네트워크는?', '1', '1.LAN;2.WAN;3.MAN;4.인터넷', 19),

    (187, 'SELECT_DESCRIPTION', '클라이언트-서버 모델에서 ''클라이언트''의 역할은?', '1', '1.요청을 보내는 역할;2.요청을 처리하고 응답하는 역할;3.네트워크를 관리하는 역할;4.단순히 데이터를 전송하는 역할', 19),

    (188, 'SELECT_DESCRIPTION', '네트워크 토폴로지 중 중앙 장치에 모든 노드가 연결되는 구조는?', '2', '1.버스형;2.성형(Star);3.링형;4.메시형', 19),

    (189, 'SELECT_DESCRIPTION', '네트워크 성능을 측정하는 지표가 아닌 것은?', '4', '1.대역폭(Bandwidth);2.지연시간(Latency);3.처리량(Throughput);4.저장 용량(Storage)', 19),

    (190, 'FILL_BLANK', '데이터를 네트워크를 통해 목적지까지 정확하게 전달하기 위해 사용하는 규칙을 _____ 이라고 한다.', '프로토콜, protocol', '-', 19),

    (191, 'SELECT_DESCRIPTION', '양쪽 모두 데이터 전송이 가능하지만 한 번에 한쪽만 전송할 수 있는 통신 방식은?', '2', '1.단방향;2.반이중;3.전이중;4.양방향', 19),

    (192, 'FILL_BLANK', '데이터를 네트워크로 전송하기 위해 캡슐화된 최소 단위를 _____ 이라고 한다.', '패킷', '-', 19),

    (193, 'FILL_BLANK', '네트워크에서 단위 시간당 전송 가능한 최대 데이터 양을 나타내는 용어는 _____ 이다.', '대역폭, bandwidth', '-', 19),

    (194, 'SELECT_DESCRIPTION', '서로 다른 네트워크 간 통신을 가능하게 하는 논리적 주소는?', '1', '1.IP 주소;2.MAC 주소;3.서브넷;4.도메인 주소', 19),

    (195, 'FILL_BLANK', '데이터를 네트워크 내 특정 그룹의 장치들에게만 전달하는 전송 방식을 _____ 라고 한다.', '멀티캐스트', '-', 19),

    (196, 'SELECT_DESCRIPTION', '서로 다른 네트워크를 연결하고 최적 경로를 선택하는 장치는?', '1', '1.라우터;2.허브;3.스위치;4.모뎀', 19),

    (197, 'SELECT_DESCRIPTION', '데이터를 작은 단위로 나누어 전송하고 인터넷에서 주로 사용하는 방식은?', '2', '1.회선교환;2.패킷교환;3.전이중;4.반이중', 19);

-- Unit15 - OSI 7계층 (Lesson ID: 20)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (198, 'SELECT_DESCRIPTION', '비트 단위로 데이터를 전송하고 케이블, 광섬유, 무선 매체를 사용하는 계층은?', '1', '1.물리;2.데이터 링크;3.네트워크;4.전송', 20),

    (199, 'SELECT_DESCRIPTION', '데이터 전송 단위를 프레임(Frame)으로 처리하는 계층은?', '2', '1.전송;2.데이터 링크;3.네트워크;4.응용', 20),

    (200, 'FILL_BLANK', '전송 계층에서 부르는 데이터 전송 단위를 _____이라고 한다.', '세그먼트, segment', '-', 20),

    (201, 'SELECT_DESCRIPTION', '데이터링크 계층에서 장치를 고유하게 식별하는 주소는?', '2', '1.IP 주소;2.MAC 주소;3.포트 번호;4.서브넷 마스크', 20),

    (202, 'SELECT_DESCRIPTION', 'OSI 7계층에서 응용 계층의 역할은?', '2', '1.실제 데이터 전송;2.사용자와 네트워크 간 인터페이스 제공;3.패킷 라우팅;4.프레임 전송', 20),

    (203, 'SELECT_DESCRIPTION', 'TCP/IP 모델에서 전송 계층에 해당하는 프로토콜은?', '2', '1.IP;2.UDP;3.HTTP;4.ARP', 20),

    (204, 'FILL_BLANK', 'TCP/IP 모델에서 데이터 전송 시 응용 프로그램을 구분하기 위해 사용하는 것은 _____이다.', '포트번호', '-', 20),

    (205, 'FILL_BLANK', '주소 지정과 라우팅 기능을 수행하는 계층은_____계층 이다.', '네트워크', '-', 20),

    (206, 'SELECT_DESCRIPTION', '서로 다른 네트워크 간 데이터를 전달할 때 사용하고 네트워크 계층에서 사용되는 주소는 _____주소 이다.', 'ip', '-', 20),

    (207, 'SELECT_DESCRIPTION', 'TCP/IP에서 포트 번호 80번은 주로 어떤 서비스에 사용되는가?', '2', '1.SMTP;2.HTTP;3.FTP;4.DNS', 20),

    (208, 'FILL_BLANK', 'TCP/IP 모델에서 TCP는 데이터를 목적지까지 _____ 있게 전달하는 프로토콜이다.', '신뢰성', '-', 20);

-- Unit15 - TCP/IP 모델 (Lesson ID: 21)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (209, 'SELECT_DESCRIPTION', 'TCP/IP 모델의 인터넷 계층은 OSI 모델의 어느 계층과 대응되는가?', '3', '1.물리;2.데이터 링크;3.네트워크;4.전송', 21),

    (210, 'SELECT_DESCRIPTION', 'TCP/IP 모델 전송 계층의 주요 기능이 아닌 것은?', '3', '1.신뢰성 있는 데이터 전송;2.흐름 제어;3.패킷 라우팅;4.포트 번호 관리', 21),

    (211, 'FILL_BLANK', 'TCP/IP 모델의 응용 계층에서 도메인을 IP 주소로 변환하는 프로토콜은 _____이다.', 'dns', '-', 21),

    (212, 'FILL_BLANK', 'TCP/IP 모델에서 데이터가 목적지까지 전송될 때 사용하는 논리적 단위 _____이다.', '패킷', '-', 21),

    (213, 'SELECT_DESCRIPTION', '데이터링크 계층에서 충돌을 감지하고 제어하는 방식은 무엇인가?', '2', '1.DHCP;2.CSMA/CD;3.FTP;4.SMTP', 21),

    (214, 'SELECT_DESCRIPTION', 'TCP/IP에서 포트 번호 53번은 주로 어떤 서비스에 사용되는가?', '3', '1.HTTP;2.FTP;3.DNS;4.SMTP', 21),

    (215, 'FILL_BLANK', 'IP 주소를 자동으로 할당해주는 서버는 _____이다.', 'dhcp', '-', 21),

    (216, 'SELECT_DESCRIPTION', 'ARP(Address Resolution Protocol)의 기능은?', '1', '1.IP 주소를 MAC 주소로 변환;2.MAC 주소를 IP 주소로 변환;3.DNS 조회;4.DHCP 주소 할당', 21),

    (217, 'SELECT_DESCRIPTION', 'OSI 데이터링크 계층에서 오류 검출을 위해 추가하는 필드 이름은?', '2', '1.포트 번호;2.CRC;3.IP 주소;4.ACK', 21);

-- Unit16 - 물리 & 데이터 링크 계층 (Lesson ID: 22)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (218, 'FILL_BLANK', '물리 계층에서는 데이터를 _____ 단위로 전송한다.', '비트, bit', '-', 22),

    (219, 'SELECT_DESCRIPTION', 'UTP 케이블에서 데이터를 보내는 선의 쌍은 몇 개인가?', '2', '1.1쌍;2.2쌍;3.3쌍;4.4쌍', 22),

    (220, 'FILL_BLANK', '스위치가 프레임을 전달할 때 참조하는 주소는 _____이다.', 'mac 주소', '-', 22),

    (221, 'SELECT_DESCRIPTION', '광섬유 케이블의 장점이 아닌 것은?', '3', '1.장거리 전송 가능;2.전자기 간섭에 강함;3.설치가 매우 저렴함;4.높은 대역폭 제공', 22),

    (222, 'SELECT_DESCRIPTION', 'CSMA/CD에 대한 설명 중 틀린 것은 무엇인가', '4', '1.장치가 데이터를 보내기 전에 매체를 감시한다;2.충돌이 발생하면 즉시 감지하고 재전송한다;3.주로 유선 LAN에서 사용된다;4.무선 LAN에서 충돌을 회피하기 위해 사용된다', 22),

    (223, 'FILL_BLANK', '전송 매체에서 신호가 약해지는 현상을 _____라 한다.', '감쇠', '-', 22),

    (224, 'SELECT_DESCRIPTION', 'CRC 방식의 특징으로 올바른 것은?', '2', '1.단일 비트 오류만 검출 가능하다;2.연속된 다중 비트 오류도 검출 가능하다;3.데이터 암호화 방식이다;4.충돌 회피 기능을 제공한다', 22),

    (225, 'SELECT_DESCRIPTION', 'CSMA/CA 방식은 주로 _____ LAN에서 사용된다.', '무선', '-', 22),

    (226, 'SELECT_DESCRIPTION', '전송 매체 중 전자기 간섭(EMI)에 가장 취약한 것은?', '2', '1.동축 케이블;2.UTP 케이블;3.광섬유;4.무선', 22),

    (227, 'FILL_BLANK', '이더넷에서 최소 프레임 크기는 _____바이트이다.', '64', '-', 22),

    (228, 'SELECT_DESCRIPTION', '스위치와 허브의 차이점으로 옳은 것은?', '3', '1.스위치는 모든 포트로 브로드캐스트한다;2.허브는 MAC 주소 기반으로 프레임을 전달한다;3.스위치는 MAC 주소 기반으로 프레임을 전달한다;4.허브는 IP 주소 기반으로 라우팅한다', 22);

-- Unit17 - 네트워크 계층 (Lesson ID: 23)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (229, 'FILL_BLANK', 'IPv4 주소는 _____비트로 구성되어 있다.', '32', '-', 23),

    (230, 'SELECT_DESCRIPTION', 'IPv6 주소 길이는 얼마인가?', '3', '1.32비트;2.64비트;3.128비트;4.256비트', 23),

    (231, 'SELECT_DESCRIPTION', 'IPv4 주소 클래스 중 일반적으로 소규모 네트워크에서 사용되는 클래스는?', '3', '1.클래스 A;2.클래스 B;3.클래스 C;4.클래스 D', 23),

    (232, 'FILL_BLANK', 'IP 주소에서 같은 네트워크 내 모든 장치로 전송하는 주소는?', '브로드캐스트', '1.브로드캐스트;2.멀티캐스트;3.유니캐스트;4.애니캐스트', 23),

    (233, 'SELECT_DESCRIPTION', '서브넷팅의 목적이 아닌 것은?', '3', '1.트래픽 분리;2.IP 주소 효율적 사용;3.데이터 암호화;4.네트워크 관리 용이', 23),

    (234, 'FILL_BLANK', '서브넷 마스크는 네트워크 주소와 _____ 주소를 구분하기 위해 사용된다.', '호스트', '-', 23),

    (235, 'SELECT_DESCRIPTION', '호스트 수 계산 공식으로 옳은 것은?', '2', '1.2^(32-서브넷 비트);2.2^(32-서브넷 비트)-2;3.2^(서브넷 비트);4.2^(서브넷 비트)-2', 23),

    (236, 'FILL_BLANK', '라우팅 테이블에는 목적지 IP, 서브넷 마스크, 게이트웨이, _____ 등이 포함된다.', '인터페이스', '-', 23),

    (237, 'SELECT_DESCRIPTION', '정적 라우팅의 특징은 무엇인가?', '2', '1.라우터가 자동으로 경로를 갱신한다;2.관리자가 수동으로 경로를 설정한다;3.트래픽에 따라 경로가 변동한다;4.동적 라우팅 프로토콜을 사용한다', 23),

    (238, 'SELECT_DESCRIPTION', '정적 라우팅은 주로 네트워크가 _____ 환경에서 사용된다', '1', '1.작거나 단순한;2.크거나 단순한;3.크거나 복잡한;4.작거나 복잡한', 23),

    (239, 'SELECT_DESCRIPTION', '동적 라우팅 프로토콜 중 내부 게이트웨이 프로토콜(IGP)이 아닌 것은?', '3', '1.RIP;2.OSPF;3.BGP;4.EIGRP', 23),

    (240, 'FILL_BLANK', '라우터가 목적지 IP와 가장 구체적인 서브넷을 매칭하여 선택하는 경로를 _____ 경로라고 한다.', '최적', '-', 23);

-- Unit18 - 전송 계층 (Lesson ID: 24)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (241, 'SELECT_DESCRIPTION', 'UDP의 주요 장점으로 올바른 것은?', '2', '1.신뢰성 보장;2.낮은 지연과 오버헤드;3.순서 제어;4.흐름 제어', 24),

    (242, 'SELECT_DESCRIPTION', 'TCP 헤더에 포함되지 않는 필드는?', '4', '1.시퀀스 번호;2.체크섬;3.포트번호;4.MAC 주소', 24),

    (243, 'FILL_BLANK', 'TCP의 흐름 제어는 _____ 윈도우 방식을 사용한다.', '슬라이딩', '-', 24),

    (244, 'FILL_BLANK', 'TCP 연결을 설정할 때 사용하는 3단계 과정은 _____ 연결(handshake)이다.', '3-way', '-', 24),

    (245, 'FILL_BLANK', 'TCP는 데이터가 순서대로 도착하도록 _____ 기능을 제공한다.', '순서 제어', '-', 24),

    (246, 'SELECT_DESCRIPTION', '3-way 핸드쉐이크 과정에서 순서가 올바른 것은?', '1', '1.SYN → SYN-ACK → ACK;2.ACK → SYN → SYN-ACK;3.SYN-ACK → SYN → ACK;4.SYN → ACK → SYN-ACK', 24),

    (247, 'SELECT_DESCRIPTION', 'TCP 헤더의 ACK 번호 필드는 무엇을 나타내는가?', '1', '1.수신 측이 다음에 받을 바이트 번호;2.송신 측이 보낸 패킷의 순서 번호;3.패킷의 포트번호;4.체크섬 값', 24),

    (248, 'SELECT_DESCRIPTION', 'TCP 흐름제어의 주요 목적은 무엇인가?', '2', '1.네트워크 대역폭 확보;2.수신 측 버퍼 오버플로우 방지;3.포트번호 충돌 방지;4.데이터 암호화', 24),

    (249, 'FILL_BLANK', '4-way 핸드쉐이크에서 ACK 수신 후에도 일정 시간 동안 연결을 유지하는 상태를 _____라고 한다.', 'time-wait', '-', 24),

    (250, 'SELECT_DESCRIPTION', 'TCP 혼잡 제어의 주요 목적은 무엇인가?', '2', '1.수신 측 버퍼 오버플로우 방지;2.네트워크 혼잡으로 인한 패킷 손실 방지;3.포트번호 관리;4.데이터 암호화', 24),

    (251, 'SELECT_DESCRIPTION', 'UDP는 주로 어떤 상황에서 사용되는가?', '2', '1.파일 전송과 이메일;2.실시간 비디오 스트리밍과 온라인 게임;3.HTTP 웹 브라우징;4.TCP 기반 데이터베이스 동기화', 24);

-- Unit19 - 응용 계층 (Lesson ID: 25)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (252, 'SELECT_DESCRIPTION', 'HTTPS는 HTTP에 무엇을 추가하여 보안을 강화했는가?', '2', '1.TCP 연결;2.SSL/TLS 암호화;3.UDP 전송;4.DNS 변환', 25),

    (253, 'SELECT_DESCRIPTION', 'SMTP의 주된 용도는 무엇인가?', '2', '1.웹 페이지 전송;2.이메일 송신;3.이메일 수신;4.파일 다운로드', 25),

    (254, 'SELECT_DESCRIPTION', 'POP3와 IMAP은 주로 어떤 기능과 관련이 있는가', '2', '1.웹 페이지 전송;2.이메일 수신;3.이메일 송신;4.파일 전송', 25),

    (255, 'SELECT_DESCRIPTION', 'FTP는 주로 어떤 목적으로 사용되는가?', '2', '1.웹 페이지 요청;2.파일 전송;3.이메일 송수신;4.도메인 이름 변환', 25),

    (256, 'SELECT_DESCRIPTION', 'SMTP의 기본 포트번호는 무엇인가?', '2', '1.21;2.25;3.53;4.80', 25),

    (257, 'FILL_BLANK', 'FTP에서 데이터 전송 시 사용하는 두 가지 채널은 제어 채널(Control Channel)과 _____ 채널이다.', '데이터', '-', 25),

    (258, 'SELECT_DESCRIPTION', 'POP3와 IMAP의 차이점은?', '1', '1.IMAP은 서버에 이메일을 남기고 동기화, POP3는 다운로드 후 삭제;2.POP3는 서버에 이메일을 남기고 동기화, IMAP은 다운로드 후 삭제;3.둘 모두 동일;4.IMAP은 웹 전송, POP3는 파일 전송', 25),

    (259, 'SELECT_DESCRIPTION', 'FTP에서 사용하는 두 채널은?', '2', '1.명령 채널과 데이터 채널;2.제어 채널과 데이터 채널;3.제어 채널과 인증 채널;4.명령 채널과 인증 채널', 25),

    (260, 'SELECT_DESCRIPTION', 'HTTP/1.1에서 Keep-Alive 기능의 목적은 무엇인가?', '1', '1.연결을 계속 열어 여러 요청을 처리;2.IP 주소를 변경;3.웹 페이지 캐시 삭제;4.클라이언트 인증', 25),

    (261, 'SELECT_DESCRIPTION', 'HTTPS가 HTTP보다 안전한 이유는?', '2', '1.TCP 연결 사용;2.데이터 암호화와 무결성 검증;3.포트번호 변경;4.DNS 변환 수행', 25),

    (262, 'SELECT_DESCRIPTION', 'DNS 레코드 중 IP 주소를 나타내는 레코드는 무엇인가?', '2', '1.MX;2.A;3.CNAME;4.TXT', 25),

    (263, 'SELECT_DESCRIPTION', 'FTP의 제어 채널과 데이터 채널의 차이점으로 올바른 것은?', '1', '1.제어 채널은 명령 전송, 데이터 채널은 파일 전송;2.제어 채널은 파일 전송, 데이터 채널은 명령 전송;3.둘 다 파일 전송만 수행;4.둘 다 명령 전송만 수행', 25);

-- Unit20 - 네트워크 보안 (Lesson ID: 26)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (264, 'SELECT_DESCRIPTION', 'SSL/TLS의 주요 목적은?', '2', '1.TCP 연결;2.데이터 암호화 및 무결성;3.포트 관리;4.파일 전송', 26),

    (265, 'SELECT_DESCRIPTION', 'VPN의 주된 목적은?', '2', '1.이메일 송신;2.안전한 터널링과 암호화;3.DNS 조회;4.포트 필터링', 26),

    (266, 'FILL_BLANK', '방화벽은 불법 접근을 차단하여 _____을 제공한다.', '보안', '-', 26),

    (267, 'SELECT_DESCRIPTION', 'MITM 공격의 특징은?', '1', '1.데이터 도청/변조;2.서비스 거부;3.포트 스캐닝;4.이메일 송신', 26),

    (268, 'SELECT_DESCRIPTION', 'DoS 공격의 목적은?', '2', '1.데이터 암호화;2.자원 소진으로 서비스 중단;3.이메일 수신;4.DNS 조회', 26),

    (269, 'FILL_BLANK', '피싱 공격은 사용자의 _____을 탈취하려는 공격이다.', '정보', '-', 26),

    (270, 'SELECT_DESCRIPTION', 'PKI에서 인증서와 공개키를 통해 보장하는 것은?', '1', '1.신뢰성;2.포트관리;3.캐시 관리;4.연결 유지', 26),

    (271, 'SELECT_DESCRIPTION', 'ACL의 주요 역할은?', '1', '1.접근 권한 제어;2.이메일 송신;3.파일 다운로드;4.DNS 변환', 26),

    (272, 'SELECT_DESCRIPTION', 'SSH의 주요 목적은?', '1', '1.원격 접속 보안;2.파일 다운로드;3.이메일 송신;4.DNS 조회', 26),

    (273, 'FILL_BLANK', '암호화 방식 중 공개키와 개인키를 사용하는 방식은 _____ 암호화이다.', '비대칭', '-', 26),

    (274, 'SELECT_DESCRIPTION', '대칭키 암호화의 장점은?', '1', '1.속도가 빠르다;2.키 관리 간단;3.인증서 필요;4.공개키 필요', 26),

    (275, 'SELECT_DESCRIPTION', 'DoS와 DDoS 공격의 차이는?', '1', '1.DDoS는 여러 컴퓨터에서 공격;2.DoS는 여러 컴퓨터에서 공격;3.둘 다 동일;4.DDoS는 이메일 공격', 26),

    (276, 'FILL_BLANK', '디지털 서명은 데이터의 _____와 송신자 신원을 확인하는 데 사용된다.', '무결성', '-', 26);

-- Chapter 4
-- Unit21 - 운영체제 & 시스템 구조 1 (Lesson ID: 27)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (277, 'FILL_BLANK', '시스템 콜(System Call)이 실행될 때 CPU 모드는 _____로 전환된다.', '커널, kernel', '-', 27),

    (278, 'FILL_BLANK', 'BIOS 이후에 실행되어 운영체제를 메모리에 적재하는 프로그램은 _____이다.', '부트로더, bootloader', '-', 27),

    (279, 'SELECT_DESCRIPTION', 'UNIX 계열의 운영체제가 아닌 것은?', '3', '1.Linux;2.macOS;3.Window;4.Android', 27),

    (280, 'FILL_BLANK', 'CPU에서 명령어 해석 역할을 하는 구성 요소는 _____이다.', '디코더, decoder', '-', 27),

    (281, 'SELECT_DESCRIPTION', '저장공간의 접근 속도가 높은 순서대로 올바르게 나열된 것은?', '4', '1.Tape Drive > Hard Drive > RAM > SSD;2.Hard Drive > SSD > Tape Drive > RAM;3.Tape Drive > Hard Drive > SSD > RAM;4.RAM > SSD > Hard Drive > Tape Drive', 27),

    (282, 'SELECT_DESCRIPTION', '다음 중 CPU에 가장 가까운 것은?', '1', '1.L1;2.L2;3.모두 동일함', 27),

    (283, 'FILL_BLANK', '64KB 메모리의 주소는 _____부터 _____까지다.', '0, 65535', '1.0, 65535;2.1, 65536;3.0, 255;4.1, 256', 27),

    (284, 'SELECT_DESCRIPTION', '디바이스가 CPU를 거치지 않고 메모리와 직접 데이터를 주고받을 수 있는 방식은?', 'dma, direct memory access', '-', 27),

    (285, 'FILL_BLANK', 'DMA는 데이터 전송이 완료되면 CPU에 _____를 보내어 전송이 끝났음을 알린다.', '인터럽트, interrupts', '-', 27),

    (286, 'SELECT_DESCRIPTION', '인터럽트의 장점으로 옳지 않은 것은?', '3', '1.CPU와 디바이스 병렬 동작;2.I/O 대기 중 다른 작업 수행;3.모든 인터럽트는 동기적 발생;4.핸들러 후 원래 프로세스 복귀', 27),

    (287, 'SELECT_DESCRIPTION', 'BIOS의 주요 역할로 옳지 않은 것은?', '4', '1.하드웨어 정상 여부 확인;2.저장장치의 MBR을 메모리에 적재;3.저수준 장치 드라이버 설치;4.프로세스 스케줄링 수행', 27),

    (288, 'FILL_BLANK', '_____는 BIOS의 설정 값을 저장한다.', '시모스, cmos', '-', 27);

-- Unit21 - 운영체제 & 시스템 구조 2 (Lesson ID: 28)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (289, 'FILL_BLANK', 'x86 아키텍처에서 시스템 콜은 int _____명령을 통해 발생한다.', '0x80', '-', 28),

    (290, 'FILL_BLANK', '사용자 모드에서 실행되는 프로그램이 시스템 콜을 호출하면 CPU 모드는 _____모드로 변환된다.', '커널, kernel', '-', 28),

    (291, 'FILL_BLANK', '파일 입출력, 프로세스 제어, 메모리 관리 등이 _____을 통해 수행된다.', '시스템 콜, 시스템콜, system call', '-', 28),

    (292, 'FILL_BLANK', '커널 아키텍처 중 _____커널은 모든 기능을 커널 공간에서 실행하며, 코드 베이스가 크고 기능이 많다. 반면 _____커널은 최소한의 기능만 커널에 포함시키고 나머지는 사용자 공간에서 실행한다.', 'monolithic, microkernel', '1.Monolithic, Microkernel;2.Microkernel, Hybrid kernel;3.Hybrid, Monolithic;4.Microkernel, Monolithic', 28),

    (293, 'SELECT_DESCRIPTION', '다음 운영체제와 커널 구조를 올바르게 연결한 것은?', '2', '1.Linux - Microkernel;2.ios - Hybrid Kernel;3.Android - Microkernel;4.QNX - Monolithic Kernel', 28),

    (294, 'SELECT_DESCRIPTION', '마이크로커널 구조에서 커널 공간에 포함되는 필수 기능으로 올바른 것은?', '3', '1.File System;2.Disk Driver;3.CPU Scheduling;4.Networking Service', 28),

    (295, 'FILL_BLANK', '마이크로커널은 많은 컨텍스트 스위치로 성능이 _____된다.', '저하', '-', 28),

    (296, 'FILL_BLANK', '모놀리식 커널은 _____ 코드 베이스로 커널 개발이 용이하다.', '단일, 싱글, single', '-', 28),

    (297, 'SELECT_DESCRIPTION', 'MBR(Master Boot Record)의 크기로 옳은 것은?', '1', '1.512byte;2.512bit;3.256byte;4.128byte', 28),

    (298, 'SELECT_DESCRIPTION', 'CPU 캐시 계층 중 가장 빠르고 용량이 작은 것은?', '1', '1.L1;2.L2;3.L3;4.모두 동일함', 28),

    (299, 'FILL_BLANK', '운영체제는 사용자에게 실제보다 많은 CPU나 메모리가 있는 것처럼 보이게 하는데, 이를 _____라고 한다.', '가상화', '-', 28),

    (300, 'SELECT_DESCRIPTION', '운영체제의 설계 목표 중 하나로, 프로그램 간 간섭을 막고 안정성을 보장하는 것은?', '보호', '-', 28);

-- Unit21 - 운영체제 & 시스템 구조 3 (Lesson ID: 29)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (301, 'SELECT_DESCRIPTION', '초기 컴퓨터 시스템의 운영 방식으로, 작업을 순서대로 모아 처리하는 것은?', '2', '1.시분할 시스템;2.배치 처리 시스템;3.멀티태스킹 시스템;4.실시간 시스템', 29),

    (302, 'FILL_BLANK', '운영체제는 프로그램이 I/O 장치를 직접 다루지 않고 사용할 수 있도록 _____를 제공한다', '장치 드라이버', '-', 29),

    (303, 'FILL_BLANK', '현대 운영체제의 중요한 목표 중 하나는, 시스템 일부가 고장나도 계속 동작하는 _____을 보장하는 것이다.', '신뢰성', '-', 29),

    (304, 'SELECT_DESCRIPTION', '다수의 사용자와 다수의 프로그램이 동시에 시스템을 사용하는 것을 가능하게 한 것은?', '시분할, time-sharing, time sharing', '-', 29),

    (305, 'SELECT_DESCRIPTION', '멀티프로그래밍이 도입된 주요 목적은?', '1', '1.CPU 활용률 향상;2.코드 가독성 향상;3.기계어 단순화;4.보안 취약점 제거', 29),

    (306, 'SELECT_DESCRIPTION', '운영체제의 설계 목표에 해당하지 않는 것은?', '4', '1.추상화 제공;2.성능 향상;3.보호와 보안;4.하드웨어 복잡도 증가', 29),

    (307, 'SELECT_DESCRIPTION', '시분할(Time-sharing) 시스템의 주요 장점은?', '2', '1.전체 시스템 처리량 최대화;2.대화식 사용자의 빠른 응답 시간 제공;3.메모리 사용량 최소화;4.네트워크 대역폭 절약', 29),

    (308, 'FILL_BLANK', '운영체제가 제공하는 핵심 기능 중 하나는 하드웨어 세부사항을 감추고 _____ 인터페이스를 제공하는 것이다.', '추상화', '-', 29);

-- Unit22 - 프로세스 1 (Lesson ID: 30)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (309, 'FILL_BLANK', '프로그램은 디스크에 저장된 명령어와 데이터의 묶음이고, 실행 중인 프로그램을 _____라 한다.', '프로세스', '-', 30),

    (310, 'SELECT_DESCRIPTION', '다음 중 프로세스 상태가 아닌 것은?', '4', '1.Running;2.Ready;3.Waiting;4.Request', 30),

    (311, 'FILL_BLANK', '실행 중인 프로세스를 다른 프로세스로 전환하기 위해 레지스터 상태를 저장하고 복원하는 과정을 _____라고 한다.', '문맥 교환, context switch, 컨텍스트 스위치', '-', 30),

    (312, 'FILL_BLANK', 'CPU가 한 프로세스를 실행하다가 다른 프로세스로 전환될 때, 이전 프로세스의 상태는 _____에 저장된다', 'pcb, process control block', '-', 30),

    (313, 'SELECT_DESCRIPTION', '다음 중 PCB에 포함되지 않는 정보는?', '4', '1.프로세스 상태;2.레지스터 값;3.프로그램 카운터;4.컴파일러 최적화 정보', 30),

    (314, 'FILL_BLANK', '프로세스가 실행할 준비는 되었으나 CPU를 할당받지 못한 상태를 _____라고 한다.', '준비, ready', '-', 30),

    (315, 'SELECT_DESCRIPTION', '부모 프로세스가 먼저 종료했지만 자식 프로세스가 계속 실행 중인 경우, 자식 프로세스는 어떤 상태가 되는가?', '2', '1.zombie;2.orphan;3.ready;4.terminated', 30),

    (316, 'FILL_BLANK', '프로세스가 I/O 요청을 하여 기다리는 동안의 상태는 _____이다.', '대기, waiting', '-', 30),

    (317, 'FILL_BLANK', '자식 프로세스의 종료를 부모 프로세스가 확인하는 시스템 콜은?', 'wait()', '-', 30),

    (318, 'SELECT_DESCRIPTION', '이중 동작 모드(Dual-Mode Operation)에서 일반 사용자 프로그램이 동작하는 모드는?', '1', '1.User Mode;2.Kernel Mode;3.Supervisor Mode;4.Hypervisor Mode', 30),

    (319, 'FILL_BLANK', '자식 프로세스가 종료되었지만 부모 프로세스가 아직 _____ 시스템 콜을 호출하지 않으면 자식은 _____ 상태가 된다.', 'wait, zombie', '1.wait, orphan;2.wait, zombie;3.fork, ready;4.kill, zombie', 30),

    (320, 'SELECT_DESCRIPTION', '프로세스의 하드웨어 상태 중 현재 실행 중인 명령어의 위치를 가리키는 레지스터는?', '프로그램 카운터, pc, program counter', '-', 30);

-- Unit22 - 프로세스 2 (Lesson ID: 31)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (321, 'SELECT_DESCRIPTION', '우선순위가 가장 높은 프로세스가 준비 상태에서 실행 상태로 전환되는 것은?', '3', '1.Wake Up;2.Timer Runout;3.Dispatch;4.Spooling', 31),

    (322, 'SELECT_DESCRIPTION', '프로세스 관리 명령어 중 현재 실행 중인 프로세스를 확인하는 명령어는?', 'ps', '-', 31),

    (323, 'SELECT_DESCRIPTION', '모든 프로세스 트리의 루트가 되며 커널에 의해 가장 먼저 시작되는 프로세스는?', 'init', '-', 31),

    (324, 'SELECT_DESCRIPTION', 'x86에서 스택의 성장 방향은?', '2', '1.위로;2.아래로;3.고정;4.OS에 따라 다름', 31),

    (325, 'SELECT_DESCRIPTION', '함수 종료 시 ret 명령은 스택에서 무엇을 꺼내나?', '2', '1.인자;2.복귀 주소;3.지역 변수;4.레지스터', 31),

    (326, 'SELECT_DESCRIPTION', '함수 호출 시 새 스택 프레임이 생성될 때 가장 먼저 수행되는 동작은?', '1', '1.EBP 저장;2.ESP 증가;3.EAX 초기화;4.PC 변경', 31),

    (327, 'SELECT_DESCRIPTION', '운영체제가 새로운 프로세스를 시작할 때 가짜 스택 프레임을 만드는 이유는 무엇인가?', '4', '1.다른 프로세스와 데이터 공유 목적;2.실행 속도 향상;3.PID 재사용 목적;4.switch()를 호출한 것처럼 보이기 위해', 31),

    (328, 'SELECT_DESCRIPTION', '운영체제가 프로세스를 전환하는 시점으로 옳지 않은 것은?', '4', '1.프로세스가 I/O 요청을 할 때;2.CPU 사용 시간이 끝났을 때;3.프로세스가 스스로 CPU를 양보할 때;4.프로세스가 정상적으로 종료될 때', 31),

    (329, 'FILL_BLANK', '운영체제가 사용자 프로세스와 커널을 분리하지 않고 모두 같은 권한으로 실행한다면, 사용자 프로세스가 _____를 덮어쓸 수 있다.', '커널 메모리', '-', 31),

    (330, 'FILL_BLANK', 'x86 CPU는 권한 링(RIng) 구조를 제공한다. 대부분의 OS는 Ring 0과 Ring _____만 사용한다.', '0, 3', '-', 31),

    (331, 'SELECT_DESCRIPTION', '다음은 시스템 콜이 실행되는 과정을 단계별로 설명한 것이다. 올바른 순서를 나열한 것은? a. OS가 시스템 콜을 실행하고 결과를 EAX에 저장한다. b. 소프트웨어가 int 0x80을 실행한다. c. CPU가 OS 핸들러로 제어를 넘기고, 링 3에서 링 0으로 전환한다. d. OS가 프로세스 상태를 복원하고, iret으로 사용자 모드로 복귀한다.', '2', '1.a-b-c-d;2.b-c-a-d;3.b-a-c-d;4.c-b-a-d', 31),

    (332, 'SELECT_DESCRIPTION', '다음 중 UNIX에서 fork()를 호출할 때 **실제로 수행되는 단계**로 옳지 않은 것은?', '3', '1.새로운 PCB를 생성하고 초기화;2.새로운 주소 공간 생성;3.부모 프로세스의 커널 복사;4.부모 프로세스의 실행 상환경을 상속 받는다.', 31);

-- Unit23 - 스레드 (Lesson ID: 32)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (333, 'FILL_BLANK', '모든 프로세스는 적어도 하나의 _____를 가진다.', '스레드', '-', 32),

    (334, 'SELECT_DESCRIPTION', '다중 스레드 프로세스에서 스레드 간에 공유되지 않는 것은?', '3', '1.코드;2.전역 데이터;3.스택;4.파일 디스크립터', 32),

    (335, 'FILL_BLANK', '_____ 모델은 여러 사용자 스레드를 여러 커널 스레드에 매핑할 수 있다.', 'many-to-many', '-', 32),

    (336, 'SELECT_DESCRIPTION', 'Many-to-One 스레드 모델의 단점으로 옳은 것은?', '3', '1.각 사용자 스레드가 커널 스레드와 1:1로 매핑된다.;2.멀티코어 시스템에서 병렬 실행이 가능하다.;3.하나의 스레드가 블록되면 모든 스레드가 블록된다.;4.운영체제가 충분한 커널 스레드를 생성할 수 있다.', 32),

    (337, 'SELECT_DESCRIPTION', 'Two-level 스레드 모델이 Many-to-Many 모델과의 차이점으로 옳은 것은?', '4', '1.하나의 커널 스레드만 사용;2.생성 시 커널 스레드 자동 생성;3.병렬 실행 불가;4.특정 스레드 바인딩 가능', 32),

    (338, 'FILL_BLANK', 'pthread_create()는 스레드를 _____하는 함수이다.', '생성', '-', 32),

    (339, 'FILL_BLANK', 'pthread_join(tid, 0)의 역할은 무엇인가? (pthread_t tid;)', '특정 스레드 종료까지 대기', '1.특정 스레드 종료까지 대기;2.현재 스레드 즉시 종료;3.스레드 속성 초기화;4.새 스레드 생성', 32),

    (340, 'FILL_BLANK', 'clone() API는 부모 프로세스의 주소 공간을 공유하지만 _____은 새로 할당받는다.', '스택, stack', '-', 32),

    (341, 'SELECT_DESCRIPTION', '예를 들어 10개의 스레드를 가지고 있다고 하자. 한 스레드가 exec()를 호출하면 어떤 일이 벌어지는가?', '2', '1.하나를 제외한 모든 스레드 종료;2.모든 스레드 종료;3.하나의 스레드 종료;4.새로운 스레드 생성', 32),

    (342, 'FILL_BLANK', 'TLS는 전역 변수처럼 보이지만 모든 스레드가 공유하는 것이 아니라 _____마다 별도로 존재한다.', '스레드, thread', '-', 32),

    (343, 'SELECT_DESCRIPTION', '실시간 주식 거래 시스템에서 성능보다는 안정성이 중요한 경우, 스레드 대신 프로세스를 선택한다. 스레드를 선택하지 않는 이유는?', '2', '1.생성 비용이 크다.;2.오류가 전체 시스템에 전파된다.;3.메모리 사용량이 많다.;4.동시 실행이 불가능하다.', 32),

    (344, 'SELECT_DESCRIPTION', '어떤 API를 사용해야 새로운 프로세스가 부모와 완전히 독립적인 주소 공간을 갖는가?', '1', '1.fork();2.clone();3.exec();4.pthread_create()', 32),

    (345, 'SELECT_DESCRIPTION', '다중 코어 CPU에서 병렬 실행이 불가능한 모델은?', '1', '1.Many-To-One;2.One-To-One;3.Many-To-Many;4.Two-level', 32),

    (346, 'SELECT_DESCRIPTION', '보안성이 중요한 금융 애플리케이션에서 전역 데이터가 스레드마다 독립적으로 유지되도록 하기 위해 사용하는 기법은?', '2', '1.Context Switching;2.TLS;3.Process Isolation;4.OpenMP', 32);

-- Unit24 - 스케줄링 1 (Lesson ID: 33)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (347, 'SELECT_DESCRIPTION', '스케줄러가 스케줄링 결정을 내리는 시점 중 선점(preemption)이 발생하는 경우는?', '3', '1.running → waiting;2.프로세스 종료;3.running → ready;4.waiting → terminated', 33),

    (348, 'SELECT_DESCRIPTION', 'Dispatch Latency가 큰 경우 시스템에 미치는 주요 영향은?', '2', '1.CPU 사용률이 높아진다.;2.응답 시간이 느려진다.;3.보안성이 강화된다.;4.프로세스 동기화가 단순해진다.', 33),

    (349, 'FILL_BLANK', '스케줄러가 다음에 실행할 프로세스를 선택하면, 디스패처는 실제로 _____를 수행하여 선택된 프로세스에게 CPU 제어권을 넘겨준다.', '컨텍스트 스위칭, context switching', '-', 33),

    (350, 'FILL_BLANK', '시스템 컨텐션 스코프(SCS)는 커널이 _____를 직접 지원할 때 적용되는 스케줄링 범위이다.', '스레드, thread', '-', 33),

    (351, 'SELECT_DESCRIPTION', '커널이 스레드를 지원하지 않는 환경에서 스레드 스케줄링은 어떻게 이루어지는가?', '1', '1.각 프로세스가 자체적으로 스레드 스케줄링 수행;2.스레드 라이브러리가 모든 스케줄링 담당;3.디스패처가 스레드를 생성;4.스케줄링이 불가능하다.', 33),

    (352, 'FILL_BLANK', '스케줄러가 고려해야 할 주요 최적화 기준에는 CPU 사용률, 처리량, 대기 시간, 응답 시간, _____이 있다.', '공정성, fairness', '-', 33),

    (353, 'SELECT_DESCRIPTION', '모든 최적화 기준을 동시에 만족할 수 없는 이유로 가장 적절한 것은?', '3', '1.CPU 자원이 무한하지 않기 때문에;2.I/O 장치가 속도가 느리기 때문에;3.각 기준이 서로 상충 관계에 있기 때문에;4.커널이 프로세스를 지원하지 않기 때문에', 33),

    (354, 'FILL_BLANK', '_____ 스케줄링은 프로세스가 자발적으로 CPU를 반납하기 전까지 CPU를 계속 점유할 수 있고, _____ 스케줄링은 스케줄러가 강제로 CPU를 회수하여 다른 프로세스에게 할당할 수 있다.', '비선점형, 선점형', '-', 33),

    (355, 'SELECT_DESCRIPTION', '프로세스가 시스템에 도착한 시점부터 완전히 실행을 마칠 때까지의 총 소요 시간은?', 'turnaround time', '-', 33),

    (356, 'FILL_BLANK', '프로세스가 실행하는 작업들의 집합을 _____라 하며, 스케줄링 성능을 평가할 때 중요한 기준이 된다.', '워크로드, workload', '-', 33);

-- Unit24 - 스케줄링 2 (Lesson ID: 34)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (357, 'SELECT_DESCRIPTION', 'CPU burst 시간이 긴 프로세스가 먼저 실행될 때 짧은 프로세스들이 오랫동안 대기하게 되는 현상을 무엇이라고 하는가?', '2', '1.Head-of-line blocking;2.Convoy effect;3.Starvation;4.Priority inversion', 34),

    (358, 'FILL_BLANK', 'SJF 스케줄링 알고리즘은 평균 _____ 시간을 최소화하는 최적 알고리즘으로 알려져 있다.', '대기, waiting', '-', 34),

    (359, 'SELECT_DESCRIPTION', 'STCF 스케줄러의 특징으로 옳은 것은?', '2', '1.프로세스가 시작하면 끝날 때까지 CPU를 독점한다.;2.남은 실행 시간이 가장 짧은 프로세스를 선택한다.;3.FCFS보다 평균 대기 시간이 항상 길다.;4.I/O bound 프로세스에는 적합하지 않다.', 34),

    (360, 'FILL_BLANK', 'SJF와 STCF 모두 각 프로세스의 CPU _____ Time을 미리 알고 있다는 가정 하에 동작한다.', 'burst', '-', 34),

    (361, 'FILL_BLANK', 'SJF에 선점 기능을 추가한 스케줄러를 _____라 한다.', 'stcf, shortest time-to-completion first', '-', 34),

    (362, 'FILL_BLANK', 'Interactive 시스템에서 가장 중요한 성능 지표는 _____이다.', '응답성, responsiveness', '-', 34),

    (363, 'FILL_BLANK', 'Response time은 _____ Run Time - Arrival time 으로 정의된다.', 'first', '-', 34),

    (364, 'FILL_BLANK', 'Round Robin 스케줄링에서 time slice를 너무 작게 설정했을 때 _____ 현상이 일어날 수 있다.', '오버헤드, overhead', '-', 34);

-- Unit24 - 스케줄링 3 (Lesson ID: 35)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (365, 'SELECT_DESCRIPTION', '우선순위 스케줄링에서 기아(Starvation) 문제를 완화하기 위한 대표적인 방법은?', '2', '1.고정된 CPU burst 시간 사용;2.우선순위를 동적으로 조정하는 방법;3.더 긴 프로세스를 우선 실행;4.FIFO 큐 사용', 35),

    (366, 'FILL_BLANK', 'EDF(Earliest Deadline First) 스케줄링은 _____이 빠를수록 더 높은 우선순위를 가진다.', 'deadline, 마감기한', '-', 35),

    (367, 'FILL_BLANK', 'MLQ(Multilevel Queue) 스케줄링에서 사용자 상호작용 프로세스는 _____ 방식으로 스케줄링되고, CPU bound 프로세스는 FCFS 방식으로 스케줄링된다.', 'rr, round robin, 라운드로빈', '-', 35),

    (368, 'FILL_BLANK', 'MLFQ에서 한 프로세스가 time slice를 끝까지 다 사용하면 우선순위가 _____진다.', '낮아', '-', 35),

    (369, 'SELECT_DESCRIPTION', '다음 중 옳지 않은 MLFQ 규칙은?', '1', '1.우선순위가 같다면 반드시 FCFS 방식을 사용한다.;2.제일 높은 우선순위를 가진 프로세스 먼저 실행한다.;3.time slice를 다 쓴 프로세스는 우선순위를 낮춘다.;4.time slice를 다 쓰기 전에 종료하면 현재 큐에 머무른다.', 35),

    (370, 'FILL_BLANK', '높은 우선순위 프로세스만 계속 수행되면 낮은 우선순위 프로세스에게 _____ 현상이 일어날 수 있다.', '기아', '-', 35),

    (371, 'SELECT_DESCRIPTION', 'Priority Boost의 주요 목적을 가장 적절히 설명한 것은?', '3', '1.높은 우선순위 프로세스를 더 빨리 끝내기 위해;2.CPU 바운드 작업을 항상 최상위 큐에 두기 위해;3.기아를 방지하고 동적 프로세스 변화를 반영하기 위해;4.모든 프로세스를 무조건 같은 우선순위로 만들기 위해', 35),

    (372, 'FILL_BLANK', '총 CPU 사용 시간을 기준으로 우선순위 강등은 MLFQ의 _____ 방지를 위해 수정된 Rule 4 규칙이다.', 'cheat', '-', 35),

    (373, 'FILL_BLANK', 'Lottery 스케줄링은 각 프로세스에 여러 장의 _____을 주고, 매 타임 슬라이스마다 추첨을 통해 실행할 프로세스를 정한다.', '티켓, ticket', '-', 35),

    (374, 'FILL_BLANK', 'Stride 스케줄링에서 각 프로세스는 일정한 _____ 값을 가지고 실행될 때마다 pass 값에 이를 더한다.', '간격, stride', '-', 35),

    (375, 'SELECT_DESCRIPTION', 'Lottery 스케줄링과 Stride 스케줄링의 공통적인 한계는?', '3', '1.랜덤성으로 인한 불안정성;2.pass 값 저장의 복잡성;3.티켓 할당 방법과 수량;4.타임 슬라이스 무시', 35),

    (376, 'SELECT_DESCRIPTION', 'Stride 스케줄링에서 K=10000일 때. P1 tickets : 200, P2 tickets : 50을 가지고 있다. 이 경우 P1과 P2의 stride 값은?', '4', '1.100, 100;2.200, 50;3.5, 20;4.50, 200', 35);

-- Unit25 - 프로세스 동기화 1 (Lesson ID: 36)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (377, 'FILL_BLANK', 'CPU의 성능 향상은 주로 _____ 수의 증가와 클럭 속도 향상에 의해 이루어졌으나, 최근에는 클럭 속도 향상이 정체되어 코어 수의 증가로 발전 방향이 바뀌었다.', '트랜지스터', '-', 36),

    (378, 'SELECT_DESCRIPTION', 'Concurrency와 Parallelism의 차이를 올바르게 설명한 것은? (C - Concurrency, P - Parallelism)', '3', '1.C는 여러 코어에서 실행되고 P은 단일 코어에서 실행된다.;2.C는 동시에 실행되지만 P은 동시에 실행되지 않는다.;3.C는 시분할 실행, P은 멀티코어 실제 동시 실행.;4.C와 P은 완전히 동일한 개념이다.', 36),

    (379, 'SELECT_DESCRIPTION', '데이터 병렬성(Data Parallelism)에 대한 설명으로 옳은 것은?', '2', '1.동일한 데이터에 대해 서로 다른 작업을 수행한다.;2.동일한 작업을 여러 코어에서 수행하지만 다른 데이터를 처리한다.;3.서로 다른 작업을 동일한 데이터에 수행한다.;4.모든 코어가 동시에 동일한 명령을 수행한다.', 36),

    (380, 'SELECT_DESCRIPTION', 'Amdahl의 법칙에 따르면, 병렬 성능 향상이 제한되는 주요 요인은 무엇인가?', '3', '1.캐시 용량.;2.CPU 발열.;3.직렬 코드의 비율.;4.I/O 속도.', 36),

    (381, 'FILL_BLANK', 'Amdahl의 법칙에서 코어 수 N이 무한대로 증가할 때, 최대 성능 향상은 _____에 수렴한다.', '1/S', '-', 36),

    (382, 'FILL_BLANK', 'Amdahl의 법칙은 현실을 단순화한 모델로, 실제 시스템에서는 데이터 종속성과 _____ 문제로 인해 예측치보다 성능이 낮게 나타난다.', '동기화', '-', 36),

    (383, 'SELECT_DESCRIPTION', '8코어 CPU에서 직렬 코드 20%, 병렬 코드 80%인 프로그램의 이론적 Speedup은?', '2', '1.2.5배;2.3.33;3.5배;4.8배', 36),

    (384, 'SELECT_DESCRIPTION', 'Amdahl''s Law에 따르면, 병렬 프로그램의 성능 향상(Speedup)을 최대화하기 위한 가장 효과적인 전략은 무엇인가?', '2', '1.코어 수 증가;2.직렬 코드 비율 최소화;3.메모리 용량 증가;4.클럭 속도 향상', 36);

-- Unit25 - 프로세스 동기화 2 (Lesson ID: 37)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (385, 'FILL_BLANK', 'Race Condition은 실행 결과가 실행 순서나 스케줄링에 따라 달라지므로, 오류가 _____적이다.', '비결정론적, nondeterministic', '-', 37),

    (386, 'FILL_BLANK', '공유 자원을 동시에 접근하지 않도록 보호해야 하는 코드 영역을 _____이라고 한다.', '임계구역, critical section', '-', 37),

    (387, 'FILL_BLANK', 'Mutex를 사용하면 한 번에 오직 _____ 스레드만이 임계 구역에 들어갈 수 있다.', '하나의, 한 개의, 1개의', '-', 37),

    (388, 'SELECT_DESCRIPTION', 'lock() 함수의 의미를 올바르게 설명한 것은?', '3', '1.항상 모든 스레드가 동시에 임계 구역에 진입하도록 허용한다.;2.스레드 실행 순서를 무작위로 바꿔준다.;3.다른 스레드가 보유하지 않을 때 lock을 획득하고 임계 구역에 진입한다.;4.lock은 항상 자동으로 해제된다.', 37),

    (389, 'FILL_BLANK', 'lock을 획득한 스레드는 해당 lock의 _____라고 불리며, 다른 스레드는 임계 구역에 들어갈 수 없다.', '소유자, owner', '-', 37),

    (390, 'SELECT_DESCRIPTION', 'Well-Behaved Mutex의 조건에 해당하지 않는 것은?', '4', '1.Mutual Exclusion: 한 번에 하나의 프로세스만 lock을 가질 수 있다.;2.Progress: 다음 lock을 누가 가질지 결정이 무한히 연기되지 않는다.;3.Bounded Waiting: 모든 lock 해제 후에는 언젠가 lock을 얻을 수 있다.;4.Fairness: 락을 요청한 순서대로 반드시 획득해야 한다.', 37),

    (391, 'FILL_BLANK', 'Lock과 Unlock 연산은 반드시 _____으로 수행되어야 한다.', '원자적, atomic', '-', 37),

    (392, 'SELECT_DESCRIPTION', '다음 중 Mutex 구현에 사용되는 하드웨어 지원 기법이 아닌 것은?', '4', '1.Test-and-Set;2.Compare-and-Swap;3.Atomic Exchange;4.Context Switching', 37),

    (393, 'SELECT_DESCRIPTION', 'Spin Lock의 단점으로 옳은 것은?', '3', '1.문맥 전환 비용이 크다.;2.항상 성능이 높다.;3.공정성이 보장되지 않아 특정 스레드가 무한히 대기할 수 있다.;4.임계 구역을 보호하지 못한다.', 37),

    (394, 'SELECT_DESCRIPTION', 'Multi-CPU(SMP) 환경에서 인터럽트를 비활성화해도 발생할 수 있는 문제는 무엇인가?', '3', '1.단일 스레드만 실행된다.;2.인터럽트가 아예 발생하지 않는다.;3.다른 CPU에서 동시에 데이터를 읽거나 쓸 수 있다.;4.캐시 동기화가 자동으로 이루어진다.', 37),

    (395, 'SELECT_DESCRIPTION', '멀티코어 시스템에서 원자적 연산이 비싼 이유로 옳지 않은 것은?', '4', '1.캐시 flush 필수.;2.메모리 버스 lock 필수.;3.다른 CPU stall 가능성.;4.CPU 클럭 속도가 항상 낮아진다.', 37),

    (396, 'SELECT_DESCRIPTION', 'Spin Lock의 가장 큰 문제점은 무엇인가?', '2', '1.구현이 복잡하다.;2.CPU 자원을 낭비하며 공정성을 보장하지 않는다.;3.메모리 사용량이 크다.;4.원자성을 보장할 수 없다.', 37),

    (397, 'SELECT_DESCRIPTION', 'Compare-and-Swap 연산에 대한 설명으로 옳은 것은?', '2', '1.항상 메모리 값을 새 값으로 교체한다.;2.예상값과 메모리값이 같을 때만 새 값으로 교체하고 원래값을 반환한다.;3.두 메모리 위치의 값을 서로 교환한다.;4.메모리 값에 관계없이 항상 예상값을 반환한다.', 37),

    (398, 'SELECT_DESCRIPTION', 'Ticket Lock의 장점으로 옳은 것은?', '2', '1.공정성을 보장하지 않는다.;2.모든 스레드가 언젠가 lock을 획득할 수 있는 fairness를 제공한다.;3.성능이 항상 Spin Lock보다 높다.;4.스레드 수가 많을수록 무조건 효율적이다.', 37),

    (399, 'SELECT_DESCRIPTION', 'Fetch-and-Add 연산이 Ticket Lock 구현에 적합한 이유는?', '1', '1.원자적으로 값을 증가시키면서 고유한 번호를 반환하기 때문이다.;2.항상 동일한 값을 반환하기 때문이다.;3.메모리 접근 없이 동작하기 때문이다.;4.두 값을 동시에 교환할 수 있기 때문이다.', 37),

    (400, 'SELECT_DESCRIPTION', 'Condition Variable의 wait() 호출이 의미하는 것은?', '2', '1.Mutex를 잠금 상태로 유지하면서 대기한다.;2.Mutex를 해제하고 스레드를 차단한다.;3.Mutex와 Condition Variable을 동시에 삭제한다.;4.Signal 호출을 무시한다.', 37),

    (401, 'SELECT_DESCRIPTION', 'Condition Variable의 특징으로 옳지 않은 것은?', '3', '1.항상 Mutex와 함께 사용된다.;2.특정 조건을 만족할 때까지 스레드를 sleep 상태로 둘 수 있다.;3.Lock 기능만을 제공한다.;4.다른 스레드가 조건을 만족하면 signal()을 통해 깨울 수 있다.', 37),

    (402, 'SELECT_DESCRIPTION', 'Semaphores와 Mutex의 차이점으로 옳은 것은?', '2', '1.Mutex는 여러 스레드가 동시에 획득할 수 있다.;2.Semaphores는 카운트 값으로 여러 자원에 대한 동시 접근을 제어한다.;3.Mutex는 초기값을 설정할 수 없다.;4.Semaphores는 단일 스레드만 사용할 수 있다.', 37),

    (403, 'SELECT_DESCRIPTION', 'Condition Variable에서 signal() 호출의 의미를 올바르게 설명한 것은?', '2', '1.모든 대기 중인 스레드를 깨운다.;2.대기 중인 스레드 중 하나를 깨운다.;3.대기 조건을 무시하고 임계 구역에 진입한다.;4.뮤텍스를 해제하지 않는다.', 37),

    (404, 'FILL_BLANK', '세마포어 값이 음수가 되면, 그 절댓값은 대기 중인 _____의 수를 의미한다.', '스레드', '-', 37);

-- Unit25 - 프로세스 동기화 3 (Lesson ID: 38)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (405, 'FILL_BLANK', 'Deadlock이 발생하기 위한 네 가지 조건은 상호 배제, 점유와 대기, _____, 순환 대기.', '비선점', '-', 38),

    (406, 'SELECT_DESCRIPTION', 'Deadlock 발생 조건에 해당하지 않는 것은?', '4', '1.Mutual Exclusion;2.Hold and Wait;3.Circular Wait;4.Preemption of all resources', 38),

    (407, 'SELECT_DESCRIPTION', 'Deadlock을 다루는 방법 중 "시스템이 결코 데드락 상태에 들어가지 않도록 보장하는 것"은 무엇인가?', '1', '1.Deadlock Prevention;2.Deadlock Avoidance;3.Deadlock Detection;4.Deadlock Recovery', 38),

    (408, 'SELECT_DESCRIPTION', 'Deadlock Prevention 기법에 대한 설명으로 옳은 것은?', '2', '1.순환 대기를 허용한다.;2.자원 요청 순서를 강제하여 Circular Wait을 방지한다.;3.점유와 대기를 허용한다.;4.모든 자원을 공유 가능하게 만든다.', 38),

    (409, 'FILL_BLANK', 'Deadlock Avoidance에서 시스템이 안전한 상태(safe state)인지 판별하기 위해 사용하는 대표적인 알고리즘은 _____의 알고리즘이다.', 'banker, 뱅커', '-', 38),

    (410, 'SELECT_DESCRIPTION', 'Deadlock Avoidance와 Prevention의 차이를 올바르게 설명한 것은?', '2', '1.Prevention은 시스템 상태를 검사하며 Avoidance는 자원 순서를 강제한다.;2.Avoidance는 자원 할당 시 안전 상태 여부를 동적으로 검사하고 Prevention은 구조적으로 조건을 차단한다.;3.두 방법 모두 동일하다.;4.Avoidance는 프로세스 강제 종료를 포함한다.', 38),

    (411, 'SELECT_DESCRIPTION', 'Deadlock Detection에서 단일 자원 타입만 있을 경우 사용하는 그래프는 무엇인가?', '1', '1.Wait-for Graph;2.Resource Allocation Graph;3.Banker''s Graph;4.Condition Graph.', 38),

    (412, 'FILL_BLANK', 'Deadlock Detection에서 그래프 내 _____이 있으면 Deadlock이 존재한다.', '사이클, cycle', '-', 38),

    (413, 'SELECT_DESCRIPTION', 'Deadlock 복구 방법 중 "모든 프로세스를 중단하지 않고 일부만 종료하여 사이클을 깨뜨리는 방식"은 무엇인가?', '2', '1.전체 프로세스 종료;2.선택적 프로세스 종료;3.자원 무시하기;4.우선순위 상향', 38),

    (414, 'SELECT_DESCRIPTION', 'Deadlock 복구에서 자원 선점(Resource Preemption)의 단점으로 옳은 것은?', '3', '1.모든 프로세스를 즉시 종료한다.;2.항상 공정성을 보장한다.;3.동일한 프로세스가 반복적으로 희생되어 기아(Starvation)가 발생할 수 있다.;4.Banker''s Algorithm이 항상 필요하다.', 38);

-- Unit26 - 메모리 관리 1 (Lesson ID: 39)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (415, 'FILL_BLANK', '운영체제는 보통 _____ 단위로 메모리를 동적 할당한다. (예: 4KB)', '페이지, page', '-', 39),

    (416, 'SELECT_DESCRIPTION', 'malloc() 함수와 free() 함수의 차이로 옳은 것은?', '2', '1.malloc()은 메모리를 해제하고, free()는 메모리를 할당한다.;2.malloc()은 원하는 크기의 메모리를 할당하고 free()는 이를 해제한다.;3.malloc()과 free()는 동일한 기능을 수행한다.;4.free()는 포인터가 아닌 크기를 인자로 받는다.', 39),

    (417, 'SELECT_DESCRIPTION', 'C 언어에서 free()가 크기를 인자로 받지 않아도 해제가 가능한 이유는?', '1', '1.메모리 블록 헤더에 크기 정보가 저장되어 있다.;2.운영체제가 free() 호출 시 크기를 자동 계산한다.;3.항상 4KB 단위만 해제되기 때문이다.;4.free()는 내부적으로 malloc()을 다시 호출한다.', 39),

    (418, 'FILL_BLANK', '자바(Java)나 C#에서는 malloc/free 대신 _____ _____가 메모리 해제를 관리한다.', '가비지 컬렉터', '-', 39),

    (419, 'SELECT_DESCRIPTION', '동적 메모리 관리의 주요 목표와 가장 거리가 먼 것은?', '3', '1.어떤 메모리 영역이 사용 중인지 추적한다.;2.각 할당의 크기를 기록한다.;3.항상 최악의 경우 O(n) 시간에 동작해야 한다.;4.단편화를 최소화한다.', 39),

    (420, 'FILL_BLANK', '동적 메모리 관리에서 _____ 단편화는 메모리가 작은 조각으로 나뉘어 충분한 총량이 있어도 연속된 공간이 없어 할당이 불가능해지는 현상이다.', '외부', '-', 39),

    (421, 'FILL_BLANK', '동적 메모리 관리에서 _____ 단편화는 요청한 크기보다 더 큰 블록을 할당해 내부에서 공간이 낭비되는 현상이다.', '내부', '-', 39),

    (422, 'SELECT_DESCRIPTION', '외부 단편화 해결책으로 자주 언급되지만 비용이 매우 큰 방법은?', '3', '1.Binning;2.Best-Fit;3.Compaction;4.Next-Fit', 39),

    (423, 'SELECT_DESCRIPTION', 'malloc(100)을 호출했을 때 실제 할당되는 크기가 104바이트인 이유는?', '2', '1.항상 4바이트를 낭비하기 때문이다.;2.블록 헤더에 메타데이터가 포함되기 때문이다.;3.운영체제가 강제로 여유 공간을 둔다.;4.캐시 라인 정렬 때문이다.', 39),

    (424, 'SELECT_DESCRIPTION', '운영체제가 제공하는 메모리 요청 시스템 콜이 아닌 것은?', '3', '1.sbrk();2.mmap();3.free();4.brk()', 39);

-- Unit26 - 메모리 관리 2 (Lesson ID: 40)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (425, 'SELECT_DESCRIPTION', 'Free List의 기본 구조는?', '2', '1.배열로 관리한다.;2.연결 리스트로 관리하며 각 노드에 크기를 기록한다.;3.트리 구조로 관리한다.;4.해시 테이블로 관리한다.', 40),

    (426, 'SELECT_DESCRIPTION', 'Free List에서 첫 번째 충분히 큰 블록을 선택하는 전략은?', '1', '1.First-Fit;2.Best-Fit;3.Next-Fit;4.Round-Fit', 40),

    (427, 'SELECT_DESCRIPTION', 'Best-Fit 전략의 장점으로 옳은 것은?', '2', '1.항상 O(1) 시간에 탐색 가능하다.;2.외부 단편화가 상대적으로 적다.;3.항상 연속된 공간을 사용한다.;4.내부 단편화를 제거한다.', 40),

    (428, 'FILL_BLANK', 'Footers를 사용하면 free() 연산이 O_____ 시간이 될 수 있다.', '(1)', '-', 40),

    (429, 'FILL_BLANK', 'Free List의 각 블록은 크기를 기록한 _____를 가진다.', '헤더', '-', 40),

    (430, 'SELECT_DESCRIPTION', 'Free List의 장점으로 옳지 않은 것은?', '4', '1.다양한 크기의 요청을 처리할 수 있다.;2.동적 할당/해제를 지원한다.;3.연결 리스트이므로 삽입/삭제가 쉽다.;4.항상 O(1) 시간에 탐색이 가능하다.', 40),

    (431, 'SELECT_DESCRIPTION', 'Free List 방식의 가장 큰 장점은?', '2', '1.항상 O(1) 탐색이 가능하다;2.다양한 크기의 요청을 동적으로 처리할 수 있다;3.내부 단편화가 전혀 발생하지 않는다;4.Compaction이 필요 없다.', 40),

    (432, 'FILL_BLANK', 'Free List는 _____와 _____를 통해 메모리 할당 시 블록을 분리하고, 해제 시 합친다.', 'splitting, coalescing', '-', 40),

    (433, 'SELECT_DESCRIPTION', 'Next-Fit 전략의 특징으로 옳은 것은?', '3', '1.항상 가장 작은 블록을 선택한다.;2.항상 리스트의 첫 번째 블록을 선택한다.;3.마지막 검색 지점 이후부터 탐색을 이어간다.;4.항상 O(1) 시간에 동작한다.', 40),

    (434, 'SELECT_DESCRIPTION', 'Splitting과 Coalescing의 관계로 옳은 것은?', '1', '1.Splitting은 malloc 시 큰 빈 블록을 나누고, Coalescing은 free 시 인접한 빈 블록을 합친다;2.둘은 정반대 개념이다;3.Splitting만으로도 충분하다;4.Coalescing은 선택사항이다.', 40);

-- Unit26 - 메모리 관리 3 (Lesson ID: 41)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (435, 'SELECT_DESCRIPTION', '메모리 할당 시 Binning 기법의 장점으로 옳은 것은?', '2', '1.항상 가장 작은 블록을 고른다.;2.크기별로 미리 리스트를 나누어 탐색 시간을 줄인다.;3.내부 단편화를 완전히 없앤다.;4.외부 단편화를 항상 제거한다.', 41),

    (436, 'FILL_BLANK', 'malloc() 성능을 높이기 위해 크기를 2의 거듭제곱 단위로 올리는 것을 _____라고 한다.', '라운딩', '-', 41),

    (437, 'SELECT_DESCRIPTION', 'Slab allocation의 장점으로 옳은 것은?', '2', '1.항상 Compaction을 제거한다.;2.같은 크기의 객체를 미리 할당해 관리 효율을 높인다.;3.내부 단편화를 제거한다.;4.free()를 항상 자동 호출한다.', 41),

    (438, 'SELECT_DESCRIPTION', 'Per-thread arena 기법의 목적은?', '1', '1.멀티스레드 환경에서 lock 경합을 줄이고 캐시 친화도를 높인다.;2.단일 스레드 프로그램을 빠르게 만든다.;3.항상 Compaction을 제거한다.;4.free()의 속도를 낮춘다.', 41),

    (439, 'FILL_BLANK', 'Dangling pointer는 이미 _____된 메모리를 가리키는 포인터를 의미한다.', '해제', '-', 41),

    (440, 'SELECT_DESCRIPTION', 'Memory Leak의 결과로 옳은 것은?', '2', '1.항상 프로그램이 비정상 종료된다.;2.사용하지 않는 메모리가 반환되지 않아 장기 실행 시 메모리 고갈을 초래한다.;3.Free List가 손상된다.;4.항상 내부 단편화를 유발한다.', 41),

    (441, 'SELECT_DESCRIPTION', '메모리 관리 버그 중 보안 취약점으로 악용될 수 있는 것은?', '3', '1.Memory Leak;2.False Sharing;3.Double Free;4.Garbage Collection', 41),

    (442, 'SELECT_DESCRIPTION', 'Object Cache를 사용하는 이유로 옳은 것은?', '2', '1.항상 내부 단편화를 줄이기 위해.;2.자주 사용하는 객체를 미리 할당해 성능을 높이기 위해.;3.free()를 자동으로 호출하기 위해.;4.Compaction을 피하기 위해', 41),

    (443, 'SELECT_DESCRIPTION', 'Slab allocation에서 동일한 크기 객체들을 미리 할당하는 이유는?', '3', '1.메모리를 절약하기 위해;2.외부 단편화를 완전히 제거하기 위해;3.할당/해제 속도를 높이고 단편화를 줄이기 위해;4.Garbage Collection을 피하기 위해', 41),

    (444, 'SELECT_DESCRIPTION', 'Dangling Pointer와 Double Free 버그의 공통적인 특징으로 옳은 것은?', '2', '1.둘 다 항상 프로그램이 즉시 종료된다.;2.둘 다 비결정적 동작을 보여 디버깅을 어렵게 만든다.;3.둘 다 메모리 누수를 발생시킨다.;4.둘 다 컴파일 시점에 발견된다.', 41);

-- Unit27 - 가상 메모리 1 (Lesson ID: 42)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (445, 'FILL_BLANK', '가상 메모리는 프로세스마다 독립적인 _____ 공간을 제공한다.', '주소', '-', 42),

    (446, 'SELECT_DESCRIPTION', '가상 메모리의 주요 목적이 아닌 것은?', '4', '1.메모리 보호;2.프로세스 간 격리;3.실제 메모리보다 큰 주소 공간 제공;4.CPU 클럭 속도를 높인다.', 42),

    (447, 'FILL_BLANK', '하드웨어적으로 가상 주소를 물리 주소로 변환하는 장치를 _____라고 한다.', 'mmu', '-', 42),

    (448, 'SELECT_DESCRIPTION', 'Base & Bound 레지스터의 주요 역할은?', '2', '1.페이지 테이블을 관리한다.;2.프로그램이 접근할 수 있는 메모리 범위를 제한한다.;3.항상 같은 물리 주소로 매핑한다.;4.가상 주소를 랜덤하게 변환한다.', 42),

    (449, 'SELECT_DESCRIPTION', '세그멘테이션의 장점으로 옳은 것은?', '1', '1.서로 다른 영역에 서로 다른 보호 비트를 줄 수 있다.;2.외부 단편화를 줄일 수 있다.;3.항상 O(1) 접근이 가능하다.;4.페이징보다 단순하다.', 42),

    (450, 'FILL_BLANK', 'Position Independent Code는 프로그램이 어떤 _____에도 로드될 수 있도록 작성된 코드이다.', '주소', '-', 42),

    (451, 'SELECT_DESCRIPTION', 'Load-time fixup의 특징은?', '3', '1.실행 시점마다 주소를 고친다.;2.코드가 절대 위치에만 올라간다.;3.프로그램 로드 시 주소를 조정한다.;4.코드가 항상 같은 주소에 올라간다.', 42),

    (452, 'FILL_BLANK', '가상 메모리를 사용하지 않는 시스템에서는 프로세스가 _____ 주소를 직접 사용해야 한다.', '물리', '-', 42),

    (453, 'SELECT_DESCRIPTION', '세그멘테이션의 단점은 무엇인가?', '4', '1.보호 비트 제공;2.코드/데이터 분리 가능;3.유연한 메모리 관리;4.외부 단편화 발생', 42),

    (454, 'SELECT_DESCRIPTION', 'MMU가 없는 시스템에서 가상 메모리를 구현할 수 없는 이유는?', '2', '1.CPU 속도가 너무 느리기 때문이다.;2.하드웨어적으로 주소 변환을 지원하지 않기 때문이다.;3.캐시가 작기 때문이다.;4.운영체제가 지원하지 않기 때문이다.', 42);

-- Unit27 - 가상 메모리 2 (Lesson ID: 43)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (455, 'SELECT_DESCRIPTION', '페이징의 주요 목적은?', '1', '1.외부 단편화를 줄인다.;2.프로세스의 주소 공간을 고정 크기 블록으로 나눈다.;3.항상 내부 단편화를 제거한다.;4.CPU 속도를 높인다.', 43),

    (456, 'FILL_BLANK', '페이징에서 가상 주소는 페이지 번호와 페이지 내 _____으로 나뉜다.', '오프셋', '-', 43),

    (457, 'SELECT_DESCRIPTION', '페이지 크기가 작아질 때의 장점은?', '2', '1.내부 단편화가 늘어난다.;2.내부 단편화가 줄어든다.;3.외부 단편화가 줄어든다.;4.페이지 테이블 크기가 줄어든다.', 43),

    (458, 'SELECT_DESCRIPTION', '페이지 테이블의 크기를 줄이는 대표적 기법은?', '3', '1.First-Fit;2.Compaction;3.다단계 페이지 테이블;4.Base & Bound.', 43),

    (459, 'SELECT_DESCRIPTION', 'Copy-on-Write의 장점으로 옳은 것은?', '2', '1.항상 새 페이지를 즉시 복사한다.;2.실제로 쓰기(write)가 일어날 때만 페이지를 복사한다.;3.프로세스를 항상 복제하지 않는다.;4.페이지 테이블을 제거한다.', 43),

    (460, 'FILL_BLANK', '가상 주소 변환을 빠르게 하기 위해 사용되는 하드웨어 캐시는 _____이다.', 'tlb', '-', 43),

    (461, 'FILL_BLANK', 'TLB miss가 발생하면, CPU는 _____을 참조하여 주소 변환을 다시 수행한다.', '페이지 테이블, page table', '-', 43),

    (462, 'SELECT_DESCRIPTION', '페이지 테이블과 TLB의 관계로 옳은 것은?', '2', '1.페이지 테이블은 캐시이고 TLB는 메인 메모리다.;2.TLB는 페이지 테이블 매핑을 캐시한다.;3.페이지 테이블이 없으면 TLB도 없다.;4.둘은 서로 독립적이다.', 43),

    (463, 'FILL_BLANK', 'TLB에서 교체 정책으로 가장 이상적인 방식은 _____ 알고리즘이다.', '최적', '-', 43),

    (464, 'FILL_BLANK', '페이지 테이블 엔트리(PTE)의 P 비트가 0이면, 해당 페이지는 메모리에 없고 _____에 있다.', '디스크', '-', 43);

-- Unit27 - 가상 메모리 3 (Lesson ID: 44)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (465, 'FILL_BLANK', '메모리에서 디스크로 페이지를 내보내는 작업을 _____라고 한다.', '스와핑', '-', 44),

    (466, 'SELECT_DESCRIPTION', '스와핑이 필요한 이유는?', '3', '1.CPU 속도를 높이기 위해.;2.캐시 크기를 줄이기 위해.;3.물리 메모리가 한정되어 있어 부족할 때 디스크를 활용하기 위해.;4.프로그램을 항상 같은 주소에 배치하기 위해.', 44),

    (467, 'FILL_BLANK', '스와핑된 페이지를 다시 메모리에 가져와 실행을 재개하는 과정에서 _____가 발생한다.', '페이지 폴트, page fault', '-', 44),

    (468, 'SELECT_DESCRIPTION', 'Page Fault 처리 절차로 옳은 것은?', '2', '1.항상 프로세스를 종료한다.;2.디스크에서 해당 페이지를 읽어와 페이지 테이블을 갱신한다.;3.CPU 캐시를 초기화한다.;4.새로운 프로세스를 생성한다.', 44),

    (469, 'SELECT_DESCRIPTION', 'LRU 페이지 교체 정책의 기본 아이디어는?', '1', '1.가장 오래 사용하지 않은 페이지를 교체한다.;2.가장 최근 사용한 페이지를 교체한다.;3.랜덤하게 페이지를 교체한다.;4.항상 첫 번째 페이지를 교체한다.', 44),

    (470, 'SELECT_DESCRIPTION', 'FIFO 페이지 교체 정책의 기본 아이디어로 옳은 것은?', '1', '1.가장 먼저 메모리에 들어온 페이지를 교체한다.;2.가장 오랫동안 사용하지 않은 페이지를 교체한다.;3.가장 최근에 사용한 페이지를 교체한다.;4.임의의 페이지를 교체한다.', 44),

    (471, 'SELECT_DESCRIPTION', '페이지 교체에서 Random 정책의 특징은?', '2', '1.항상 최적의 교체를 보장한다.;2.단순히 임의의 페이지를 교체한다.;3.가장 오랫동안 사용하지 않은 페이지를 교체한다.;4.Dirty 페이지를 우선 교체한다.', 44),

    (472, 'FILL_BLANK', 'Dirty 페이지를 교체할 때는 반드시 _____에 기록해야 한다.', '디스크', '-', 44),

    (473, 'SELECT_DESCRIPTION', 'Dirty 페이지보다 Clean 페이지를 먼저 교체하는 이유는?', '2', '1.Dirty 페이지는 항상 더 자주 쓰인다.;2.Clean 페이지는 디스크에 다시 기록할 필요가 없어 비용이 적기 때문이다.;3.Clean 페이지는 항상 작기 때문이다.;4.Dirty 페이지는 이미 디스크에 있다.', 44),

    (474, 'FILL_BLANK', 'RAM은 대용량 디스크를 위한 고속 _____로 볼 수 있다.', '캐시', '-', 44),

    (475, 'SELECT_DESCRIPTION', '페이지 교체 정책 중 가장 구현이 간단한 것은?', '1', '1.FIFO;2.LRU;3.Optimal;4.Clock', 44),

    (476, 'FILL_BLANK', '페이지 교체 정책의 목표는 _____을 최대화하는 것이다.', '히트율, 적중률', '-', 44);

-- Unit28 - 파일 시스템 & 저장장치 1 (Lesson ID: 45)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (477, 'FILL_BLANK', '하드 디스크의 데이터 최소 단위는 _____이며, 보통 512바이트 또는 4096바이트이다.', '섹터', '-', 45),

    (478, 'SELECT_DESCRIPTION', '실린더(cylinder)를 올바르게 설명한 것은?', '3', '1.디스크의 회전 속도를 의미한다.;2.단일 플래터의 하나의 트랙을 의미한다.;3.여러 플래터의 같은 트랙 위치를 모은 집합이다.;4.섹터를 묶어놓은 집합이다.', 45),

    (479, 'FILL_BLANK', '디스크의 회전 속도는 _____ 단위로 측정된다.', 'rpm', '-', 45),

    (480, 'SELECT_DESCRIPTION', '디스크 지연 요소에 포함되지 않는 것은?', '4', '1.Seek Delay;2.Rotational Delay;3.Transfer Time;4.CPU Scheduling Time', 45),

    (481, 'SELECT_DESCRIPTION', 'Rotational Delay는 무엇을 의미하는가?', '2', '1.디스크를 회전시키는 데 걸리는 시간;2.원하는 섹터가 헤드 아래로 올 때까지 기다리는 시간;3.데이터를 디스크에 기록하는 시간;4.CPU 캐시를 접근하는 시간.', 45),

    (482, 'FILL_BLANK', 'I/O 총 시간은 Seek Time, Rotational Delay, _____의 합으로 계산된다.', 'transfer time', '-', 45),

    (483, 'SELECT_DESCRIPTION', '디스크에서 순차 접근(sequential access)의 장점은?', '1', '1.회전 및 탐색 지연을 최소화할 수 있다.;2.항상 디스크의 바깥쪽에서만 읽는다.;3.캐시를 사용할 필요가 없다.;4.디스크 속도에 영향을 받지 않는다.', 45),

    (484, 'FILL_BLANK', '디스크의 바깥쪽 트랙은 안쪽 트랙보다 더 ___은 데이터를 담을 수 있다.', '많', '-', 45),

    (485, 'SELECT_DESCRIPTION', 'Torn Write 문제가 발생하는 경우는?', '3', '1.Read Caching이 실패했을 때;2.Disk RPM이 너무 낮을 때;3.여러 섹터를 연속으로 쓰다가 중간에 실패할 때;4.디스크가 포맷되지 않았을 때.', 45),

    (486, 'SELECT_DESCRIPTION', '디스크의 랜덤 I/O 성능이 낮은 이유는?', '3', '1.디스크 캐시 크기가 작기 때문이다.;2.CPU 속도가 느리기 때문이다.;3.Seek Delay와 Rotational Delay가 매번 발생하기 때문이다.;4.섹터 크기가 작기 때문이다.', 45),

    (487, 'SELECT_DESCRIPTION', 'Write-back Cache의 위험성으로 옳은 것은?', '2', '1.데이터를 더 빠르게 읽을 수 있다.;2.캐시에만 기록되고 실제 디스크에는 아직 쓰이지 않아 전원 장애 시 손실될 수 있다.;3.디스크 RPM이 증가한다.;4.순차 접근이 더 빨라진다.', 45);

-- Unit28 - 파일 시스템 & 저장장치 2 (Lesson ID: 46)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (488, 'SELECT_DESCRIPTION', 'FCFS 디스크 스케줄링의 특징은?', '1', '1.요청 순서대로 처리해 공정성은 높으나 성능이 낮다.;2.탐색 시간을 최소화한다.;3.헤드 이동을 최소화한다.;4.특정 요청을 무한히 지연시킬 수 있다.', 46),

    (489, 'FILL_BLANK', 'SSTF는 _____ Seek Time First의 약자이다.', 'shortest', '-', 46),

    (490, 'SELECT_DESCRIPTION', 'SSTF 스케줄링의 단점은?', '3', '1.탐색 시간을 줄일 수 없다.;2.항상 최적해를 보장하지 않는다.;3.특정 요청이 기아(starvation)에 빠질 수 있다.;4.항상 FCFS보다 느리다.', 46),

    (491, 'SELECT_DESCRIPTION', '디스크 스케줄링이 필요한 가장 큰 이유는?', '1', '1.헤드 이동 거리를 줄여 성능을 높이기 위해.;2.디스크 RPM을 낮추기 위해.;3.섹터 크기를 늘리기 위해.;4.캐시를 제거하기 위해.', 46),

    (492, 'FILL_BLANK', 'SATA에서 지원하는 명령 큐 기능은 _____라고 불린다.', 'native command queuing, ncq', '-', 46),

    (493, 'SELECT_DESCRIPTION', 'RAID의 기본 목적이 아닌 것은?', '4', '1.성능 향상;2.용량 확대;3.신뢰성 향상;4.CPU 속도 향상', 46),

    (494, 'FILL_BLANK', 'RAID 0은 데이터를 여러 디스크에 _____하여 성능을 높인다.', '스트라이핑, striping', '-', 46),

    (495, 'SELECT_DESCRIPTION', 'RAID 0의 단점으로 옳은 것은?', '2', '1.용량을 절반만 사용한다.;2.디스크 하나만 고장 나도 전체 데이터가 손실된다.;3.쓰기 성능이 낮다.;4.항상 RAID 1보다 안전하다.', 46),

    (496, 'FILL_BLANK', 'RAID 1은 데이터를 _____하여 신뢰성을 높인다.', '미러링, mirroring', '-', 46),

    (497, 'SELECT_DESCRIPTION', 'RAID 5가 RAID 4보다 나은 이유는?', '3', '1.항상 읽기 성능이 높다.;2.패리티 디스크가 두 개다.;3.패리티 블록을 모든 디스크에 분산시켜 병목을 줄인다.;4.RAID 4보다 더 적은 디스크가 필요하다.', 46);

-- Unit28 - 파일 시스템 & 저장장치 3 (Lesson ID: 47)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (498, 'SELECT_DESCRIPTION', 'SSD에서 쓰기 증폭(write amplification)이 발생하는 원인은?', '2', '1.캐시 크기가 작아서;2.페이지 단위 쓰기와 블록 단위 삭제 차이 때문에;3.RPM이 너무 낮아서;4.CPU 클럭이 낮아서', 47),

    (499, 'FILL_BLANK', 'SSD에서 쓰여진 페이지를 지우려면 전체 _____을 삭제해야 한다.', '블록, block', '-', 47),

    (500, 'SELECT_DESCRIPTION', 'SSD에서 Garbage Collection의 역할은?', '3', '1.항상 데이터를 삭제한다.;2.전력 소모를 줄인다.;3.유효한 페이지를 모아 비어 있는 블록을 확보한다.;4.Wear Leveling을 제거한다.', 47),

    (501, 'FILL_BLANK', 'SSD는 일정 횟수 이상 쓰면 셀 수명이 다하기 때문에 _____ 기법으로 쓰기를 분산시킨다.', 'wear leveling', '-', 47),

    (502, 'SELECT_DESCRIPTION', 'TRIM 명령어의 목적은?', '2', '1.SSD 속도를 낮춘다.;2.Garbage Collection 효율을 높인다.;3.데이터를 무조건 지운다.;4.항상 읽기 속도를 줄인다.', 47),

    (503, 'FILL_BLANK', 'SSD의 _____는 논리 블록 주소를 실제 플래시 페이지로 매핑하고, GC와 Wear Leveling을 관리한다.', '컨트롤러, controller', '-', 47),

    (504, 'SELECT_DESCRIPTION', 'SSD가 HDD보다 불리한 점은?', '3', '1.랜덤 접근 속도가 낮다.;2.전력 소모가 크다.;3.쓰기 횟수 제한으로 수명이 짧다.;4.기계적 충격에 취약하다.', 47),

    (505, 'FILL_BLANK', 'SSD의 기본 데이터 쓰기 단위는 _____이며, 보통 4KB~16KB이다.', '페이지, page', '-', 47),

    (506, 'SELECT_DESCRIPTION', 'SSD에서 블록 단위 삭제로 인해 발생하는 성능 문제는?', '2', '1.캐시 미스;2.Write Amplification;3.Random I/O Bottleneck;4.Compaction', 47),

    (507, 'FILL_BLANK', 'SSD의 수명을 늘리기 위해 표기 용량보다 실제로는 더 큰 용량의 메모리를 탑재하는 기법을 _____라고 한다.', '오버 프로비저닝, over-provisioning', '-', 47),

    (508, 'SELECT_DESCRIPTION', 'SSD에서 Wear Leveling의 목적은?', '3', '1.SSD 속도를 늦춘다.;2.특정 셀에 집중적으로 쓰기를 유도한다.;3.모든 셀에 고르게 쓰기를 분산해 수명을 늘린다.;4.전력 소모를 늘린다.', 47);

-- Unit01 - 데이터베이스 시스템 1 (Lesson ID: 48)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (509, 'FILL_BLANK', '데이터는 처리되지 않은 _____의 집합이다.', '사실', '-', 48),

    (510, 'FILL_BLANK', '3단계 스키마에서 사용자별 뷰를 정의하는 것은 _____ 스키마이다.', '1', '1.외부(External);2.개념(Conceptual);3.내부(Internal);4.전역(Global)', 48),

    (511, 'FILL_BLANK', '3단계 스키마에서 저장 구조와 접근 경로를 기술하는 것은 _____ 스키마이다.', '3', '1.외부(External);2.개념(Conceptual);3.내부(Internal/Physical);4.논리(Logical)', 48),

    (512, 'FILL_BLANK', '3단계 스키마의 핵심 목적은 응용과 데이터 저장 간 _____을/를 낮추는 것이다.', '1', '1.결합도;2.중복도;3.비용;4.지연시간', 48),

    (513, 'FILL_BLANK', '데이터 사전/카탈로그는 _____에 대한 _____을/를 저장한다.', '1', '1.데이터 - 메타데이터;2.트랜잭션 - 로그;3.인덱스 - 레코드;4.결과 - 캐시', 48),

    (514, 'FILL_BLANK', 'DBMS 사용자 역할에 속하지 않는 것은 _____이다.', '4', '1.DBA;2.응용 프로그래머;3.최종 사용자;4.프린터 관리자', 48),

    (515, 'FILL_BLANK', '데이터 독립성은 스키마 변경 시 _____의 영향이 최소화됨을 뜻한다.', '2', '1.운영체제;2.응용프로그램;3.네트워크 스위치;4.프린터 드라이버', 48),

    (516, 'FILL_BLANK', '논리적 독립성은 _____ 스키마 변경이 외부 스키마와 응용에 영향을 거의 주지 않음을 의미한다.', '3', '1.파일;2.내부;3.개념;4.운영체제', 48),

    (517, 'FILL_BLANK', '물리적 독립성은 저장 구조나 _____변경이 개념 스키마에 영향을 거의 주지 않음을 의미한다.', '1', '1.접근 경로;2.엔터티 관계;3.사용자 뷰;4.도메인 제약', 48),

    (518, 'FILL_BLANK', '스키마를 정의하는 언어는 _____이고, 데이터를 조작하는 언어는 _____이다.', '4', '1.TCL·DCL;2.DML·DDL;3.DCL·DDL;4.DDL·DML', 48),

    (519, 'FILL_BLANK', 'DBMS의 쿼리 처리기에는 파서와 _____가/이 포함되어 있다.', '1', '1.옵티마이저;2.버퍼 매니저;3.트랜잭션 관리자;4.스토리지 관리자', 48),

    (520, 'FILL_BLANK', '트랜잭션의 ACID에서 C(일관성)는 트랜잭션 전후로 _____이/가 유지됨을 의미한다.', '2', '1.동시 실행 수;2.무결성 제약;3.로그 크기;4.캐시 적중률', 48);

-- Unit01 - 데이터베이스 시스템 2 (Lesson ID: 49)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (521, 'FILL_BLANK', '3단계 스키마는 외부(External), _____, 내부(Internal) 스키마로 구성된다.', '1', '1.개념(Conceptual);2.물리(Physical);3.전역(Global);4.논리(Logical)', 49),

    (522, 'SELECT_DESCRIPTION', '물리적 데이터 독립성을 가장 잘 설명하는 것은?', '2', '1.외부 스키마 변경이 내부에 전파됨;2.내부 저장 구조 변경이 외부 스키마에 영향을 주지 않음;3.개념 스키마 변경이 내부 스키마를 고정함;4.사용자 뷰가 테이블을 자동 생성함', 49),

    (523, 'SELECT_DESCRIPTION', '논리적 데이터 독립성 사례로 적절한 것은?', '3', '1.인덱스 유형 변경;2.파일 블록 크기 조정;3.개념 스키마에 속성 추가 후 기존 사용자 뷰 유지;4.버퍼 캐시 크기 조절', 49),

    (524, 'FILL_BLANK', '외부-개념 매핑은 _____와 개념 스키마 간의 대응을 정의한다.', '4', '1.운영체제;2.내부 스키마;3.저장 파일;4.사용자 뷰', 49),

    (525, 'FILL_BLANK', '내부 스키마는 데이터의 _____ 표현과 접근 경로, 저장 구조를 기술한다.', '물리적', '-', 49),

    (526, 'SELECT_DESCRIPTION', '다음 변경 중 애플리케이션 수정 없이 가능해야 하는 이상적인 경우는? (논리/물리 독립성 관점)', '4', '1.B+트리 → 해시 인덱스 교체;2.외부 뷰의 열 순서 변경;3.데이터파일 페이지 크기 변경;4.모두 가능해야 함', 49),

    (527, 'FILL_BLANK', '개념-내부 매핑은 개념 스키마의 구조를 _____에 대응시키는 규칙이다.', '1', '1.내부 저장 구조;2.사용자 뷰;3.외부 스키마;4.운영체제 커널', 49),

    (528, 'SELECT_DESCRIPTION', '"테이블을 수직 분할하여 저장했지만 사용자 뷰는 기존 컬럼 집합을 그대로 보여준다." 이 설명에 해당하는 성질은?', '2', '1.논리적 독립성;2.물리적 독립성;3.참조 무결성;4.정규화', 49),

    (529, 'FILL_BLANK', '외부 스키마는 _____ 관점에서 데이터 표현을 제공하여 개별 사용자 요구를 반영한다.', '1', '1.사용자/응용;2.하드웨어;3.운영체제;4.네트워크', 49),

    (530, 'SELECT_DESCRIPTION', '"개념 스키마 변경이 외부 스키마에 미치는 영향 최소화"를 무엇이라 하는가?', '3', '1.참조 무결성;2.물리적 독립성;3.논리적 독립성;4.정규화', 49),

    (531, 'SELECT_DESCRIPTION', '다음 중 3단계 스키마 구조의 주요 목적으로 보기 어려운 것은?', '3', '1.데이터 독립성;2.보안/뷰 제공;3.성능 고정(튜닝 불가);4.다양한 응용 지원', 49),

    (532, 'SELECT_DESCRIPTION', '다음 설명 중 옳은 것만을 모두 고른 것은? 1.외부 스키마: 사용자/응용별 뷰를 제공한다. 2.개념 스키마: 조직 전체의 통합 논리 구조를 정의한다. 3.내부 스키마: 물리 저장 구조와 접근 경로를 기술한다. 4.외부-개념 매핑: 사용자 뷰와 개념 스키마 간의 대응을 정의한다.', '4', '1.1, 2;2.1, 3, 4;3.1, 2, 4;4.1, 2, 3, 4', 49);

-- Unit01 - 데이터베이스 시스템 3 (Lesson ID: 50)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (533, 'SELECT_DESCRIPTION', '다음 중 DBA의 주요 역할로 가장 거리가 먼 것은?', '3', '1.권한 관리;2.백업/복구;3.쿼리 옵티마이저 개발;4.성능 모니터링', 50),

    (534, 'SELECT_DESCRIPTION', 'CREATE TABLE, ALTER TABLE, DROP VIEW는 각각 어떤 범주의 언어인가?', '1', '1.모두 DDL;2.모두 DML;3.모두 DCL;4.모두 TCL', 50),

    (535, 'SELECT_DESCRIPTION', 'GRANT SELECT ON T TO U; 문은 어떤 언어 범주에 해당하는가?', '3', '1.DDL;2.DML;3.DCL;4.TCL', 50),

    (536, 'SELECT_DESCRIPTION', '트랜잭션의 종료를 명시하는 명령은?', '1', '1.COMMIT/ROLLBACK;2.GRANT/REVOKE;3.CREATE/DROP;4.ANALYZE/EXPLAIN', 50),

    (537, 'FILL_BLANK', 'DML은 _____ 형태와 _____ 형태가 모두 존재할 수 있다.', '1', '1.절차적·비절차적;2.정규화·비정규화;3.동기·비동기;4.고정·가변', 50),

    (538, 'FILL_BLANK', '일반 사용자(naive user)는 보통 _____를 통해 사전에 작성된 질의나 화면으로 DB에 접근한다.', '2', '1.DDL 스크립트;2.응용 프로그램;3.백업 스케줄러;4.클러스터 매니저', 50),

    (539, 'SELECT_DESCRIPTION', '다음 SQL을 분류하라 - INSERT, UPDATE, DELETE, SELECT … FOR UPDATE, SAVEPOINT S1.', '4', '1.TCL;2.DDL;3.DCL;4.DML', 50),

    (540, 'SELECT_DESCRIPTION', '응용 개발자의 주 업무로 보기 적절한 것은?', '3', '1.스키마 표준 수립;2.정기 백업/복구;3.트리거/프로시저 작성 및 CRUD 구현;4.저장장치 교체', 50),

    (541, 'FILL_BLANK', 'REVOKE는 _____에 속하며, _____을 의미한다.', '1', '1.DCL·권한 회수;2.DDL·스키마 삭제;3.TCL·트랜잭션 종료;4.DML·데이터 삭제', 50),

    (542, 'FILL_BLANK', '테이블 스키마를 정의·변경·삭제하는 명령의 집합을 _____라고 한다.', '3', '1.DCL;2.DML;3.DDL;4.TCL', 50),

    (543, 'SELECT_DESCRIPTION', '다음 SQL과 분류의 짝이 올바른 것은?', '2', '1.GRANT SELECT ON T TO U; - DML;2.CREATE TABLE T(...); - DDL;3.REVOKE UPDATE ON T FROM U; - DML;4.INSERT INTO T VALUES(...); - DDL', 50),

    (544, 'FILL_BLANK', '_____은 스키마 정의·변경·삭제에 해당하고, _____은 데이터 조회·조작에 해당하며, _____은 권한 부여·회수에 해당한다.', '3', '1.DDL, DCL, DML;2.DML, DDL, DCL;3.DDL, DML, DCL;4.DCL, DDL, DML', 50);

-- Unit02 - 관계형 모델 1 (Lesson ID: 51)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (545, 'SELECT_DESCRIPTION', '다음 중 릴레이션의 기본 구성 요소가 아닌 것은?', '4', '1.속성(Attribute);2.튜플(Tuple);3.카디널리티(Cardinality);4.인덱스(Index)', 51),

    (546, 'FILL_BLANK', '릴레이션의 _____는 속성의 개수, _____는 튜플의 개수를 의미한다.', '1', '1.차수-카디널리티;2.카디널리티-차수;3.도메인-슈퍼키;4.슈퍼키-도메인', 51),

    (547, 'SELECT_DESCRIPTION', '최소성과 유일성을 모두 만족하는 키를 무엇이라 하는가?', '2', '1.슈퍼키;2.후보키;3.기본키;4.대체키', 51),

    (548, 'SELECT_DESCRIPTION', '다음 설명 중 옳은 것만을 모두 고르시오. ① 모든 기본키는 후보키이다. ② 모든 후보키는 슈퍼키이다. ③ 슈퍼키는 항상 최소성을 만족한다. ④ 외래키는 반드시 NULL을 가질 수 없다.', '1', '1.①, ②;2.①, ③;3.②, ④;4.①, ②, ③, ④', 51),

    (549, 'SELECT_DESCRIPTION', '기본키 선정 기준으로 옳지 않은 것은?', '3', '1.변경 가능성이 낮은 속성을 고른다;2.가능한 짧은 길이가 좋다;3.의미 있는 자연키를 반드시 사용한다;4.NULL/중복이 불가능해야 한다', 51),

    (550, 'SELECT_DESCRIPTION', 'Member(employee_no UNIQUE, email UNIQUE, phone UNIQUE, name)에서 \n후보키 집합과 추천 기본키의 조합으로 옳은 것은?', '1', '1.후보키={employee_no},{email},{phone} / 기본키=employee_no;2.후보키={employee_no},{email} / 기본키=email;3.후보키={email},{phone} / 기본키=phone;4.후보키={employee_no},{name} / 기본키=name', 51),

    (551, 'SELECT_DESCRIPTION', '다음 DDL에서 기본키는 무엇인가? \nCREATE TABLE Enrollment(\n  student_id BIGINT NOT NULL,\n  course_id BIGINT NOT NULL,\n  enrolled_at TIMESTAMP NOT NULL,\n  PRIMARY KEY (student_id, course_id),\n  FOREIGN KEY (student_id) REFERENCES Student(id),\n  FOREIGN KEY (course_id) REFERENCES Course(id)\n);', '3', '1.student_id;2.course_id;3.(student_id, course_id);4.enrolled_at', 51),

    (552, 'SELECT_DESCRIPTION', '외래키에 대한 설명으로 옳은 것은?', '2', '1.외래키는 항상 기본키여야 한다;2.외래키는 참조 대상의 후보키/기본키를 참조한다;3.외래키는 NULL이 될 수 없다;4.외래키는 항상 UNIQUE여야 한다', 51),

    (553, 'SELECT_DESCRIPTION', '한 주문에 여러 주문상세. 같은 주문에서 같은 상품은 한 번만 담을 수 있음.\n인조키 금지, 다른 테이블이 OrderItem 직접 참조하지 않음, PK는 업무 속성만 사용. 가장 타당한 PK 설계는?', '2', '1.id + (order_id, product_id) UNIQUE;2.(order_id, product_id) 복합 PK;3.product_id 단일 PK;4.order_id 단일 PK', 51),

    (554, 'SELECT_DESCRIPTION', '다음 중 참조 무결성을 가장 강하게 보장하는 삭제 정책은?', '3', '1.ON DELETE RESTRICT;2.ON DELETE SET NULL;3.ON DELETE CASCADE;4.ON DELETE NO ACTION', 51),

    (555, 'FILL_BLANK', '기본키로 선택되지 않은 후보키를 _____라 하고, 업무 의미와 무관한 인조 식별자를 _____라 한다.', '1', '1.대체키·서로게이트 키;2.슈퍼키·후보키;3.기본키·외래키;4.복합키·부분키', 51),

    (556, 'FILL_BLANK', 'Category(id PK, name, parent_id FK→Category.id)에서 루트 카테고리를 허용하려면 가장 적절한 제약은?', '2', '1.parent_id NOT NULL;2.parent_id NULL 허용;3.parent_id UNIQUE;4.parent_id에 기본키 부여', 51);

-- Unit02 - 관계형 모델 2 (Lesson ID: 52)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (557, 'SELECT_DESCRIPTION', '엔터티 무결성(Entity Integrity) 규칙으로 옳은 것은?', '3', '1.기본키는 NULL 가능;2.기본키는 중복 가능;3.기본키는 NULL 불가·유일해야 한다;4.외래키는 반드시 기본키여야 한다', 52),

    (558, 'FILL_BLANK', '세 가지 무결성은 엔티티 무결성, 참조 무결성, _____ 무결성이다.', '도메인', '-', 52),

    (559, 'SELECT_DESCRIPTION', '다음 중 엔터티 무결성을 위반하는 DDL은?', '3', '1.CREATE TABLE A(id INT PRIMARY KEY, name TEXT NOT NULL);2.CREATE TABLE B(id INT, name TEXT, PRIMARY KEY (id));3.CREATE TABLE C(id INT NULL, PRIMARY KEY (id));4.CREATE TABLE D(a INT, b INT, PRIMARY KEY (a, b))', 52),

    (560, 'SELECT_DESCRIPTION', '잘못된 선지를 골라주세요.', '1', '1.WHERE col = NULL은 참인 행을 찾는다.;2.COUNT(col)은 NULL을 제외한다.;3.WHERE col <> 5는 col이 NULL인 행은 잡아내지 않는다.;4.COUNT(DISTINCT col)은 NULL을 제외한다.', 52),

    (561, 'SELECT_DESCRIPTION', 'Product(category_id FK → Category.id)에서 \n카테고리 삭제 시 상품은 남기되, 소속만 제거하려면?', '3', '1.ON DELETE RESTRICT + category_id NOT NULL;2.ON DELETE CASCADE + category_id NOT NULL;3.ON DELETE SET NULL + category_id NULL 허용;4.ON DELETE NO ACTION + category_id NOT NULL', 52),

    (562, 'SELECT_DESCRIPTION', '다음 쿼리가 결과를 전혀 반환하지 않는다. 이유와 올바른 대안은? (Blacklist.user_id에 NULL이 하나라도 있으면 어떤 문제가?) \nSELECT * FROM Order o \nWHERE o.user_id NOT IN (SELECT user_id FROM Blacklist);', '2', '1.NOT IN은 NULL과 상관없다;2.NOT EXISTS로 바꾸거나 서브 쿼리에서 WHERE user_id IS NOT NULL을 추가;3.IN으로 바꾸면 된다;4.IS NOT NULL만 쓰면 된다', 52),

    (563, 'SELECT_DESCRIPTION', '일반적인 RDBMS에서 UNIQUE(email) 제약의 동작으로 옳은 것은?', '2', '1.email = NULL은 한 행만 허용;2.email = NULL은 여러 행도 허용될 수 있다;3.UNIQUE는 항상 NULL을 금지;4.DB에 따라 UNIQUE가 중복도 허용', 52),

    (564, 'SELECT_DESCRIPTION', 'price가 0보다 커야 하고 비어 있으면 안 된다. 가장 적절한 제약 조합은?', '3', '1.CHECK (price > 0);2.price NOT NULL;3.price NOT NULL CHECK (price > 0);4.DEFAULT 0만 지정', 52),

    (565, 'SELECT_DESCRIPTION', 'Subscription(start_date DATE NOT NULL, end_date DATE NULL)에서 \n"진행중 구독은 end_date가 NULL이고, 종료된 구독은 end_date ≥ start_date여야 한다." 올바른 CHECK는?', '2', '1.CHECK (end_date >= start_date);2.CHECK (end_date IS NULL OR end_date >= start_date);3.CHECK (end_date IS NOT NULL AND end_date >= start_date);4.CHECK (start_date <= end_date OR end_date = '')', 52),

    (566, 'SELECT_DESCRIPTION', '다음 테이블에서 어떤 INSERT가 실패할까? \nCREATE TABLE T( a INT, b INT, PRIMARY KEY (a,b) );', '4', '1.INSERT INTO T(a,b) VALUES (1,1);2.INSERT INTO T(a,b) VALUES (1,NULL);3.INSERT INTO T(a,b) VALUES (NULL,1);4.2)와 3) 모두', 52),

    (567, 'SELECT_DESCRIPTION', '다음 정의에서 어떤 문제가 있는가? \nCREATE TABLE UserProfile(\n  user_id BIGINT NOT NULL,\n  profile_img_url TEXT,\n  FOREIGN KEY (user_id) REFERENCES User(id) ON DELETE SET NULL\n);', '2', '1.FK가 PK를 참조하지 않는다;2.ON DELETE SET NULL이지만 user_id가 NOT NULL;3.profile_img_url은 NULL이면 안 된다;4.FOREIGN KEY에는 UNIQUE가 필요', 52),

    (568, 'SELECT_DESCRIPTION', '기본값과 NULL에 관한 설명으로 옳은 것은? \nCREATE TABLE Log( level INT NOT NULL DEFAULT 1 );', '2', '1.INSERT INTO Log(level) VALUES (NULL);는 DEFAULT가 적용된다;2.INSERT INTO Log DEFAULT VALUES;는 level=1로 들어간다;3.INSERT INTO Log(level) VALUES (2);는 에러;4.DEFAULT는 SELECT시에만 적용', 52);

-- Unit03 - 관계대수 1 (Lesson ID: 53)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (569, 'SELECT_DESCRIPTION', 'A={1,2,3}, B={3,4,5}일 때 A∪B는?', '3', '1.{1, 2, 3};2.{3};3.{1,2,3,4,5};4.{4, 5}', 53),

    (570, 'SELECT_DESCRIPTION', 'A={a,b,c}, B={b,c,d}일 때 A와 B의 교집합은?', '2', '1.{a,d};2.{b,c};3.{a,b,c,d};4.{}', 53),

    (571, 'SELECT_DESCRIPTION', 'A={1,2,3,4}, B={3,4,5}일 때 A-B는?', '1', '1.{1,2};2.{3,4};3.{5};4.{1,2,5}', 53),

    (572, 'SELECT_DESCRIPTION', 'A={1,2}, B={x,y}일 때 A x B(데카르트 곱)는?', '1', '1.{(1,x),(1,y),(2,x),(2,y)};2.{(x,1),(y,1),(x,2),(y,2)};3.{1,2,x,y};4.{(1,2),(x,y)}', 53),

    (573, 'FILL_BLANK', '항상 교환법칙이 성립하는 두 연산은 합집합과 _____입니다.', '교집합', '-', 53),

    (574, 'FILL_BLANK', '항상 결합 법칙이 성립하는 두 연산은 합집합과 _____입니다.', '교집합', '-', 53),

    (575, 'SELECT_DESCRIPTION', '다음 중 항상 참인 등식은?', '2', '1.A x (B 합집합 C) = (A x B) 교집합 (A x C);2.A x (B 교집합 C) = (A x B) 교집합 (A x C);3.A - (B 합집합 C) = (A-B) 합집합 (A-C);4.A - (B 교집합 C) = (A-B) 교집합 (A-C)', 53),

    (576, 'SELECT_DESCRIPTION', '보편집합 U와 공집합(빈집합) {}에 대해 항상 참인 것을 고르시오.', '1', '1.A 합집합 {} = A, A 교집합 U = A;2.A 합집합 U = {}, A 교집합 {} = A;3.A 합집합 {} = {}, A 교집합 U = U;4.A 합집합 U = A, A 교집합 {} = U', 53),

    (577, 'SELECT_DESCRIPTION', '|A|=20, |B|=15, |A 교집합 B|=5일 때 |A 합집합 B|는?', '2', '1.25;2.30;3.35;4.40', 53),

    (578, 'SELECT_DESCRIPTION', '전체 원소가 100개이고 |A|=60, |B|=50, |A 교집합 B|=20일 때 A도 B도 아닌 원소의 수는?', '3', '1.0;2.5;3.10;4.20', 53),

    (579, 'SELECT_DESCRIPTION', 'A={1,2,3}, B={3,4,5}일 때 (A-B) 합집합 (B-A)는?', '2', '1.{3};2.{1,2,4,5};3.{1,2,3,4,5};4.{}', 53),

    (580, 'SELECT_DESCRIPTION', '|A|=4, |B|=10, |C|=3이고 C는 B의 부분 집합일 때 |A x (B-C)|는?', '4', '1.7;2.12;3.21;4.28', 53);

-- Unit03 - 관계대수 2 (Lesson ID: 54)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (581, 'SELECT_DESCRIPTION', 'Student(sid, name, dept) 스키마가 있을 때, \n"CS 학과 학생들의 이름만"에 해당하는 식은?', '1', '1.π name ( σ dept=''CS'' ( Student ) );2.σ dept=''CS'' ( π name ( Student ) );3.π dept ( σ name=''CS'' ( Student ) );4.π name ( Student ▷◁ Course )', 54),

    (582, 'SELECT_DESCRIPTION', 'Enroll(sid, cid) 스키마가 있을 때, \n"DB101을 수강한 학생 sid 목록"에 해당하는 식은?', '1', '1.π sid ( σ cid=''DB101'' ( Enroll ) );2.σ cid=''DB101'' ( π sid ( Enroll ) );3.π name ( σ cid=''DB101'' ( Enroll ) );4.π cid ( σ sid=''DB101'' ( Enroll ) )', 54),

    (583, 'FILL_BLANK', 'Student(sid, name), Enroll(sid, cid), Course(cid, title) 스키마가 있을 때, \n"수강한 학생 이름과 과목 제목(title)"을 얻는 식의 빈칸을 채우시오. \nπ name, title ( ( Student _____ Enroll ) _____ Course )', '1', '1.▷◁ , ▷◁;2.▷◁ , ÷;3.÷ , ▷◁;4.▷◁ , σ', 54),

    (584, 'FILL_BLANK', 'Student(sid, name), Enroll(sid, cid, grade) 스키마가 있을 때, \n"A학점을 받은 학생 이름"을 σ, π, ▷◁로만 표현하시오. \n→ π name ( Student _____ σ grade=''A'' ( Enroll ) )', '1', '1.▷◁;2.π;3.σ;4.÷', 54),

    (585, 'SELECT_DESCRIPTION', 'Teaches(pid, cid, term), Course(cid, title) 스키마가 있을 때, \n"pid=10 교수가 2025S 학기에 가르친 과목 제목(title)"은?', '1', '1.π title ( σ pid=10 ∧ term=''2025S'' ( Teaches ) ▷◁ Course );2.π title ( Teaches ▷◁ σ pid=10 ( Course ) );3.σ pid=10 ( π title ( Teaches ▷◁ Course ) );4.π cid ( σ pid=10 ∧ term=''2025S'' ( Teaches ) )', 54),

    (586, 'FILL_BLANK', 'Enroll(sid, cid), Course(cid, dept) 스키마가 있을 때, \n"CS 학과에서 개설된 모든 과목을 수강한 학생 sid"를 ÷로 표현하시오. \nEnroll _____ π cid ( σ dept=''CS'' ( Course ) )', '4', '1.▷◁;2.π;3.σ;4.÷', 54),

    (587, 'SELECT_DESCRIPTION', 'Enroll(sid, cid), Req(cid) 스키마가 있을 때, \n"Req의 모든 과목을 수강한 학생 sid"에 해당하는 가장 직접적인 식은?', '1', '1.Enroll ÷ Req;2.π sid ( Enroll ▷◁ Req );3.π sid ( σ cid∈Req ( Enroll ) );4.π sid ( Enroll )', 54),

    (588, 'FILL_BLANK', 'Enroll(sid, cid, grade), Student(sid, name) 스키마가 있을 때, \n다음 두 식이 동치가 되도록 빈칸에 들어갈 곳을 고르시오. \nπ name ( σ grade=''A'' ( Enroll ) ▷◁ Student ) = π name ( Student ▷◁ _____ )', '1', '1.σ grade=''A'' ( Enroll );2.π sid ( Enroll );3.σ name=''A'' ( Student );4.Enroll ÷ σ grade=''A'' ( Enroll )', 54),

    (589, 'SELECT_DESCRIPTION', 'Enroll(sid, cid), Course(cid, title) 스키마가 있을 때, \n"학생 sid와 수강 과목 title 쌍"을 가장 간단히 나타내는 식은?', '1', '1.π sid, title ( Enroll ▷◁ Course );2.π name, title ( Student ▷◁ Course );3.π sid, title ( Student ▷◁ Course );4.π sid, title ( σ dept=''CS'' ( Enroll ) )', 54),

    (590, 'FILL_BLANK', 'Student(sid, name, dept), Enroll(sid, cid), Course(cid, title, dept) 스키마가 있을 때, \n"학생이 자신의 학과(dept)의 과목을 수강한 (sid, name, title)"을 표현하시오. → π sid, name, title ( Student ▷◁ Enroll _____ Course )', '1', '1.▷◁;2.π;3.σ;4.÷', 54),

    (591, 'FILL_BLANK', 'Student(sid, name, dept), Enroll(sid, cid) 스키마가 있을 때, \n다음 식에서 빈칸에 맞는 연산을 고르시오. \nπ name ( _____ ( Student ) ▷◁ Enroll ) = "CS 학과이면서 수강 경험이 있는 학생 이름"', '1', '1.σ dept=''CS'';2.π dept;3.÷ Req;4.σ name=''CS''', 54),

    (592, 'FILL_BLANK', 'Teaches(pid, cid), Req(cid) 스키마가 있을 때, \n다음 식에서 빈칸에 들어갈 가장 알맞은 표현을 고르시오. \nπ pid ( _____ ) = "필수 과목 Req를 모두 가르친 교수 pid"', '1', '1.Teaches ÷ Req;2.π pid ( Teaches ▷◁ Req );3.σ cid IN π cid(Req) ( Teaches );4.π pid,cid ( Teaches ) ▷◁ Req', 54);

-- Unit04 - SQL 1-1 (Lesson ID: 55)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (593, 'FILL_BLANK', 'Users(id, name, status) 스키마가 있을 때, \n활성 사용자 이름만 조회하려 한다. 빈칸에 들어갈 컬럼을 고르시오. \nSELECT _____ FROM Users WHERE status=''ACTIVE'';', '2', '1.id;2.name;3.*;4.id, name', 55),

    (594, 'SELECT_DESCRIPTION', 'Users(id, dept, active) 스키마가 있을 때, \n"CS 또는 EE 학과이면서 active=1"을 정확히 표현한 WHERE는?', '2', '1.WHERE dept=''CS'' OR dept=''EE'' AND active=1;2.WHERE (dept=''CS'' OR dept=''EE'') AND active=1;3.WHERE dept IN (''CS'',''EE'' AND active=1);4.WHERE (dept=''CS'' AND dept=''EE'') OR active=1', 55),

    (595, 'FILL_BLANK', 'Orders(id, amount) 스키마가 있을 때, \n결제 금액이 100 이상 200 이하인 주문을 조회한다. 빈칸에 올바른 연산자를 고르시오. \nSELECT id FROM Orders WHERE amount _____ 100 AND 200;', '1', '1.BETWEEN;2.IN;3.LIKE;4.EXISTS', 55),

    (596, 'FILL_BLANK', 'Customers(id, name, phone) 스키마가 있을 때, \n연락처가 없는 고객을 찾는 WHERE 조건으로 맞는 것은?', '3', '1.WHERE phone = NULL;2.WHERE phone == NULL;3.WHERE phone IS NULL;4.WHERE ISNULL(phone)', 55),

    (597, 'FILL_BLANK', 'Articles(id, title) 스키마가 있을 때, \n제목이 ''SQL''로 시작하는 글을 찾는 LIKE 패턴은? \nSELECT id FROM Articles WHERE title LIKE _____ ;', '1', '1.''SQL%'';2.''%SQL'';3.''%SQL%'';4.''SQL_''', 55),

    (598, 'SELECT_DESCRIPTION', 'Users(u_id), Orders(o_id, user_id) 스키마가 있을 때, \n"주문이 없는 사용자"를 안전하게 구하는 WHERE는? (서브쿼리에 NULL이 포함될 수 있음)', '2', '1.WHERE u_id NOT IN (SELECT user_id FROM Orders);2.WHERE NOT EXISTS (SELECT 1 FROM Orders o WHERE o.user_id = u.u_id);3.WHERE u_id IN (SELECT user_id FROM Orders) = FALSE;4.WHERE user_id IS NULL', 55),

    (599, 'SELECT_DESCRIPTION', 'Users(id), Orders(id, user_id) 스키마가 있을 때, \n"주문이 있는 사용자만"을 가장 간결히 표현한 WHERE는?', '3', '1.WHERE id IN (SELECT user_id FROM Orders);2.WHERE EXISTS (SELECT 1 FROM Orders o WHERE o.user_id = Users.id);3.1)과 2) 모두 가능;4.WHERE id = ANY (SELECT id FROM Orders)', 55),

    (600, 'SELECT_DESCRIPTION', 'Sales(id, created_at) 스키마가 있을 때, \n2025-08-01 당일 데이터만 정확히(시분초 포함) 조회하려면?', '3', '1.WHERE DATE(created_at) = ''2025-08-01'';2.WHERE created_at BETWEEN ''2025-08-01'' AND ''2025-08-01 23:59:59'';3.WHERE created_at >= ''2025-08-01'' AND created_at < ''2025-08-02'';4.WHERE created_at LIKE ''2025-08-01%''', 55),

    (601, 'SELECT_DESCRIPTION', 'Items(id, price, qty) 스키마가 있을 때, \n합계(total)=price*qty가 1000 초과인 행을 고를 때 올바른 WHERE는?', '2', '1.SELECT id, price*qty AS total FROM Items WHERE total > 1000;;2.SELECT id FROM Items WHERE price*qty > 1000;;3.SELECT id FROM Items WHERE qty > 1000/price AS total;;4.SELECT id, total FROM Items WHERE price*qty > 1000;', 55),

    (602, 'FILL_BLANK', 'Employees(id, role) 스키마가 있을 때, \nADMIN 또는 MANAGER만 조회하는 WHERE 절에서 빈칸에 알맞는 내용을 작성하라. \nWHERE role _____ (''ADMIN'', ''MANAGER'')', 'in', '-', 55),

    (603, 'SELECT_DESCRIPTION', 'Employees(id, bonus) 스키마가 있을 때, \n보너스가 0보다 큰 직원만 찾는 WHERE로 ANSI 표준에 맞는 것은?', '3', '1.WHERE IFNULL(bonus,0) > 0;2.WHERE NVL(bonus,0) > 0;3.WHERE COALESCE(bonus,0) > 0;4.WHERE ISNULL(bonus,0) > 0', 55),

    (604, 'SELECT_DESCRIPTION', 'Users(id, country, status) 스키마가 있을 때, \n''활성'' 사용자들의 서로 다른 ''국가'' 목록만 가져오는 올바른 SELECT는?', '2', '1.SELECT country FROM Users WHERE status=''ACTIVE'';;2.SELECT DISTINCT country FROM Users WHERE status=''ACTIVE'';;3.SELECT country FROM Users GROUP BY status=''ACTIVE'';;4.SELECT DISTINCT country FROM Users;', 55);

-- Unit04 - SQL 1-2 (Lesson ID: 56)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (605, 'SELECT_DESCRIPTION', 'Users(user_id, nickname) 스키마가 있을 때, \n사용자 표시명을 닉네임이 있으면 닉네임으로, 없으면 ''user#'' || user_id로 보여주려면?', '2', '1.SELECT NVL(nickname, ''user#'' || user_id) AS display_name FROM Users;2.SELECT COALESCE(nickname, ''user#'' || user_id) AS display_name FROM Users;3.SELECT IFNULL(nickname, CONCAT(''user#'', user_id)) AS display_name FROM Users;4.SELECT CASE WHEN nickname IS NULL THEN ''user#'' || user_id END AS display_name FROM Users', 56),

    (606, 'SELECT_DESCRIPTION', 'Orders(order_id, amount, created_at) 스키마가 있을 때, \n''월별'' 매출 합계를 집계하려고 한다. 올바른 GROUP BY는?', '2', '1.SELECT SUM(amount), created_at FROM Orders GROUP BY created_at;2.SELECT EXTRACT(YEAR FROM created_at) AS y, EXTRACT(MONTH FROM created_at) AS m, SUM(amount) FROM Orders GROUP BY EXTRACT(YEAR FROM created_at), EXTRACT(MONTH FROM created_at);3.SELECT TO_CHAR(created_at, ''YYYY-MM'') ym, SUM(amount) FROM Orders GROUP BY ym;4.SELECT SUM(amount) FROM Orders GROUP BY 1', 56),

    (607, 'SELECT_DESCRIPTION', 'Orders(order_id, amount, created_at) 스키마가 있을 때, \n정확히 "일자별" 매출 합계를 구하는 쿼리는?', '2', '1.SELECT created_at, SUM(amount) FROM Orders GROUP BY created_at;2.SELECT CAST(created_at AS DATE) d, SUM(amount) FROM Orders GROUP BY CAST(created_at AS DATE);3.SELECT DATE(created_at) d, SUM(amount) FROM Orders GROUP BY created_at;4.SELECT SUM(amount) FROM Orders GROUP BY DATE(created_at), created_at', 56),

    (608, 'SELECT_DESCRIPTION', 'Orders(order_id, user_id) 스키마가 있을 때, \nCOUNT(col) vs COUNT(*)의 차이로 옳은 것은?', '2', '1.COUNT(col)은 NULL 포함, COUNT(*)는 NULL 제외;2.COUNT(col)은 NULL 제외, COUNT(*)는 행 개수 전부;3.둘 다 NULL 제외;4.둘 다 NULL 포함', 56),

    (609, 'SELECT_DESCRIPTION', 'Orders(order_id, user_id, status, amount) 스키마가 있을 때, \n상태가 PAID인 주문만 대상으로 사용자의 총 결제액이 1,000,000원 초과인 user_id를 찾으려면?', '2', '1.SELECT user_id FROM Orders WHERE status=''PAID'' GROUP BY user_id WHERE SUM(amount) > 1000000;2.SELECT user_id FROM Orders WHERE status=''PAID'' GROUP BY user_id HAVING SUM(amount) > 1000000;3.SELECT user_id FROM Orders GROUP BY user_id WHERE SUM(amount) > 1000000 AND status=''PAID'';4.SELECT user_id FROM Orders HAVING status=''PAID'' AND SUM(amount) > 1000000', 56),

    (610, 'FILL_BLANK', 'OrderItem(order_id, product_id, qty), Product(product_id, category) 스키마가 있을 때, \n다음 쿼리의 빈칸 [A]~[C]를 알맞게 채워, 카테고리 별 판매 수량 합계를 구하고 합계가 100 이상인 카테고리만 조회하라. \nSELECT _____, SUM(oi.qty) AS total_qty \nFROM OrderItem oi JOIN Product p _____ \nGROUP BY _____ \n_____ SUM(oi.qty) >= 100;', '4', '1.A = p.category, B = HAVING, C = WHERE;2.A = HAVING, B = p.category, C = WHERE;3.A = USING(product_id), B = WHERE, C = p.category;4.A = p.category, B = USING(product_id), C = HAVING', 56),

    (611, 'FILL_BLANK', 'Orders(order_id, user_id, amount, created_at), Users(user_id, city) 스키마가 있을 때, \n일자별·도시별 매출 합계를 구하려 한다. 다음 쿼리의 빈칸을 채우시오. \nSELECT CAST(o.created_at AS DATE) AS d, u.city, SUM(o.amount) AS total_amount \nFROM Orders o JOIN Users u ON u.user_id = o.user_id \nGROUP BY _____, _____ ;', '4', '1.o.created_at, u.city;2.d, u.city;3.DATE(o.created_at), Users.city;4.CAST(o.created_at AS DATE), u.city', 56),

    (612, 'SELECT_DESCRIPTION', 'Orders(order_id, user_id, status) 스키마가 있을 때, \n사용자별 취소율(= 취소건수 / 전체건수)을 0~1 실수로 구하는 식으로 옳은 것은?', '2', '1.SUM(CASE WHEN status=''CANCELED'' THEN 1 END) / COUNT(*);2.SUM(CASE WHEN status=''CANCELED'' THEN 1 ELSE 0 END) * 1.0 / COUNT(*);3.COUNT(CASE WHEN status=''CANCELED'' THEN 1 END) / COUNT(*);4.AVG(CASE WHEN status=''CANCELED'' THEN 1 END)', 56),

    (613, 'SELECT_DESCRIPTION', 'Orders(order_id, user_id, created_at) 스키마가 있을 때, \n월별로 구매한 서로 다른 사용자 수를 구하려면?', '2', '1.... COUNT(user_id) ... GROUP BY 년,월;2.... COUNT(DISTINCT user_id) ... GROUP BY EXTRACT(YEAR FROM created_at), EXTRACT(MONTH FROM created_at);3.... SUM(DISTINCT user_id) ...;4.... COUNT(*) FILTER (WHERE DISTINCT user_id) ...', 56),

    (614, 'SELECT_DESCRIPTION', 'Orders(order_id, created_at), OrderItem(order_id, product_id) 스키마가 있을 때, \n제품별 최초 판매일과 최종 판매일을 구하는 쿼리는?', '2', '1.SELECT product_id, MIN(created_at), MAX(created_at) FROM Orders GROUP BY product_id;2.SELECT product_id, MIN(o.created_at), MAX(o.created_at) FROM OrderItem oi JOIN Orders o USING(order_id) GROUP BY product_id;3.SELECT product_id, FIRST(created_at), LAST(created_at) FROM OrderItem GROUP BY product_id;4.SELECT product_id, MIN(created_at), MAX(created_at) FROM OrderItem GROUP BY created_at', 56),

    (615, 'SELECT_DESCRIPTION', 'Orders(user_id, amount, created_at) 스키마가 있을 때, \n다음 쿼리에서 표준 SQL 기준으로 잘못된 부분을 고르시오. \n1. SELECT user_id, SUM(amount) AS s \n2. FROM Orders \n3. GROUP BY user_id \n4. ORDER BY created_at', '4', '1.1;2.2;3.3;4.4', 56),

    (616, 'FILL_BLANK', 'Orders(order_id, user_id, status, amount), Users(user_id, city) 스키마가 있을 때, \nPAID 주문만 대상으로 도시별 평균 결제액이 50,000원 이상인 도시를 구하는 쿼리의 HAVING 부분을 완성하라. \nSELECT u.city, AVG(o.amount) AS avg_amt \nFROM Orders o JOIN Users u ON u.user_id = o.user_id \nWHERE o.status = ''PAID'' \nGROUP BY u.city HAVING _____ >= 50000;', '1', '1.AVG(o.amount);2.SUM(o.amount);3.COUNT(o.amount);4.o.amount', 56);

-- Unit04 - SQL 1-3 (Lesson ID: 57)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (617, 'SELECT_DESCRIPTION', 'Users(id, level, created_at) 스키마가 있을 때, \nlevel 내림차순, 동점이면 created_at 내림차순, 그래도 같으면 id 오름차순으로 정렬하라. 올바른 ORDER BY는?', '3', '1.ORDER BY level, created_at DESC, id;2.ORDER BY level DESC, created_at, id ASC;3.ORDER BY level DESC, created_at DESC, id ASC;4.ORDER BY level DESC, id ASC, created_at DESC', 57),

    (618, 'SELECT_DESCRIPTION', 'Posts(id, title, created_at, pinned_at) 스키마가 있을 때, \n고정 글(pinned_at NOT NULL)을 먼저, 그 다음 비고정 글을, 각 그룹 내에서는 최신(created_at DESC) 순으로 정렬하라.', '2', '1.ORDER BY pinned_at DESC, created_at DESC;2.ORDER BY CASE WHEN pinned_at IS NULL THEN 1 ELSE 0 END, created_at DESC;3.ORDER BY pinned_at, created_at DESC;4.ORDER BY created_at DESC', 57),

    (619, 'FILL_BLANK', 'Posts(id, created_at) 스키마가 있을 때, \n최신순으로 2페이지(page=2, size=20)를 조회하려고 한다. 빈칸을 채우시오. \nSELECT id FROM Posts \nORDER BY created_at DESC, id DESC \nLIMIT :size OFFSET _____ ;', '2', '1.:page * :size;2.(:page - 1) * :size;3.:page + :size;4.:size - :page', 57),

    (620, 'SELECT_DESCRIPTION', 'Orders(id, created_at) 스키마가 있을 때, \nOracle에서 "최신 10건"을 올바르게 가져오는 쿼리는?', '2', '1.SELECT * FROM Orders WHERE ROWNUM <= 10 ORDER BY created_at DESC;2.SELECT * FROM (SELECT * FROM Orders ORDER BY created_at DESC) WHERE ROWNUM <= 10;3.SELECT * FROM Orders ORDER BY created_at DESC FETCH FIRST 10 ROWS ONLY;4.SELECT * FROM Orders WHERE ROWNUM BETWEEN 1 AND 10 ORDER BY created_at DESC', 57),

    (621, 'SELECT_DESCRIPTION', 'Posts(id, created_at, category) 스키마가 있을 때, \n최신순 키셋 페이지네이션으로 "커서(created_at=:c_at, id=:c_id) 이전" 20개를 가져올 올바른 조건은?', '2', '1.WHERE created_at <= :c_at AND id < :c_id ORDER BY created_at DESC, id DESC LIMIT 20;2.WHERE (created_at, id) < (:c_at, :c_id) ORDER BY created_at DESC, id DESC LIMIT 20;3.WHERE created_at < :c_at OR id < :c_id ORDER BY created_at DESC, id DESC LIMIT 20;4.WHERE created_at < :c_at ORDER BY id DESC LIMIT 20', 57),

    (622, 'SELECT_DESCRIPTION', 'Posts(id, category, is_public, created_at) 스키마가 있을 때, \n카테고리=''news'' AND is_public=TRUE 조건의 전체 행 수(페이지네이션 총 건수)를 구하는 쿼리는?', '1', '1.SELECT COUNT(*) FROM Posts WHERE category=''news'' AND is_public=TRUE;2.SELECT COUNT(*) OVER() FROM Posts WHERE category=''news'' AND is_public=TRUE LIMIT 1;3.SELECT COUNT(id) FROM Posts GROUP BY category, is_public;4.SELECT SUM(1) FROM Posts', 57),

    (623, 'SELECT_DESCRIPTION', '페이지네이션에서 신규 행 삽입으로 인한 중복/누락을 줄이는 데 더 안전한 방식은?', '2', '1.OFFSET/LIMIT;2.키셋 페이지네이션(커서 방식: WHERE (k1,k2) < (:cursor...));3.-;4.-', 57),

    (624, 'SELECT_DESCRIPTION', '1부터 시작하는 페이지 번호 p와 페이지 크기 s가 있을 때 OFFSET을 구하는 수식은?', '3', '1.p * s;2.(p - 1) + s;3.(p - 1) * s;4.p + s', 57),

    (625, 'SELECT_DESCRIPTION', 'Orders(id, user_id, amount, created_at) 스키마가 있을 때, \ncreated_at 값이 같은 행들 사이에서도 결과 정렬이 항상 결정되도록 하려면?', '2', '1.ORDER BY created_at DESC;2.ORDER BY created_at DESC, id DESC;3.ORDER BY id DESC;4.ORDER BY created_at', 57),

    (626, 'SELECT_DESCRIPTION', 'Posts(id, category, created_at) 스키마가 있을 때, \nWHERE category=:cat AND ORDER BY created_at DESC, id DESC 쿼리를 가속하기 좋은 인덱스는?', '2', '1.INDEX ON Posts(created_at);2.INDEX ON Posts(category, created_at DESC, id DESC);3.INDEX ON Posts(id, created_at);4.INDEX ON Posts(category)', 57),

    (627, 'SELECT_DESCRIPTION', 'Products(id, price, updated_at) 스키마가 있을 때, \n가격 높은 순으로 상위 5개를 가져오는 올바른 쿼리는?', '1', '1.SELECT * FROM Products ORDER BY price DESC FETCH FIRST 5 ROWS ONLY;2.SELECT * FROM Products WHERE ROWNUM <= 5 ORDER BY price DESC;3.SELECT * FROM (SELECT * FROM Products ORDER BY price) WHERE ROWNUM <= 5;4.SELECT TOP 5 * FROM Products ORDER BY price DESC', 57),

    (628, 'FILL_BLANK', 'Posts(id, created_at) 스키마가 있을 때, \n윈도우 함수로 21~40번째(페이지 2, size 20) 최신 글을 구하는 쿼리의 빈칸을 채우시오. \nSELECT id FROM \n( SELECT id, ROW_NUMBER() OVER (ORDER BY created_at DESC, id DESC) AS rn \n  FROM Posts ) t \nWHERE _____ ;', '4', '1.rn BETWEEN 20 AND 40;2.rn > 20;3.rn <= 40;4.rn >= 21 AND rn <= 40', 57);

-- Unit05 - SQL 2-1 (Lesson ID: 58)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (629, 'SELECT_DESCRIPTION', 'Departments(id, name), Employees(id, name, dept_id NULL 허용) 스키마가 있을 때, \n"직원이 없어도 모든 부서를 포함해 조회"하려면 어떤 조인이 적절한가?', '2', '1.INNER JOIN;2.LEFT JOIN (Departments → Employees);3.RIGHT JOIN (Employees → Departments);4.NATURAL JOIN', 58),

    (630, 'FILL_BLANK', 'Departments(id), Employees(id, dept_id) 스키마가 있을 때, \n"부서가 존재하는 직원만" 조회하는 빈칸을 채우시오. \nSELECT e.* \nFROM Employees e _____ JOIN Departments d \nON d.id = e.dept_id;', '1', '1.INNER;2.LEFT;3.RIGHT;4.FULL OUTER', 58),

    (631, 'SELECT_DESCRIPTION', 'NATURAL JOIN에 대한 설명으로 가장 정확한 것은?', '1', '1.동일한 이름의 모든 컬럼에 대해 자동으로 동등 조인한다.;2.기본키 컬럼만 자동으로 조인한다.;3.USING(id)와 항상 동일하다.;4.스키마 변경에 강하다.', 58),

    (632, 'FILL_BLANK', 'Employees(id, name, manager_id) 스키마가 있을 때, \n직원과 그 매니저 이름을 함께 조회하되, 매니저가 없는 직원도 포함하라. \nSELECT e.name AS emp, m.name AS manager \nFROM Employees e \nLEFT JOIN Employees m \nON _____ ;', '1', '1.e.manager_id = m.id;2.e.id = m.manager_id;3.e.dept_id = m.dept_id;4.e.manager_id <> m.id', 58),

    (633, 'SELECT_DESCRIPTION', 'Departments(id), Employees(id, dept_id) 스키마가 있을 때, \n다음 RIGHT JOIN을 LEFT JOIN으로 동치 변환한 것은? \nSELECT d.id, e.id \nFROM Employees e \nRIGHT JOIN Departments d \nON d.id = e.dept_id;', '1', '1.Departments d LEFT JOIN Employees e ON e.dept_id = d.id;2.Departments d INNER JOIN Employees e ON e.dept_id = d.id;3.Employees e LEFT JOIN Departments d ON d.id = e.dept_id;4.Employees e FULL OUTER JOIN Departments d ON d.id = e.dept_id', 58),

    (634, 'SELECT_DESCRIPTION', 'Customers(id), Orders(id, customer_id) 스키마가 있을 때, \n"주문 유무와 상관없이 모든 고객과 모든 주문을 한 번에 나열(양쪽 모두 보존)"하려면?', '4', '1.INNER JOIN;2.LEFT JOIN;3.RIGHT JOIN;4.FULL OUTER JOIN', 58),

    (635, 'FILL_BLANK', 'Customers(id), Orders(id, customer_id) 스키마가 있을 때, \n"주문이 없는 고객"을 의도에 가장 안전하게 구하라. 빈칸을 채우시오. \nSELECT c.* FROM Customers c WHERE _____ ;', '1', '1.NOT EXISTS (SELECT 1 FROM Orders o WHERE o.customer_id = c.id);2.o.id IS NULL;3.c.id NOT IN (SELECT customer_id FROM Orders);4.-', 58),

    (636, 'FILL_BLANK', 'Customers(id), Orders(id, customer_id), OrderItems(order_id, product_id) 스키마가 있을 때, \n"상품 :pid를 주문한 고객만(중복 없이)"을 구하라. 빈칸을 채우시오. \nSELECT c.* FROM Customers c WHERE _____ ;', '1', '1.EXISTS (SELECT 1 FROM Orders o JOIN OrderItems oi ON oi.order_id = o.id WHERE o.customer_id = c.id AND oi.product_id = :pid);2.c.id IN (SELECT o.customer_id FROM Orders o JOIN OrderItems oi ON oi.order_id = o.id WHERE oi.product_id = :pid);3.NATURAL JOIN으로 모두 결합 후 WHERE product_id = :pid;4.-', 58),

    (637, 'FILL_BLANK', 'Departments(id, active), Employees(id, dept_id, active) 스키마가 있을 때, \n"활성 부서는 모두 보이고, 활성 직원만 매칭"되도록 빈칸을 채우시오. \nSELECT d.id, e.id \nFROM Departments d LEFT JOIN Employees e ON e.dept_id = d.id _____ \nWHERE d.active = ''Y'';', '3', '1.AND d.active = ''Y'';2.WHERE e.active = ''Y'';3.AND e.active = ''Y'';4.-', 58),

    (638, 'FILL_BLANK', 'Posts(id), Comments(id, post_id), Likes(id, post_id) 스키마가 있을 때, \n"댓글 ≥1 AND 좋아요 ≥1" 포스트 개수를 중복 없이 구하라. 빈칸을 채우시오. \nSELECT COUNT(*) \nFROM Posts p \nWHERE _____ AND _____ ;', '2', '1.(1) p.id IN (SELECT post_id FROM Comments) (2) p.id IN (SELECT post_id FROM Likes);2.(1) EXISTS (SELECT 1 FROM Comments c WHERE c.post_id = p.id) (2) EXISTS (SELECT 1 FROM Likes l WHERE l.post_id = p.id);3.(1) JOIN Comments (2) JOIN Likes;4.-', 58),

    (639, 'FILL_BLANK', 'Users(id, name), Profiles(user_id, name, photo_url) 스키마가 있을 때, \nNATURAL JOIN 대신 의도 컬럼만 명시하라. 빈칸을 채우시오. \nSELECT * \nFROM Users u JOIN Profiles p ON _____ ;', '1', '1.p.user_id = u.id;2.p.name = u.name;3.USING (id);4.-', 58),

    (640, 'SELECT_DESCRIPTION', 'Employees(id, name, dept_id) 스키마가 있을 때, \n같은 부서의 "동료 페어(본인은 제외)"를 구하는 조인 조건은?', '2', '1.e1.dept_id = e2.dept_id AND e1.id = e2.id;2.e1.dept_id = e2.dept_id AND e1.id <> e2.id;3.e1.dept_id <> e2.dept_id AND e1.id <> e2.id;4.e1.dept_id = e2.id', 58);

-- Unit05 - SQL 2-2 (Lesson ID: 59)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (641, 'FILL_BLANK', 'Customers(id), Orders(id, customer_id) 스키마가 있을 때, \n"주문이 있는 고객"만 조회. 빈칸을 채우시오. \nSELECT c.* \nFROM Customers c \nWHERE _____ ;', '1', '1.EXISTS (SELECT 1 FROM Orders o WHERE o.customer_id = c.id);2.NOT EXISTS (SELECT 1 FROM Orders o WHERE o.customer_id = c.id);3.c.id IN (SELECT o.id FROM Orders o);4.-', 59),

    (642, 'FILL_BLANK', 'Customers(id), Orders(id, customer_id) 스키마가 있을 때, \n아래 IN을 JOIN으로 바꿀 때, 조인 종류를 채우시오. \nSELECT c.id \nFROM Customers c \nWHERE c.id IN (SELECT o.customer_id FROM Orders o) \n→ \nSELECT DISTINCT c.id \nFROM Customers c _____ JOIN Orders o ON o.customer_id = c.id;', '2', '1.LEFT;2.INNER;3.RIGHT;4.FULL OUTER', 59),

    (643, 'FILL_BLANK', 'Customers(id), Orders(id, customer_id NULL 허용) 스키마가 있을 때, \nNULL 함정 없이 "주문이 없는 고객"을 안전하게 구하는 조건을 채우시오. \nSELECT c.* \nFROM Customers c \nWHERE _____ ;', '3', '1.c.id NOT IN (SELECT customer_id FROM Orders);2.c.id NOT IN (SELECT customer_id FROM Orders WHERE customer_id IS NOT NULL);3.NOT EXISTS (SELECT 1 FROM Orders o WHERE o.customer_id = c.id);4.-', 59),

    (644, 'SELECT_DESCRIPTION', 'IN 서브쿼리에 중복이 많아도 결과는 바뀌지 않는다.', '1', '1.참;2.거짓;3.경우에 따라 다름;4.-', 59),

    (645, 'FILL_BLANK', 'Employees(id, salary), DeptSalaries(dept_id, salary) 스키마가 있을 때, \nsalary > ANY(SELECT salary FROM DeptSalaries WHERE dept_id = :d)와 동치인 집계 표현을 채우시오. \nsalary > _____ (SELECT salary FROM DeptSalaries WHERE dept_id = :d)', '1', '1.MIN;2.MAX;3.AVG;4.-', 59),

    (646, 'FILL_BLANK', 'Products(id, price) 스키마가 있을 때, \nprice < ALL(SELECT price FROM Products WHERE id <> :id)와 동치인 집계 표현은? \nprice < _____ (SELECT price FROM Products WHERE id <> :id)', '1', '1.MIN;2.MAX;3.SUM;4.-', 59),

    (647, 'FILL_BLANK', 'Products(id, price), CompetitorPrices(product_id, price) 스키마가 있을 때,\n p.price > ANY(...)를 EXISTS로 바꿀 때 비교 연산자를 채우시오. \nSELECT p.id \nFROM Products p \nWHERE EXISTS ( \n  SELECT 1 FROM CompetitorPrices cp \n  WHERE cp.product_id = p.id AND p.price _____ cp.price \n);', '3', '1.<;2.=;3.>;4.=', 59),

    (648, 'FILL_BLANK', 'Products(id, price), CompetitorPrices(product_id, price) 스키마가 있을 때, \np.price >= ALL(서브쿼리)와 동치인 NOT EXISTS 조건을 채우시오. \nNOT EXISTS ( SELECT 1 \n  FROM CompetitorPrices cp \n  WHERE cp.product_id = p.id AND p.price _____ cp.price \n)', '2', '1.<=;2.<;3.>;4.=', 59),

    (649, 'FILL_BLANK', 'Customers(id), Orders(id, customer_id, created_at) 스키마가 있을 때, \n"2025년에 주문이 없는 고객"을 LEFT JOIN으로 구한다. 빈칸을 채우시오. \nSELECT c.id \nFROM Customers c LEFT JOIN Orders o \nON o.customer_id = c.id AND o.created_at >= DATE ''2025-01-01'' AND o.created_at < DATE ''2026-01-01'' \nWHERE _____ ;', '3', '1.o.customer_id IS NOT NULL;2.c.id IS NULL;3.o.id IS NULL;4.-', 59),

    (650, 'FILL_BLANK', 'A(a1, a2), B(b1, b2) 스키마가 있을 때, \n(a1, a2) IN (SELECT b1, b2 FROM B)를 EXISTS로 바꿀 때 조건을 채우시오. \nEXISTS (SELECT 1 FROM B b WHERE _____ )', '1', '1.b.b1 = a.a1 AND b.b2 = a.a2;2.b.b1 = a.a2 AND b.b2 = a.a1;3.b.b1 = a.a1 OR b.b2 = a.a2;4.-', 59),

    (651, 'FILL_BLANK', 'OrderItems(order_id, price) 스키마가 있을 때, \noi.price > ALL(SELECT price FROM OrderItems WHERE order_id = :x)와 동치인 집계 표현은? \noi.price > _____ (SELECT price FROM OrderItems WHERE order_id = :x)', '2', '1.MIN;2.MAX;3.AVG', 59),

    (652, 'FILL_BLANK', 'Customers(id), Orders(id, customer_id) 스키마가 있을 때, \nIN을 JOIN으로 바꿀 때, IN과 같은 "고객 중복 제거"를 위해 SELECT에 채워야 할 키워드는? \nSELECT _____ c.id \nFROM Customers c INNER JOIN Orders o ON o.customer_id = c.id;', '1', '1.DISTINCT;2.UNIQUE;3.TOP 1;4.-', 59);

-- Unit05 - SQL 2-3 (Lesson ID: 60)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (653, 'FILL_BLANK', 'A(id), B(id) 스키마가 있을 때, \n두 테이블의 id를 중복 없이 합치려면 빈칸을 채우시오. \nSELECT id FROM A \n_____ \nSELECT id FROM B;', '1', '1.UNION;2.UNION ALL;3.INTERSECT;4.MINUS/EXCEPT', 60),

    (654, 'FILL_BLANK', 'A(id), B(id) 스키마가 있을 때, \n두 테이블을 합칠 때 중복 허용 + 빠른 경로를 선택하라. 빈칸을 채우시오. \nSELECT id FROM A \n_____ \nSELECT id FROM B;', '2', '1.UNION;2.UNION ALL;3.INTERSECT;4.MINUS/EXCEPT', 60),

    (655, 'FILL_BLANK', 'Customers(id), Orders(customer_id) 스키마가 있을 때, \n주문이 없는 고객 id를 집합 연산으로 구하라(Oracle: MINUS, PostgreSQL: EXCEPT). 빈칸을 채우시오. \nSELECT id FROM Customers \n_____ \nSELECT customer_id FROM Orders;', '4', '1.UNION;2.UNION ALL;3.INTERSECT;4.MINUS/EXCEPT', 60),

    (656, 'FILL_BLANK', 'A(id), B(id) 스키마가 있을 때, \n두 테이블에 공통으로 존재하는 id만 구하라. 빈칸을 채우시오. \nSELECT id FROM A \n_____ \nSELECT id FROM B;', '3', '1.UNION;2.UNION ALL;3.INTERSECT;4.MINUS/EXCEPT', 60),

    (657, 'SELECT_DESCRIPTION', 'A(id), B(id) 스키마가 있을 때, \n집합 연산 결과를 id 오름차순 정렬하려면 ORDER BY는 어디에 둬야 하는가?', '1', '1.마지막 SELECT 뒤 한 번만;2.각 SELECT마다;3.UNION ALL 사이사이;4.MINUS 앞', 60),

    (658, 'FILL_BLANK', 'A(id, active), B(id, active) 스키마가 있을 때, \nactive=''Y'' 조건을 집합 전에 밀어 넣어 비용을 줄여라. 빈칸을 채우시오. \nSELECT id FROM A \nWHERE active=''Y'' _____ SELECT id FROM B WHERE active=''Y'';', '1', '1.UNION;2.CONCAT;3.INTERSECT;4.MINUS/EXCEPT', 60),

    (659, 'SELECT_DESCRIPTION', 'T(x 인덱스 존재), 조건: x IN (:a, :b) 스키마가 있을 때, \n인덱스 활용 측면에서 유리한 형태는?', '2', '1.SELECT * FROM T WHERE x=:a OR x=:b;2.SELECT * FROM T WHERE x=:a UNION ALL SELECT * FROM T WHERE x=:b;3.SELECT * FROM T WHERE x IN (:a,:b) ORDER BY 1;4.-', 60),

    (660, 'SELECT_DESCRIPTION', 'A(id), B(id) 스키마가 있을 때, \n두 테이블의 중복 포함 합계 건수를 가장 간단히 구하라.', '2', '1.SELECT COUNT(*) FROM (SELECT id FROM A UNION SELECT id FROM B);2.SELECT COUNT(*) FROM (SELECT id FROM A UNION ALL SELECT id FROM B);3.SELECT COUNT(DISTINCT id) FROM (SELECT id FROM A UNION ALL SELECT id FROM B);4.-', 60),

    (661, 'FILL_BLANK', 'A(a1,a2), B(b1,b2) 스키마가 있을 때, \n(a1,a2) 교집합을 구하라. 빈칸을 채우시오. \nSELECT a1, a2 FROM A _____ SELECT b1, b2 FROM B;', '3', '1.UNION;2.UNION ALL;3.INTERSECT;4.MINUS/EXCEPT', 60),

    (662, 'FILL_BLANK', 'A(id), B(id) 스키마가 있을 때, \n두 테이블에서 중복으로 나타나는 id만 골라라(교집합 값 목록). 빈칸을 채우시오. \nSELECT id FROM A _____ SELECT id FROM B;', '3', '1.UNION;2.UNION ALL;3.INTERSECT;4.MINUS/EXCEPT', 60),

    (663, 'FILL_BLANK', 'A(id), B(id) 스키마가 있을 때, \n다음 MINUS/EXCEPT를 NOT EXISTS로 바꿀 때 괄호 안을 채우시오. \nSELECT id FROM A MINUS/EXCEPT SELECT id FROM B; \n→ \nSELECT a.id FROM A a WHERE NOT EXISTS (\n SELECT 1 FROM B b WHERE _____ \n);', '1', '1.b.id = a.id;2.b.id <> a.id;3.a.id IS NULL;4.-', 60),

    (664, 'SELECT_DESCRIPTION', '괄호 없이 A UNION B INTERSECT C의 평가 순서는?', '2', '1.(A UNION B) INTERSECT C;2.A UNION (B INTERSECT C);3.(A INTERSECT B) UNION C;4.-', 60);

-- Unit06 - SQL 3-1 (Lesson ID: 61)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (665, 'FILL_BLANK', 'Users 테이블 생성 시 id를 기본키로 지정하라. 빈칸을 채우시오. \nCREATE TABLE Users ( \n  id BIGINT _____ , \n  email VARCHAR(255) \n);', '1', '1.PRIMARY KEY;2.UNIQUE;3.FOREIGN KEY;4.UNION', 61),

    (666, 'FILL_BLANK', 'email을 유니크 제약으로 추가하라. 빈칸을 채우시오. \nALTER TABLE Users \nADD CONSTRAINT ux_users_email _____ (email);', '2', '1.PRIMARY KEY;2.UNIQUE;3.FOREIGN KEY;4.UNION', 61),

    (667, 'FILL_BLANK', 'Orders에 status 컬럼을 기본값 ''PENDING'', NULL 금지로 추가하라. 빈칸을 채우시오. \nALTER TABLE Orders \nADD COLUMN status VARCHAR(20) _____ ;', '4', '1.DEFAULT ''PENDING'' NULL;2.NOT NULL;3.DEFAULT ''PENDING'';4.DEFAULT ''PENDING'' NOT NULL', 61),

    (668, 'FILL_BLANK', 'Users의 nickname 컬럼을 handle로 이름 변경. 빈칸을 채우시오. \nALTER TABLE Users _____ nickname TO handle;', '1', '1.RENAME COLUMN;2.CHANGE COLUMN;3.RENAME TO;4.MODIFY', 61),

    (669, 'FILL_BLANK', 'Orders.user_id → Users(id) 외래키를 추가하며, 사용자 삭제 시 주문도 삭제되게 하라. 빈칸을 채우시오. \nALTER TABLE Orders ADD CONSTRAINT fk_orders_user \nFOREIGN KEY (user_id) REFERENCES Users(id) ON DELETE _____ ;', '3', '1.SET NULL;2.RESTRICT;3.CASCADE;4.NO ACTION', 61),

    (670, 'FILL_BLANK', '다른 객체가 참조 중이어도 강제로 Users의 old_col 컬럼을 삭제. 빈칸을 채우시오. \nALTER TABLE Users DROP COLUMN old_col _____ ;', '1', '1.CASCADE;2.RESTRICT;3.SET NULL;4.-', 61),

    (671, 'FILL_BLANK', 'Orders의 모든 행을 빠르게 지우고, 스키마는 유지하라. 빈칸을 채우시오. \n _____ TABLE Orders;', '1', '1.TRUNCATE;2.DROP;3.DELETE;4.-', 61),

    (672, 'FILL_BLANK', 'Users.email에 유니크 인덱스를 생성하라. 빈칸을 채우시오. \nCREATE _____ INDEX ux_users_email ON Users(email);', '1', '1.UNIQUE;2.PRIMARY;3.FOREIGN;4.-', 61),

    (673, 'FILL_BLANK', 'Products.price가 0보다 커야 한다. 빈칸을 채우시오. \nALTER TABLE Products ADD CONSTRAINT chk_price_pos CHECK (price _____ 0);', '1', '1.>;2.>=;3.<>;4.<', 61),

    (674, 'FILL_BLANK', 'MySQL에서 Users.bio 타입을 VARCHAR(255)로 변경. 빈칸을 채우시오. \nALTER TABLE Users _____ bio VARCHAR(255);', '2', '1.TYPE;2.MODIFY;3.CHANGE;4.ALTER', 61),

    (675, 'FILL_BLANK', 'OldName 테이블을 NewName으로 변경. 빈칸을 채우시오. \nALTER TABLE OldName _____ NewName;', '1', '1.RENAME;2.RENAME TABLE;3.CHANGE TO;4.-', 61),

    (676, 'FILL_BLANK', 'Users 테이블이 존재할 때만 삭제. 빈칸을 채우시오. \nDROP TABLE _____ Users;', '3', '1.RESTRICT;2.CASCADE;3.IF EXISTS;4.NOT NULL', 61);

-- Unit06 - SQL 3-2 (Lesson ID: 62)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (677, 'FILL_BLANK', 'Users(id BIGINT PK AUTO_INCREMENT, email VARCHAR(255) NOT NULL DEFAULT ''guest@example.com'') 스키마가 있을 때, \nemail 값을 생략하고 기본값으로 INSERT 하라. 빈칸을 채우시오. \nINSERT INTO Users(email) VALUES _____ ;', '1', '1.DEFAULT;2.NULL;3.'''';4.NOT NULL', 62),

    (678, 'FILL_BLANK', 'Orders(id PK, user_id BIGINT NOT NULL, FOREIGN KEY (user_id) REFERENCES Users(id)) 스키마가 있을 때, \nFK 위반 없이 주문을 삽입하려면 user_id에 무엇이 들어가야 하는가? 빈칸을 채우시오. \nINSERT INTO Orders(user_id) VALUES _____ ;', '4', '1.NOT NULL;2.NULL;3.음수;4.존재하는 Users.id', 62),

    (679, 'FILL_BLANK', 'Orders(user_id BIGINT _____ , FOREIGN KEY (user_id) REFERENCES Users(id) ON DELETE SET NULL) 스키마가 있을 때, \nSET NULL이 오류 없이 동작하도록 user_id 정의의 빈칸을 채우시오.', '3', '1.UNIQUE;2.NOT NULL;3.NULL;4.-', 62),

    (680, 'FILL_BLANK', 'Orders(user_id FK → Users(id) ON UPDATE CASCADE) 스키마가 있을 때, \n사용자 PK가 100→200으로 바뀔 때 참조도 함께 갱신되게 하라. 빈칸을 채우시오. \nUPDATE Users SET id = _____ WHERE id = 100;', '1', '1.200;2.NULL;3.DEFAULT;4.NOT NULL', 62),

    (681, 'FILL_BLANK', 'Users(email UNIQUE, signups INT NOT NULL DEFAULT 0) 스키마가 있을 때, \n같은 email이면 signups를 +1 하도록 UPSERT 하라. 빈칸을 채우시오. \nINSERT INTO Users(email, signups) \nVALUES(:email, 1) _____ signups = signups + 1;', '1', '1.ON DUPLICATE KEY UPDATE;2.ON CONFLICT DO UPDATE;3.REPLACE;4.-', 62),

    (682, 'FILL_BLANK', 'REPLACE는 키 충돌 시 기존 행을 _____ 한 뒤 새로 INSERT 한다.', '4', '1.SELECT;2.UPDATE;3.LOCK;4.DELETE', 62),

    (683, 'FILL_BLANK', 'Products(id PK, price DECIMAL(10,2), CHECK (price > 0)) 스키마가 있을 때, \n제약을 위반하지 않게 INSERT 하라. 빈칸을 채우시오. \nINSERT INTO Products(price) VALUES _____ ;', '3', '1.-10;2.0;3.10;4.-10.0', 62),

    (684, 'FILL_BLANK', '대량 적재 중 FK 검사를 끄고 다시 켜라. 두 빈칸을 채우시오. \nSET _____ = 0; -- 적재 전 \nSET _____ = 1; -- 적재 후', '1', '1.FOREIGN_KEY_CHECKS;2.UNIQUE_CHECKS;3.SQL_SAFE_UPDATES;4.-', 62),

    (685, 'FILL_BLANK', 'Orders(user_id FK → Users(id) ON DELETE RESTRICT) 스키마가 있을 때, \n사용자 10과 그 주문들을 삭제하라(에러 없이). 빈칸을 채우시오. \nDELETE FROM Orders \nWHERE user_id = :uid; \nDELETE FROM Users \nWHERE id = _____ ;', '1', '1.:uid;2.NULL;3.:order_id;4.-', 62),

    (686, 'FILL_BLANK', 'Users(email VARCHAR(255) NOT NULL DEFAULT ''guest@example.com'') 스키마가 있을 때, \nemail을 기본값으로 되돌리려면? 빈칸을 채우시오. \nUPDATE Users SET email = _____ WHERE id = :id;', '1', '1.DEFAULT(email);2.'''';3.NULL;4.-', 62),

    (687, 'FILL_BLANK', 'Users(id BIGINT PK AUTO_INCREMENT, email UNIQUE) 스키마가 있을 때, \n자동 증가 값을 사용해 삽입하라(모든 환경에서 안전). 빈칸을 채우시오. \nINSERT INTO Users(id, email) \nVALUES( _____ , ''a@b.com'');', '1', '1.DEFAULT;2.NULL;3.0;4.1', 62),

    (688, 'FILL_BLANK', 'Orders(id PK, user_id FK → Users(id)), Users(id PK, email) 스키마가 있을 때, \n스팸 도메인 사용자 주문만 삭제하라. 빈칸을 채우시오. \nDELETE o FROM Orders o _____ Users u ON u.id = o.user_id \nWHERE u.email LIKE ''%@spam.com'';', '3', '1.CROSS JOIN;2.LEFT JOIN;3.INNER JOIN;4.-', 62);

-- Unit06 - SQL 3-3 (Lesson ID: 63)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (689, 'FILL_BLANK', '트랜잭션을 시작하고 변경을 확정할 때, 다음 SQL 문의 빈칸을 채우시오. \nSTART TRANSACTION; \n-- DML … \n_____ ;', '1', '1.COMMIT;2.ROLLBACK;3.SAVEPOINT sp;4.TRANSACTION', 63),

    (690, 'FILL_BLANK', '트랜잭션 내 변경을 모두 취소할 때, 다음 SQL 문의 빈칸을 채우시오. \nSTART TRANSACTION; \n-- DML … \n_____ ;', '2', '1.COMMIT;2.ROLLBACK;3.SAVEPOINT sp;4.TRANSACTION', 63),

    (691, 'FILL_BLANK', '중간 지점으로만 되돌리도록 다음 SQL 문의 빈칸을 채우시오. \nSTART TRANSACTION; \nSAVEPOINT sp1; \n-- DML A … \n_____ sp1; \n-- DML B … \nCOMMIT;', '4', '1.ROLLBACK;2.RELEASE;3.COMMIT TO;4.ROLLBACK TO', 63),

    (692, 'FILL_BLANK', '세이브포인트 sp1을 해제할 때, 다음 SQL 문의 빈칸을 채우시오. \nSTART TRANSACTION; \nSAVEPOINT sp1; \n-- DML … \n_____ SAVEPOINT sp1; \nCOMMIT;', '1', '1.RELEASE;2.ROLLBACK TO;3.DELETE;4.COMMIT TO', 63),

    (693, 'FILL_BLANK', '세션에서 자동 커밋을 끄고 수동으로 제어하려면 다음 SQL 문의 빈칸을 채우시오. \n _____ autocommit = 0;', '3', '1.SHOW;2.ALTER;3.SET;4.TABLE', 63),

    (694, 'FILL_BLANK', '세션 격리수준을 READ COMMITTED로 바꿀 때, 다음 SQL 문의 빈칸을 채우시오. \nSET SESSION TRANSACTION ISOLATION LEVEL _____ ;', '1', '1.READ COMMITTED;2.REPEATABLE READ;3.SERIALIZABLE;4.-', 63),

    (695, 'FILL_BLANK', 'InnoDB에서 일관 스냅샷을 잡아 읽기 트랜잭션을 시작할 때, 다음 SQL 문의 빈칸을 채우시오. \nSTART TRANSACTION _____ ;', '1', '1.WITH CONSISTENT SNAPSHOT;2.READ ONLY;3.FOR UPDATE;4.START TRANSACTION', 63),

    (696, 'FILL_BLANK', 'Accounts(id PK) 스키마가 있을 때, 특정 행을 업데이트 전 선점 잠금으로 읽으려면 다음 SQL 문의 빈칸을 채우시오. \nSELECT * FROM Accounts WHERE id = :id _____ ;', '3', '1.LOCK IN SHARE MODE;2.FOR SHARE;3.FOR UPDATE;4.LOCK', 63),

    (697, 'FILL_BLANK', 'Products(id PK) 스키마가 있을 때, 다른 트랜잭션의 업데이트를 막고 읽기만 허용하는 공유 잠금으로 읽으려면 다음 SQL 문의 빈칸을 채우시오. \nSELECT * FROM Products WHERE id = :id _____ ;', '2', '1.FOR UPDATE;2.FOR SHARE;3.NOWAIT;4.LOCK', 63),

    (698, 'FILL_BLANK', 'CSV를 가장 빠르게 적재하는 표준적인 구문의 빈칸을 채우시오. \n_____ DATA INFILE ''/path/file.csv'' \nINTO TABLE T \nFIELDS TERMINATED BY '','' \nENCLOSED BY ''"'' \nLINES TERMINATED BY ''\\n'' \nIGNORE 1 LINES;', '1', '1.LOAD;2.IMPORT;3.COPY;4.-', 63),

    (699, 'FILL_BLANK', 'T에 UNIQUE 키가 존재할 때, 중복키가 발생하면 해당 행을 건너뛰고 계속 적재하려면 다음 SQL 문의 빈칸을 채우시오. \nLOAD DATA INFILE ''f.csv'' \nINTO TABLE T _____ ;', '4', '1.UPDATE;2.REPLACE;3.UPSERT;4.IGNORE', 63),

    (700, 'FILL_BLANK', '자식 테이블이 FK를 보유할 때, 대량 적재 전후 FK 검사를 제어하고, 하나의 트랜잭션으로 원자적으로 처리하려면 다음 SQL 문의 빈칸을 채우시오. \nSET FOREIGN_KEY_CHECKS = 0; \nSTART TRANSACTION; \n-- LOAD DATA … \nCOMMIT; \nSET FOREIGN_KEY_CHECKS = _____ ;', '2', '1.0;2.1;3.DEFAULT;4.UNIQUE', 63);

-- Chapter 6: 보안
-- Unit 1 - Lesson 1: 입력 검증 & 신뢰 경계 Concept (Lesson ID: 64)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (701, 'SELECT_DESCRIPTION', '다음 중 ''입력 검증''의 주된 목적을 가장 정확히 설명한 것은?', '2', '1.들어온 값을 자동 보정해 최대한 통과시킨다;2.규정된 형식·범위·타입을 만족하지 않으면 거부한다;3.출력 시 특수문자를 치환한다;4.암호화로 기밀성을 보장한다', 64),

    (702, 'SELECT_DESCRIPTION', '신뢰 경계(Trust Boundary)에 대한 설명으로 가장 적절한 것은?', '2', '1.동일 프로세스 내부 함수 간 호출 지점이다;2.데이터가 서로 다른 보안 영역을 넘어가는 지점이다;3.코드 리뷰가 필요한 라인이다;4.암호화를 수행하는 위치이다', 64),

    (703, 'FILL_BLANK', '데이터를 컴퓨터가 이해할 수 있는 바이너리 형식으로 변환하는 것을 _____라고 하며 XSS 방어의 기본이다.', '인코딩', '-', 64),

    (704, 'SELECT_DESCRIPTION', '입력 검증보다 ''출력 인코딩''이 핵심이 되는 상황은?', '3', '1.숫자 범위 체크;2.파일 크기 제한;3.사용자 이름을 HTML에 출력;4.비밀번호 길이 검사', 64),

    (705, 'FILL_BLANK', '허용 가능한 값의 집합만 통과시키는 검증 방식을 _____라고 한다.', '허용목록', '-', 64),

    (706, 'SELECT_DESCRIPTION', '다음 중 ''싱크(sink)''에 해당하는 예시는?', '2', '1.입력 폼 placeholder;2.문자열을 SQL 쿼리에 이어붙여 실행;3.디버그 로그에 값 출력;4.toUpperCase 변환', 64),

    (707, 'FILL_BLANK', 'SQL·HTML·셸은 서로 다른 _____에 속하므로 동일한 필터로 모두를 방어할 수 없다.', '컨텍스트', '-', 64),

    (708, 'SELECT_DESCRIPTION', '신뢰 경계 관점에서 일반적으로 가장 위험한 입력 소스는?', '3', '1.서버 상수;2.내부 구성 파일;3.사용자가 제어하는 HTTP 헤더/바디;4.컴파일 타임 상수', 64);

-- Unit 1 - Lesson 2: 입력 검증 & 신뢰 경계 Exploit (Lesson ID: 65)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (709, 'SELECT_DESCRIPTION', '입력 검증이 부재한 경우 발생 가능한 일로 가장 적절한 것은?', '3', '1.CPU 온도 상승;2.UI 글꼴 붕괴;3.SQL/OS/스크립트 인젝션 발생;4.자동 백업 실패', 65),

    (710, 'FILL_BLANK', '사용자 제공 파일 경로를 이용해 상위 디렉터리로 이동하는 공격을 _____라고 한다.', '디렉터리트래버설', '-', 65),

    (711, 'SELECT_DESCRIPTION', '다중 컨텍스트를 악용해 필터를 우회하는 사례는?', '2', '1.정수 범위 초과;2.JSON 안의 HTML 안의 스크립트 삽입;3.잘못된 시간대 파싱;4.큰 이미지 로딩 지연', 65),

    (712, 'FILL_BLANK', '여러 컨텍스트가 얽힌 입력 문제를 줄이려면 우선 각 _____를 구분해 처리해야 한다.', '컨텍스트', '-', 65),

    (713, 'SELECT_DESCRIPTION', '공격자가 가장 자주 악용하는 전송 요소는?', '1', '1.HTTP 헤더/바디;2.서버 환경변수;3.컴파일 옵션;4.타임존', 65),

    (714, 'FILL_BLANK', '공격 표면을 줄이는 기본 수단 중 하나는 입력 길이 _____이다.', '제한', '-', 65),

    (715, 'SELECT_DESCRIPTION', '입력값이 로깅만 되고 실행 경로에 들어가지 않도록 해야 하는 이유는?', '3', '1.디스크 사용량 증가;2.개인정보 보호법 위반;3.로그 주입/탈출 위험 차단;4.성능 저하', 65),

    (716, 'SELECT_DESCRIPTION', '확장자·MIME·매직넘버를 교차 검증하지 않으면 어떤 취약점이 발생하기 쉬운가?', '2', '1.중간자 공격;2.형식우회(포맷 스푸핑);3.세션 고정;4.클릭재킹', 65);

-- Unit 1 - Lesson 3: 입력 검증 & 신뢰 경계 Exploit (Lesson ID: 66)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (717, 'SELECT_DESCRIPTION', '서버 측 검증과 클라이언트 측 검증의 관계로 가장 적절한 것은?', '2', '1.클라이언트 검증만 있으면 충분하다;2.서버 검증이 필수이고, 클라이언트는 사용자 편의용 보조다;3.서버 검증은 성능 저하로 지양한다;4.둘 다 불필요하다', 66),

    (718, 'FILL_BLANK', '국가 코드 입력에는 ^[A-Z]{2}$ 같은 _____ 기반 검증이 적절하다.', '정규식', '-', 66),

    (719, 'SELECT_DESCRIPTION', '출력 인코딩을 적용해야 할 시점으로 가장 적절한 것은?', '3', '1.DB 저장 직전;2.네트워크 송신 직전;3.렌더링 대상 컨텍스트에 출력하기 직전;4.사용자가 입력할 때', 66),

    (720, 'FILL_BLANK', '파일 업로드 보안에서는 Content-Type과 파일 _____(예: 매직넘버)을 교차 검증해야 한다.', '시그니처', '-', 66),

    (721, 'SELECT_DESCRIPTION', '숫자 ID를 입력받는 엔드포인트의 안전한 처리로 가장 적절한 것은?', '3', '1.정규식으로 숫자인지만 확인;2.클라이언트에서 버튼 숨김;3.서버에서 소유권/권한을 함께 검증;4.프론트에서만 필터링', 66),

    (722, 'FILL_BLANK', '위험한 함수 호출 전 유해 문자를 제거·치환하여 안전하게 만드는 과정을 _____라고 한다.', '세니타이즈', '-', 66),

    (723, 'SELECT_DESCRIPTION', 'JSON API에서 Mass Assignment 취약점을 막기 위한 입력 검증 전략으로 가장 적절한 것은?', '2', '1.민감 필드만 블랙리스트로 차단한다;2.서버에서 DTO/스키마에 명시된 필드만 허용(allowlist)하고 나머지는 거부한다;3.민감 필드는 프런트엔드에서 숨긴다;4.허용되지 않은 필드는 로그만 남기고 그대로 처리한다', 66),

    (724, 'FILL_BLANK', '로그에는 민감정보를 남기지 말고 _____ 처리를 적용해야 한다.', '마스킹', '-', 66);

-- Unit 2 - Lesson 4: Broken Access Control Concept (Lesson ID: 67)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (725, 'FILL_BLANK', '사용자가 애플리케이션에 제공하는 입력값을 통해 시스템의 객체(파일, 데이터베이스 레코드 등)에 직접 접근할 때, 권한이 없는 사용자도 해당 객체에 접근할 수 있게 되는 취약점을 _____라고 한다.', 'idor', '-', 67),

    (726, 'SELECT_DESCRIPTION', '기능 수준 권한 실패에 대한 설명으로 가장 적절한 것은?', '2', '1.다른 테넌트 데이터가 섞이는 문제;2.관리자 기능이 일반 사용자에게 노출되는 문제;3.로그인 실패 시 메시지 노출;4.비밀번호 재사용 문제', 67),

    (727, 'FILL_BLANK', '클라이언트에서 버튼을 숨기는 것만으로 권한을 통제하는 것은 ''_____''에 의한 보안으로 취약하다.', '은폐', '-', 67),

    (728, 'SELECT_DESCRIPTION', '/api/admin/delete?id=1 이 인증만 확인하고 인가를 확인하지 않는 경우의 문제는?', '2', '1.인증 우회;2.권한 상승/기능 수준 접근제어 실패;3.XSS;4.세션 고정', 67),

    (729, 'FILL_BLANK', '권한 확인은 항상 _____ 측에서 수행되어야 하며, 클라이언트 검증은 보조 수단이다.', '서버', '-', 67),

    (730, 'SELECT_DESCRIPTION', '다음 중 객체 수준 권한 검증이 핵심인 사례는?', '1', '1.GET /api/invoices/123;2.POST /api/admin/users;3.POST /api/auth/login;4.GET /api/metrics', 67),

    (731, 'FILL_BLANK', '다중 테넌트 시스템에서는 모든 조회·변경에 _____ ID 바인딩을 강제해야 한다.', '테넌트', '-', 67),

    (732, 'SELECT_DESCRIPTION', '객체 수준과 기능 수준 권한의 차이에 대한 설명으로 옳은 것은?', '2', '1.둘은 동일하다;2.객체는 데이터 레코드, 기능은 엔드포인트/행동;3.객체는 UI, 기능은 DB;4.객체는 캐시, 기능은 CDN', 67);

-- Unit 2 - Lesson 5: Broken Access Control Exploit (Lesson ID: 68)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (733, 'SELECT_DESCRIPTION', 'IDOR 공격의 전형적 절차로 가장 적절한 것은?', '2', '1.암호 추측→브루트포스;2.리소스 식별자 예측/변경→응답 비교→소유권 우회;3.이미지 업로드→용량 초과;4.쿠키 삭제→로그아웃', 68),

    (734, 'FILL_BLANK', '1001, 1002처럼 예측 가능한 연속 번호를 _____ 식별자라고 하며 IDOR 위험을 키운다.', '순차', '-', 68),

    (735, 'SELECT_DESCRIPTION', '객체 수준 권한 실패의 영향이 특히 큰 메서드는?', '2', '1.GET;2.PUT/DELETE;3.OPTIONS;4.HEAD', 68),

    (736, 'FILL_BLANK', '권한 상승 테스트에서는 ''일반 사용자 → _____ 사용자''로의 기능 접근 시도가 핵심이다.', '관리자', '-', 68),

    (737, 'SELECT_DESCRIPTION', '다중 테넌트 시스템에서 가장 먼저 확인해야 할 취약 지점은?', '2', '1.환경 변수 이름;2.테넌트 ID 바인딩 누락;3.로고 파일 크기;4.CDN 캐시 만료', 68),

    (738, 'FILL_BLANK', '클라이언트가 전송한 role, isAdmin 같은 필드는 _____ 대상이 아니므로 신뢰하면 안 된다.', '권위', '-', 68),

    (739, 'SELECT_DESCRIPTION', '리소스 URL의 예측 가능성을 낮추는 좋은 방법은?', '2', '1.숫자 증가 ID;2.UUID v4;3.해시 없는 슬러그;4.연속 문자열', 68),

    (740, 'FILL_BLANK', '중요 기능은 _____ 경로나 전용 서브도메인으로 분리해 네트워크 정책을 분리한다.', '관리', '-', 68);

-- Unit 2 - Lesson 6: Broken Access Control Exploit (Lesson ID: 69)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (741, 'SELECT_DESCRIPTION', '리소스 소유권 검증에 반드시 필요한 정보는?', '3', '1.사용자 선호 언어;2.로그인 시간대;3.주체ID와 리소스 소유자 매핑;4.브라우저 종류', 69),

    (742, 'FILL_BLANK', '엔드포인트 보호는 allowlist 기반 _____ 정책으로 구현하는 것이 기본이다.', '인가', '-', 69),

    (743, 'SELECT_DESCRIPTION', '순차 ID 대신 불투명 식별자(예: UUID v4)를 쓰는 주요 이점은?', '2', '1.저장공간 절약;2.예측 가능성 감소로 IDOR 위험 완화;3.네트워크 단절;4.캐시 무효화', 69),

    (744, 'FILL_BLANK', '권한 검사 실패 시 돌려줄 HTTP 상태 코드는 보안상 _____가 적절하다.', '403', '-', 69),

    (745, 'SELECT_DESCRIPTION', '권한 정책 설계로 가장 적절한 것은?', '2', '1.모든 사용자에게 모든 엔드포인트 허용;2.RBAC/ABAC로 최소권한 적용;3.UI에서만 버튼 숨김;4.로그 레벨만 높임', 69),

    (746, 'FILL_BLANK', '감사 가능성을 높이기 위해 접근 거부 이벤트에는 사용자ID와 _____를 함께 로그로 남긴다.', '요청id', '-', 69),

    (747, 'SELECT_DESCRIPTION', '다중 테넌트에서 { "role": "admin" }가 온 요청을 안전하게 처리하는 방법은?', '3', '1.본문 role 신뢰;2.JWT role만 확인;3.서명·클레임 검증 후 서버측 권한·테넌트 소유 검증;4.프런트 버튼만 숨김', 69),

    (748, 'FILL_BLANK', 'URL·바디·헤더 어디에 있든 _____ 기반으로 권한을 평가해야 일관성이 보장된다.', '주체', '-', 69);

-- Unit 3 - Lesson 7: Authentication & Session Concept (Lesson ID: 70)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (749, 'FILL_BLANK', '인증(Authentication)은 ''누구인가''를 확인하는 절차이며, 인가(Authorization)는 _____을 결정하는 절차다.', '권한', '-', 70),

    (750, 'SELECT_DESCRIPTION', '다음 중 인증 요소로 분류되지 않는 것은?', '4', '1.소지(토큰/기기);2.지식(비밀번호/PIN);3.생체(지문/얼굴);4.화면 해상도', 70),

    (751, 'FILL_BLANK', '세션 고정(Session Fixation)은 공격자가 미리 _____ 값을 정해두고 피해자가 그 값으로 로그인하게 만드는 공격이다.', '세션id, 세션아이디, sessionid', '-', 70),

    (752, 'SELECT_DESCRIPTION', '비밀번호 저장의 올바른 설명은?', '3', '1.단순 SHA-256 해시;2.솔트 없이 MD5;3.솔트+워크팩터 있는 해시 사용;4.평문 암호화 저장', 70),

    (753, 'FILL_BLANK', '쿠키 기반 세션 보호를 위해서는 HttpOnly, Secure, _____ 속성을 적절히 설정해야 한다.', 'samesite', '-', 70),

    (754, 'SELECT_DESCRIPTION', 'JWT의 ''서명'' 목적은?', '2', '1.기밀성 제공;2.무결성/진위 확인;3.압축;4.세션 무효화', 70),

    (755, 'FILL_BLANK', 'TOTP는 _____ 기반 일회용 비밀번호 방식이다.', '시간', '-', 70),

    (756, 'SELECT_DESCRIPTION', '세션 타임아웃 설정의 주요 목적은?', '3', '1.UX 향상;2.리소스 절약;3.장기 미사용 세션 위험 감소;4.로그 축소', 70);

-- Unit 3 - Lesson 8: Authentication & Session Exploit (Lesson ID: 71)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (757, 'SELECT_DESCRIPTION', '인증 우회 시 흔히 시도되지 않는 것은?', '4', '1.약한 비밀번호 정책 악용;2.계정 잠금 우회;3.세션 만료 강제;4.UI 테마 변경', 71),

    (758, 'FILL_BLANK', '로그인 시도 무차별 대입에 대응하지 않으면 _____ 공격(credential stuffing)에 취약해진다.', '브루트포스', '-', 71),

    (759, 'SELECT_DESCRIPTION', '세션 탈취의 전제조건으로 보기 어려운 것은?', '4', '1.세션 ID 노출;2.전송 구간 평문;3.XSS 등 실행 컨텍스트;4.정적 파일 압축', 71),

    (760, 'FILL_BLANK', '동일 브라우저 내 스크립트가 쿠키를 읽지 못하게 하려면 쿠키에 _____ 속성을 설정해야 한다.', 'httponly', '-', 71),

    (761, 'SELECT_DESCRIPTION', 'MFA 구성에서 보안성이 가장 높은 조합은?', '3', '1.비밀번호+메일 링크;2.비밀번호+SMS;3.비밀번호+TOTP/하드웨어 키;4.비밀번호만', 71),

    (762, 'FILL_BLANK', '패스워드 재사용 방지를 위해 금지 목록과 최소 _____ 정책이 권장된다.', '길이', '-', 71),

    (763, 'SELECT_DESCRIPTION', '세션 하이재킹과 거리가 먼 시나리오는?', '3', '1.공용 PC 자동 로그인;2.피싱 통한 토큰 탈취;3.CSS 스프라이트 깨짐;4.XSS로 세션 읽기', 71),

    (764, 'FILL_BLANK', '계정 탈취 시도 탐지를 위해 실패 로그인 횟수와 _____ 주소를 함께 모니터링한다.', 'ip', '-', 71);

-- Unit 3 - Lesson 9: Authentication & Session Exploit (Lesson ID: 72)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (765, 'SELECT_DESCRIPTION', '세션 관리 베스트 프랙티스가 아닌 것은?', '3', '1.로그인 직후 세션 ID 재발급;2.로그아웃 시 세션 무효화;3.장기 미활동에도 세션 유지;4.민감 요청 시 재인증', 72),

    (766, 'FILL_BLANK', '로그인 실패 횟수 제한, 지연 삽입 등은 _____ 방어 기법에 해당한다.', '브루트포스', '-', 72),

    (767, 'SELECT_DESCRIPTION', '비밀번호 정책으로 가장 적절한 것은?', '2', '1.복잡도만 높이고 길이는 6자;2.길이 우선 정책과 금지 목록;3.30일마다 강제 변경;4.특수문자 3개 필수', 72),

    (768, 'FILL_BLANK', 'HOTP는 _____ 기반 일회용 비밀번호 방식으로, 서버와 클라이언트의 카운터가 증가할 때마다 코드가 생성된다.', '카운터', '-', 72),

    (769, 'SELECT_DESCRIPTION', '쿠키 SameSite 값 설명으로 가장 맞는 것은?', '2', '1.None은 완전 차단;2.Lax는 대부분의 내비게이션에 쿠키 전송 제한;3.Strict는 크로스사이트 요청에도 전송;4.None은 HTTPS 불필요', 72),

    (770, 'FILL_BLANK', '비밀번호 재설정 링크는 충분히 무작위이며 만료가 짧은 _____ 토큰이어야 한다.', '일회용', '-', 72),

    (771, 'SELECT_DESCRIPTION', '세션 고정 방어의 핵심은?', '2', '1.로그인 전 세션 유지;2.로그인 직후 세션 ID 재발급;3.쿠키 삭제 금지;4.토큰 로컬 저장', 72),

    (772, 'FILL_BLANK', '민감한 상태 변경 요청에는 MFA나 _____ 확인(재인증)을 요구한다.', '본인', '-', 72);

-- Unit 4 - Lesson 10: SQL Injection Concept (Lesson ID: 73)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (773, 'FILL_BLANK', 'SQL 인젝션의 핵심 원인은 값과 _____ 구조의 분리가 이뤄지지 않는 데 있다.', '쿼리', '-', 73),

    (774, 'SELECT_DESCRIPTION', '다음 중 SQLi 유형 설명으로 적절하지 않은 것은?', '4', '1.Boolean 기반;2.시간 기반;3.UNION 기반;4.네이티브 앱이면 안전', 73),

    (775, 'FILL_BLANK', '입력 데이터를 쿼리 파라미터로 바인딩하는 ''_____''가 기본 방어다.', '프리페어드', '-', 73),

    (776, 'SELECT_DESCRIPTION', '최소 권한 원칙으로 올바른 것은?', '2', '1.DB 소유자 권한 사용;2.읽기 전용 작업은 읽기 계정만 사용;3.모든 권한 부여 후 감시;4.루트 계정 통합', 73),

    (777, 'FILL_BLANK', 'ORM을 사용하더라도 _____ 쿼리(문자열 이어붙이기)는 지양해야 한다.', '동적', '-', 73),

    (778, 'SELECT_DESCRIPTION', '에러 메시지 노출의 위험은?', '2', '1.UX 향상;2.정보 노출;3.캐시 증가;4.정렬 개선', 73),

    (779, 'FILL_BLANK', '바인딩되지 않은 입력은 _____절의 논리를 임의로 바꿀 수 있다.', 'where', '-', 73),

    (780, 'SELECT_DESCRIPTION', '검색 API에서 안전한 방법은?', '2', '1.문자열로 WHERE 조립;2.바인딩 변수와 허용 컬럼 리스트;3.클라이언트만 필터;4.관리자만 접근', 73),

    -- Unit 4 - Lesson 11: SQL Injection Exploit (Lesson ID: 74)
    (781, 'SELECT_DESCRIPTION', 'SQLi 탐지와 관련 없는 신호는?', '3', '1.예외 메시지 노출;2.비정상적 응답 지연;3.정적 파일 캐시 적중 증가;4.결과 행 수 급변', 74),

    (782, 'FILL_BLANK', '데이터베이스 에러 메시지 과다 노출은 _____을 유발하여 공격 난이도를 낮춘다.', '정보노출', '-', 74),

    (783, 'SELECT_DESCRIPTION', '검색 조건에 사용자 입력을 직접 이어붙이는 패턴의 위험은?', '3', '1.인덱스 미사용;2.문자열 정렬 오류;3.논리 조작 통한 조건 우회;4.캐시 미스', 74),

    (784, 'FILL_BLANK', 'SQLi는 입력 검증만으로 충분하지 않으며 반드시 _____화가 필요하다.', '매개변수', '-', 74),

    (785, 'SELECT_DESCRIPTION', '스토어드 프로시저가 항상 안전하지 않은 이유는?', '2', '1.느림;2.내부에서 동적 쿼리 문자열을 만들 수 있음;3.트랜잭션 불가;4.인덱스 없음', 74),

    (786, 'FILL_BLANK', 'Blind SQLi에서는 응답 지연을 유발하는 _____ 기반 기법이 사용된다.', '시간', '-', 74),

    (787, 'SELECT_DESCRIPTION', 'UNION 기반 공격의 전제조건은?', '1', '1.컬럼 수와 타입 일치;2.관리자 권한;3.트랜잭션 사용;4.뷰 존재', 74),

    (788, 'FILL_BLANK', '주입 지점 식별에는 특수문자 주입과 응답 _____ 비교가 유용하다.', '차이', '-', 74);

-- Unit 4 - Lesson 12: SQL Injection Exploit (Lesson ID: 75)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (789, 'SELECT_DESCRIPTION', '입력 검증의 목적은?', '2', '1.모든 공격 차단;2.형식 제약으로 의도치 않은 입력 감소;3.DB 성능 튜닝;4.캐시 최적화', 75),

    (790, 'FILL_BLANK', 'DB 계정은 기능별로 분리하고 필요 최소 권한만 부여하는 _____ 원칙을 따른다.', '최소권한', '-', 75),

    (791, 'SELECT_DESCRIPTION', '로깅 시 주의사항으로 맞지 않는 것은?', '3', '1.민감정보 마스킹;2.실패 쿼리 패턴 기록;3.평문 비밀번호 저장;4.의심 IP/요청ID 기록', 75),

    (792, 'FILL_BLANK', '에러 응답은 내부 정보를 숨기는 _____ 메시지로 변환해 제공해야 한다.', '일반', '-', 75),

    (793, 'SELECT_DESCRIPTION', '쿼리 안전성 검증에 도움이 되는 것은?', '1', '1.정적 분석/리뷰;2.이미지 최적화;3.CDN 추가;4.폰트 서브셋', 75),

    (794, 'FILL_BLANK', '애플리케이션은 DB 루트 대신 제한된 _____ 계정을 사용해야 한다.', 'role', '-', 75),

    (795, 'SELECT_DESCRIPTION', '입력값 화이트리스트의 장점은?', '2', '1.우회 패턴에 취약;2.정의된 값만 허용;3.모든 값 허용;4.가독성 저하', 75),

    (796, 'SELECT_DESCRIPTION', 'Prepared Statement의 플레이스홀더에 바인딩할 수 있는 것은?', '1', '1.데이터 값(리터럴);2.테이블 이름;3.컬럼 이름;4.SQL 키워드(ORDER BY)', 75);

-- Unit 5 - Lesson 13: XSS Concept (Lesson ID: 76)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (797, 'FILL_BLANK', 'XSS는 신뢰되지 않은 입력이 브라우저에서 _____로 실행되는 문제를 의미한다.', '스크립트', '-', 76),

    (798, 'SELECT_DESCRIPTION', 'Stored XSS의 특징은?', '2', '1.응답에 즉시 반사;2.서버에 저장되어 다수에게 전파;3.DOM 조작 없이 발생;4.CSP와 무관', 76),

    (799, 'FILL_BLANK', '출력 컨텍스트에 맞는 _____(HTML/속성/URL/JS)이 XSS 방어의 기본이다.', '인코딩', '-', 76),

    (800, 'SELECT_DESCRIPTION', 'DOM XSS 설명으로 맞는 것은?', '2', '1.서버 템플릿에서만 발생;2.클라이언트 JS가 위험한 싱크에 값을 주입;3.DB 저장 필수;4.쿠키 설정과만 관련', 76),

    (801, 'FILL_BLANK', '스크립트 출처를 통제하는 보안 헤더는 _____이다.', 'csp', '-', 76),

    (802, 'SELECT_DESCRIPTION', 'Reflected XSS의 일반적 특징은?', '2', '1.지속성;2.즉시 반사;3.서버 저장 필요;4.오프라인만', 76),

    (803, 'FILL_BLANK', '속성 값 컨텍스트에는 _____ 인코딩을 적용해야 한다.', '속성', '-', 76),

    (804, 'SELECT_DESCRIPTION', 'URL 컨텍스트에서 안전하지 않은 것은?', '3', '1.encodeURIComponent 사용;2.URL 스킴 화이트리스트;3.문자열 연결로 href 생성;4.안전 템플릿', 76);

-- Unit 5 - Lesson 14: XSS Exploit (Lesson ID: 77)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (805, 'SELECT_DESCRIPTION', 'XSS 악용과 직접 관련이 적은 것은?', '3', '1.세션 탈취;2.DOM 조작;3.클릭재킹;4.키로깅', 77),

    (806, 'FILL_BLANK', 'DOM XSS는 신뢰되지 않은 데이터를 위험한 _____(예: innerHTML)에 주입할 때 발생한다.', '싱크', '-', 77),

    (807, 'SELECT_DESCRIPTION', 'Stored XSS 탐지에 도움 되는 것은?', '2', '1.입력 즉시 응답만 확인;2.저장 후 다양한 뷰 경로 확인;3.정적 파일 해시;4.폰트 캐시', 77),

    (808, 'FILL_BLANK', 'URL 생성 시 프로토콜을 제한하는 것은 _____ 방어에 해당한다.', '스킴화이트리스트', '-', 77),

    (809, 'SELECT_DESCRIPTION', '이벤트 핸들러 속성에 직접 문자열을 바인딩하는 패턴은?', '3', '1.안전;2.경고;3.위험;4.무관', 77),

    (810, 'FILL_BLANK', '템플릿 자동 이스케이프를 끄면 기본 _____ 방어가 해제된다.', 'xss', '-', 77),

    (811, 'SELECT_DESCRIPTION', '쿠키 탈취를 방지하기 위한 설정은?', '2', '1.SameSite=None만;2.HttpOnly;3.도메인 제거;4.Max-Age=0', 77),

    (812, 'FILL_BLANK', '마크다운/HTML 입력 허용 시 일부 태그/속성만 허용하는 _____ 파서가 권장된다.', '화이트리스트', '-', 77);

-- Unit 5 - Lesson 15: XSS Exploit (Lesson ID: 78)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (813, 'SELECT_DESCRIPTION', '프레임워크 템플릿의 자동 이스케이프를 끄면 안 되는 이유는?', '3', '1.성능 저하;2.다국어 미지원;3.기본 XSS 방어 해제;4.CSS 오류', 78),

    (814, 'FILL_BLANK', '스크립트 인라인을 제한하려면 CSP의 _____-src 지시자를 사용한다.', 'script', '-', 78),

    (815, 'SELECT_DESCRIPTION', '안전한 DOM 조작은?', '2', '1.innerHTML 삽입;2.텍스트 노드로 삽입;3.document.write 사용;4.이벤트 핸들러 문자열', 78),

    (816, 'FILL_BLANK', '사용자 생성 콘텐츠를 보여줄 때는 허용 태그 _____를 따르는 파서를 사용한다.', '화이트리스트', '-', 78),

    (817, 'SELECT_DESCRIPTION', 'URL 컨텍스트 안전화를 위한 필수는?', '1', '1.encodeURIComponent 사용;2.decodeURI 사용;3.문자열 연결;4.raw HTML', 78),

    (818, 'FILL_BLANK', 'HTML 텍스트를 그대로 출력할 때는 _____ API(createTextNode 등)를 사용한다.', '텍스트', '-', 78),

    (819, 'SELECT_DESCRIPTION', 'CSP에서 외부 스크립트 출처를 통제하는 것은?', '2', '1.style-src;2.script-src;3.img-src;4.connect-src', 78),

    (820, 'FILL_BLANK', 'DOM XSS를 유발하는 위험한 속성의 대표 예는 _____이다.', 'innerhtml', '-', 78);

-- Unit 6 - Lesson 16: CSRF Concept (Lesson ID: 79)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES
    (821, 'FILL_BLANK', 'CSRF는 사용자의 _____를 악용해 원치 않는 상태 변경 요청을 타 사이트에서 발생시키는 공격이다.', '인증', '-', 79),

    (822, 'SELECT_DESCRIPTION', 'CSRF가 특히 문제 되는 요청 유형은?', '2', '1.GET 정적 리소스;2.상태 변이 POST/PUT/DELETE;3.OPTIONS;4.HEAD', 79),

    (823, 'FILL_BLANK', '_____ 토큰은 폼/요청마다 포함되어 서버에서 검증되는 CSRF 방어 기법이다.', 'csrf', '-', 79),

    (824, 'SELECT_DESCRIPTION', 'SameSite=Lax의 설명으로 맞는 것은?', '2', '1.모든 크로스사이트 요청에 쿠키 전송;2.대부분의 내비게이션 요청에서 쿠키 미전송;3.모든 요청 차단;4.HTTPS 미요구', 79),

    (825, 'FILL_BLANK', '토큰 검증 외에 _____/Origin 헤더 확인은 보조적 방어 수단이 된다.', 'referer', '-', 79),

    (826, 'SELECT_DESCRIPTION', '더블 서브밋 쿠키 패턴의 핵심은?', '2', '1.토큰을 서버 저장;2.쿠키와 요청 내부 토큰 비교;3.헤더만 검사;4.로컬스토리지 저장', 79),

    (827, 'FILL_BLANK', '중요 요청은 GET이 아닌 _____ 메서드로 처리해야 한다.', '상태변이', '-', 79),

    (828, 'SELECT_DESCRIPTION', 'SPA에서 CSRF 방어로 적절한 것은?', '2', '1.토큰을 로컬스토리지;2.쿠키+서버 검증 토큰 조합;3.프론트만 체크;4.GET으로 변경', 79);

-- Unit 6 - Lesson 17: CSRF Exploit (Lesson ID: 80)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (829, 'SELECT_DESCRIPTION', 'CSRF 성공의 전제조건이 아닌 것은?', '4', '1.피해자 로그인 상태;2.쿠키 자동 전송;3.토큰/검증 부재;4.이미지 최적화 실패', 80),

    (830, 'FILL_BLANK', 'CSRF는 브라우저가 크로스사이트 요청에도 자동으로 _____를 첨부하는 성질을 악용한다.', '쿠키', '-', 80),

    (831, 'SELECT_DESCRIPTION', '읽기 전용 GET 요청에 CSRF가 덜 치명적인 이유는?', '2', '1.캐시됨;2.상태 변경이 없어야 함이 원칙;3.HTTPS면 안전;4.이미지라서', 80),

    (832, 'FILL_BLANK', '폼 제출 외에도 스크립트 없는 HTML 요소로 요청을 유발할 수 있어 _____이 필요하다.', '서버검증', '-', 80),

    (833, 'SELECT_DESCRIPTION', 'CSRF 취약 가능성이 높은 설계는?', '4', '1.상태 변경에 토큰 요구;2.SameSite=Lax 사용;3.Referer/Origin 확인;4.중요 요청을 GET으로 처리', 80),

    (834, 'FILL_BLANK', '쿠키 SameSite=None 사용 시 반드시 _____ 속성을 요구해야 한다.', 'secure', '-', 80),

    (835, 'SELECT_DESCRIPTION', 'OAuth 리디렉트 기반 CSRF 완화책은?', '1', '1.state 파라미터 검증;2.scope 줄이기;3.로깅만;4.HTTP 사용', 80),

    (836, 'FILL_BLANK', '토큰은 충분히 _____하고 예측 불가능해야 한다.', '무작위', '-', 80);

-- Unit 6 - Lesson 18: CSRF Exploit (Lesson ID: 81)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (837, 'SELECT_DESCRIPTION', '토큰 기반 방어에서 필수가 아닌 항목은?', '4', '1.토큰 무작위성;2.세션/사용자에 고유;3.서버 측 검증;4.클라이언트만 체크', 81),

    (838, 'FILL_BLANK', '더블 서브밋은 쿠키 값과 요청 내 토큰 값을 _____하는 방식이다.', '비교', '-', 81),

    (839, 'SELECT_DESCRIPTION', 'API에서 CSRF 영향이 낮아지는 경우는?', '2', '1.쿠키 인증;2.헤더 기반 토큰 인증;3.폼 인증;4.자동 로그인', 81),

    (840, 'FILL_BLANK', '민감 요청에는 토큰 외에 _____을 요구할 수 있다.', '재인증', '-', 81),

    (841, 'SELECT_DESCRIPTION', 'SameSite=None의 필수 전제는?', '2', '1.HTTP 허용;2.HTTPS 전용;3.도메인 미설정;4.만료 연장', 81),

    (842, 'FILL_BLANK', '토큰 탈취를 줄이기 위해 토큰 _____/회전을 적용한다.', '폐기', '-', 81),

    (843, 'SELECT_DESCRIPTION', 'SSR 애플리케이션에서 토큰 삽입의 안전한 위치는?', '2', '1.URL 쿼리;2.숨김 폼 필드;3.쿠키 없는 로컬스토리지;4.이미지 alt', 81),

    (844, 'FILL_BLANK', '참조자 검사 실패 시 요청을 _____하는 로직을 포함한다.', '거부', '-', 81);

-- Unit 7 - Lesson 19: File Upload Concept (Lesson ID: 82)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (845, 'FILL_BLANK', '업로드 처리의 핵심 위험은 경로 조작, 콘텐츠 _____ 속이기, 실행 가능 파일 저장 등이다.', '타입', '-', 82),

    (846, 'SELECT_DESCRIPTION', '안전한 업로드 설계는?', '2', '1.확장자만 검사;2.MIME/매직넘버/확장자 교차검증;3.클라이언트 검사만;4.웹루트에 저장', 82),

    (847, 'FILL_BLANK', '파일 이름은 사용자 입력 대신 _____ 파일명으로 바꿔 충돌과 추측을 방지한다.', '무작위', '-', 82),

    (848, 'SELECT_DESCRIPTION', '이미지 처리 시 권장되는 것은?', '2', '1.원본 그대로 보관;2.서버 재인코딩/메타데이터 제거;3.EXIF 유지;4.클라 리사이즈만', 82),

    (849, 'FILL_BLANK', '업로드 파일은 실행 가능 경로가 아닌 _____ 외부 저장소에 보관한다.', '웹루트', '-', 82),

    (850, 'SELECT_DESCRIPTION', '경로 조작과 직접 관련이 적은 것은?', '4', '1.상위 디렉터리 참조;2.심볼릭 링크 오용;3.파일 이름 정규화 부재;4.이미지 압축률', 82),

    (851, 'FILL_BLANK', 'Content-Type을 속여 전송하면 서버의 _____만 믿는 경우 위험하다.', '헤더', '-', 82),

    (852, 'SELECT_DESCRIPTION', '확장자 우회에 취약한 경우는?', '2', '1.화이트리스트;2.블랙리스트로 금지 확장자만 차단;3.서버 재인코딩;4.저장소 격리', 82);

-- Unit 7 - Lesson 20: File Upload Exploit (Lesson ID: 83)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (853, 'SELECT_DESCRIPTION', '파일 업로드 후 바로 공개하지 말아야 하는 이유는?', '2', '1.성능 저하;2.승인/검증 전 노출 위험;3.UX 악화;4.CDN 비용 증가', 83),

    (854, 'FILL_BLANK', '업로드 후 바로 공개하지 말고 백엔드에서 _____를 거쳐 안전한 링크만 노출한다.', '승인', '-', 83),

    (855, 'SELECT_DESCRIPTION', '이미지 처리 라이브러리 취약점을 줄이는 방법은?', '2', '1.외부 입력 신뢰;2.최신 버전 유지/자원 제한;3.루트 권한 실행;4.로그 비활성화', 83),

    (856, 'FILL_BLANK', '파일 이름 정규화(normalization)로 _____를 제거해 예상 경로만 허용한다.', '상위참조', '-', 83),

    (857, 'SELECT_DESCRIPTION', '공개 URL 발급 방식으로 안전한 것은?', '2', '1.무기한 공개;2.서명된 URL/만료 시간;3.디렉터리 인덱싱;4.링크 추측 허용', 83),

    (858, 'FILL_BLANK', '콘텐츠 타입 검증 시 헤더뿐 아니라 파일 _____(매직 넘버)를 확인한다.', '시그니처', '-', 83),

    (859, 'SELECT_DESCRIPTION', '업로드 디렉토리에 실행 권한 부여의 위험은?', '2', '1.없음;2.임의 코드 실행;3.캐시 미스;4.색인 실패', 83),

    (860, 'FILL_BLANK', '대용량 업로드는 서비스 _____ 위험을 낮추기 위해 크기/시간 제한을 둔다.', '거부', '-', 83);

-- Unit 7 - Lesson 21: File Upload Exploit (Lesson ID: 84)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (861, 'SELECT_DESCRIPTION', '저장소 설계로 안전한 것은?', '2', '1.웹루트 내부 저장;2.별도 버킷/도메인에서 서빙;3.DB BLOB만 사용;4.CDN 없이 직접 서빙', 84),

    (862, 'FILL_BLANK', '업로드 기본 원칙은 ''검증·재인코딩·격리·_____''이다.', '최소공개', '-', 84),

    (863, 'SELECT_DESCRIPTION', '썸네일 생성 시 안전한 방법은?', '2', '1.사용자 제공 경로 실행;2.안전 API 사용 및 명령 호출 지양;3.쉘 호출;4.임시 파일 공개', 84),

    (864, 'FILL_BLANK', '파일 경로 입력에 대한 안전한 검증은 정규화 후 _____ 화이트리스트를 적용하는 것이다.', '허용디렉토리', '-', 84),

    (865, 'SELECT_DESCRIPTION', '악성 파일 업로드 탐지에 도움 되는 것은?', '2', '1.랜덤 파일명 비활성화;2.안티바이러스/샌드박스 연계;3.클라이언트 신뢰;4.공개 폴더 자동 노출', 84),

    (866, 'FILL_BLANK', '서명된 URL은 만료 시간과 _____을 포함으로 추측 난이도를 높인다.', '서명', '-', 84),

    (867, 'SELECT_DESCRIPTION', '콘텐츠 스니핑을 막는 헤더는?', '2', '1.X-Frame-Options;2.X-Content-Type-Options;3.Referrer-Policy;4.Content-Security-Policy', 84),

    (868, 'FILL_BLANK', '이미지 재인코딩은 스테가노그래피/악성 페이로드 _____에 도움이 된다.', '제거', '-', 84);

-- Unit 8 - Lesson 22: Command Injection Concept (Lesson ID: 85)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (869, 'FILL_BLANK', '명령 인젝션은 사용자 입력이 쉘/OS _____로 해석되어 의도치 않은 명령 실행으로 이어지는 문제다.', '명령', '-', 85),

    (870, 'SELECT_DESCRIPTION', '명령 인젝션과 직접 관련이 적은 것은?', '4', '1.쉘 메타문자;2.인자 분리 실패;3.안전 API 부재;4.이미지 CDN 캐시', 85),

    (871, 'FILL_BLANK', '외부 프로세스 호출 대신 라이브러리/_____사용이 바람직하다.', '시스템api', '-', 85),

    (872, 'SELECT_DESCRIPTION', '허용 리스트 기반 입력 검증의 예는?', '2', '1.모든 문자열 허용;2.소문자 a~z와 숫자만 허용;3.블랙리스트로 금지 문자만 차단;4.길이만 제한', 85),

    (873, 'FILL_BLANK', '프로세스 격리를 위해 컨테이너/샌드박스/제한된 _____로 실행하는 것도 방어에 도움 된다.', '권한', '-', 85),

    (874, 'SELECT_DESCRIPTION', '명령 인젝션의 전형적 전제조건이 아닌 것은?', '3', '1.입력이 인자로 직접 연결;2.쉘을 통해 실행;3.인자 이스케이프 적절;4.검증 부재', 85),

    (875, 'FILL_BLANK', '공백·세미콜론 등 _____가 명령 체이닝을 유발할 수 있다.', '메타문자', '-', 85),

    (876, 'SELECT_DESCRIPTION', '외부 도구 호출이 필요한 경우 안전한 방법은?', '2', '1.쉘 문자열 조립;2.인자 배열로 안전 API 호출;3.사용자 입력을 그대로 옵션에 삽입;4.루트로 실행', 85);

-- Unit 8 - Lesson 23: Command Injection Exploit (Lesson ID: 86)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (877, 'SELECT_DESCRIPTION', '가장 영향이 큰 케이스는?', '2', '1.비동기 실패;2.임의 명령 실행으로 서버 권한 획득;3.로그레벨 변경;4.테마 전환', 86),

    (878, 'FILL_BLANK', '경로/파일명 등을 연결해 외부 명령을 만들면 _____ 우회 위험이 높아진다.', '검증', '-', 86),

    (879, 'SELECT_DESCRIPTION', '환경 변수 오염으로 이어질 수 있는 취약점은?', '2', '1.경로 하드코딩;2.PATH 조작;3.정적 링크;4.정렬 오류', 86),

    (880, 'FILL_BLANK', '임시 파일 이름 예측 가능성은 _____ 위험을 키운다.', '경쟁조건', '-', 86),

    (881, 'SELECT_DESCRIPTION', '셸 해석을 피하기 위해 필요한 것은?', '2', '1.문자열 합성;2.인자 분리 전달;3.환경 공유;4.작업 디렉터리 미지정', 86),

    (882, 'FILL_BLANK', '출력 캡처 시 쉘 리다이렉션 대신 _____를 사용한다.', '파이프', '-', 86),

    (883, 'SELECT_DESCRIPTION', '권한 상승 위험을 낮추는 실행은?', '2', '1.루트 실행;2.기본 사용자 실행;3.SUID 바이너리 사용;4.CAP_SYS_ADMIN 추가', 86),

    (884, 'FILL_BLANK', '실행 전 환경을 통제해 예측 가능한 _____에서만 동작하게 한다.', '컨텍스트', '-', 86);

-- Unit 8 - Lesson 24: Command Injection Exploit (Lesson ID: 87)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (885, 'SELECT_DESCRIPTION', '가장 우선 고려해야 할 방어 전략은?', '1', '1.외부 명령 호출 회피;2.로그만 강화;3.UI 경고;4.캐시 비활성화', 87),

    (886, 'FILL_BLANK', '불가피한 경우 인자를 문자열이 아닌 _____으로 분리해 전달한다.', '배열', '-', 87),

    (887, 'SELECT_DESCRIPTION', '런타임 격리로 적절하지 않은 것은?', '4', '1.chroot/네임스페이스;2.seccomp-bpf;3.불필요한 Capabilities 제거;4.루트 권한 상향', 87),

    (888, 'FILL_BLANK', '환경 변수/작업 디렉터리 등 실행 _____을 통제한다.', '환경', '-', 87),

    (889, 'SELECT_DESCRIPTION', '로깅/모니터링으로 적절한 것은?', '2', '1.명령 문자열 전체 평문 저장;2.호출 API/인자/결과 코드 기록(민감정보 마스킹);3.로그 비활성화;4.실패만 기록', 87),

    (890, 'FILL_BLANK', '컨테이너 실행 시 불필요한 Linux _____를 제거(cap_drop)는 공격면 축소에 유효하다.', 'capabilities', '-', 87),

    (891, 'SELECT_DESCRIPTION', '파일 경로 입력 검증으로 안전한 것은?', '2', '1.블랙리스트만;2.정규화 후 허용 디렉터리 화이트리스트;3.길이만 제한;4.클라 체크만', 87),

    (892, 'FILL_BLANK', '외부 도구 호출이 꼭 필요하면 전용 _____/권한 격리 환경에서 실행한다.', '샌드박스', '-', 87);

-- Chapter 7: 소프트웨어 공학

-- Unit 1 - Lesson 1: 소프트웨어와 하드웨어의 이해 (Lesson ID: 88)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (893, 'SELECT_DESCRIPTION', '소프트웨어가 하드웨어와 구분되는 가장 큰 특징으로 옳지 않은 것은?', '3', '1.소프트웨어는 시간이 지나도 마모되지 않는다.;2.소프트웨어는 높은 유연성을 가진다.;3.소프트웨어는 물리적인 제약이 크다.;4.소프트웨어 개발은 논리적 오류에 취약하다.', 88),

    (894, 'SELECT_DESCRIPTION', '하드웨어와 소프트웨어의 수정(업데이트) 방식에 대한 설명으로 올바른 것은?', '3', '1.하드웨어는 업데이트만으로 모든 기능을 개선할 수 있다.;2.소프트웨어는 부품을 교체해야만 수정이 가능하다.;3.소프트웨어는 주로 패치, 업데이트를 통해 개선된다.;4.하드웨어와 소프트웨어 모두 물리적으로 업그레이드해야 한다.', 88),

    (895, 'FILL_BLANK', '소프트웨어는 외부환경에 의해 _____않지만 시간이 지날수록 품질이 점점 나빠진다.', '마모되지', '-', 88),

    (896, 'FILL_BLANK', '소프트웨어는 시간이 지나면서 변경과 수정이 이루어질수록 _____ 현상이 생겨 품질이 저하된다.', '소프트웨어 노화', '-', 88),

    (897, 'FILL_BLANK', '소프트웨어는 물리적 자원이 아닌 코드와 _____로 이루어져 있기 때문에 물리적으로 마모되지 않는다.', '데이터, data', '-', 88),

    (898, 'SELECT_DESCRIPTION', '소프트웨어가 비물질적인 산출물인 이유는?', '3', '1.시간이 지나면서 물리적 마모가 발생해서;2.전자 장치에만 저장 가능해서;3.물리적 실체가 없이 코드와 데이터의 집합으로 존재해서;4.물리적 형태로 항상 출력되기 때문에', 88),

    (899, 'FILL_BLANK', '소프트웨어의 높은 유연성은 사용자의 요구 변화에 대응을 쉽게 하지만, 변화가 빈번해질 경우 _____가 복잡해질 수 있다.', '유지보수', '-', 88),

    (900, 'SELECT_DESCRIPTION', '다음 중 소프트웨어 유지보수가 어려운 이유로 가장 적절한 것은?', '1', '1.개발 팀과 유지보수 팀이 다르고 시스템 구조와 업무 프로세스를 완전히 이해해야 하기 때문;2.소프트웨어가 물리적인 마모로 인해 자주 고장 나기 때문;3.유지보수는 새로운 소프트웨어를 처음부터 개발하는 것보다 비용이 적게 들기 때문;4.소프트웨어는 항상 최신 기술로 자동 업데이트되기 때문', 88),

    (901, 'FILL_BLANK', '소프트웨어 설계와 구현 과정에서 사람의 실수로 _____ 오류가 발생할 수 있으며, 이는 소프트웨어의 결함이나 고장으로 이어진다.', '논리적', '-', 88),

    (902, 'SELECT_DESCRIPTION', '소프트웨어 생명주기(Software Life Cycle)에서 소프트웨어가 하드웨어와 다른 특징으로 올바른 것은?', '1', '1.소프트웨어는 초기 결함률이 낮고 시간이 지나면서 결함률이 증가한다.;2.소프트웨어는 물리적 마모로 인해 사용 기간이 제한된다.;3.소프트웨어는 Bath Tub Curve를 따라 결함률이 변화한다.;4.소프트웨어는 시간이 지나도 성능 저하가 발생하지 않는다.', 88),

    (903, 'FILL_BLANK', '소프트웨어는 물리적 부품이 아니라 전자적 형태로 존재하기 때문에 추가 비용 없이 쉽게 _____할 수 있다.', '복제', '-', 88),

    (904, 'SELECT_DESCRIPTION', '소프트웨어 개발에서 발생하는 오류의 특성으로 옳지 않은 것은?', '3', '1.논리적 오류는 주로 설계나 구현 단계에서 발생한다.;2.소프트웨어 오류는 대부분 사람의 실수로 인해 발생한다.;3.소프트웨어 오류는 물리적 마모로 인해 시간이 지나면서 증가한다.;4.논리적 오류는 테스팅을 통해 발견하고 수정할 수 있다.', 88);

-- Unit 1 - Lesson 2: 소프트웨어 위기와 소프트웨어 공학의 등장 (Lesson ID: 89)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (905, 'SELECT_DESCRIPTION', '다음 중 소프트웨어 위기 현상이 아닌 것은 무엇인가?', '5', '1.개발 일정이 계획보다 지연된다.;2.초과 비용이 발생한다.;3.제품의 신뢰도가 결여된다.;4.빈번하게 명세와 불일치하는 부분이 나타난다.;5.프로젝트 팀원 간 원활한 의사소통이 이루어진다.', 89),

    (906, 'SELECT_DESCRIPTION', '다음 중 소프트웨어 위기 현상이 아닌 것은 무엇인가?', '3', '1.개발 일정 지연;2.초과 비용 발생;3.상세한 요구가 추상적 프로그램으로 바뀜;4.소프트웨어 품질 저하;5.유지보수의 어려움', 89),

    (907, 'FILL_BLANK', '소프트웨어 공학의 궁극적인 목표는 고품질의 소프트웨어를 _____으로 개발하고 유지보수하는 것이다.', '효율적', '-', 89),

    (908, 'SELECT_DESCRIPTION', '소프트웨어의 비가시성(Invisibility)이 개발 과정에 미치는 영향은?', '1', '1.설계 및 개발의 복잡성 증가;2.오류 발견과 관리 용이;3.작업 속도 향상;4.요구사항 감소', 89),

    (909, 'SELECT_DESCRIPTION', '소프트웨어 위험의 대표적 특성으로 짝지어진 것 중 가장 적합한 것은?', '2', '1.연쇄작용, 확실성;2.불확실성, 손실;3.연쇄작용, 예측;4.확실성, 예측', 89),

    (910, 'SELECT_DESCRIPTION', '공학적으로 잘 작성된 소프트웨어의 특성에 관한 설명으로 가장 옳지 않은 것은?', '3', '1.소프트웨어는 신뢰성이 높아야 하며 효율적이어야 한다.;2.소프트웨어는 사용자가 원하는 대로 동작해야 한다.;3.소프트웨어는 편리성이나 유지보수성에 점차 비중을 적게 두는 경향이 있다.;4.소프트웨어는 잠재적인 오류가 가능한 적어야 하며 유지보수가 용이해야 한다.', 89),

    (911, 'SELECT_DESCRIPTION', 'Software Reengineering의 필요성이 대두된 가장 주된 이유는?', '4', '1.구현의 문제;2.설계의 문제;3.요구사항 분석의 문제;4.유지보수의 문제', 89),

    (912, 'SELECT_DESCRIPTION', '공학적 관점에서 좋은 소프트웨어에 대한 설명으로 적합하지 않은 것은?', '3', '1.사용법, 구조의 설명, 성능, 기능이 이해하기 쉬워야 한다.;2.사용자 수준에 따른 적당한 사용자 인터페이스를 제공한다.;3.실행 속도가 빠르고, 소요 기억 용량을 많이 차지할수록 좋다.;4.유지보수가 용이해야 한다.', 89),

    (913, 'SELECT_DESCRIPTION', '소프트웨어 개발의 생산성에 영향을 미치는 요소로 가장 거리가 먼 것은?', '4', '1.프로그래머의 능력;2.팀 의사 전달;3.제품의 복잡도;4.소프트웨어 사용자의 능력', 89),

    (914, 'SELECT_DESCRIPTION', '소프트웨어 공학에 대한 설명으로 가장 적합한 것은?', '1', '1.소프트웨어의 제작부터 운영까지 생산성을 높이기 위해 기술적, 인간적인 요소에 대한 방법론을 제공한다.;2.소프트웨어의 설계, 제작, 운영에 있어서 인간적인 요소를 배제한 프로그래밍 자체에 대한 공학적 연구를 의미한다.;3.소프트웨어의 공학적이고 기술적인 영향을 사회 경제적인 시각에서만 설명한다.;4.소프트웨어의 위기를 해결하기 위해서 현재 이미 해결된 문제들에 대해서 역사적 관점을 설명한다.', 89),

    (915, 'SELECT_DESCRIPTION', '다음 중 공학적으로 잘 작성된 소프트웨어가 갖는 특성으로 가장 적합한 것은?', '4', '1.원하는 요구사항 중에 중요한 사항만 반영한다.;2.유지보수 비용이 많이 들어간다.;3.신뢰성이 떨어지더라도 효율성이 높다.;4.사용자가 손쉽게 사용할 수 있다.', 89),

    (916, 'SELECT_DESCRIPTION', 'Software Engineering의 Engineering이 가지는 의미와 가장 관계없는 것은?', '1', '1.예술성;2.경제성;3.보편타당성;4.적시성', 89);

-- Unit 1 - Lesson 3: 소프트웨어 개발 프로세스 (Lesson ID: 90)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

(917, 'SELECT_DESCRIPTION', '소프트웨어 개발 모델 중 나선형 모델의 네 가지 주요활동이 순서대로 나열된 것은?', '2', '1.Ⓐ-Ⓑ-Ⓓ-Ⓒ 순으로 반복;2.Ⓐ-Ⓓ-Ⓒ-Ⓑ 순으로 반복;3.Ⓐ-Ⓑ-Ⓒ-Ⓓ 순으로 반복;4.Ⓐ-Ⓒ-Ⓑ-Ⓓ 순으로 반복', 90),

(918, 'SELECT_DESCRIPTION', '프로토타이핑 모형(Prototyping Model)에 대한 설명으로 옳지 않은 것은?', '1', '1.개발단계에서 오류 수정이 불가하므로 유지보수 비용이 많이 발생한다.;2.최종 결과물이 만들어지기 전에 의뢰자가 최종 결과물의 일부 또는 모형을 볼 수 있다.;3.프로토타입은 발주자나 개발자 모두에게 공동의 참조 모델을 제공한다.;4.프로토타입은 구현단계의 구현 골격이 될 수 있다.', 90),

(919, 'SELECT_DESCRIPTION', '다음 설명에 해당하는 생명주기 모형으로 가장 옳은 것은?\n가장 오래된 모형으로 많은 적용 사례가 있지만 요구사항의 변경이 어려우며, 각 단계의 결과가 확인되어야지만 다음 단계로 넘어간다. 선형 순차적 모형으로 고전적 생명주기 모형이라고도 한다.', '3', '1.프로토타입 모형(Prototype Model);2.코코모 모형(Cocomo Model);3.폭포수 모형(Waterfall Model);4.점진적 모형(Spiral Model)', 90),

(920, 'SELECT_DESCRIPTION', '나선형 모형의 각 개발 단계에 대한 설명으로 가장 옳은 것은?', '4', '1.Planning(계획) 단계에서는 위험 요소와 타당성을 분석하여 프로젝트의 추진 여부를 결정한다.;2.Development(개발) 단계에서는 선택된 기능을 수행하는 프로토 타입을 개발한다.;3.Risk Analysis(위험분석) 단계에서는 개발 목적과 기능 선택, 제약 조건 등을 결정하고 분석한다.;4.Evaluation(평가) 단계에서는 고객 평가와 검증 과정을 수행하여 개발된 결과를 평가한다.', 90),

(921, 'SELECT_DESCRIPTION', '프로토타입 모형에 대한 설명으로 가장 옳지 않은 것은?', '2', '1.개발 단계 안에서 유지보수가 이루어지는 것으로 볼 수 있다.;2.최종 결과물이 만들어지는 소프트웨어 개발 완료시점에 최초로 오류 발견이 가능하다.;3.발주자나 개발자 모두에게 공동의 참조모델을 제공한다.;4.사용자나 요구사항을 충실히 반영할 수 있다.', 90),

(922, 'SELECT_DESCRIPTION', '프로토타입 모형의 장점으로 가장 적절한 것은?', '3', '1.비용과 시간의 절감;2.책임 한계의 명백한 구분;3.요구사항의 충실 반영;4.프로젝트 관리의 용이', 90),

(923, 'SELECT_DESCRIPTION', '소프트웨어 생명주기 모형 중 Spiral Model(나선형모델)에 대한 설명으로 가장 옳지 않은 것은?', '4', '1.대규모 시스템에 적합하다.;2.개발 순서는 계획 및 정의, 위험 분석, 공학적 개발, 고객 평가 순으로 진행된다.;3.소프트웨어를 개발하면서 발생할 수 있는 위험을 관리하고 최소화하는 것을 목적으로 한다.;4.개발 과정의 앞 단계가 완료되어야만 다음 단계로 넘어갈 수 있는 선형 순차적 모형이다.', 90),

(924, 'SELECT_DESCRIPTION', '소프트웨어 프로젝트 관리를 효율적으로 수행하기 위한 3P 중 소프트웨어 프로젝트를 수행하기 위한 Task Framework의 고려와 가장 연관되는 것은?', '4', '1.People;2.Problem;3.Product;4.Process', 90),

(925, 'SELECT_DESCRIPTION', 'V-모델의 주요 특징으로 옳지 않은 것은?', '3', '1.개발과 테스트가 병행되어 결함을 조기에 발견할 수 있다.;2.각 단계별 요구사항과 설계가 올바른지 지속적으로 검증할 수 있다.;3.요구사항 변경 시에도 모든 단계를 유연하게 재수행한다.;4.각 개발 단계에 대응하는 테스트 단계가 명확하게 존재한다.', 90),

(926, 'SELECT_DESCRIPTION', '애자일 방법론의 기본 특징으로 옳지 않은 것을 고르시오', '2', '1.프로젝트 요구사항은 기능 중심으로 정의한다.;2.문서 중심의 개발을 중요시한다.;3.개인과 상호작용을 절차와 도구보다 중요하게 생각한다.;4.고객과의 피드백을 중요하게 생각한다.', 90),

(927, 'SELECT_DESCRIPTION', '소프트웨어 개발 중 가장 많은 비용이 요구되는 단계는?', '4', '1.분석;2.설계;3.구현;4.유지보수', 90),

(928, 'SELECT_DESCRIPTION', '소프트웨어 재사용에 대한 설명으로 가장 옳은 것은?', '4', '1.프로젝트 실패의 위험을 증가시킨다.;2.소프트웨어를 재사용함으로써 유지보수 비용이 높아진다.;3.모든 소프트웨어를 재사용해야 한다.;4.소프트웨어의 개발 생산성과 품질을 높이려는 주요 방법이다.', 90);

-- Unit 2 - Lesson 1: 요구사항 수집, 분석, 명세 (Lesson ID: 91)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (929, 'SELECT_DESCRIPTION', '사용자 요구사항의 분석 작업이 어려운 이유로 가장 거리가 먼 것은?', '3', '1.개발자와 사용자 간의 지식이나 표현의 차이가 커서 상호 이해가 쉽지 않다.;2.사용자의 요구사항이 모호하고 부정확하며, 불완전하다.;3.사용자의 요구사항은 거의 예외가 없어 열거와 구조화가 용이하다.;4.개발하고자 하는 시스템 자체가 복잡하다.', 91),

    (930, 'SELECT_DESCRIPTION', '자료 사전에서 기호"{ }"의 의미는?', '2', '1."comment"(주석);2."iteration of"(반복);3."is composed of"(정의);4."optional"(생략)', 91),

    (931, 'SELECT_DESCRIPTION', '자료 사전에서 기호 "{ }"의 의미는?', '3', '1.정의;2.생략;3.반복;4.선택', 91),

    (932, 'SELECT_DESCRIPTION', '데이터 흐름도(DFD)의 구성요소에 포함되지 않는 것은?', '2', '1.data flow;2.data dictionary;3.process;4.data store', 91),

    (933, 'SELECT_DESCRIPTION', 'DFD(data flow diagram)에 대한 설명으로 거리가 먼 것은?', '3', '1.자료 흐름 그래프 또는 버블(bubble)차트라고도 한다.;2.구조적 분석 기법에 이용된다.;3.시간 흐름의 개념을 명확하게 표현할 수 있다.;4.DFD의 요소는 화살표, 원, 사각형, 직선(단선/이중선)으로 표시한다.', 91),

    (934, 'SELECT_DESCRIPTION', '세분화된 자료흐름도에서 최하위 단계 프로세스의 처리 절차를 설명한 것은?', '2', '1.ERD;2.Mini-spec;3.DD;4.STD', 91),

    (935, 'SELECT_DESCRIPTION', '자료 사전에서 자료의 생략을 의미하는 기호는?', '4', '1.{ };2.*;3.=;4.()', 91),

    (936, 'SELECT_DESCRIPTION', '자료 흐름도(DFD)에서 "Process"의 표기 형태는?', '1', '1.원;2.화살표;3.사각형;4.직선(단선, 이중선)', 91),

    (937, 'SELECT_DESCRIPTION', '자료 사전에서 기호 "( )"의 의미는?', '2', '1.정의;2.생략;3.선택;4.반복', 91),

    (938, 'SELECT_DESCRIPTION', '자료사전에서 자료의 연결("and")을 나타내는 기호는?', '1', '1.+;2.=;3.( );4.{ }', 91),

    (939, 'SELECT_DESCRIPTION', '구조적 분석에서 자료 사전(Data Dictionary)작성 시 고려할 사항으로 옳지 않은 것은?', '2', '1.갱신하기 쉬워야 한다.;2.이름이 중복되어야 한다.;3.이름으로 정의를 쉽게 찾을 수 있어야 한다.;4.정의하는 방식이 명확해야 한다.', 91),

    (940, 'SELECT_DESCRIPTION', '자료흐름도(DFD)의 각 요소별 표기 형태의 연결이 옳지 않은 것은?', '3', '1.Process : 원;2.Data Flow : 화살표;3.Data Store : 삼각형;4.Terminator : 사각형', 91);

-- Unit 3 - Lesson 1: 소프트웨어 설계 (Lesson ID: 92)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (941, 'SELECT_DESCRIPTION', '럼바우(Rumbaugh)의 객체지향 분석에서 사용되는 분석 활동을 가장 옳게 나열한 것은?', '2', '1.객체 모델링, 동적 모델링, 정적 모델링;2.객체 모델링, 동적 모델링, 기능 모델링;3.동적 모델링, 기능 모델링, 정적 모델링;4.정적 모델링, 객체 모델링, 기능 모델링', 92),

    (942, 'SELECT_DESCRIPTION', '객체에 대한 특성을 설명한 것으로 가장 옳지 않은 것은?', '4', '1.객체마다 각각의 상태를 갖고 있다.;2.식별성을 가진다.;3.행위에 대하여 그 특징을 나타낼 수 있다.;4.일정한 기억장소를 가지고 있지 않다.', 92),

    (943, 'SELECT_DESCRIPTION', '한 모듈 내의 각 구성 요소들이 공통의 목적을 달성하기 위하여 서로 얼마나 관련이 있는지의 기능적 연관의 정도를 나타내는 것은?', '1', '1.cohesion(응집도) : 높을수록 좋음;2.coupling(결합도) : 모듈 간의 상호 의존성 정도를 나타내는 개념. 낮을수록 좋음;3.structure;4.unity', 92),

    (944, 'SELECT_DESCRIPTION', '객체지향에서 정보 은닉과 가장 밀접한 관계가 있는 것은?', '1', '1.Encapsulation(캡슐화);2.Class;3.Method;4.Instance', 92),

    (945, 'SELECT_DESCRIPTION', '결합도(Coupling) 단계를 약한 순서에서 강한 순서로 가장 옳게 표시한 것은?', '4', '1.stamp → data → control → common → content;2.control → data → stamp → common → content;3.content → stamp → control → common → data;4.data → stamp → control → common → content', 92),

    (946, 'SELECT_DESCRIPTION', '객체지향 기법에서 다음 설명에 해당하는 것으로 가장 옳은 것은?\n다른 객체에게 자신의 정보를 숨기고 자신의 연산만을 통하여 접근한다.\n유지보수와 소프트웨어 확장 시 오류를 최소화할 수 있다.', '3', '1.Abstraction(추상화);2.Inheritance(상속);3.Information Hiding(정보은닉);4.Polymorphism(다형성)', 92),

    (947, 'SELECT_DESCRIPTION', '모듈의 응집도(Cohesion)에 대한 설명으로 틀린 것은?', '2', '1.모듈의 응집도란 모듈안의 요소들이 서로 관련되어 있는 정도를 말한다.;2.기능적 응집도(Functional Cohesion)는 한 모듈 내부의 한 기능 요소에 의한 출력 자료가 다음 기능 원소의 입력 자료로서 제공되는 형태이다.;3.교환적 응집도(Communication Cohesion)는 동일한 입력과 출력을 사용하는 소작업들이 모인 모듈에서 볼 수 있다.;4.논리적 응집도(Logical Cohesion)는 유사한 성격을 갖거나 특정형태로 분류되는 처리요소들로 하나의 모듈이 형성되는 경우이다.', 92),

    (948, 'SELECT_DESCRIPTION', '설계 기법 중 하향식 설계 방법과 상향식 설계 방법에 대한 비교 설명으로 가장 옳지 않은 것은?', '2', '1.하향식 설계에서는 통합 검사 시 인터페이스가 이미 정의 되어 있어 통합이 간단하다.;2.하향식 설계에서 레벨이 낮은 데이터 구조의 세부 사항은 설계 초기 단계에서 필요하다.;3.상향식 설계는 최하위 수준에서 각각의 모듈들을 설계하고 이러한 모듈이 완성되면 이들을 결합하여 검사한다.;4.상향식 설계에서는 인터페이스가 이미 성립되어 있지 않더라도 기능 추가가 쉽다.', 92),

    (949, 'SELECT_DESCRIPTION', '객체 지향 기법에서 하나 이상의 유사한 객체들을 묶어서 하나의 공통된 특성을 표현한 것은?', '2', '1.메시지;2.클래스;3.추상화;4.메소드', 92),

    (950, 'SELECT_DESCRIPTION', '다음 중 가장 약한 결합도(Coupling)는?', '4', '1.Common(공통) Coupling;2.Control(제어) Coupling;3.External Coupling;4.Stamp(스탬프) Coupling', 92),

    (951, 'SELECT_DESCRIPTION', '효과적인 모듈화 설계 방법으로 가장 거리가 먼 것은?', '1', '1.Coupling은 강하게 Cohesion는 약하게 설계한다.;2.Complexity(복잡성)와 Redundancy(중복성)를 최대한 줄일 수 있도록 설계한다.;3.Maintenance(유지보수)가 용이하도록 설계한다.;4.Module 크기는 시스템의 전반적인 기능과 구조를 이해하기 쉬운 크기로 설계한다.', 92),

    (952, 'SELECT_DESCRIPTION', '럼바우(Rumbaugh) 분석기법에서 정보 모델링이라고도 하며, 시스템에서 요구되는 객체를 찾아내어 속성과 연산 식별 및 객체들 간의 관계를 규정하여 그래픽 다이어그램으로 표시하는 모델링은?', '1', '1.Object;2.Dynamic;3.Function;4.Static', 92);

-- Unit 3 - Lesson 2: 객체 지향 설계 (Lesson ID: 93)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (953, 'SELECT_DESCRIPTION', '객체지향 기법에서 객체가 메시지를 받아 실행해야 할 객체의 구체적인 연산을 정의한 것은?', '2', '1.Entity;2.Method;3.Instance;4.Class', 93),

    (954, 'SELECT_DESCRIPTION', '럼바우의 객체지향 분석 기법에서 상태다이어그램을 사용하여 시스템의 행위를 기술하는 모델링은?', '1', '1.dynamic modeling(동적모델링) : 상태다이어그램;2.object modeling(객체모델링) : 클래스와 클래스 사이의 관련;3.functional modeling(기능모델링) : 자료흐름도(DFD);4.static modeling(정적모델링)', 93),

    (955, 'SELECT_DESCRIPTION', 'Rumbaugh의 모델링에서 상태도와 자료흐름도는 각각 어떤 모델링과 가장 관련이 있는가?', '1', '1.상태도 – 동적 모델링, 자료흐름도 – 기능 모델링;2.상태도 – 기능 모델링, 자료흐름도 – 동적 모델링;3.상태도 – 객체 모델링, 자료흐름도 – 기능 모델링;4.상태도 – 객체 모델링, 자료흐름도 – 동적 모델링', 93),

    (956, 'SELECT_DESCRIPTION', '객체지향의 캡슐화에 대한 설명으로 가장 옳지 않은 것은?', '4', '1.결합도가 낮아진다.;2.재사용이 용이하다.;3.인터페이스를 단순화 시킬 수 있다.;4.변경이 발생할 때 오류의 파급효과가 크다.', 93),

    (957, 'SELECT_DESCRIPTION', '객체 지향 설계 및 분석단계에 대한 설명으로 틀린 것은?', '2', '1.분석 단계에서는 주어진 문제 안에서 객체들을 발견하고 객체들의 상관관계를 분석한다.;2.분석 설계 및 구현 단계들 사이에 의미적 갭(semantic gap)이 크다.;3.설계 단계에서는 객체들을 클래스로 정의하고 상관관계를 상속단계로 정의한다.;4.구현단계에서는 정의된 클래스들에 대해 특정언어를 이용하여 1:1로 정의한다.', 93),

    (958, 'SELECT_DESCRIPTION', '객체지향 개발 과정에 대한 설명으로 가장 거리가 먼 것은?', '3', '1.분석 단계에서는 객체의 이름과 상태, 행위들을 개념적으로 파악한다.;2.설계 단계에서는 객체의 속성과 연산으로 정의하고 접근 방법을 구체화한다.;3.구현 단계에서는 클래스를 절차적 프로그래밍 언어로 기술한다.;4.테스트 단계에서는 클래스 단위 테스트와 시스템 테스트를 진행한다.', 93),

    (959, 'SELECT_DESCRIPTION', '럼바우의 분석 기법 중 자료 흐름도(DFD)를 이용하는 것은?', '1', '1.기능 모델링;2.동적 모델링;3.객체 모델링;4.정적모델링', 93),

    (960, 'SELECT_DESCRIPTION', '다음 중 가장 높은 응집도(Cohesion)에 해당하는 것은?', '1', '1.순서적(순차적) 응집도(Sequential Cohesion);2.시간적 응집도(Temporal Cohesion);3.논리적 응집도(Logical Cohesion);4.절차적 응집도(Procedural Cohesion)', 93),

    (961, 'SELECT_DESCRIPTION', '시스템에서 모듈 사이의 결합도(Coupling)에 대한 설명으로 옳은 것은?', '3', '1.한 모듈 내에 있는 처리요소를 사이의 기능적인 연관 정도를 나타낸다.;2.결합도가 높으면 시스템 구현 및 유지보수가 용이하다.;3.모듈간의 결합도를 약하게 하면 모듈 독립성이 향상된다.;4.자료(data)결합도는 내용(content)결합도 보다 결합도가 높다.', 93),

    (962, 'SELECT_DESCRIPTION', '객체에게 어떤 행위를 하도록 지시하는 명령은?', '4', '1.Class;2.Instance;3.Object;4.Message', 93),

    (963, 'SELECT_DESCRIPTION', '객체들 간에 메시지를 주고받을 때 각 객체의 세부내용은 알 필요가 없으므로 인터페이스가 단순해지고 데이터와 데이터를 처리하는 함수를 하나로 묶는 것을 의미하는 것은?', '3', '1.abstraction(추상화);2.class;3.encapsulation(캡슐화);4.Inheritance(상속)', 93),

    (964, 'SELECT_DESCRIPTION', '다음 중 독립적인 모듈이 되기 위해서 가장 좋은 결합도 상태는?', '2', '1.control coupling;2.stamp coupling;3.common coupling;4.content coupling', 93);

-- Unit 3 - Lesson 3: UML & 디자인 패턴 (Lesson ID: 94)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (965, 'SELECT_DESCRIPTION', 'UML에서 시퀀스 다이어그램의 구성 항목에 해당하지 않는 것은?', '3', '1.생명선;2.실행;3.확장;4.메시지', 94),

    (966, 'SELECT_DESCRIPTION', 'UML 다이어그램 중 정적 다이어그램이 아닌 것은?', '3', '1.컴포넌트 다이어그램;2.배치 다이어그램;3.순차 다이어그램;4.패키지 다이어그램', 94),

    (967, 'SELECT_DESCRIPTION', 'UML 다이어그램 중 순차 다이어그램에 대한 설명으로 틀린 것은?', '2', '1.객체 간의 동적 상호작용을 시간 개념을 중심으로 모델링 하는 것이다.;2.주로 시스템의 정적 측면을 모델링 하기 위해 사용한다.;3.일반적으로 다이어그램의 수직 방향이 시간의 흐름을 나타낸다.;4.회귀 메시지(Self-Message), 제어블록(Statement block) 등으로 구성된다.', 94),

    (968, 'SELECT_DESCRIPTION', '유스케이스(Use Case)의 구성 요소 간의 관계에 포함되지 않는 것은?', '3', '1.연관;2.확장;3.구체화;4.일반화', 94),

    (969, 'SELECT_DESCRIPTION', '유스케이스 다이어그램(Use Case Diagram)에 관련된 내용으로 틀린 것은?', '1', '1.시스템과 상호작용하는 외부 시스템은 액터로 파악해서는 안된다.;2.유스케이스는 사용자 측면에서의 요구사항으로, 사용자가 원하는 목표를 달성하기 위해 수행할 내용을 기술 한다.;3.시스템 액터는 다른 프로젝트에서 이미 개발되어 사용되고 있으며, 본 시스템과 데이터를 주고받는 등 서로 연동되는 시스템을 말한다.;4.액터가 인식할 수 없는 시스템 내부의 기능을 하나의 유스케이스로 파악해서는 안된다.', 94),

    (970, 'SELECT_DESCRIPTION', 'GoF(Gang of Four)의 디자인 패턴에서 행위 패턴에 속하는 것은?', '2', '1.Builder;2.Visitor;3.Prototype;4.Bridge', 94),

    (971, 'SELECT_DESCRIPTION', '디자인 패턴 중에서 행위적 패턴에 속하지 않는 것은?', '3', '1.커맨드(Command) 패턴;2.옵저버(Observer) 패턴;3.프로토타입(Prototype) 패턴;4.상태(State) 패턴', 94),

    (972, 'SELECT_DESCRIPTION', 'GoF(Gang of Four) 디자인 패턴을 생성, 구조, 행동 패턴의 세 그룹으로 분류할 때, 구조 패턴이 아닌 것은?', '3', '1.Adapter 패턴;2.Bridge 패턴;3.Builder 패턴;4.Proxy 패턴', 94),

    (973, 'SELECT_DESCRIPTION', 'GoF(Gangs of Four) 디자인 패턴 분류에 해당하지 않는 것은?', '4', '1.생성 패턴;2.구조 패턴;3.행위 패턴;4.추상 패턴', 94),

    (974, 'FILL_BLANK', 'UML 시퀀스 다이어그램의 메시지 종류 3가지를 쓰시오.', '동기 메시지, 비동기 메시지, 자체 메시지', '-', 94),

    (975, 'FILL_BLANK', 'UML 시퀀스 다이어그램에서 객체가 메시지를 처리하는 구간을 나타내는 직사각형을 무엇이라 하는가?', '실행 상자', '-', 94),

    (976, 'FILL_BLANK', 'UML 시퀀스 다이어그램에서 객체가 메모리 내 존재하는 기간을 나타내는 선은 무엇인가?', '생명선', '-', 94);

-- Unit 4 - Lesson 1: 소프트웨어 테스트 기법 및 법칙 (Lesson ID: 95)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (977, 'SELECT_DESCRIPTION', 'Alpha test, Beta test와 관계있는 검사 방법은?', '4', '1.Unit(단위테스트) : 독립적으로 테스트 가능한 가장 작은 구성 요소;2.Integration(통합테스트) : 개별적으로 테스트된 구성 요소들이 함께 작동하는 것을 확인하는 단계;3.System(시스템테스트) : 완전한 소프트웨어 시스템을 대상으로 수행되는 테스트;4.Validation(검증) : 개발된 소프트웨어가 사용자의 요구사항을 충족하는지 확인하는 과정', 95),

    (978, 'SELECT_DESCRIPTION', '필드 테스팅(field testing)이라고도 불리며 개발자 없이 고객의 사용 환경에 소프트웨어를 설치하여 검사를 수행하는 인수검사 기법은?', '1', '1.베타 검사;2.알파 검사;3.형상 검사;4.복구 검사', 95),

    (979, 'SELECT_DESCRIPTION', '소프트웨어 테스트에서 오류의 80%는 전체 모듈의 20% 내에서 발견된다는 법칙은?', '3', '1.Brooks의 법칙;2.Boehm의 법칙;3.Pareto의 법칙;4.Jackson의 법칙', 95),

    (980, 'SELECT_DESCRIPTION', '다음 중 검증 시험(Validation Test)과 거리가 먼 것은?', '4', '1.알파(Alpha) 테스트;2.베타(Beta) 테스트;3.블랙박스(Black-Box) 테스트;4.화이트박스(White-Box) 테스트', 95),

    (981, 'SELECT_DESCRIPTION', '화이트박스 테스트에 대한 설명으로 가장 옳지 않은 것은?', '4', '1.제품의 내부 요소들이 명세서에 따라 수행되고 충분히 실행되는가를 보장하기 위한 검사이다.;2.모듈 안의 작동을 직접 관찰한다.;3.프로그램 원시 코드의 논리적인 구조를 커버하도록 테스트 케이스를 설계한다.;4.화이트박스 테스트 기법에는 조건 검사, 루프 검사, 비교 검사 등이 있다.', 95),

    (982, 'SELECT_DESCRIPTION', '블랙박스 검사 기법에 해당하는 것으로만 짝지어진 것은?\n가 - 데이터 흐름 검사\n나 - 루프 검사\n다 - 동치 분할 검사\n라 - 경계값 분석\n마 - 원인- 효과 그래프 기법', '4', '1.가, 나;2.가, 라, 마, 바;3.나, 라, 마, 바;4.다, 라, 마, 바', 95),

    (983, 'SELECT_DESCRIPTION', '검증(Validation) 검사 기법 중 개발자의 장소에서 사용자가 개발자 앞에서 행해지며, 오류와 사용상의 문제점을 사용자와 개발자가 함께 확인하면서 검사하는 기법은?', '4', '1.디버깅 검사;2.형상 검사;3.베타 검사;4.알파 검사', 95),

    (984, 'SELECT_DESCRIPTION', 'White Box Testing의 설명으로 옳지 않은 것은?', '1', '1.Base Path Testing, Boundary Value Analysis가 대표적인 기법이다.;2.Source Code의 모든 문장을 한번 이상 수행함으로써 진행된다.;3.모듈 안의 작동을 직접 관찰할 수 있다.;4.산출물의 각 기능별로 적절한 프로그램의 제어구조에 따라 선택, 반복 등의 부분들을 수행함으로써 논리적 경로를 점검한다.', 95),

    (985, 'SELECT_DESCRIPTION', '블랙박스 테스트 기법 중 여러 버전의 프로그램에 동일한 검사 자료를 제공하여 동일한 결과가 출력되는지 검사하는 것은?', '1', '1.Comparison Testing(비교테스트);2.Boundary Value Analysis;3.Cause Effect Graphing Testing;4.Equivalence Partitioning Testing', 95),

    (986, 'SELECT_DESCRIPTION', '블랙박스 테스트 기법에 해당하는 내용을 모두 고르면?\nⒶ 소프트웨어 인터페이스에서 실시되는 검사로 설계된 모든 기능들이 정상적으로 수행되는지 확인한다.\nⒷ 소프트웨어의 기능이 의도대로 작동하고 있는 지, 입력은 적절하게 받아들였는지, 출력은 정확하게 생성 되는지를 보여주는데 사용된다.\nⒸ Equivalence Partitioning Testing, Boundary Value Analysis 등이 이 기법에 해당한다.', '4', '1.Ⓐ;2.Ⓐ, Ⓒ;3.Ⓑ, Ⓒ;4.Ⓐ, Ⓑ, Ⓒ', 95),

    (987, 'SELECT_DESCRIPTION', '블랙박스 테스트의 유형으로 틀린 것은?', '4', '1.경계값 분석;2.오류 예측;3.동등 분할 기법;4.조건, 루프 검사', 95),

    (988, 'SELECT_DESCRIPTION', '테스트 케이스에 일반적으로 포함되는 항목이 아닌 것은?', '3', '1.테스트 조건;2.테스트 데이터, data;3.테스트 비용;4.예상 결과', 95);

-- Unit 5 - Lesson 1: 유지보수 (Lesson ID: 96)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (989, 'SELECT_DESCRIPTION', '소프트웨어 시스템 명세서의 유지 보수에 대한 설명으로 가장 거리가 먼 것은?', '4', '1.명세서의 유지 보수란 명세서를 항상 최신의 상태로 만드는 것을 말한다.;2.소프트웨어는 계속 수정 보완되기 때문에 명세서도 따라서 보완되지 않으면 일관성을 유지하기 어렵다.;3.최신의 명세서는 필요한 경우 즉시 사용자에게 배포해야 한다.;4.시스템 개발자와 사용자는 동일한 명세서를 사용하기 때문에 시스템의 구조를 사용자도 잘 알고 있어야 한다.', 96),

    (990, 'SELECT_DESCRIPTION', '유지보수의 종류 중 소프트웨어 테스팅 동안 밝혀지지 않은 모든 잠재적인 오류를 수정하기 위한 보수 형태로서 오류의 수정과 진단 과정이 포함되는 것은?', '4', '1.Perfective maintenance(완전 유지보수);2.Adaptive maintenance(적응 유지보수);3.Preventive maintenance(예방 유지보수);4.Corrective maintenance(수정 유지보수)', 96),

    (991, 'SELECT_DESCRIPTION', '외계인코드(Alien Code)를 가장 잘 설명한 것은?', '4', '1.프로그램의 로직이 복잡하여 이해하기 어려운 프로그램을 말한다.;2.오류가 없어 디버깅 과정이 필요 없는 프로그램을 의미한다.;3.사용자가 직접 작성한 프로그램을 의미한다.;4.아주 오래되거나 참고문서 또는 개발자가 없어 유지보수 작업이 어려운 프로그램을 의미한다.', 96),

    (992, 'SELECT_DESCRIPTION', '소프트웨어 형상 관리(Configuration management)의 의미로 가장 적절한 것은?', '2', '1.비용에 관한 사항을 효율적으로 관리하는 것;2.개발 과정의 변경 사항을 관리하는 것;3.테스트 과정에서 소프트웨어를 통합하는 것;4.개발 인력을 관리하는 것', 96),

    (993, 'SELECT_DESCRIPTION', 'S/W 유지보수 작업의 목적이 아닌 것은?', '1', '1.설계수정;2.예방조치;3.환경적응;4.하자보수', 96),

    (994, 'SELECT_DESCRIPTION', '소프트웨어 형상 관리(Configuration Management)에 대한 설명으로 가장 타당한 것은?', '2', '1.개발 인력을 관리하는 것;2.개발 과정의 변화되는 사항을 관리 하는 것;3.개발 일정을 관리 하는것;4.테스트과정에서 소프트웨어를 통합하는 것', 96),

    (995, 'SELECT_DESCRIPTION', 'S/W를 운용하는 환경 변화에 대응하여 S/W를 변경하는 경우로 써, O/S와 Compiler 같은 개발환경의 변화 또는 Peripheral Device, System Component, element가 향상되거나 변경될 경우에 대처 가능한 Maintenance의 형태는?', '4', '1.Corrective(수정);2.Perfective(완전);3.Preventive(예방);4.Adaptive(적응)', 96),

    (996, 'SELECT_DESCRIPTION', '아주 오래되거나 참고문서 또는 개발자가 없어 유지보수 작업이 아주 어려운 프로그램을 의미하는 것은?', '1', '1.Alien Code;2.Title Code;3.Object Code;4.Source Code', 96),

    (997, 'SELECT_DESCRIPTION', '소프트웨어 개발 중 가장 많은 비용이 요구되는 단계는?', '4', '1.분석;2.설계;3.구현;4.유지보수', 96),

    (998, 'SELECT_DESCRIPTION', '장래의 유지보수성 또는 신뢰성을 개선하거나 소프트웨어의 오류발생에 대비하여 미리 예방수단을 강구해 두는 경우의 유지보수 형태는?', '3', '1.Corrective maintenance(수정);2.Perfective maintenance(완전);3.Preventive maintenance(예방);4.Adaptive maintenance(적응)', 96),

    (999, 'SELECT_DESCRIPTION', '유지보수의 활동 종류로 볼 수 없는 것은?', '1', '1.Interfere Maintenance(방해);2.Adaptive Maintenance(적응);3.Perfective Maintenance(완전);4.Preventive Maintenance(예방)', 96),

    (1000, 'SELECT_DESCRIPTION', 'S/W 재공학 관점에서 가장 연관 깊은 유지보수 유형은?', '2', '1.Adaptive maintenance(적응);2.Perfective maintenance(완전);3.Corrective maintenance(수정);4.Preventive maintenance(예방)', 96);

-- Unit 6 - Lesson 1: 품질 및 프로세스 개선 (Lesson ID: 97)
INSERT INTO problem (id, problem_type, question, answer, options, lesson_id) VALUES

    (1001, 'SELECT_DESCRIPTION', '소프트웨어 품질 측정을 위해 개발자 관점에서 고려해야 할 항목으로 거리가 먼 것은?', '4', '1.정확성;2.무결성;3.사용성;4.간결성', 97),

    (1002, 'SELECT_DESCRIPTION', 'SPICE 모델의 프로세스 수행능력 수준의 단계별 설명이 틀린 것은?', '1', '1.수준 7 - 미완성 단계;2.수준 5 - 최적화 단계;3.수준 4 - 예측 단계;4.수준 3 - 확립 단계', 97),

    (1003, 'SELECT_DESCRIPTION', 'ISO 12207 표준의 기본 생명주기의 주요 프로세스에 해당하지 않는 것은?', '3', '1.획득 프로세스, process;2.개발 프로세스, process;3.성능평가 프로세스, process;4.유지보수 프로세스, process', 97),

    (1004, 'SELECT_DESCRIPTION', '소프트웨어 품질 관련 국제 표준인 ISO/IEC 25000에 관한 설명으로 옳지 않은 것은?', '3', '1.소프트웨어 품질 평가를 위한 소프트웨어 품질평가 통합모델 표준이다.;2.System and Software Quality Requirements and Evaluation으로 줄여서 SQuaRE라고도 한다.;3.ISO/IEC 2501n에서는 소프트웨어의 내부 측정, 외부측정, 사용품질 측정, 품질 측정 요소 등을 다룬다.;4.기존 소프트웨어 품질 평가 모델과 소프트웨어 평가 절차 모델인 ISO/IEC 9126과 ISO/IEC 14598을 통합하였다.', 97),

    (1005, 'SELECT_DESCRIPTION', '보기에서 설명하는 소프트웨어 품질 요소를 옳게 짝지은 것은? ( ㈎ - ㈏ - ㈐ 순)\n보기:\n㈎ 사용자의 요구사항을 만족시키는 정도\n㈏ 프로그램 수행을 위한 자원의 최적화 정도\n㈐ 다른 시스템에 결합시키는 데 요구되는 노력의 정도', '3', '1.유지보수성(maintainability) - 상호운영성(interoperability) - 정확성(correctness);2.정확성(correctness) - 상호운영성(interoperability) - 효율성(efficiency);3.정확성(correctness) - 효율성(efficiency) - 상호운영성(interoperability);4.상호운영성(interoperability) - 효율성(efficiency) - 유지보수성(maintainability)', 97),

    (1006, 'SELECT_DESCRIPTION', 'ISO의 소프트웨어 프로세스 평가를 위한 국제 표준인 SPICE에 대한 설명이다. 이에 해당하는 프로세스 범주는?\n시스템과 소프트웨어 제품을 개발하는 모든 프로세스, 즉 요구사항 분석(명세화), 설계, 구현, 테스트 등이 이 범주에 속한다.', '2', '1.조직 프로세스(Organization Process);2.공학 프로세스(Engineering Process);3.고객－공급 프로세스(Customer-Supplier Process);4.지원 프로세스(Support Process)', 97),

    (1007, 'SELECT_DESCRIPTION', 'CMM(Capability Maturity Model) 모델의 레벨로 옳지 않은 것은?', '4', '1.최적단계;2.관리단계;3.정의단계;4.계획단계', 97),

    (1008, 'SELECT_DESCRIPTION', '소프트웨어 품질 보증(SQA)의 주요 목적이 아닌 것은?', '2', '1.제품의 품질을 보장하기 위해 체계적인 프로세스를 운영한다.;2.개발 단계 이후에만 품질 검증을 수행한다.;3.개발 및 유지보수 시간과 비용을 절감한다.;4.프로젝트 리스크를 줄이는 데 기여한다.', 97),

    (1009, 'SELECT_DESCRIPTION', '소프트웨어 프로세스 개선의 주요 활동을 올바르게 나열한 것은?', '1', '1.현황 분석 - 변경 및 개선 적용 - 성과 측정과 지속적 관리;2.코드 최적화 - 서버 증설 - 신규 인력 채용;3.요구사항 추가 - UI 개편 - 홍보 강화;4.DB 튜닝 - 네트워크 확장 - 로깅 레벨 상향', 97),

    (1010, 'SELECT_DESCRIPTION', 'ISO/IEC 9126 품질 모델에서 소프트웨어의 수정 및 변경 용이성을 나타내는 품질 특성은?', '2', '1.신뢰성;2.유지보수성;3.이식성;4.효율성', 97),

    (1011, 'SELECT_DESCRIPTION', '소프트웨어 품질보증 활동에 포함되지 않는 것은?', '3', '1.형상관리: 변경 사항 추적 및 관리;2.문서관리: 작성, 보관, 폐기 절차 수립;3.무결성 검사: 모든 데이터의 보안 강제;4.시정조치: 결함 해결 방안 수립 및 조치', 97),

    (1012, 'SELECT_DESCRIPTION', '소프트웨어 품질 보증 활동에 포함되는 항목으로 옳지 않은 것은?', '4', '1.테스트 계획 수립 및 실행;2.소프트웨어 구성 관리;3.품질 관련 문서 작성과 검토;4.코드 최적화 및 성능 개선', 97);